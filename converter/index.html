
  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8">
    <title>XBL To Custom Element Converter</title>
    <link rel="stylesheet" href="../static/styles.css" />
    <script src="../static/xmlom.js"></script>
    <script src="../static/beautify.js"></script>
    <style>
    main {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
      width: 100vw;
      position: absolute;
      top: 0;
      left: 0;
    }
    #converter {
      font-family: monospace;
      display: grid;
      overflow: hidden;
      grid-template-columns: auto 1fr 1fr;
      grid-gap: 10px;
    }
    textarea, pre {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: monospace;
      font-size: 12px;
    }
    ul {
      min-width: 100px;
      margin: 0;
      padding: 0;
      overflow: scroll;
      font-size: smaller;
    }
    li {
      margin: 0;
      padding: 0;
      list-style: none;
      word-break: keep-all;
    }
    </style>
    <script>
      var files = [{"file":"tabbrowser.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"tabBrowserBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n  <binding id=\"tabbrowser-tabs\"\n           extends=\"chrome://global/content/bindings/tabbox.xml#tabs\">\n    <content>\n      <xul:hbox class=\"tab-drop-indicator-box\">\n        <xul:image class=\"tab-drop-indicator\" anonid=\"tab-drop-indicator\" collapsed=\"true\"/>\n      </xul:hbox>\n      <xul:arrowscrollbox anonid=\"arrowscrollbox\" orient=\"horizontal\" flex=\"1\"\n                          style=\"min-width: 1px;\"\n                          clicktoscroll=\"true\"\n                          class=\"tabbrowser-arrowscrollbox\">\n<!--\n This is a hack to circumvent bug 472020, otherwise the tabs show up on the\n right of the newtab button.\n-->\n        <children includes=\"tab\"/>\n<!--\n  This is to ensure anything extensions put here will go before the newtab\n  button, necessary due to the previous hack.\n-->\n        <children/>\n        <xul:toolbarbutton class=\"tabs-newtab-button toolbarbutton-1\"\n                           anonid=\"tabs-newtab-button\"\n                           command=\"cmd_newNavigatorTab\"\n                           onclick=\"checkForMiddleClick(this, event);\"\n                           />\n        <xul:spacer class=\"closing-tabs-spacer\" anonid=\"closing-tabs-spacer\"\n                    style=\"width: 0;\"/>\n      </xul:arrowscrollbox>\n    </content>\n\n    <implementation implements=\"nsIObserver\">\n      <constructor>\n        <![CDATA[\n          this._tabClipWidth = Services.prefs.getIntPref(\"browser.tabs.tabClipWidth\");\n          this._hiddenSoundPlayingTabs = new Set();\n\n          let strId = PrivateBrowsingUtils.isWindowPrivate(window) ?\n              \"emptyPrivateTabTitle\" : \"emptyTabTitle\";\n          this.emptyTabTitle = gTabBrowserBundle.GetStringFromName(\"tabs.\" + strId);\n\n          var tab = this.firstElementChild;\n          tab.label = this.emptyTabTitle;\n\n          let newTabButton = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"tabs-newtab-button\");\n          newTabButton.setAttribute(\"tooltiptext\", GetDynamicShortcutTooltipText(\"tabs-newtab-button\"));\n\n          window.addEventListener(\"resize\", this);\n\n          Services.prefs.addObserver(\"privacy.userContext\", this);\n          this.observe(null, \"nsPref:changed\", \"privacy.userContext.enabled\");\n\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"_tabMinWidthPref\",\n            \"browser.tabs.tabMinWidth\", null,\n            (pref, prevValue, newValue) => this._tabMinWidth = newValue,\n            newValue => {\n              const LIMIT = 50;\n              return Math.max(newValue, LIMIT);\n            },\n          );\n\n          this._tabMinWidth = this._tabMinWidthPref;\n\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"_multiselectEnabledPref\",\n            \"browser.tabs.multiselect\", null,\n            (pref, prevValue, newValue) => this._multiselectEnabled = newValue);\n          this._multiselectEnabled = this._multiselectEnabledPref;\n\n          this._setPositionalAttributes();\n\n          CustomizableUI.addListener(this);\n          this._updateNewTabVisibility();\n          this._initializeArrowScrollbox();\n\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"_closeTabByDblclick\",\n            \"browser.tabs.closeTabByDblclick\", false);\n\n          if (gMultiProcessBrowser) {\n            this.tabbox.tabpanels.setAttribute(\"async\", \"true\");\n          }\n        ]]>\n      </constructor>\n\n      <destructor>\n        <![CDATA[\n          Services.prefs.removeObserver(\"privacy.userContext\", this);\n\n          CustomizableUI.removeListener(this);\n        ]]>\n      </destructor>\n\n      <field name=\"tabbox\" readonly=\"true\">\n        document.getElementById(\"tabbrowser-tabbox\");\n      </field>\n\n      <field name=\"contextMenu\" readonly=\"true\">\n        document.getElementById(\"tabContextMenu\");\n      </field>\n\n      <field name=\"arrowScrollbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowscrollbox\");\n      </field>\n\n      <field name=\"_firstTab\">null</field>\n      <field name=\"_lastTab\">null</field>\n      <field name=\"_beforeSelectedTab\">null</field>\n      <field name=\"_beforeHoveredTab\">null</field>\n      <field name=\"_afterHoveredTab\">null</field>\n      <field name=\"_hoveredTab\">null</field>\n\n      <property name=\"_tabMinWidth\">\n        <setter>\n          this.style.setProperty(\"--tab-min-width\", val + \"px\");\n          return val;\n        </setter>\n      </property>\n\n      <property name=\"_multiselectEnabled\">\n        <setter>\n          // Unlike boolean HTML attributes, the value of boolean ARIA attributes actually matters.\n          this.setAttribute(\"aria-multiselectable\", !!val);\n          return val;\n        </setter>\n        <getter>\n          return this.getAttribute(\"aria-multiselectable\") == \"true\";\n        </getter>\n      </property>\n\n      <method name=\"_initializeArrowScrollbox\">\n        <body><![CDATA[\n          let arrowScrollbox = this.arrowScrollbox;\n          arrowScrollbox.addEventListener(\"underflow\", event => {\n            // Ignore underflow events:\n            // - from nested scrollable elements\n            // - for vertical orientation\n            // - corresponding to an overflow event that we ignored\n            if (event.originalTarget != arrowScrollbox.scrollbox ||\n                event.detail == 0 ||\n                !this.hasAttribute(\"overflow\")) {\n              return;\n            }\n\n            this.removeAttribute(\"overflow\");\n\n            if (this._lastTabClosedByMouse) {\n              this._expandSpacerBy(this._scrollButtonWidth);\n            }\n\n            for (let tab of Array.from(gBrowser._removingTabs)) {\n              gBrowser.removeTab(tab);\n            }\n\n            this._positionPinnedTabs();\n          }, true);\n\n          arrowScrollbox.addEventListener(\"overflow\", event => {\n            // Ignore overflow events:\n            // - from nested scrollable elements\n            // - for vertical orientation\n            if (event.originalTarget != arrowScrollbox.scrollbox ||\n                event.detail == 0) {\n              return;\n            }\n\n            this.setAttribute(\"overflow\", \"true\");\n            this._positionPinnedTabs();\n            this._handleTabSelect(true);\n          });\n\n          // Override scrollbox.xml method, since our scrollbox's children are\n          // inherited from the scrollbox binding parent (this).\n          arrowScrollbox._getScrollableElements = () => {\n            return Array.prototype.filter.call(this.children, arrowScrollbox._canScrollToElement);\n          };\n          arrowScrollbox._canScrollToElement = tab => {\n            return !tab._pinnedUnscrollable && !tab.hidden;\n          };\n        ]]></body>\n      </method>\n\n      <method name=\"observe\">\n        <parameter name=\"aSubject\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aData\"/>\n        <body><![CDATA[\n          switch (aTopic) {\n            case \"nsPref:changed\":\n              // This is has to deal with changes in\n              // privacy.userContext.enabled and\n              // privacy.userContext.longPressBehavior.\n              let containersEnabled = Services.prefs.getBoolPref(\"privacy.userContext.enabled\")\n                                        && !PrivateBrowsingUtils.isWindowPrivate(window);\n\n              // This pref won't change so often, so just recreate the menu.\n              let longPressBehavior = Services.prefs.getIntPref(\"privacy.userContext.longPressBehavior\");\n\n              // If longPressBehavior pref is set to 0 (or any invalid value)\n              // long press menu is disabled.\n              if (containersEnabled && (longPressBehavior <= 0 || longPressBehavior > 2)) {\n                containersEnabled = false;\n              }\n\n              // There are separate \"new tab\" buttons for when the tab strip\n              // is overflowed and when it is not.  Attach the long click\n              // popup to both of them.\n              const newTab = document.getElementById(\"new-tab-button\");\n              const newTab2 = document.getAnonymousElementByAttribute(this, \"anonid\", \"tabs-newtab-button\");\n\n              for (let parent of [newTab, newTab2]) {\n                if (!parent)\n                  continue;\n\n                gClickAndHoldListenersOnElement.remove(parent);\n                parent.removeAttribute(\"type\");\n                if (parent.menupopup) {\n                  parent.menupopup.remove();\n                }\n\n                if (containersEnabled) {\n                  let popup = document.createElementNS(\n                                \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\",\n                                \"menupopup\");\n                  if (parent.id) {\n                    popup.id = \"newtab-popup\";\n                  } else {\n                    popup.setAttribute(\"anonid\", \"newtab-popup\");\n                  }\n                  popup.className = \"new-tab-popup\";\n                  popup.setAttribute(\"position\", \"after_end\");\n                  popup.addEventListener(\"popupshowing\", event => {\n                    createUserContextMenu(event, {\n                      useAccessKeys: false,\n                      showDefaultTab: Services.prefs.getIntPref(\"privacy.userContext.longPressBehavior\") == 1,\n                    });\n                  });\n                  parent.prepend(popup);\n\n                  // longPressBehavior == 2 means that the menu is shown after X\n                  // millisecs. Otherwise, with 1, the menu is open immediatelly.\n                  if (longPressBehavior == 2) {\n                    gClickAndHoldListenersOnElement.add(parent);\n                  }\n\n                  parent.setAttribute(\"type\", \"menu\");\n                }\n              }\n\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <property name=\"_isCustomizing\" readonly=\"true\">\n        <getter><![CDATA[\n          return document.documentElement.getAttribute(\"customizing\") == \"true\";\n        ]]></getter>\n      </property>\n\n      <method name=\"_getVisibleTabs\">\n        <body><![CDATA[\n          // Cannot access gBrowser before it's initialized.\n          if (!gBrowser) {\n            return [ this.firstElementChild ];\n          }\n\n          return gBrowser.visibleTabs;\n        ]]></body>\n      </method>\n\n      <method name=\"_setPositionalAttributes\">\n        <body><![CDATA[\n          let visibleTabs = this._getVisibleTabs();\n          if (!visibleTabs.length) {\n            return;\n          }\n          let selectedTab = this.selectedItem;\n          let selectedIndex = visibleTabs.indexOf(selectedTab);\n          if (this._beforeSelectedTab) {\n            this._beforeSelectedTab.removeAttribute(\"beforeselected-visible\");\n          }\n\n          if (selectedTab.closing || selectedIndex <= 0) {\n            this._beforeSelectedTab = null;\n          } else {\n            let beforeSelectedTab = visibleTabs[selectedIndex - 1];\n            let separatedByScrollButton = this.getAttribute(\"overflow\") == \"true\" &&\n              beforeSelectedTab.pinned && !selectedTab.pinned;\n            if (!separatedByScrollButton) {\n              this._beforeSelectedTab = beforeSelectedTab;\n              this._beforeSelectedTab.setAttribute(\"beforeselected-visible\",\n                                                   \"true\");\n            }\n          }\n\n          if (this._firstTab)\n            this._firstTab.removeAttribute(\"first-visible-tab\");\n          this._firstTab = visibleTabs[0];\n          this._firstTab.setAttribute(\"first-visible-tab\", \"true\");\n          if (this._lastTab)\n            this._lastTab.removeAttribute(\"last-visible-tab\");\n          this._lastTab = visibleTabs[visibleTabs.length - 1];\n          this._lastTab.setAttribute(\"last-visible-tab\", \"true\");\n\n          let hoveredTab = this._hoveredTab;\n          if (hoveredTab) {\n            hoveredTab._mouseleave();\n          }\n          hoveredTab = this.querySelector(\"tab:hover\");\n          if (hoveredTab) {\n            hoveredTab._mouseenter();\n          }\n\n          // Update before-multiselected attributes.\n          // gBrowser may not be initialized yet, so avoid using it\n          for (let i = 0; i < visibleTabs.length - 1; i++) {\n            let tab = visibleTabs[i];\n            let nextTab = visibleTabs[i + 1];\n            tab.removeAttribute(\"before-multiselected\");\n            if (nextTab.multiselected) {\n              tab.setAttribute(\"before-multiselected\", \"true\");\n            }\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_blockDblClick\">false</field>\n\n      <field name=\"_tabDropIndicator\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"tab-drop-indicator\");\n      </field>\n\n      <field name=\"_dragOverDelay\">350</field>\n      <field name=\"_dragTime\">0</field>\n\n      <field name=\"_closeButtonsUpdatePending\">false</field>\n      <method name=\"_updateCloseButtons\">\n        <body><![CDATA[\n          // If we're overflowing, tabs are at their minimum widths.\n          if (this.getAttribute(\"overflow\") == \"true\") {\n            this.setAttribute(\"closebuttons\", \"activetab\");\n            return;\n          }\n\n          if (this._closeButtonsUpdatePending) {\n            return;\n          }\n          this._closeButtonsUpdatePending = true;\n\n          // Wait until after the next paint to get current layout data from\n          // getBoundsWithoutFlushing.\n          window.requestAnimationFrame(() => {\n            window.requestAnimationFrame(() => {\n              this._closeButtonsUpdatePending = false;\n\n              // The scrollbox may have started overflowing since we checked\n              // overflow earlier, so check again.\n              if (this.getAttribute(\"overflow\") == \"true\") {\n                this.setAttribute(\"closebuttons\", \"activetab\");\n                return;\n              }\n\n              // Check if tab widths are below the threshold where we want to\n              // remove close buttons from background tabs so that people don't\n              // accidentally close tabs by selecting them.\n              let rect = ele => {\n                return window.windowUtils.getBoundsWithoutFlushing(ele);\n              };\n              let tab = this._getVisibleTabs()[gBrowser._numPinnedTabs];\n              if (tab && rect(tab).width <= this._tabClipWidth) {\n                this.setAttribute(\"closebuttons\", \"activetab\");\n              } else {\n                this.removeAttribute(\"closebuttons\");\n              }\n            });\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"_updateHiddenTabsStatus\">\n        <body><![CDATA[\n          if (gBrowser.visibleTabs.length < gBrowser.tabs.length) {\n            this.setAttribute(\"hashiddentabs\", \"true\");\n          } else {\n            this.removeAttribute(\"hashiddentabs\");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_handleTabSelect\">\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          let selectedTab = this.selectedItem;\n          if (this.getAttribute(\"overflow\") == \"true\")\n            this.arrowScrollbox.ensureElementIsVisible(selectedTab, aInstant);\n\n          selectedTab._notselectedsinceload = false;\n        ]]></body>\n      </method>\n\n      <field name=\"_closingTabsSpacer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"closing-tabs-spacer\");\n      </field>\n\n      <field name=\"_tabDefaultMaxWidth\">NaN</field>\n      <field name=\"_lastTabClosedByMouse\">false</field>\n      <field name=\"_hasTabTempMaxWidth\">false</field>\n      <field name=\"_scrollButtonWidth\">0</field>\n\n      <!-- Try to keep the active tab's close button under the mouse cursor -->\n      <method name=\"_lockTabSizing\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aTabWidth\"/>\n        <body><![CDATA[\n          let tabs = this._getVisibleTabs();\n          if (!tabs.length) {\n            return;\n          }\n\n          var isEndTab = (aTab._tPos > tabs[tabs.length - 1]._tPos);\n\n          if (!this._tabDefaultMaxWidth) {\n            this._tabDefaultMaxWidth =\n              parseFloat(window.getComputedStyle(aTab).maxWidth);\n          }\n          this._lastTabClosedByMouse = true;\n          this._scrollButtonWidth = window.windowUtils.getBoundsWithoutFlushing(this.arrowScrollbox._scrollButtonDown).width;\n\n          if (this.getAttribute(\"overflow\") == \"true\") {\n            // Don't need to do anything if we're in overflow mode and aren't scrolled\n            // all the way to the right, or if we're closing the last tab.\n            if (isEndTab || !this.arrowScrollbox._scrollButtonDown.disabled) {\n              return;\n            }\n            // If the tab has an owner that will become the active tab, the owner will\n            // be to the left of it, so we actually want the left tab to slide over.\n            // This can't be done as easily in non-overflow mode, so we don't bother.\n            if (aTab.owner) {\n              return;\n            }\n            this._expandSpacerBy(aTabWidth);\n          } else { // non-overflow mode\n            // Locking is neither in effect nor needed, so let tabs expand normally.\n            if (isEndTab && !this._hasTabTempMaxWidth) {\n              return;\n            }\n            let numPinned = gBrowser._numPinnedTabs;\n            // Force tabs to stay the same width, unless we're closing the last tab,\n            // which case we need to let them expand just enough so that the overall\n            // tabbar width is the same.\n            if (isEndTab) {\n              let numNormalTabs = tabs.length - numPinned;\n              aTabWidth = aTabWidth * (numNormalTabs + 1) / numNormalTabs;\n              if (aTabWidth > this._tabDefaultMaxWidth) {\n                aTabWidth = this._tabDefaultMaxWidth;\n              }\n            }\n            aTabWidth += \"px\";\n            let tabsToReset = [];\n            for (let i = numPinned; i < tabs.length; i++) {\n              let tab = tabs[i];\n              tab.style.setProperty(\"max-width\", aTabWidth, \"important\");\n              if (!isEndTab) { // keep tabs the same width\n                tab.style.transition = \"none\";\n                tabsToReset.push(tab);\n              }\n            }\n\n            if (tabsToReset.length) {\n              window.promiseDocumentFlushed(() => {}).then(() => {\n                window.requestAnimationFrame(() => {\n                  for (let tab of tabsToReset) {\n                    tab.style.transition = \"\";\n                  }\n                });\n              });\n            }\n\n            this._hasTabTempMaxWidth = true;\n            gBrowser.addEventListener(\"mousemove\", this);\n            window.addEventListener(\"mouseout\", this);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_expandSpacerBy\">\n        <parameter name=\"pixels\"/>\n        <body><![CDATA[\n          let spacer = this._closingTabsSpacer;\n          spacer.style.width = parseFloat(spacer.style.width) + pixels + \"px\";\n          this.setAttribute(\"using-closing-tabs-spacer\", \"true\");\n          gBrowser.addEventListener(\"mousemove\", this);\n          window.addEventListener(\"mouseout\", this);\n        ]]></body>\n      </method>\n\n      <method name=\"_unlockTabSizing\">\n        <body><![CDATA[\n          gBrowser.removeEventListener(\"mousemove\", this);\n          window.removeEventListener(\"mouseout\", this);\n\n          if (this._hasTabTempMaxWidth) {\n            this._hasTabTempMaxWidth = false;\n            let tabs = this._getVisibleTabs();\n            for (let i = 0; i < tabs.length; i++) {\n              tabs[i].style.maxWidth = \"\";\n            }\n          }\n\n          if (this.hasAttribute(\"using-closing-tabs-spacer\")) {\n            this.removeAttribute(\"using-closing-tabs-spacer\");\n            this._closingTabsSpacer.style.width = 0;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"uiDensityChanged\">\n        <body><![CDATA[\n          this._positionPinnedTabs();\n          this._updateCloseButtons();\n          this._handleTabSelect(true);\n        ]]></body>\n      </method>\n\n      <field name=\"_lastNumPinned\">0</field>\n      <field name=\"_pinnedTabsLayoutCache\">null</field>\n      <method name=\"_positionPinnedTabs\">\n        <body><![CDATA[\n          let numPinned = gBrowser._numPinnedTabs;\n          let doPosition = this.getAttribute(\"overflow\") == \"true\" &&\n                           this._getVisibleTabs().length > numPinned &&\n                           numPinned > 0;\n\n          if (doPosition) {\n            this.setAttribute(\"positionpinnedtabs\", \"true\");\n\n            let layoutData = this._pinnedTabsLayoutCache;\n            let uiDensity = document.documentElement.getAttribute(\"uidensity\");\n            if (!layoutData ||\n                layoutData.uiDensity != uiDensity) {\n              let arrowScrollbox = this.arrowScrollbox;\n              layoutData = this._pinnedTabsLayoutCache = {\n                uiDensity,\n                pinnedTabWidth: this.children[0].getBoundingClientRect().width,\n                scrollButtonWidth: arrowScrollbox._scrollButtonDown.getBoundingClientRect().width,\n              };\n            }\n\n            let width = 0;\n            for (let i = numPinned - 1; i >= 0; i--) {\n              let tab = this.children[i];\n              width += layoutData.pinnedTabWidth;\n              tab.style.setProperty(\"margin-inline-start\",\n                -(width + layoutData.scrollButtonWidth) + \"px\", \"important\");\n              tab._pinnedUnscrollable = true;\n            }\n            this.style.paddingInlineStart = width + \"px\";\n          } else {\n            this.removeAttribute(\"positionpinnedtabs\");\n\n            for (let i = 0; i < numPinned; i++) {\n              let tab = this.children[i];\n              tab.style.marginInlineStart = \"\";\n              tab._pinnedUnscrollable = false;\n            }\n\n            this.style.paddingInlineStart = \"\";\n          }\n\n          if (this._lastNumPinned != numPinned) {\n            this._lastNumPinned = numPinned;\n            this._handleTabSelect(true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_animateTabMove\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);\n          let movingTabs = draggedTab._dragData.movingTabs;\n\n          if (this.getAttribute(\"movingtab\") != \"true\") {\n            this.setAttribute(\"movingtab\", \"true\");\n            gNavToolbox.setAttribute(\"movingtab\", \"true\");\n            if (!draggedTab.multiselected)\n              this.selectedItem = draggedTab;\n          }\n\n          if (!(\"animLastScreenX\" in draggedTab._dragData))\n            draggedTab._dragData.animLastScreenX = draggedTab._dragData.screenX;\n\n          let screenX = event.screenX;\n          if (screenX == draggedTab._dragData.animLastScreenX)\n            return;\n\n          // Direction of the mouse movement.\n          let ltrMove = screenX > draggedTab._dragData.animLastScreenX;\n\n          draggedTab._dragData.animLastScreenX = screenX;\n\n          let pinned = draggedTab.pinned;\n          let numPinned = gBrowser._numPinnedTabs;\n          let tabs = this._getVisibleTabs()\n                         .slice(pinned ? 0 : numPinned,\n                                pinned ? numPinned : undefined);\n\n          if (RTL_UI) {\n            tabs.reverse();\n            // Copy moving tabs array to avoid infinite reversing.\n            movingTabs = [...movingTabs].reverse();\n          }\n          let tabWidth = draggedTab.getBoundingClientRect().width;\n          let shiftWidth = tabWidth * movingTabs.length;\n          draggedTab._dragData.tabWidth = tabWidth;\n\n          // Move the dragged tab based on the mouse position.\n\n          let leftTab = tabs[0];\n          let rightTab = tabs[tabs.length - 1];\n          let rightMovingTabScreenX = movingTabs[movingTabs.length - 1].screenX;\n          let leftMovingTabScreenX = movingTabs[0].screenX;\n          let translateX = screenX - draggedTab._dragData.screenX;\n          if (!pinned) {\n            translateX += this.arrowScrollbox.scrollbox.scrollLeft - draggedTab._dragData.scrollX;\n          }\n          let leftBound = leftTab.screenX - leftMovingTabScreenX;\n          let rightBound = (rightTab.screenX + rightTab.getBoundingClientRect().width) -\n                           (rightMovingTabScreenX + tabWidth);\n          translateX = Math.min(Math.max(translateX, leftBound), rightBound);\n\n          for (let tab of movingTabs) {\n            tab.style.transform = \"translateX(\" + translateX + \"px)\";\n          }\n\n          draggedTab._dragData.translateX = translateX;\n\n          // Determine what tab we're dragging over.\n          // * Single tab dragging: Point of reference is the center of the dragged tab. If that\n          //   point touches a background tab, the dragged tab would take that\n          //   tab's position when dropped.\n          // * Multiple tabs dragging: All dragged tabs are one \"giant\" tab with two\n          //   points of reference (center of tabs on the extremities). When\n          //   mouse is moving from left to right, the right reference gets activated,\n          //   otherwise the left reference will be used. Everything else works the same\n          //   as single tab dragging.\n          // * We're doing a binary search in order to reduce the amount of\n          //   tabs we need to check.\n\n          tabs = tabs.filter(t => !movingTabs.includes(t) || t == draggedTab);\n          let leftTabCenter = leftMovingTabScreenX + translateX + tabWidth / 2;\n          let rightTabCenter = rightMovingTabScreenX + translateX + tabWidth / 2;\n          let tabCenter = ltrMove ? rightTabCenter : leftTabCenter;\n          let newIndex = -1;\n          let oldIndex = \"animDropIndex\" in draggedTab._dragData ?\n                         draggedTab._dragData.animDropIndex : movingTabs[0]._tPos;\n          let low = 0;\n          let high = tabs.length - 1;\n          while (low <= high) {\n            let mid = Math.floor((low + high) / 2);\n            if (tabs[mid] == draggedTab && ++mid > high)\n              break;\n            screenX = tabs[mid].screenX + getTabShift(tabs[mid], oldIndex);\n            if (screenX > tabCenter) {\n              high = mid - 1;\n            } else if (screenX + tabs[mid].getBoundingClientRect().width < tabCenter) {\n              low = mid + 1;\n            } else {\n              newIndex = tabs[mid]._tPos;\n              break;\n            }\n          }\n          if (newIndex >= oldIndex)\n            newIndex++;\n          if (newIndex < 0 || newIndex == oldIndex)\n            return;\n          draggedTab._dragData.animDropIndex = newIndex;\n\n          // Shift background tabs to leave a gap where the dragged tab\n          // would currently be dropped.\n\n          for (let tab of tabs) {\n            if (tab != draggedTab) {\n              let shift = getTabShift(tab, newIndex);\n              tab.style.transform = shift ? \"translateX(\" + shift + \"px)\" : \"\";\n            }\n          }\n\n          function getTabShift(tab, dropIndex) {\n            if (tab._tPos < draggedTab._tPos && tab._tPos >= dropIndex)\n              return (RTL_UI ? -shiftWidth : shiftWidth);\n            if (tab._tPos > draggedTab._tPos && tab._tPos < dropIndex)\n              return (RTL_UI ? shiftWidth : -shiftWidth);\n            return 0;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_finishAnimateTabMove\">\n        <body><![CDATA[\n          if (this.getAttribute(\"movingtab\") != \"true\") {\n            return;\n          }\n\n          for (let tab of this._getVisibleTabs()) {\n            tab.style.transform = \"\";\n          }\n\n          this.removeAttribute(\"movingtab\");\n          gNavToolbox.removeAttribute(\"movingtab\");\n\n          this._handleTabSelect();\n        ]]></body>\n      </method>\n\n      <!--  Regroup all selected tabs around the\n            tab in param  -->\n      <method name=\"_groupSelectedTabs\">\n        <parameter name=\"tab\"/>\n        <body><![CDATA[\n          let draggedTabPos = tab._tPos;\n          let selectedTabs = gBrowser.selectedTabs;\n          let animate = gBrowser.animationsEnabled;\n\n          tab.groupingTabsData = {\n            finished: !animate,\n          };\n\n\n          // Animate left selected tabs\n\n          let insertAtPos = draggedTabPos - 1;\n          for (let i = selectedTabs.indexOf(tab) - 1; i > -1; i--) {\n            let movingTab = selectedTabs[i];\n            insertAtPos = newIndex(movingTab, insertAtPos);\n\n            if (animate) {\n              movingTab.groupingTabsData = {};\n              addAnimationData(movingTab, insertAtPos, \"left\");\n            } else {\n              gBrowser.moveTabTo(movingTab, insertAtPos);\n            }\n            insertAtPos--;\n          }\n\n          // Animate right selected tabs\n\n          insertAtPos = draggedTabPos + 1;\n          for (let i = selectedTabs.indexOf(tab) + 1; i < selectedTabs.length; i++) {\n            let movingTab = selectedTabs[i];\n            insertAtPos = newIndex(movingTab, insertAtPos);\n\n            if (animate) {\n              movingTab.groupingTabsData = {};\n              addAnimationData(movingTab, insertAtPos, \"right\");\n            } else {\n              gBrowser.moveTabTo(movingTab, insertAtPos);\n            }\n            insertAtPos++;\n          }\n\n          // Slide the relevant tabs to their new position.\n          for (let t of this._getVisibleTabs()) {\n            if (t.groupingTabsData && t.groupingTabsData.translateX) {\n              let translateX = (RTL_UI ? -1 : 1) * t.groupingTabsData.translateX;\n              t.style.transform = \"translateX(\" + translateX + \"px)\";\n            }\n          }\n\n          function newIndex(aTab, index) {\n            // Don't allow mixing pinned and unpinned tabs.\n            if (aTab.pinned) {\n              return Math.min(index, gBrowser._numPinnedTabs - 1);\n            }\n            return Math.max(index, gBrowser._numPinnedTabs);\n          }\n\n          function addAnimationData(movingTab, movingTabNewIndex, side) {\n            let movingTabOldIndex = movingTab._tPos;\n\n            if (movingTabOldIndex == movingTabNewIndex) {\n              // movingTab is already at the right position\n              // and thus don't need to be animated.\n              return;\n            }\n\n            let movingTabWidth = movingTab.getBoundingClientRect().width;\n            let shift = (movingTabNewIndex - movingTabOldIndex) * movingTabWidth;\n\n            movingTab.groupingTabsData.animate = true;\n            movingTab.setAttribute(\"tab-grouping\", \"true\");\n\n            movingTab.groupingTabsData.translateX = shift;\n\n            let onTransitionEnd = transitionendEvent => {\n              if (transitionendEvent.propertyName != \"transform\" ||\n                  transitionendEvent.originalTarget != movingTab) {\n                return;\n              }\n              movingTab.removeEventListener(\"transitionend\", onTransitionEnd);\n              movingTab.groupingTabsData.newIndex = movingTabNewIndex;\n              movingTab.groupingTabsData.animate = false;\n            };\n\n            movingTab.addEventListener(\"transitionend\", onTransitionEnd);\n\n            // Add animation data for tabs between movingTab (selected\n            // tab moving towards the dragged tab) and draggedTab.\n            // Those tabs in the middle should move in\n            // the opposite direction of movingTab.\n\n            let lowerIndex = Math.min(movingTabOldIndex, draggedTabPos);\n            let higherIndex = Math.max(movingTabOldIndex, draggedTabPos);\n\n            for (let i = lowerIndex + 1; i < higherIndex; i++) {\n              let middleTab = gBrowser.visibleTabs[i];\n\n              if (middleTab.pinned != movingTab.pinned) {\n                // Don't mix pinned and unpinned tabs\n                break;\n              }\n\n              if (middleTab.multiselected) {\n                // Skip because this selected tab should\n                // be shifted towards the dragged Tab.\n                continue;\n              }\n\n              if (!middleTab.groupingTabsData || !middleTab.groupingTabsData.translateX) {\n                middleTab.groupingTabsData = { translateX: 0};\n              }\n              if (side == \"left\") {\n                middleTab.groupingTabsData.translateX -= movingTabWidth;\n              } else {\n                middleTab.groupingTabsData.translateX += movingTabWidth;\n              }\n\n              middleTab.setAttribute(\"tab-grouping\", \"true\");\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_finishGroupSelectedTabs\">\n        <parameter name=\"tab\"/>\n        <body><![CDATA[\n          if (!tab.groupingTabsData || tab.groupingTabsData.finished)\n            return;\n\n          tab.groupingTabsData.finished = true;\n\n          let selectedTabs = gBrowser.selectedTabs;\n          let tabIndex = selectedTabs.indexOf(tab);\n\n          // Moving left tabs\n          for (let i = tabIndex - 1; i > -1; i--) {\n            let movingTab = selectedTabs[i];\n            if (movingTab.groupingTabsData.newIndex) {\n              gBrowser.moveTabTo(movingTab, movingTab.groupingTabsData.newIndex);\n            }\n          }\n\n          // Moving right tabs\n          for (let i = tabIndex + 1; i < selectedTabs.length; i++) {\n            let movingTab = selectedTabs[i];\n            if (movingTab.groupingTabsData.newIndex) {\n              gBrowser.moveTabTo(movingTab, movingTab.groupingTabsData.newIndex);\n            }\n          }\n\n          for (let t of this._getVisibleTabs()) {\n            t.style.transform = \"\";\n            t.removeAttribute(\"tab-grouping\");\n            delete t.groupingTabsData;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_isGroupTabsAnimationOver\">\n        <body><![CDATA[\n          for (let tab of gBrowser.selectedTabs) {\n            if (tab.groupingTabsData && tab.groupingTabsData.animate)\n              return false;\n          }\n          return true;\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.type) {\n            case \"resize\":\n              if (aEvent.target != window)\n                break;\n\n              this._updateCloseButtons();\n              this._handleTabSelect(true);\n              break;\n            case \"mouseout\":\n              // If the \"related target\" (the node to which the pointer went) is not\n              // a child of the current document, the mouse just left the window.\n              let relatedTarget = aEvent.relatedTarget;\n              if (relatedTarget && relatedTarget.ownerDocument == document)\n                break;\n            case \"mousemove\":\n              if (document.getElementById(\"tabContextMenu\").state != \"open\")\n                this._unlockTabSizing();\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_animateElement\">\n        this.arrowScrollbox._scrollButtonDown;\n      </field>\n\n      <method name=\"_notifyBackgroundTab\">\n        <parameter name=\"aTab\"/>\n        <body><![CDATA[\n          if (aTab.pinned || aTab.hidden || this.getAttribute(\"overflow\") != \"true\")\n            return;\n\n          this._lastTabToScrollIntoView = aTab;\n          if (!this._backgroundTabScrollPromise) {\n            this._backgroundTabScrollPromise = window.promiseDocumentFlushed(() => {\n              let lastTabRect = this._lastTabToScrollIntoView.getBoundingClientRect();\n              let selectedTab = this.selectedItem;\n              if (selectedTab.pinned) {\n                selectedTab = null;\n              } else {\n                selectedTab = selectedTab.getBoundingClientRect();\n                selectedTab = {left: selectedTab.left, right: selectedTab.right};\n              }\n              return [\n                this._lastTabToScrollIntoView,\n                this.arrowScrollbox.scrollClientRect,\n                {left: lastTabRect.left, right: lastTabRect.right},\n                selectedTab,\n              ];\n            }).then(([tabUsed, scrollRect, tabRect, selectedRect]) => {\n              // First off, remove the promise so we can re-enter if necessary.\n              delete this._backgroundTabScrollPromise;\n              // Then, if the layout info isn't for the last-scrolled-to-tab, re-run\n              // the code above to get layout info for *that* tab, and don't do\n              // anything here, as we really just want to run this for the last-opened tab.\n              if (this._lastTabToScrollIntoView != tabUsed) {\n                this._notifyBackgroundTab(this._lastTabToScrollIntoView);\n                return;\n              }\n              delete this._lastTabToScrollIntoView;\n              // Is the new tab already completely visible?\n              if (scrollRect.left <= tabRect.left && tabRect.right <= scrollRect.right)\n                return;\n\n              if (this.arrowScrollbox.smoothScroll) {\n                // Can we make both the new tab and the selected tab completely visible?\n                if (!selectedRect ||\n                    Math.max(tabRect.right - selectedRect.left, selectedRect.right - tabRect.left) <=\n                      scrollRect.width) {\n                  this.arrowScrollbox.ensureElementIsVisible(aTab);\n                  return;\n                }\n\n                this.arrowScrollbox.scrollByPixels(RTL_UI ?\n                                                     selectedRect.right - scrollRect.right :\n                                                     selectedRect.left - scrollRect.left);\n              }\n\n              if (!this._animateElement.hasAttribute(\"highlight\")) {\n                this._animateElement.setAttribute(\"highlight\", \"true\");\n                setTimeout(function(ele) {\n                  ele.removeAttribute(\"highlight\");\n                }, 150, this._animateElement);\n              }\n            });\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_getDragTargetTab\">\n        <parameter name=\"event\"/>\n        <parameter name=\"isLink\"/>\n        <body><![CDATA[\n          let tab = event.target;\n          while (tab && tab.localName != \"tab\") {\n            tab = tab.parentNode;\n          }\n          if (tab && isLink) {\n            let {width} = tab.getBoundingClientRect();\n            if (event.screenX < tab.screenX + width * .25 ||\n                event.screenX > tab.screenX + width * .75)\n              return null;\n          }\n          return tab;\n        ]]></body>\n      </method>\n\n      <method name=\"_getDropIndex\">\n        <parameter name=\"event\"/>\n        <parameter name=\"isLink\"/>\n        <body><![CDATA[\n          var tabs = this.children;\n          var tab = this._getDragTargetTab(event, isLink);\n          if (!RTL_UI) {\n            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)\n              if (event.screenX < tabs[i].screenX + tabs[i].getBoundingClientRect().width / 2)\n                return i;\n          } else {\n            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)\n              if (event.screenX > tabs[i].screenX + tabs[i].getBoundingClientRect().width / 2)\n                return i;\n          }\n          return tabs.length;\n        ]]></body>\n      </method>\n\n      <method name=\"_getDropEffectForTabDrag\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          var dt = event.dataTransfer;\n\n          let isMovingTabs = dt.mozItemCount > 0;\n          for (let i = 0; i < dt.mozItemCount; i++) {\n            // tabs are always added as the first type\n            let types = dt.mozTypesAt(0);\n            if (types[0] != TAB_DROP_TYPE) {\n              isMovingTabs = false;\n              break;\n            }\n          }\n\n          if (isMovingTabs) {\n            let sourceNode = dt.mozGetDataAt(TAB_DROP_TYPE, 0);\n            if (sourceNode instanceof XULElement &&\n                sourceNode.localName == \"tab\" &&\n                sourceNode.ownerGlobal.isChromeWindow &&\n                sourceNode.ownerDocument.documentElement.getAttribute(\"windowtype\") == \"navigator:browser\" &&\n                sourceNode.ownerGlobal.gBrowser.tabContainer == sourceNode.parentNode) {\n              // Do not allow transfering a private tab to a non-private window\n              // and vice versa.\n              if (PrivateBrowsingUtils.isWindowPrivate(window) !=\n                  PrivateBrowsingUtils.isWindowPrivate(sourceNode.ownerGlobal))\n                return \"none\";\n\n              if (window.gMultiProcessBrowser !=\n                  sourceNode.ownerGlobal.gMultiProcessBrowser)\n                return \"none\";\n\n              return dt.dropEffect == \"copy\" ? \"copy\" : \"move\";\n            }\n          }\n\n          if (browserDragAndDrop.canDropLink(event)) {\n            return \"link\";\n          }\n          return \"none\";\n        ]]></body>\n      </method>\n\n      <method name=\"_handleNewTab\">\n        <parameter name=\"tab\"/>\n        <body><![CDATA[\n          if (tab.parentNode != this) {\n            return;\n          }\n          tab._fullyOpen = true;\n          gBrowser.tabAnimationsInProgress--;\n\n          this._updateCloseButtons();\n\n          if (tab.getAttribute(\"selected\") == \"true\") {\n            this._handleTabSelect();\n          } else if (!tab.hasAttribute(\"skipbackgroundnotify\")) {\n            this._notifyBackgroundTab(tab);\n          }\n\n          // XXXmano: this is a temporary workaround for bug 345399\n          // We need to manually update the scroll buttons disabled state\n          // if a tab was inserted to the overflow area or removed from it\n          // without any scrolling and when the tabbar has already\n          // overflowed.\n          this.arrowScrollbox._updateScrollButtonsDisabledState();\n\n          // If this browser isn't lazy (indicating it's probably created by\n          // session restore), preload the next about:newtab if we don't\n          // already have a preloaded browser.\n          if (tab.linkedPanel) {\n            NewTabPagePreloading.maybeCreatePreloadedBrowser(window);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_canAdvanceToTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          return !aTab.closing;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getRelatedElement\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          if (!aTab) {\n            return null;\n          }\n\n          // Cannot access gBrowser before it's initialized.\n          if (!gBrowser) {\n            return this.tabbox.tabpanels.firstElementChild;\n          }\n\n          // If the tab's browser is lazy, we need to `_insertBrowser` in order\n          // to have a linkedPanel.  This will also serve to bind the browser\n          // and make it ready to use when the tab is selected.\n          gBrowser._insertBrowser(aTab);\n          return document.getElementById(aTab.linkedPanel);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_updateNewTabVisibility\">\n        <body><![CDATA[\n          // Helper functions to help deal with customize mode wrapping some items\n          let wrap = n => n.parentNode.localName == \"toolbarpaletteitem\" ? n.parentNode : n;\n          let unwrap = n => n && n.localName == \"toolbarpaletteitem\" ? n.firstElementChild : n;\n\n          // Starting from the tabs element, find the next sibling that:\n          // - isn't hidden; and\n          // - isn't the all-tabs button.\n          // If it's the new tab button, consider the new tab button adjacent to the tabs.\n          // If the new tab button is marked as adjacent and the tabstrip doesn't\n          // overflow, we'll display the 'new tab' button inline in the tabstrip.\n          // In all other cases, the separate new tab button is displayed in its\n          // customized location.\n          let sib = this;\n          do {\n            sib = unwrap(wrap(sib).nextElementSibling);\n          } while (sib && (sib.hidden ||\n                           sib.id == \"alltabs-button\"));\n\n          const kAttr = \"hasadjacentnewtabbutton\";\n          if (sib && sib.id == \"new-tab-button\") {\n            this.setAttribute(kAttr, \"true\");\n          } else {\n            this.removeAttribute(kAttr);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onWidgetAfterDOMChange\">\n        <parameter name=\"aNode\"/>\n        <parameter name=\"aNextNode\"/>\n        <parameter name=\"aContainer\"/>\n        <body><![CDATA[\n          if (aContainer.ownerDocument == document &&\n              aContainer.id == \"TabsToolbar-customization-target\") {\n            this._updateNewTabVisibility();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onAreaNodeRegistered\">\n        <parameter name=\"aArea\"/>\n        <parameter name=\"aContainer\"/>\n        <body><![CDATA[\n          if (aContainer.ownerDocument == document &&\n              aArea == \"TabsToolbar\") {\n            this._updateNewTabVisibility();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onAreaReset\">\n        <parameter name=\"aArea\"/>\n        <parameter name=\"aContainer\"/>\n        <body><![CDATA[\n          this.onAreaNodeRegistered(aArea, aContainer);\n        ]]></body>\n      </method>\n\n      <method name=\"_hiddenSoundPlayingStatusChanged\">\n        <parameter name=\"tab\"/>\n        <parameter name=\"opts\"/>\n        <body><![CDATA[\n          let closed = opts && opts.closed;\n          if (!closed && tab.soundPlaying && tab.hidden) {\n            this._hiddenSoundPlayingTabs.add(tab);\n            this.setAttribute(\"hiddensoundplaying\", \"true\");\n          } else {\n            this._hiddenSoundPlayingTabs.delete(tab);\n            if (this._hiddenSoundPlayingTabs.size == 0) {\n              this.removeAttribute(\"hiddensoundplaying\");\n            }\n          }\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"TabSelect\"><![CDATA[\n        this._handleTabSelect();\n      ]]></handler>\n\n      <handler event=\"TabClose\"><![CDATA[\n        this._hiddenSoundPlayingStatusChanged(event.target, {closed: true});\n      ]]></handler>\n\n      <handler event=\"TabAttrModified\"><![CDATA[\n        if (event.detail.changed.includes(\"soundplaying\") && event.target.hidden) {\n          this._hiddenSoundPlayingStatusChanged(event.target);\n        }\n      ]]></handler>\n\n      <handler event=\"TabHide\"><![CDATA[\n        if (event.target.soundPlaying) {\n          this._hiddenSoundPlayingStatusChanged(event.target);\n        }\n      ]]></handler>\n\n      <handler event=\"TabShow\"><![CDATA[\n        if (event.target.soundPlaying) {\n          this._hiddenSoundPlayingStatusChanged(event.target);\n        }\n      ]]></handler>\n\n      <handler event=\"transitionend\"><![CDATA[\n        if (event.propertyName != \"max-width\") {\n          return;\n        }\n\n        let tab = event.target.closest(\"tab\");\n        if (!tab) {\n          return;\n        }\n\n        if (tab.getAttribute(\"fadein\") == \"true\") {\n          if (tab._fullyOpen) {\n            this._updateCloseButtons();\n          } else {\n            this._handleNewTab(tab);\n          }\n        } else if (tab.closing) {\n          gBrowser._endRemoveTab(tab);\n        }\n\n        let evt = new CustomEvent(\"TabAnimationEnd\", { bubbles: true });\n        tab.dispatchEvent(evt);\n      ]]></handler>\n\n      <handler event=\"dblclick\"><![CDATA[\n        // When the tabbar has an unified appearance with the titlebar\n        // and menubar, a double-click in it should have the same behavior\n        // as double-clicking the titlebar\n        if (TabsInTitlebar.enabled)\n          return;\n\n        if (event.button != 0 ||\n            event.originalTarget.localName != \"scrollbox\")\n          return;\n\n        if (!this._blockDblClick)\n          BrowserOpenTab();\n\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"click\" button=\"0\" phase=\"capturing\"><![CDATA[\n        /* Catches extra clicks meant for the in-tab close button.\n         * Placed here to avoid leaking (a temporary handler added from the\n         * in-tab close button binding would close over the tab and leak it\n         * until the handler itself was removed). (bug 897751)\n         *\n         * The only sequence in which a second click event (i.e. dblclik)\n         * can be dispatched on an in-tab close button is when it is shown\n         * after the first click (i.e. the first click event was dispatched\n         * on the tab). This happens when we show the close button only on\n         * the active tab. (bug 352021)\n         * The only sequence in which a third click event can be dispatched\n         * on an in-tab close button is when the tab was opened with a\n         * double click on the tabbar. (bug 378344)\n         * In both cases, it is most likely that the close button area has\n         * been accidentally clicked, therefore we do not close the tab.\n         *\n         * We don't want to ignore processing of more than one click event,\n         * though, since the user might actually be repeatedly clicking to\n         * close many tabs at once.\n         */\n        let target = event.originalTarget;\n        if (target.classList.contains(\"tab-close-button\")) {\n          // We preemptively set this to allow the closing-multiple-tabs-\n          // in-a-row case.\n          if (this._blockDblClick) {\n            target._ignoredCloseButtonClicks = true;\n          } else if (event.detail > 1 && !target._ignoredCloseButtonClicks) {\n            target._ignoredCloseButtonClicks = true;\n            event.stopPropagation();\n            return;\n          } else {\n            // Reset the \"ignored click\" flag\n            target._ignoredCloseButtonClicks = false;\n          }\n        }\n\n        /* Protects from close-tab-button errant doubleclick:\n         * Since we're removing the event target, if the user\n         * double-clicks the button, the dblclick event will be dispatched\n         * with the tabbar as its event target (and explicit/originalTarget),\n         * which treats that as a mouse gesture for opening a new tab.\n         * In this context, we're manually blocking the dblclick event.\n         */\n        if (this._blockDblClick) {\n          if (!(\"_clickedTabBarOnce\" in this)) {\n            this._clickedTabBarOnce = true;\n            return;\n          }\n          delete this._clickedTabBarOnce;\n          this._blockDblClick = false;\n        }\n      ]]></handler>\n\n      <handler event=\"click\"><![CDATA[\n        if (event.button != 1) {\n          return;\n        }\n\n        let tab = event.target.closest(\"tab\");\n        if (tab) {\n          gBrowser.removeTab(tab, {\n            animate: true,\n            byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE,\n          });\n        } else if (event.originalTarget.localName == \"scrollbox\") {\n          // The user middleclicked on the tabstrip. Check whether the click\n          // was dispatched on the open space of it.\n          let visibleTabs = this._getVisibleTabs();\n          let lastTab = visibleTabs[visibleTabs.length - 1];\n          let winUtils = window.windowUtils;\n          let endOfTab = winUtils.getBoundsWithoutFlushing(lastTab)[RTL_UI ? \"left\" : \"right\"];\n          if ((!RTL_UI && event.clientX > endOfTab) ||\n              (RTL_UI && event.clientX < endOfTab)) {\n            BrowserOpenTab();\n          }\n        } else {\n          return;\n        }\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"keydown\" group=\"system\"><![CDATA[\n        let {altKey, shiftKey} = event;\n        let [accel, nonAccel] = AppConstants.platform == \"macosx\" ? [event.metaKey, event.ctrlKey] : [event.ctrlKey, event.metaKey];\n\n        let keyComboForMove = accel && shiftKey && !altKey && !nonAccel;\n        let keyComboForFocus = accel && !shiftKey && !altKey && !nonAccel;\n\n        if (!keyComboForMove && !keyComboForFocus) {\n          return;\n        }\n\n        // Don't check if the event was already consumed because tab navigation\n        // should work always for better user experience.\n        let {visibleTabs, selectedTab} = gBrowser;\n        let {arrowKeysShouldWrap} = this;\n        let focusedTabIndex = this.ariaFocusedIndex;\n        if (focusedTabIndex == -1) {\n          focusedTabIndex = visibleTabs.indexOf(selectedTab);\n        }\n        let lastFocusedTabIndex = focusedTabIndex;\n        switch (event.keyCode) {\n          case KeyEvent.DOM_VK_UP:\n            if (keyComboForMove) {\n              gBrowser.moveTabBackward();\n            } else {\n              focusedTabIndex--;\n            }\n            break;\n          case KeyEvent.DOM_VK_DOWN:\n            if (keyComboForMove) {\n              gBrowser.moveTabForward();\n            } else {\n              focusedTabIndex++;\n            }\n            break;\n          case KeyEvent.DOM_VK_RIGHT:\n          case KeyEvent.DOM_VK_LEFT:\n            if (keyComboForMove) {\n              gBrowser.moveTabOver(event);\n            } else if ((!RTL_UI && event.keyCode == KeyEvent.DOM_VK_RIGHT) ||\n                       (RTL_UI && event.keyCode == KeyEvent.DOM_VK_LEFT)) {\n              focusedTabIndex++;\n            } else {\n              focusedTabIndex--;\n            }\n            break;\n          case KeyEvent.DOM_VK_HOME:\n            if (keyComboForMove) {\n              gBrowser.moveTabToStart();\n            } else {\n              focusedTabIndex = 0;\n            }\n            break;\n          case KeyEvent.DOM_VK_END:\n            if (keyComboForMove) {\n              gBrowser.moveTabToEnd();\n            } else {\n              focusedTabIndex = visibleTabs.length - 1;\n            }\n            break;\n          case KeyEvent.DOM_VK_SPACE:\n            if (visibleTabs[lastFocusedTabIndex].multiselected) {\n              gBrowser.removeFromMultiSelectedTabs(visibleTabs[lastFocusedTabIndex]);\n            } else {\n              gBrowser.addToMultiSelectedTabs(visibleTabs[lastFocusedTabIndex], false);\n            }\n            break;\n          default:\n            // Consume the keydown event for the above keyboard\n            // shortcuts only.\n            return;\n        }\n\n        if (arrowKeysShouldWrap) {\n          if (focusedTabIndex >= visibleTabs.length) {\n            focusedTabIndex = 0;\n          } else if (focusedTabIndex < 0) {\n            focusedTabIndex = visibleTabs.length - 1;\n          }\n        } else {\n          focusedTabIndex = Math.min(visibleTabs.length - 1, Math.max(0, focusedTabIndex));\n        }\n\n        if (keyComboForFocus &&\n            focusedTabIndex != lastFocusedTabIndex) {\n          this.ariaFocusedItem = visibleTabs[focusedTabIndex];\n        }\n\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        var tab = this._getDragTargetTab(event, false);\n        if (!tab || this._isCustomizing)\n          return;\n\n        let selectedTabs = gBrowser.selectedTabs;\n        let otherSelectedTabs = selectedTabs.filter(selectedTab => selectedTab != tab);\n        let dataTransferOrderedTabs = [tab].concat(otherSelectedTabs);\n\n        let dt = event.dataTransfer;\n        for (let i = 0; i < dataTransferOrderedTabs.length; i++) {\n          let dtTab = dataTransferOrderedTabs[i];\n\n          dt.mozSetDataAt(TAB_DROP_TYPE, dtTab, i);\n          let dtBrowser = dtTab.linkedBrowser;\n\n          // We must not set text/x-moz-url or text/plain data here,\n          // otherwise trying to detach the tab by dropping it on the desktop\n          // may result in an \"internet shortcut\"\n          dt.mozSetDataAt(\"text/x-moz-text-internal\", dtBrowser.currentURI.spec, i);\n        }\n\n        // Set the cursor to an arrow during tab drags.\n        dt.mozCursor = \"default\";\n\n        // Set the tab as the source of the drag, which ensures we have a stable\n        // node to deliver the `dragend` event.  See bug 1345473.\n        dt.addElement(tab);\n\n        if (tab.multiselected) {\n          this._groupSelectedTabs(tab);\n        }\n\n        // Create a canvas to which we capture the current tab.\n        // Until canvas is HiDPI-aware (bug 780362), we need to scale the desired\n        // canvas size (in CSS pixels) to the window's backing resolution in order\n        // to get a full-resolution drag image for use on HiDPI displays.\n        let windowUtils = window.windowUtils;\n        let scale = windowUtils.screenPixelsPerCSSPixel / windowUtils.fullZoom;\n        let canvas = this._dndCanvas;\n        if (!canvas) {\n          this._dndCanvas = canvas =\n            document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n          canvas.style.width = \"100%\";\n          canvas.style.height = \"100%\";\n          canvas.mozOpaque = true;\n        }\n\n        canvas.width = 160 * scale;\n        canvas.height = 90 * scale;\n        let toDrag = canvas;\n        let dragImageOffset = -16;\n        let browser = tab.linkedBrowser;\n        if (gMultiProcessBrowser) {\n          var context = canvas.getContext(\"2d\");\n          context.fillStyle = \"white\";\n          context.fillRect(0, 0, canvas.width, canvas.height);\n\n          let captureListener;\n          let platform = AppConstants.platform;\n          // On Windows and Mac we can update the drag image during a drag\n          // using updateDragImage. On Linux, we can use a panel.\n          if (platform == \"win\" || platform == \"macosx\") {\n            captureListener = function() {\n              dt.updateDragImage(canvas, dragImageOffset, dragImageOffset);\n            };\n          } else {\n            // Create a panel to use it in setDragImage\n            // which will tell xul to render a panel that follows\n            // the pointer while a dnd session is on.\n            if (!this._dndPanel) {\n              this._dndCanvas = canvas;\n              this._dndPanel = document.createXULElement(\"panel\");\n              this._dndPanel.className = \"dragfeedback-tab\";\n              this._dndPanel.setAttribute(\"type\", \"drag\");\n              let wrapper = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"div\");\n              wrapper.style.width = \"160px\";\n              wrapper.style.height = \"90px\";\n              wrapper.appendChild(canvas);\n              this._dndPanel.appendChild(wrapper);\n              document.documentElement.appendChild(this._dndPanel);\n            }\n            toDrag = this._dndPanel;\n          }\n          // PageThumb is async with e10s but that's fine\n          // since we can update the image during the dnd.\n          PageThumbs.captureToCanvas(browser, canvas, captureListener);\n        } else {\n          // For the non e10s case we can just use PageThumbs\n          // sync, so let's use the canvas for setDragImage.\n          PageThumbs.captureToCanvas(browser, canvas);\n          dragImageOffset = dragImageOffset * scale;\n        }\n        dt.setDragImage(toDrag, dragImageOffset, dragImageOffset);\n\n        // _dragData.offsetX/Y give the coordinates that the mouse should be\n        // positioned relative to the corner of the new window created upon\n        // dragend such that the mouse appears to have the same position\n        // relative to the corner of the dragged tab.\n        function clientX(ele) {\n          return ele.getBoundingClientRect().left;\n        }\n        let tabOffsetX = clientX(tab) - clientX(this);\n        tab._dragData = {\n          offsetX: event.screenX - window.screenX - tabOffsetX,\n          offsetY: event.screenY - window.screenY,\n          scrollX: this.arrowScrollbox.scrollbox.scrollLeft,\n          screenX: event.screenX,\n          movingTabs: (tab.multiselected ? gBrowser.selectedTabs : [tab])\n                      .filter(t => t.pinned == tab.pinned),\n        };\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        var effects = this._getDropEffectForTabDrag(event);\n\n        var ind = this._tabDropIndicator;\n        if (effects == \"\" || effects == \"none\") {\n          ind.collapsed = true;\n          return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n\n        var arrowScrollbox = this.arrowScrollbox;\n\n        // autoscroll the tab strip if we drag over the scroll\n        // buttons, even if we aren't dragging a tab, but then\n        // return to avoid drawing the drop indicator\n        var pixelsToScroll = 0;\n        if (this.getAttribute(\"overflow\") == \"true\") {\n          var targetAnonid = event.originalTarget.getAttribute(\"anonid\");\n          switch (targetAnonid) {\n            case \"scrollbutton-up\":\n              pixelsToScroll = arrowScrollbox.scrollIncrement * -1;\n              break;\n            case \"scrollbutton-down\":\n              pixelsToScroll = arrowScrollbox.scrollIncrement;\n              break;\n          }\n          if (pixelsToScroll)\n            arrowScrollbox.scrollByPixels((RTL_UI ? -1 : 1) * pixelsToScroll, true);\n        }\n\n        let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);\n        if ((effects == \"move\" || effects == \"copy\") &&\n            this == draggedTab.parentNode) {\n          ind.collapsed = true;\n\n          if (!this._isGroupTabsAnimationOver()) {\n            // Wait for grouping tabs animation to finish\n            return;\n          }\n          this._finishGroupSelectedTabs(draggedTab);\n\n          if (effects == \"move\") {\n            this._animateTabMove(event);\n            return;\n          }\n        }\n\n        this._finishAnimateTabMove();\n\n        if (effects == \"link\") {\n          let tab = this._getDragTargetTab(event, true);\n          if (tab) {\n            if (!this._dragTime)\n              this._dragTime = Date.now();\n            if (Date.now() >= this._dragTime + this._dragOverDelay)\n              this.selectedItem = tab;\n            ind.collapsed = true;\n            return;\n          }\n        }\n\n        var rect = arrowScrollbox.getBoundingClientRect();\n        var newMargin;\n        if (pixelsToScroll) {\n          // if we are scrolling, put the drop indicator at the edge\n          // so that it doesn't jump while scrolling\n          let scrollRect = arrowScrollbox.scrollClientRect;\n          let minMargin = scrollRect.left - rect.left;\n          let maxMargin = Math.min(minMargin + scrollRect.width,\n                                   scrollRect.right);\n          if (RTL_UI) {\n            [minMargin, maxMargin] = [this.clientWidth - maxMargin,\n                                      this.clientWidth - minMargin];\n          }\n          newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;\n        } else {\n          let newIndex = this._getDropIndex(event, effects == \"link\");\n          if (newIndex == this.children.length) {\n            let tabRect = this.children[newIndex - 1].getBoundingClientRect();\n            if (RTL_UI) {\n              newMargin = rect.right - tabRect.left;\n            } else {\n              newMargin = tabRect.right - rect.left;\n            }\n          } else {\n            let tabRect = this.children[newIndex].getBoundingClientRect();\n            if (RTL_UI) {\n              newMargin = rect.right - tabRect.right;\n            } else {\n              newMargin = tabRect.left - rect.left;\n            }\n          }\n        }\n\n        ind.collapsed = false;\n\n        newMargin += ind.clientWidth / 2;\n        if (RTL_UI) {\n          newMargin *= -1;\n        }\n\n        ind.style.transform = \"translate(\" + Math.round(newMargin) + \"px)\";\n        ind.style.marginInlineStart = (-ind.clientWidth) + \"px\";\n      ]]></handler>\n\n      <handler event=\"drop\"><![CDATA[\n        var dt = event.dataTransfer;\n        var dropEffect = dt.dropEffect;\n        var draggedTab;\n        let movingTabs;\n        if (dt.mozTypesAt(0)[0] == TAB_DROP_TYPE) { // tab copy or move\n          draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);\n          // not our drop then\n          if (!draggedTab)\n            return;\n          movingTabs = draggedTab._dragData.movingTabs;\n          draggedTab.parentNode._finishGroupSelectedTabs(draggedTab);\n        }\n\n        this._tabDropIndicator.collapsed = true;\n        event.stopPropagation();\n        if (draggedTab && dropEffect == \"copy\") {\n          // copy the dropped tab (wherever it's from)\n          let newIndex = this._getDropIndex(event, false);\n          let draggedTabCopy;\n          for (let tab of movingTabs) {\n            let newTab = gBrowser.duplicateTab(tab);\n            gBrowser.moveTabTo(newTab, newIndex++);\n            if (tab == draggedTab)\n              draggedTabCopy = newTab;\n          }\n          if (draggedTab.parentNode != this || event.shiftKey) {\n            this.selectedItem = draggedTabCopy;\n          }\n        } else if (draggedTab && draggedTab.parentNode == this) {\n          let oldTranslateX = Math.round(draggedTab._dragData.translateX);\n          let tabWidth = Math.round(draggedTab._dragData.tabWidth);\n          let translateOffset = oldTranslateX % tabWidth;\n          let newTranslateX = oldTranslateX - translateOffset;\n          if (oldTranslateX > 0 && translateOffset > tabWidth / 2) {\n            newTranslateX += tabWidth;\n          } else if (oldTranslateX < 0 && -translateOffset > tabWidth / 2) {\n            newTranslateX -= tabWidth;\n          }\n\n          let dropIndex = \"animDropIndex\" in draggedTab._dragData &&\n                          draggedTab._dragData.animDropIndex;\n          let incrementDropIndex = true;\n          if (dropIndex && dropIndex > movingTabs[0]._tPos) {\n            dropIndex--;\n            incrementDropIndex = false;\n          }\n\n          let animate = gBrowser.animationsEnabled;\n          if (oldTranslateX && oldTranslateX != newTranslateX && animate) {\n            for (let tab of movingTabs) {\n              tab.setAttribute(\"tabdrop-samewindow\", \"true\");\n              tab.style.transform = \"translateX(\" + newTranslateX + \"px)\";\n              let onTransitionEnd = transitionendEvent => {\n                if (transitionendEvent.propertyName != \"transform\" ||\n                    transitionendEvent.originalTarget != tab) {\n                  return;\n                }\n                tab.removeEventListener(\"transitionend\", onTransitionEnd);\n\n                tab.removeAttribute(\"tabdrop-samewindow\");\n\n                this._finishAnimateTabMove();\n                if (dropIndex !== false) {\n                  gBrowser.moveTabTo(tab, dropIndex);\n                  if (incrementDropIndex)\n                    dropIndex++;\n                }\n\n                gBrowser.syncThrobberAnimations(tab);\n              };\n              tab.addEventListener(\"transitionend\", onTransitionEnd);\n            }\n          } else {\n            this._finishAnimateTabMove();\n            if (dropIndex !== false) {\n              for (let tab of movingTabs) {\n                gBrowser.moveTabTo(tab, dropIndex);\n                if (incrementDropIndex)\n                  dropIndex++;\n              }\n            }\n          }\n        } else if (draggedTab) {\n          let newIndex = this._getDropIndex(event, false);\n          let newTabs = [];\n          for (let tab of movingTabs) {\n            let newTab = gBrowser.adoptTab(tab, newIndex++, tab == draggedTab);\n            newTabs.push(newTab);\n          }\n\n          // Restore tab selection\n          gBrowser.addRangeToMultiSelectedTabs(newTabs[0], newTabs[newTabs.length - 1]);\n        } else {\n          // Pass true to disallow dropping javascript: or data: urls\n          let links;\n          try {\n            links = browserDragAndDrop.dropLinks(event, true);\n          } catch (ex) {}\n\n          if (!links || links.length === 0)\n            return;\n\n          let inBackground = Services.prefs.getBoolPref(\"browser.tabs.loadInBackground\");\n          if (event.shiftKey)\n            inBackground = !inBackground;\n\n          let targetTab = this._getDragTargetTab(event, true);\n          let userContextId = this.selectedItem.getAttribute(\"usercontextid\");\n          let replace = !!targetTab;\n          let newIndex = this._getDropIndex(event, true);\n          let urls = links.map(link => link.url);\n\n          let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(event);\n\n          (async () => {\n            if (urls.length >= Services.prefs.getIntPref(\"browser.tabs.maxOpenBeforeWarn\")) {\n              // Sync dialog cannot be used inside drop event handler.\n              let answer = await OpenInTabsUtils.promiseConfirmOpenInTabs(urls.length,\n                                                                          window);\n              if (!answer) {\n                return;\n              }\n            }\n\n            gBrowser.loadTabs(urls, {\n              inBackground,\n              replace,\n              allowThirdPartyFixup: true,\n              targetTab,\n              newIndex,\n              userContextId,\n              triggeringPrincipal,\n            });\n          })();\n        }\n\n        if (draggedTab) {\n          delete draggedTab._dragData;\n        }\n      ]]></handler>\n\n      <handler event=\"dragend\"><![CDATA[\n        var dt = event.dataTransfer;\n        var draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);\n\n        // Prevent this code from running if a tabdrop animation is\n        // running since calling _finishAnimateTabMove would clear\n        // any CSS transition that is running.\n        if (draggedTab.hasAttribute(\"tabdrop-samewindow\"))\n          return;\n\n        this._finishGroupSelectedTabs(draggedTab);\n        this._finishAnimateTabMove();\n\n        if (dt.mozUserCancelled || dt.dropEffect != \"none\" || this._isCustomizing) {\n          delete draggedTab._dragData;\n          return;\n        }\n\n        // Disable detach within the browser toolbox\n        var eX = event.screenX;\n        var eY = event.screenY;\n        var wX = window.screenX;\n        // check if the drop point is horizontally within the window\n        if (eX > wX && eX < (wX + window.outerWidth)) {\n          // also avoid detaching if the the tab was dropped too close to\n          // the tabbar (half a tab)\n          let rect = window.windowUtils.getBoundsWithoutFlushing(this.arrowScrollbox);\n          let detachTabThresholdY = window.screenY + rect.top + 1.5 * rect.height;\n          if (eY < detachTabThresholdY && eY > window.screenY)\n            return;\n        }\n\n        // screen.availLeft et. al. only check the screen that this window is on,\n        // but we want to look at the screen the tab is being dropped onto.\n        var screen = Cc[\"@mozilla.org/gfx/screenmanager;1\"]\n                       .getService(Ci.nsIScreenManager)\n                       .screenForRect(eX, eY, 1, 1);\n        var fullX = {}, fullY = {}, fullWidth = {}, fullHeight = {};\n        var availX = {}, availY = {}, availWidth = {}, availHeight = {};\n        // get full screen rect and available rect, both in desktop pix\n        screen.GetRectDisplayPix(fullX, fullY, fullWidth, fullHeight);\n        screen.GetAvailRectDisplayPix(availX, availY, availWidth, availHeight);\n\n        // scale factor to convert desktop pixels to CSS px\n        var scaleFactor =\n          screen.contentsScaleFactor / screen.defaultCSSScaleFactor;\n        // synchronize CSS-px top-left coordinates with the screen's desktop-px\n        // coordinates, to ensure uniqueness across multiple screens\n        // (compare the equivalent adjustments in nsGlobalWindow::GetScreenXY()\n        // and related methods)\n        availX.value = (availX.value - fullX.value) * scaleFactor + fullX.value;\n        availY.value = (availY.value - fullY.value) * scaleFactor + fullY.value;\n        availWidth.value *= scaleFactor;\n        availHeight.value *= scaleFactor;\n\n        // ensure new window entirely within screen\n        var winWidth = Math.min(window.outerWidth, availWidth.value);\n        var winHeight = Math.min(window.outerHeight, availHeight.value);\n        var left = Math.min(Math.max(eX - draggedTab._dragData.offsetX, availX.value),\n                            availX.value + availWidth.value - winWidth);\n        var top = Math.min(Math.max(eY - draggedTab._dragData.offsetY, availY.value),\n                           availY.value + availHeight.value - winHeight);\n\n        delete draggedTab._dragData;\n\n        if (gBrowser.tabs.length == 1) {\n          // resize _before_ move to ensure the window fits the new screen.  if\n          // the window is too large for its screen, the window manager may do\n          // automatic repositioning.\n          window.resizeTo(winWidth, winHeight);\n          window.moveTo(left, top);\n          window.focus();\n        } else {\n          let props = { screenX: left, screenY: top, suppressanimation: 1 };\n          if (AppConstants.platform != \"win\") {\n            props.outerWidth = winWidth;\n            props.outerHeight = winHeight;\n          }\n          gBrowser.replaceTabsWithWindow(draggedTab, props);\n        }\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragexit\"><![CDATA[\n        this._dragTime = 0;\n\n        // This does not work at all (see bug 458613)\n        var target = event.relatedTarget;\n        while (target && target != this)\n          target = target.parentNode;\n        if (target)\n          return;\n\n        this._tabDropIndicator.collapsed = true;\n        event.stopPropagation();\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"urlbarBindings.xml","body":"<?xml version=\"1.0\"?>\n\n<!--\n-*- Mode: HTML -*-\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n-->\n\n<!DOCTYPE bindings [\n<!ENTITY % notificationDTD SYSTEM \"chrome://global/locale/notification.dtd\">\n%notificationDTD;\n<!ENTITY % browserDTD SYSTEM \"chrome://browser/locale/browser.dtd\">\n%browserDTD;\n<!ENTITY % brandDTD SYSTEM \"chrome://branding/locale/brand.dtd\">\n%brandDTD;\n]>\n\n<bindings id=\"urlbarBindings\" xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"urlbar\" extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content role=\"combobox\">\n      <children includes=\"box\"/>\n      <xul:moz-input-box anonid=\"moz-input-box\"\n                         tooltip=\"aHTMLTooltip\"\n                         class=\"urlbar-input-box\"\n                         flex=\"1\">\n        <children/>\n        <html:input anonid=\"scheme\"\n                    class=\"urlbar-scheme textbox-input\"\n                    required=\"required\"\n                    xbl:inherits=\"textoverflow,focused\"/>\n        <html:input anonid=\"input\"\n                    class=\"urlbar-input textbox-input\"\n                    aria-owns=\"urlbarView-results\"\n                    aria-controls=\"urlbarView-results\"\n                    aria-autocomplete=\"both\"\n                    allowevents=\"true\"\n                    inputmode=\"mozAwesomebar\"\n                    xbl:inherits=\"value,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,focused,textoverflow\"/>\n      </xul:moz-input-box>\n      <xul:image anonid=\"urlbar-go-button\"\n                 class=\"urlbar-go-button urlbar-icon\"\n                 onclick=\"gURLBar.handleCommand(event);\"\n                 tooltiptext=\"FROM-DTD.goEndCap.tooltip;\"\n                 xbl:inherits=\"pageproxystate,parentfocused=focused,usertyping\"/>\n      <xul:dropmarker anonid=\"historydropmarker\"\n                      class=\"urlbar-history-dropmarker urlbar-icon chromeclass-toolbar-additional\"\n                      tooltiptext=\"FROM-DTD.urlbar.openHistoryPopup.tooltip;\"\n                      allowevents=\"true\"\n                      xbl:inherits=\"open,parentfocused=focused,usertyping\"/>\n      <children includes=\"hbox\"/>\n    </content>\n  </binding>\n\n  <binding id=\"legacy-urlbar\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete\">\n    <content newlines=\"stripsurroundingwhitespace\"\n             type=\"autocomplete\"\n             autocompletesearch=\"unifiedcomplete\"\n             autocompletesearchparam=\"enable-actions\"\n             autocompletepopup=\"PopupAutoCompleteRichResult\"\n             completeselectedindex=\"true\"\n             tabscrolling=\"true\"\n             ontextentered=\"this.handleCommand(param);\"\n             ontextreverted=\"return this.handleRevert();\">\n      <children includes=\"box\"/>\n      <xul:moz-input-box anonid=\"moz-input-box\"\n                         tooltip=\"aHTMLTooltip\"\n                         class=\"urlbar-input-box\"\n                         flex=\"1\">\n        <children/>\n        <html:input anonid=\"scheme\"\n                    class=\"urlbar-scheme textbox-input\"\n                    required=\"required\"\n                    xbl:inherits=\"textoverflow,focused\"/>\n        <html:input anonid=\"input\"\n                    class=\"urlbar-input textbox-input\"\n                    allowevents=\"true\"\n                    inputmode=\"mozAwesomebar\"\n                    xbl:inherits=\"value,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,focused,textoverflow\"/>\n      </xul:moz-input-box>\n      <xul:image anonid=\"urlbar-go-button\"\n                 class=\"urlbar-go-button urlbar-icon\"\n                 onclick=\"gURLBar.handleCommand(event);\"\n                 tooltiptext=\"FROM-DTD.goEndCap.tooltip;\"\n                 xbl:inherits=\"pageproxystate,parentfocused=focused,usertyping\"/>\n      <xul:dropmarker anonid=\"historydropmarker\"\n                      class=\"urlbar-history-dropmarker urlbar-icon chromeclass-toolbar-additional\"\n                      tooltiptext=\"FROM-DTD.urlbar.openHistoryPopup.tooltip;\"\n                      allowevents=\"true\"\n                      xbl:inherits=\"open,parentfocused=focused,usertyping\"/>\n      <children includes=\"hbox\"/>\n    </content>\n\n    <implementation implements=\"nsIObserver\">\n      <field name=\"ExtensionSearchHandler\" readonly=\"true\">\n        (ChromeUtils.import(\"resource://gre/modules/ExtensionSearchHandler.jsm\", {})).ExtensionSearchHandler;\n      </field>\n\n      <constructor><![CDATA[\n        // UrlbarInput compatibility shims\n        this.document = document;\n        this.window = window;\n        this.textbox = this;\n\n        this._prefs = Cc[\"@mozilla.org/preferences-service;1\"]\n                        .getService(Ci.nsIPrefService)\n                        .getBranch(\"browser.urlbar.\");\n        this._prefs.addObserver(\"\", this);\n\n        this._defaultPrefs = Cc[\"@mozilla.org/preferences-service;1\"]\n                               .getService(Ci.nsIPrefService)\n                               .getDefaultBranch(\"browser.urlbar.\");\n\n        Services.prefs.addObserver(\"browser.search.suggest.enabled\", this);\n        this.browserSearchSuggestEnabled = Services.prefs.getBoolPref(\"browser.search.suggest.enabled\");\n\n        this.openInTab = this._prefs.getBoolPref(\"openintab\");\n        this.clickSelectsAll = this._prefs.getBoolPref(\"clickSelectsAll\");\n        this.doubleClickSelectsAll = this._prefs.getBoolPref(\"doubleClickSelectsAll\");\n        this.completeDefaultIndex = this._prefs.getBoolPref(\"autoFill\");\n        this.urlbarSearchSuggestEnabled = this._prefs.getBoolPref(\"suggest.searches\");\n        this.timeout = this._prefs.getIntPref(\"delay\");\n        this._mayTrimURLs = this._prefs.getBoolPref(\"trimURLs\");\n        this._adoptIntoActiveWindow = this._prefs.getBoolPref(\"switchTabs.adoptIntoActiveWindow\");\n        this._ctrlCanonizesURLs = this._prefs.getBoolPref(\"ctrlCanonizesURLs\");\n        this.inputField.controllers.insertControllerAt(0, this._copyCutController);\n        this.inputField.addEventListener(\"paste\", this);\n        this.inputField.addEventListener(\"mousedown\", this);\n        this.inputField.addEventListener(\"mouseover\", this);\n        this.inputField.addEventListener(\"overflow\", this);\n        this.inputField.addEventListener(\"underflow\", this);\n        this.inputField.addEventListener(\"scrollend\", this);\n        window.addEventListener(\"resize\", this);\n\n        var textBox = document.getAnonymousElementByAttribute(this,\n                                                \"anonid\", \"moz-input-box\");\n        // Force the Custom Element to upgrade until Bug 1470242 handles this:\n        customElements.upgrade(textBox);\n        var cxmenu = textBox.menupopup;\n        var pasteAndGo;\n        cxmenu.addEventListener(\"popupshowing\", function() {\n          if (!pasteAndGo)\n            return;\n          var controller = document.commandDispatcher.getControllerForCommand(\"cmd_paste\");\n          var enabled = controller.isCommandEnabled(\"cmd_paste\");\n          if (enabled)\n            pasteAndGo.removeAttribute(\"disabled\");\n          else\n            pasteAndGo.setAttribute(\"disabled\", \"true\");\n        });\n\n        var insertLocation = cxmenu.firstElementChild;\n        while (insertLocation.nextElementSibling &&\n               insertLocation.getAttribute(\"cmd\") != \"cmd_paste\")\n          insertLocation = insertLocation.nextElementSibling;\n        if (insertLocation) {\n          pasteAndGo = document.createXULElement(\"menuitem\");\n          let label = Services.strings.createBundle(\"chrome://browser/locale/browser.properties\").\n                                   GetStringFromName(\"pasteAndGo.label\");\n          pasteAndGo.setAttribute(\"label\", label);\n          pasteAndGo.setAttribute(\"anonid\", \"paste-and-go\");\n          pasteAndGo.setAttribute(\"oncommand\",\n              \"gURLBar.select(); goDoCommand('cmd_paste'); gURLBar.handleCommand();\");\n          cxmenu.insertBefore(pasteAndGo, insertLocation.nextElementSibling);\n        }\n\n        this.popup.addEventListener(\"popupshowing\", () => {\n          this._enableOrDisableOneOffSearches();\n        }, {capture: true, once: true});\n\n        // history dropmarker open state\n        this.popup.addEventListener(\"popupshowing\", () => {\n          this.setAttribute(\"open\", \"true\");\n        });\n        this.popup.addEventListener(\"popuphidden\", () => {\n          requestAnimationFrame(() => {\n            this.removeAttribute(\"open\");\n          });\n        });\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // Somehow, it's possible for the XBL destructor to fire without the\n        // constructor ever having fired. Fix:\n        if (!this._prefs) {\n          return;\n        }\n        this._prefs.removeObserver(\"\", this);\n        this._prefs = null;\n        Services.prefs.removeObserver(\"browser.search.suggest.enabled\", this);\n        try {\n          this.inputField.controllers.removeController(this._copyCutController);\n        } catch (ex) {\n          // Sometimes this fails for unclear reasons; anyway we want to\n          // continue cleaning up.\n          Cu.reportError(ex);\n        }\n        this.inputField.removeEventListener(\"paste\", this);\n        this.inputField.removeEventListener(\"mousedown\", this);\n        this.inputField.removeEventListener(\"mouseover\", this);\n        this.inputField.removeEventListener(\"overflow\", this);\n        this.inputField.removeEventListener(\"underflow\", this);\n        this.inputField.removeEventListener(\"scrollend\", this);\n        window.removeEventListener(\"resize\", this);\n\n        if (this._deferredKeyEventTimeout) {\n          clearTimeout(this._deferredKeyEventTimeout);\n          this._deferredKeyEventTimeout = null;\n        }\n\n        // Null out the one-offs' popup and textbox so that it cleans up its\n        // internal state for both.  Most importantly, it removes the event\n        // listeners that it added to both.\n        this.popup.oneOffSearchButtons.popup = null;\n        this.popup.oneOffSearchButtons.textbox = null;\n\n        this.valueFormatter.uninit();\n      ]]></destructor>\n\n      <field name=\"valueFormatter\" readonly=\"true\">\n        new UrlbarValueFormatter(this);\n      </field>\n\n      <field name=\"goButton\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"urlbar-go-button\");\n      </field>\n\n      <field name=\"_value\">\"\"</field>\n      <field name=\"gotResultForCurrentQuery\">false</field>\n\n      <!--\n        This is set around HandleHenter so it can be used in handleCommand.\n        It is also used to track whether we must handle a delayed handleEnter,\n        by checking if it has been cleared.\n      -->\n      <field name=\"handleEnterInstance\">null</field>\n\n      <!--\n        Since we never want scrollbars, we always use the maxResults value.\n      -->\n      <property name=\"maxRows\"\n                onget=\"return this.popup.maxResults;\"/>\n\n      <!--\n        Set by focusAndSelectUrlBar to indicate whether the next focus event was\n        initiated by an explicit user action. See the \"focus\" handler below.\n      -->\n      <field name=\"userInitiatedFocus\">false</field>\n\n      <!--\n        onBeforeValueGet is called by the base-binding's .value getter.\n        It can return an object with a \"value\" property, to override the\n        return value of the getter.\n      -->\n      <method name=\"onBeforeValueGet\">\n        <body><![CDATA[\n          return { value: this._value };\n        ]]></body>\n      </method>\n\n      <!--\n        onBeforeValueSet is called by the base-binding's .value setter.\n        It should return the value that the setter should use.\n      -->\n      <method name=\"onBeforeValueSet\">\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          this._value = aValue;\n          var returnValue = aValue;\n          var action = this._parseActionUrl(aValue);\n\n          if (action) {\n            switch (action.type) {\n              case \"switchtab\": // Fall through.\n              case \"remotetab\": // Fall through.\n              case \"visiturl\": {\n                returnValue = action.params.displayUrl;\n                break;\n              }\n              case \"keyword\": // Fall through.\n              case \"searchengine\": {\n                returnValue = action.params.input;\n                break;\n              }\n              case \"extension\": {\n                returnValue = action.params.content;\n                break;\n              }\n            }\n          } else {\n            let originalUrl = ReaderMode.getOriginalUrlObjectForDisplay(aValue);\n            if (originalUrl) {\n              returnValue = originalUrl.displaySpec;\n            }\n          }\n\n          // Set the actiontype only if the user is not overriding actions.\n          if (action && this._pressedNoActionKeys.size == 0) {\n            this.setAttribute(\"actiontype\", action.type);\n          } else {\n            this.removeAttribute(\"actiontype\");\n          }\n          return returnValue;\n        ]]></body>\n      </method>\n\n      <method name=\"onKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aOptions\"/>\n        <body><![CDATA[\n          switch (aEvent.keyCode) {\n            case KeyEvent.DOM_VK_LEFT:\n            case KeyEvent.DOM_VK_RIGHT:\n            case KeyEvent.DOM_VK_HOME:\n              // Reset the selected index so that nsAutoCompleteController\n              // simply closes the popup without trying to fill anything.\n              this.popup.selectedIndex = -1;\n              break;\n            case KeyEvent.DOM_VK_TAB:\n              this.userSelectionBehavior = \"tab\";\n              // The user is explicitly making a selection, so the popup\n              // should get accessibility focus.\n              this.popup.richlistbox.suppressMenuItemEvent = false;\n              break;\n            case KeyEvent.DOM_VK_UP:\n            case KeyEvent.DOM_VK_DOWN:\n            case KeyEvent.DOM_VK_PAGE_UP:\n            case KeyEvent.DOM_VK_PAGE_DOWN:\n              if (this.userSelectionBehavior != \"tab\")\n                this.userSelectionBehavior = \"arrow\";\n              // The user is explicitly making a selection, so the popup\n              // should get accessibility focus.\n              this.popup.richlistbox.suppressMenuItemEvent = false;\n              break;\n          }\n\n          if (AppConstants.platform == \"macosx\") {\n            switch (aEvent.key) {\n              case \"n\":\n              case \"p\":\n                if (aEvent.ctrlKey) {\n                  // The user is explicitly making a selection, so the popup\n                  // should get accessibility focus.\n                  this.popup.richlistbox.suppressMenuItemEvent = false;\n                }\n                break;\n            }\n          }\n\n          let noDefer = aOptions && aOptions.noDefer;\n          if (!noDefer && this._shouldDeferKeyEvent(aEvent)) {\n            this._deferKeyEvent(aEvent, \"onKeyPress\");\n            return false;\n          }\n          if (this.popup.popupOpen && this.popup.handleKeyPress(aEvent)) {\n            return true;\n          }\n          return this.handleKeyPress(aEvent, aOptions);\n        ]]></body>\n      </method>\n\n      <!--\n        Search results arrive asynchronously, which means that keypresses may\n        arrive before results do and therefore not have the effect the user\n        intends.  That's especially likely to happen with the down arrow and\n        enter keys due to the one-off search buttons: if the user very quickly\n        pastes something in the input, presses the down arrow key, and then hits\n        enter, they are probably expecting to visit the first result.  But if\n        there are no results, then pressing down and enter will trigger the\n        first one-off button.  To prevent that undesirable behavior, certain\n        keys are buffered and deferred until more results arrive, at which time\n        they're replayed.\n\n        @param  event\n                The key event that should maybe be deferred.\n        @return True if the event should be deferred, false if not.\n       -->\n      <method name=\"_shouldDeferKeyEvent\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          // If any event has been deferred for this search, then defer all\n          // subsequent events so that the user does not experience any\n          // keypresses out of order.  All events will be replayed when\n          // _deferredKeyEventTimeout fires.\n          if (this._deferredKeyEventQueue.length) {\n            return true;\n          }\n\n          // At this point, no events have been deferred for this search, and we\n          // need to decide whether `event` is the first one that should be.\n          if (!this._keyCodesToDefer.has(event.keyCode) &&\n              !(/Mac/.test(navigator.platform) &&\n                event.ctrlKey &&\n                (event.key === \"n\" || event.key === \"p\") &&\n                this.popupOpen)) {\n            // Not a key that should trigger deferring.\n            return false;\n          }\n\n          let waitedLongEnough =\n            this._searchStartDate + this._deferredKeyEventTimeoutMs <= Cu.now();\n          if (waitedLongEnough) {\n            // This is a key that we would defer, but enough time has passed\n            // since the start of the search that we don't want to block the\n            // user's keypresses anymore.\n            return false;\n          }\n\n          if (event.keyCode == KeyEvent.DOM_VK_TAB && !this.popupOpen) {\n            // The popup is closed and the user pressed the Tab key.  The\n            // focus should move out of the urlbar immediately.\n            return false;\n          }\n\n          return !this._safeToPlayDeferredKeyEvent(event);\n        ]]></body>\n      </method>\n\n      <!--\n        Returns true if the given deferred key event can be played now without\n        possibly surprising the user.  This depends on the state of the popup,\n        its results, and the type of keypress.  Use this method only after\n        determining that the event should be deferred, or after it's already\n        been deferred and you want to know if it can be played now.\n\n        @param  event\n                The key event.\n        @return True if the event can be played, false if not.\n      -->\n      <method name=\"_safeToPlayDeferredKeyEvent\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (event.keyCode == KeyEvent.DOM_VK_RETURN) {\n            return this.popup.selectedIndex != 0 ||\n                   this.gotResultForCurrentQuery;\n          }\n\n          if (!this.gotResultForCurrentQuery || !this.popupOpen) {\n            // We're still waiting on the first result, or the popup hasn't\n            // opened yet, so not safe.\n            return false;\n          }\n\n          let maxResultsRemaining =\n            this.popup.maxResults - this.popup.matchCount;\n          if (maxResultsRemaining == 0) {\n            // The popup can't possibly have any more results, so there's no\n            // need to defer any event now.\n            return true;\n          }\n\n          if (event.keyCode == KeyEvent.DOM_VK_DOWN) {\n            // Don't play the event if the last result is selected so that the\n            // user doesn't accidentally arrow down into the one-off buttons\n            // when they didn't mean to.\n            let lastResultSelected =\n              this.popup.selectedIndex + 1 == this.popup.matchCount;\n            return !lastResultSelected;\n          }\n\n          return true;\n        ]]></body>\n      </method>\n\n      <!--\n        Adds a key event to the deferred event queue.\n\n        @param event\n               The key event to defer.\n        @param methodName\n               The name of the method on `this` to call.  It's expected to take\n               two arguments: the event, and an optional options object:\n               {\n                  noDefer: If true, then the event is being replayed and it\n                           should not be deferred again.\n               }\n      -->\n      <method name=\"_deferKeyEvent\">\n        <parameter name=\"event\"/>\n        <parameter name=\"methodName\"/>\n        <body><![CDATA[\n          // Somehow event.defaultPrevented ends up true for deferred events.\n          // autocomplete ignores defaultPrevented events, which means it would\n          // ignore replayed deferred events if we didn't tell it to bypass\n          // defaultPrevented.  That's the purpose of this expando.  If we could\n          // figure out what's setting defaultPrevented and prevent it, then we\n          // could get rid of this.\n          if (event.urlbarDeferred) {\n            throw new Error(\"Key event already deferred!\");\n          }\n          event.urlbarDeferred = true;\n\n          this._deferredKeyEventQueue.push({\n            methodName,\n            event,\n            searchString: this.mController.searchString,\n          });\n\n          if (!this._deferredKeyEventTimeout) {\n            // Start the timeout that will unconditionally replay all deferred\n            // events when it fires so that, after a certain point, we don't\n            // keep blocking the user's keypresses when nothing else has caused\n            // the events to be replayed.  Do not check whether it's safe to\n            // replay the events because otherwise it may look like we ignored\n            // the user's input.\n            let elapsed = Cu.now() - this._searchStartDate;\n            let remaining = this._deferredKeyEventTimeoutMs - elapsed;\n            this._deferredKeyEventTimeout = setTimeout(() => {\n              this.replayAllDeferredKeyEvents();\n              this._deferredKeyEventTimeout = null;\n            }, Math.max(0, remaining));\n          }\n        ]]></body>\n      </method>\n\n      <!-- The enter key is always deferred, so it's not included here. -->\n      <field name=\"_keyCodesToDefer\">new Set([\n        KeyboardEvent.DOM_VK_RETURN,\n        KeyboardEvent.DOM_VK_DOWN,\n        KeyboardEvent.DOM_VK_TAB,\n      ])</field>\n      <field name=\"_deferredKeyEventQueue\">[]</field>\n      <field name=\"_deferredKeyEventTimeout\">null</field>\n      <field name=\"_deferredKeyEventTimeoutMs\">200</field>\n      <field name=\"_searchStartDate\">0</field>\n\n      <method name=\"replaySafeDeferredKeyEvents\">\n        <body><![CDATA[\n          if (!this._deferredKeyEventQueue.length) {\n            return;\n          }\n          let instance = this._deferredKeyEventQueue[0];\n          if (!this._safeToPlayDeferredKeyEvent(instance.event)) {\n            return;\n          }\n          this._deferredKeyEventQueue.shift();\n          this._replayKeyEventInstance(instance);\n          Services.tm.dispatchToMainThread(() => {\n            this.replaySafeDeferredKeyEvents();\n          });\n        ]]></body>\n      </method>\n\n      <!--\n        Unconditionally replays all deferred key events.  This does not check\n        whether it's safe to replay the events; use replaySafeDeferredKeyEvents\n        for that.  Use this method when you must replay all events so that it\n        does not appear that we ignored the user's input.\n      -->\n      <method name=\"replayAllDeferredKeyEvents\">\n        <body><![CDATA[\n          let instance = this._deferredKeyEventQueue.shift();\n          if (!instance) {\n            return;\n          }\n          this._replayKeyEventInstance(instance);\n          Services.tm.dispatchToMainThread(() => {\n            this.replayAllDeferredKeyEvents();\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"_replayKeyEventInstance\">\n        <parameter name=\"instance\"/>\n        <body><![CDATA[\n          // Safety check: handle only if the search string didn't change.\n          if (this.mController.searchString == instance.searchString) {\n            this[instance.methodName](instance.event, {noDefer: true});\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_mayTrimURLs\">true</field>\n      <method name=\"trimValue\">\n        <parameter name=\"aURL\"/>\n        <body><![CDATA[\n          // This method must not modify the given URL such that calling\n          // nsIURIFixup::createFixupURI with the result will produce a different URI.\n          return this._mayTrimURLs ? BrowserUtils.trimURL(aURL) : aURL;\n        ]]></body>\n      </method>\n\n      <!--\n        This method tries to apply styling to the text in the input, depending\n        on the text.  See the _format* methods.\n      -->\n      <method name=\"formatValue\">\n        <body><![CDATA[\n          // The editor may not exist if the toolbar is not visible.\n          if (this.editor) {\n            this.valueFormatter.update();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"handleRevert\">\n        <body><![CDATA[\n          var isScrolling = this.popupOpen;\n\n          gBrowser.userTypedValue = null;\n\n          // don't revert to last valid url unless page is NOT loading\n          // and user is NOT key-scrolling through autocomplete list\n          if (!XULBrowserWindow.isBusy && !isScrolling) {\n            URLBarSetURI(null, true);\n\n            // If the value isn't empty and the urlbar has focus, select the value.\n            if (this.value && this.hasAttribute(\"focused\"))\n              this.select();\n          }\n\n          // tell widget to revert to last typed text only if the user\n          // was scrolling when they hit escape\n          return !isScrolling;\n        ]]></body>\n      </method>\n\n      <method name=\"_whereToOpen\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let isMouseEvent = event instanceof MouseEvent;\n          let reuseEmpty = !isMouseEvent;\n          let where = undefined;\n          if (!isMouseEvent && event && event.altKey) {\n            // We support using 'alt' to open in a tab, because ctrl/shift\n            // might be used for canonizing URLs:\n            where = event.shiftKey ? \"tabshifted\" : \"tab\";\n          } else if (!isMouseEvent && this._ctrlCanonizesURLs && event && event.ctrlKey) {\n            // If we're allowing canonization, and this is a key event with ctrl\n            // pressed, open in current tab to allow ctrl-enter to canonize URL.\n            where = \"current\";\n          } else {\n            where = whereToOpenLink(event, false, false);\n          }\n          if (this.openInTab) {\n            if (where == \"current\") {\n              where = \"tab\";\n            } else if (where == \"tab\") {\n              where = \"current\";\n            }\n            reuseEmpty = true;\n          }\n          if (where == \"tab\" && reuseEmpty && gBrowser.selectedTab.isEmpty) {\n            where = \"current\";\n          }\n          return where;\n        ]]></body>\n      </method>\n\n      <!--\n        This is ultimately called by the autocomplete controller as the result\n        of handleEnter when the Return key is pressed in the textbox.  Since\n        onPopupClick also calls handleEnter, this is also called as a result in\n        that case.\n\n        @param event\n               The event that triggered the command.\n        @param openUILinkWhere\n               Optional.  The \"where\" to pass to openTrustedLinkIn.  This method\n               computes the appropriate \"where\" given the event, but you can\n               use this to override it.\n        @param openUILinkParams\n               Optional.  The parameters to pass to openTrustedLinkIn.  As with\n               \"where\", this method computes the appropriate parameters, but\n               any parameters you supply here will override those.\n      -->\n      <method name=\"handleCommand\">\n        <parameter name=\"event\"/>\n        <parameter name=\"openUILinkWhere\"/>\n        <parameter name=\"openUILinkParams\"/>\n        <parameter name=\"triggeringPrincipal\"/>\n        <body><![CDATA[\n          let isMouseEvent = event instanceof MouseEvent;\n          if (isMouseEvent && event.button == 2) {\n            // Do nothing for right clicks.\n            return;\n          }\n\n          // Determine whether to use the selected one-off search button.  In\n          // one-off search buttons parlance, \"selected\" means that the button\n          // has been navigated to via the keyboard.  So we want to use it if\n          // the triggering event is not a mouse click -- i.e., it's a Return\n          // key -- or if the one-off was mouse-clicked.\n          let selectedOneOff = this.popup.oneOffSearchButtons.selectedButton;\n          if (selectedOneOff &&\n              isMouseEvent &&\n              event.originalTarget != selectedOneOff) {\n            selectedOneOff = null;\n          }\n\n          // Do the command of the selected one-off if it's not an engine.\n          if (selectedOneOff && !selectedOneOff.engine) {\n            selectedOneOff.doCommand();\n            return;\n          }\n\n          let where = openUILinkWhere || this._whereToOpen(event);\n\n          let url = this.value;\n          if (!url) {\n            return;\n          }\n\n          BrowserUsageTelemetry.recordLegacyUrlbarSelectedResultMethod(\n            event, this.userSelectionBehavior);\n\n          let mayInheritPrincipal = false;\n          let postData = null;\n          let browser = gBrowser.selectedBrowser;\n          let action = this._parseActionUrl(url);\n\n          if (selectedOneOff && selectedOneOff.engine) {\n            // If there's a selected one-off button then load a search using\n            // the one-off's engine.\n            [url, postData] =\n              this._parseAndRecordSearchEngineLoad(selectedOneOff.engine,\n                                                   this.oneOffSearchQuery,\n                                                   event);\n          } else if (action) {\n            switch (action.type) {\n              case \"visiturl\":\n                // Unifiedcomplete uses fixupURI to tell if something is a visit\n                // or a search, and passes out the fixedURI as the url param.\n                // By using that uri we would end up passing a different string\n                // to the docshell that may run a different not-found heuristic.\n                // For example, \"mozilla/run\" would be fixed by unifiedcomplete\n                // to \"http://mozilla/run\". The docshell, once it can't resolve\n                // mozilla, would note the string has a scheme, and try to load\n                // http://mozilla.com/run instead of searching \"mozilla/run\".\n                // So, if we have the original input at hand, we pass it through\n                // and let the docshell handle it.\n                if (action.params.input) {\n                  url = action.params.input;\n                  break;\n                }\n                url = action.params.url;\n                break;\n              case \"remotetab\":\n                url = action.params.url;\n                break;\n              case \"keyword\":\n                if (action.params.postData) {\n                  postData = UrlbarUtils.getPostDataStream(action.params.postData);\n                }\n                mayInheritPrincipal = true;\n                url = action.params.url;\n                break;\n              case \"switchtab\":\n                url = action.params.url;\n                if (this.hasAttribute(\"actiontype\")) {\n                  this.handleRevert();\n                  let prevTab = gBrowser.selectedTab;\n                  let loadOpts = {\n                    adoptIntoActiveWindow: this._adoptIntoActiveWindow,\n                  };\n\n                  if (switchToTabHavingURI(url, false, loadOpts) &&\n                      prevTab.isEmpty) {\n                    gBrowser.removeTab(prevTab);\n                  }\n                  return;\n                }\n\n                // Once we get here, we got a switchtab action but the user\n                // bypassed it by pressing shift/meta/ctrl. Those modifiers\n                // might otherwise affect where we open - we always want to\n                // open in the current tab.\n                where = \"current\";\n                break;\n              case \"searchengine\":\n                if (selectedOneOff && selectedOneOff.engine) {\n                  // Replace the engine with the selected one-off engine.\n                  action.params.engineName = selectedOneOff.engine.name;\n                }\n                // If the selected result is an @alias offer -- an @alias with\n                // an empty query string -- then instead of loading the engine's\n                // empty search results page, put the @alias in the input so\n                // that the user can type a search query and search directly\n                // from the urlbar.\n                if (action.params.alias &&\n                    action.params.alias.startsWith(\"@\") &&\n                    !action.params.searchQuery) {\n                  this.search(action.params.input);\n                  return;\n                }\n                const actionDetails = {\n                  isSuggestion: !!action.params.searchSuggestion,\n                  alias: action.params.alias,\n                };\n                [url, postData] = this._parseAndRecordSearchEngineLoad(\n                  action.params.engineName,\n                  action.params.searchSuggestion || action.params.searchQuery,\n                  event,\n                  actionDetails\n                );\n                break;\n              case \"extension\":\n                this.handleRevert();\n                // Give the extension control of handling the command.\n                let searchString = action.params.content;\n                let keyword = action.params.keyword;\n                this.ExtensionSearchHandler.handleInputEntered(keyword, searchString, where);\n                return;\n            }\n          } else {\n            // This is a fallback for add-ons and old testing code that directly\n            // set value and try to confirm it. UnifiedComplete should always\n            // resolve to a valid url.\n            try {\n              url = url.trim();\n              new URL(url);\n            } catch (ex) {\n              let lastLocationChange = browser.lastLocationChange;\n              UrlbarUtils.getShortcutOrURIAndPostData(url).then(data => {\n                if (where != \"current\" ||\n                    browser.lastLocationChange == lastLocationChange) {\n                  this._loadURL(data.url, browser, data.postData, where,\n                                openUILinkParams, data.mayInheritPrincipal,\n                                triggeringPrincipal);\n                }\n              });\n              return;\n            }\n          }\n\n          this._loadURL(url, browser, postData, where, openUILinkParams,\n                        mayInheritPrincipal, triggeringPrincipal);\n        ]]></body>\n      </method>\n\n      <property name=\"oneOffSearchQuery\">\n        <getter><![CDATA[\n          // If the user has selected a search suggestion, chances are they\n          // want to use the one off search engine to search for that suggestion,\n          // not the string that they manually entered into the location bar.\n          let action = this._parseActionUrl(this.value);\n          if (action && action.type == \"searchengine\") {\n            return action.params.input;\n          }\n          // this.textValue may be an autofilled string.  Search only with the\n          // portion that the user typed, if any, by preferring the autocomplete\n          // controller's searchString (including handleEnterInstance.searchString).\n          return this.handleEnterSearchString ||\n                 this.mController.searchString ||\n                 this.textValue;\n        ]]></getter>\n      </property>\n\n      <method name=\"_loadURL\">\n        <parameter name=\"url\"/>\n        <parameter name=\"browser\"/>\n        <parameter name=\"postData\"/>\n        <parameter name=\"openUILinkWhere\"/>\n        <parameter name=\"openUILinkParams\"/>\n        <parameter name=\"mayInheritPrincipal\"/>\n        <parameter name=\"triggeringPrincipal\"/>\n        <body><![CDATA[\n          this.value = url;\n          browser.userTypedValue = url;\n          if (gInitialPages.includes(url)) {\n            browser.initialPageLoadedFromUserAction = url;\n          }\n          try {\n            UrlbarUtils.addToUrlbarHistory(url, window);\n          } catch (ex) {\n            // Things may go wrong when adding url to session history,\n            // but don't let that interfere with the loading of the url.\n            Cu.reportError(ex);\n          }\n\n          // Reset DOS mitigations for the basic auth prompt.\n          // TODO: When bug 1498553 is resolved, we should be able to\n          // remove the !triggeringPrincipal condition here.\n          if (!triggeringPrincipal || triggeringPrincipal.isSystemPrincipal) {\n            delete browser.authPromptAbuseCounter;\n          }\n\n          let params = {\n            postData,\n            allowThirdPartyFixup: true,\n            triggeringPrincipal,\n          };\n          if (openUILinkWhere == \"current\") {\n            params.targetBrowser = browser;\n            params.indicateErrorPageLoad = true;\n            params.allowPinnedTabHostChange = true;\n            params.allowPopups = url.startsWith(\"javascript:\");\n          } else {\n            params.initiatingDoc = document;\n          }\n          params.allowInheritPrincipal = mayInheritPrincipal;\n\n          if (openUILinkParams) {\n            for (let key in openUILinkParams) {\n              params[key] = openUILinkParams[key];\n            }\n          }\n\n          // Focus the content area before triggering loads, since if the load\n          // occurs in a new tab, we want focus to be restored to the content\n          // area when the current tab is re-selected.\n          browser.focus();\n\n          if (openUILinkWhere != \"current\") {\n            this.handleRevert();\n          }\n\n          try {\n            openTrustedLinkIn(url, openUILinkWhere, params);\n          } catch (ex) {\n            // This load can throw an exception in certain cases, which means\n            // we'll want to replace the URL with the loaded URL:\n            if (ex.result != Cr.NS_ERROR_LOAD_SHOWED_ERRORPAGE) {\n              this.handleRevert();\n            }\n          }\n\n          // Ensure the start of the URL is visible for usability reasons.\n          this.selectionStart = this.selectionEnd = 0;\n        ]]></body>\n      </method>\n\n      <method name=\"_parseAndRecordSearchEngineLoad\">\n        <parameter name=\"engineOrEngineName\"/>\n        <parameter name=\"query\"/>\n        <parameter name=\"event\"/>\n        <parameter name=\"searchActionDetails\"/>\n        <body><![CDATA[\n          let engine =\n            typeof(engineOrEngineName) == \"string\" ?\n              Services.search.getEngineByName(engineOrEngineName) :\n              engineOrEngineName;\n          let isOneOff = this.popup.oneOffSearchButtons\n              .maybeRecordTelemetry(event);\n          // Infer the type of the event which triggered the search.\n          let eventType = \"unknown\";\n          if (event instanceof KeyboardEvent) {\n            eventType = \"key\";\n          } else if (event instanceof MouseEvent) {\n            eventType = \"mouse\";\n          }\n          // Augment the search action details object.\n          let details = searchActionDetails || {};\n          details.isOneOff = isOneOff;\n          details.type = eventType;\n\n          BrowserSearch.recordSearchInTelemetry(engine, \"urlbar\", details);\n          let submission = engine.getSubmission(query, null, \"keyword\");\n          return [submission.uri.spec, submission.postData];\n        ]]></body>\n      </method>\n\n      <method name=\"maybeCanonizeURL\">\n        <parameter name=\"aTriggeringEvent\"/>\n        <parameter name=\"aUrl\"/>\n        <body><![CDATA[\n          // Only add the suffix when the URL bar value isn't already \"URL-like\",\n          // and only if we get a keyboard event, to match user expectations.\n          if (!/^\\s*[^.:\\/\\s]+(?:\\/.*|\\s*)$/i.test(aUrl) ||\n              !this._ctrlCanonizesURLs ||\n              !(aTriggeringEvent instanceof KeyboardEvent) ||\n              !aTriggeringEvent.ctrlKey) {\n            return;\n          }\n\n          let suffix = Services.prefs.getCharPref(\"browser.fixup.alternate.suffix\", \".com/\");\n          if (!suffix.endsWith(\"/\")) {\n            suffix += \"/\";\n          }\n\n          // trim leading/trailing spaces (bug 233205)\n          let url = aUrl.trim();\n\n          // Tack www. and suffix on.  If user has appended directories, insert\n          // suffix before them (bug 279035).  Be careful not to get two slashes.\n          let firstSlash = url.indexOf(\"/\");\n          if (firstSlash >= 0) {\n            url = url.substring(0, firstSlash) + suffix +\n                  url.substring(firstSlash + 1);\n          } else {\n            url = url + suffix;\n          }\n\n          this.popup.overrideValue = \"http://www.\" + url;\n        ]]></body>\n      </method>\n\n      <method name=\"_updateUrlTooltip\">\n        <body><![CDATA[\n          if (this.focused || !this._inOverflow) {\n            this.inputField.removeAttribute(\"title\");\n          } else {\n            this.inputField.setAttribute(\"title\", this.value);\n          }\n        ]]></body>\n      </method>\n\n      <!-- Returns:\n           null if there's a security issue and we should do nothing.\n           a URL object if there is one that we're OK with loading,\n           a text value otherwise.\n           -->\n      <method name=\"_getDroppableItem\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let links;\n          try {\n            links = browserDragAndDrop.dropLinks(aEvent);\n          } catch (ex) {\n            // this is possibly a security exception, in which case we should return\n            // null. Always return null because we can't *know* what exception is\n            // being returned.\n            return null;\n          }\n          // The URL bar automatically handles inputs with newline characters,\n          // so we can get away with treating text/x-moz-url flavours as text/plain.\n          if (links.length > 0 && links[0].url) {\n            let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(aEvent);\n            aEvent.preventDefault();\n            let url = links[0].url;\n            let strippedURL = UrlbarUtils.stripUnsafeProtocolOnPaste(url);\n            if (strippedURL != url) {\n              aEvent.stopImmediatePropagation();\n              return null;\n            }\n            let urlObj;\n            try {\n              // If this throws, urlSecurityCheck would also throw, as that's what it\n              // does with things that don't pass the IO service's newURI constructor\n              // without fixup. It's conceivable we may want to relax this check in\n              // the future (so e.g. www.foo.com gets fixed up), but not right now.\n              urlObj = new URL(url);\n              // If we succeed, try to pass security checks. If this works, return the\n              // URL object. If the *security checks* fail, return null.\n              try {\n                urlSecurityCheck(url,\n                                 triggeringPrincipal,\n                                 Ci.nsIScriptSecurityManager.DISALLOW_INHERIT_PRINCIPAL);\n                return urlObj;\n              } catch (ex) {\n                return null;\n              }\n            } catch (ex) {\n              // We couldn't make a URL out of this. Continue on, and return text below.\n            }\n          }\n          return aEvent.dataTransfer.getData(\"text/unicode\");\n        ]]></body>\n      </method>\n\n      <method name=\"onDragOver\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this._getDroppableItem(aEvent)) {\n            aEvent.dataTransfer.dropEffect = \"none\";\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onDrop\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let droppedItem = this._getDroppableItem(aEvent);\n          let droppedURL = droppedItem instanceof URL ? droppedItem.href : droppedItem;\n          if (droppedURL && (droppedURL !== gBrowser.currentURI.spec)) {\n            let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(aEvent);\n            this.value = droppedURL;\n            SetPageProxyState(\"invalid\");\n            this.focus();\n            this.handleCommand(null, undefined, undefined, triggeringPrincipal);\n            // Force not showing the dropped URI immediately.\n            gBrowser.userTypedValue = null;\n            URLBarSetURI(null, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"makeURIReadable\">\n        <parameter name=\"aURI\"/>\n        <body>\n          <![CDATA[\n            // Avoid copying 'about:reader?url=', and always provide the original URI:\n            // Reader mode ensures we call createExposableURI itself.\n            let readerStrippedURI = ReaderMode.getOriginalUrlObjectForDisplay(aURI.displaySpec);\n            if (readerStrippedURI) {\n              aURI = readerStrippedURI;\n            } else {\n              // Only copy exposable URIs\n              try {\n                aURI = Services.uriFixup.createExposableURI(aURI);\n              } catch (ex) {}\n            }\n            return aURI;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_getSelectedValueForClipboard\">\n        <body><![CDATA[\n          // Grab the actual input field's value, not our value, which could\n          // include \"moz-action:\".\n          var inputVal = this.inputField.value;\n          let selection = this.editor.selection;\n          const flags = Ci.nsIDocumentEncoder.OutputPreformatted |\n                        Ci.nsIDocumentEncoder.OutputRaw;\n          let selectedVal = selection.toStringWithFormat(\"text/plain\", flags, 0);\n\n          // Handle multiple-range selection as a string for simplicity.\n          if (selection.rangeCount > 1) {\n             return selectedVal;\n          }\n\n          // If the selection doesn't start at the beginning or doesn't span the\n          // full domain or the URL bar is modified or there is no text at all,\n          // nothing else to do here.\n          if (this.selectionStart > 0 || this.valueIsTyped || selectedVal == \"\")\n            return selectedVal;\n          // The selection doesn't span the full domain if it doesn't contain a slash and is\n          // followed by some character other than a slash.\n          if (!selectedVal.includes(\"/\")) {\n            let remainder = inputVal.replace(selectedVal, \"\");\n            if (remainder != \"\" && remainder[0] != \"/\")\n              return selectedVal;\n          }\n\n          // If the value was filled by a search suggestion, just return it.\n          let action = this._parseActionUrl(this.value);\n          if (action && action.type == \"searchengine\")\n            return selectedVal;\n\n          let uriFixup = Cc[\"@mozilla.org/docshell/urifixup;1\"].getService(Ci.nsIURIFixup);\n\n          let uri;\n          if (this.getAttribute(\"pageproxystate\") == \"valid\") {\n            uri = gBrowser.currentURI;\n          } else {\n            // We're dealing with an autocompleted value, create a new URI from that.\n            try {\n              uri = uriFixup.createFixupURI(inputVal, Ci.nsIURIFixup.FIXUP_FLAG_NONE);\n            } catch (e) {}\n            if (!uri)\n              return selectedVal;\n          }\n\n          uri = this.makeURIReadable(uri);\n\n          // If the entire URL is selected, just use the actual loaded URI,\n          // unless we want a decoded URI, or it's a data: or javascript: URI,\n          // since those are hard to read when encoded.\n          if (inputVal == selectedVal &&\n              !uri.schemeIs(\"javascript\") && !uri.schemeIs(\"data\") &&\n              !Services.prefs.getBoolPref(\"browser.urlbar.decodeURLsOnCopy\")) {\n            return uri.displaySpec;\n          }\n\n          // Just the beginning of the URL is selected, or we want a decoded\n          // url. First check for a trimmed value.\n          let spec = uri.displaySpec;\n          let trimmedSpec = this.trimValue(spec);\n          if (spec != trimmedSpec) {\n            // Prepend the portion that trimValue removed from the beginning.\n            // This assumes trimValue will only truncate the URL at\n            // the beginning or end (or both).\n            let trimmedSegments = spec.split(trimmedSpec);\n            selectedVal = trimmedSegments[0] + selectedVal;\n          }\n\n          return selectedVal;\n        ]]></body>\n      </method>\n\n      <field name=\"_copyCutController\"><![CDATA[\n        ({\n          urlbar: this,\n          doCommand(aCommand) {\n            var urlbar = this.urlbar;\n            var val = urlbar._getSelectedValueForClipboard();\n            if (!val)\n              return;\n\n            if (aCommand == \"cmd_cut\" && this.isCommandEnabled(aCommand)) {\n              let start = urlbar.selectionStart;\n              let end = urlbar.selectionEnd;\n              urlbar.inputField.value = urlbar.inputField.value.substring(0, start) +\n                                        urlbar.inputField.value.substring(end);\n              urlbar.selectionStart = urlbar.selectionEnd = start;\n\n              let event = document.createEvent(\"UIEvents\");\n              event.initUIEvent(\"input\", true, false, window, 0);\n              urlbar.inputField.dispatchEvent(event);\n            }\n\n            Cc[\"@mozilla.org/widget/clipboardhelper;1\"]\n              .getService(Ci.nsIClipboardHelper)\n              .copyString(val);\n          },\n          supportsCommand(aCommand) {\n            switch (aCommand) {\n              case \"cmd_copy\":\n              case \"cmd_cut\":\n                return true;\n            }\n            return false;\n          },\n          isCommandEnabled(aCommand) {\n            return this.supportsCommand(aCommand) &&\n                   (aCommand != \"cmd_cut\" || !this.urlbar.readOnly) &&\n                   this.urlbar.selectionStart < this.urlbar.selectionEnd;\n          },\n          onEvent(aEventName) {},\n        })\n      ]]></field>\n\n      <method name=\"observe\">\n        <parameter name=\"aSubject\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aData\"/>\n        <body><![CDATA[\n          if (aTopic == \"nsPref:changed\") {\n            switch (aData) {\n              case \"clickSelectsAll\":\n              case \"doubleClickSelectsAll\":\n                this[aData] = this._prefs.getBoolPref(aData);\n                break;\n              case \"autoFill\":\n                this.completeDefaultIndex = this._prefs.getBoolPref(aData);\n                break;\n              case \"delay\":\n                this.timeout = this._prefs.getIntPref(aData);\n                break;\n              case \"ctrlCanonizesURLs\":\n                this._ctrlCanonizesURLs = this._prefs.getBoolPref(aData);\n                break;\n              case \"openintab\":\n                this.openInTab = this._prefs.getBoolPref(aData);\n                break;\n              case \"browser.search.suggest.enabled\":\n                this.browserSearchSuggestEnabled = Services.prefs.getBoolPref(aData);\n                break;\n              case \"suggest.searches\":\n                this.urlbarSearchSuggestEnabled = this._prefs.getBoolPref(aData);\n              case \"userMadeSearchSuggestionsChoice\":\n                // Mirror the value for future use, see the comment in the\n                // binding's constructor.\n                this._prefs.setBoolPref(\"searchSuggestionsChoice\",\n                  this.urlbarSearchSuggestEnabled);\n                // Clear the cached value to allow changing conditions in tests.\n                delete this._whichSearchSuggestionsNotification;\n                break;\n              case \"trimURLs\":\n                this._mayTrimURLs = this._prefs.getBoolPref(aData);\n                break;\n              case \"oneOffSearches\":\n                this._enableOrDisableOneOffSearches();\n                break;\n              case \"maxRichResults\":\n                this.popup.maxResults = this._prefs.getIntPref(aData);\n                break;\n              case \"switchTabs.adoptIntoActiveWindow\":\n                this._adoptIntoActiveWindow =\n                  this._prefs.getBoolPref(\"switchTabs.adoptIntoActiveWindow\");\n                break;\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_enableOrDisableOneOffSearches\">\n        <body><![CDATA[\n          this.popup.toggleOneOffSearches(\n            this._prefs.getBoolPref(\"oneOffSearches\"),\n            \"pref\"\n          );\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.type) {\n            case \"paste\":\n              let originalPasteData = aEvent.clipboardData.getData(\"text/plain\");\n              if (!originalPasteData) {\n                return;\n              }\n\n              let oldValue = this.inputField.value;\n              let oldStart = oldValue.substring(0, this.inputField.selectionStart);\n              // If there is already non-whitespace content in the URL bar\n              // preceding the pasted content, it's not necessary to check\n              // protocols used by the pasted content:\n              if (oldStart.trim()) {\n                return;\n              }\n              let oldEnd = oldValue.substring(this.inputField.selectionEnd);\n\n              let pasteData = UrlbarUtils.stripUnsafeProtocolOnPaste(originalPasteData);\n              if (originalPasteData != pasteData) {\n                // Unfortunately we're not allowed to set the bits being pasted\n                // so cancel this event:\n                aEvent.preventDefault();\n                aEvent.stopImmediatePropagation();\n\n                this.inputField.value = oldStart + pasteData + oldEnd;\n                // Fix up cursor/selection:\n                let newCursorPos = oldStart.length + pasteData.length;\n                this.inputField.selectionStart = newCursorPos;\n                this.inputField.selectionEnd = newCursorPos;\n              }\n              break;\n            case \"mousedown\":\n              if (this.doubleClickSelectsAll &&\n                  aEvent.button == 0 && aEvent.detail == 2) {\n                this.editor.selectAll();\n                aEvent.preventDefault();\n              }\n              break;\n            case \"mouseover\":\n              this._updateUrlTooltip();\n              break;\n            case \"overflow\": {\n              const targetIsPlaceholder =\n                !aEvent.originalTarget.classList.contains(\"anonymous-div\");\n              // We only care about the non-placeholder text.\n              // This shouldn't be needed, see bug 1487036.\n              if (targetIsPlaceholder) {\n                break;\n              }\n              this._inOverflow = true;\n              this.updateTextOverflow();\n              break;\n            }\n            case \"underflow\": {\n              const targetIsPlaceholder =\n                !aEvent.originalTarget.classList.contains(\"anonymous-div\");\n              // We only care about the non-placeholder text.\n              // This shouldn't be needed, see bug 1487036.\n              if (targetIsPlaceholder) {\n                break;\n              }\n              this._inOverflow = false;\n              this.updateTextOverflow();\n              this._updateUrlTooltip();\n              break;\n            }\n            case \"scrollend\":\n              this.updateTextOverflow();\n              break;\n            case \"TabSelect\":\n              // The autocomplete controller uses heuristic on some internal caches\n              // to handle cases like backspace, autofill or repeated searches.\n              // Ensure to clear those internal caches when switching tabs.\n              this.controller.resetInternalState();\n              break;\n            case \"resize\":\n              if (aEvent.target == window) {\n                // Close the popup since it would be wrongly sized, we'll\n                // recalculate a proper size on reopening. For example, this may\n                // happen when using special OS resize functions like Win+Arrow.\n                this.closePopup();\n              }\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"updateTextOverflow\">\n        <body><![CDATA[\n          if (this._inOverflow) {\n            window.promiseDocumentFlushed(() => {\n              // Check overflow again to ensure it didn't change in the meanwhile.\n              let input = this.inputField;\n              if (input && this._inOverflow) {\n                let side = input.scrollLeft &&\n                           input.scrollLeft == input.scrollLeftMax ? \"start\" : \"end\";\n                window.requestAnimationFrame(() => {\n                  // And check once again, since we might have stopped overflowing\n                  // since the promiseDocumentFlushed callback fired.\n                  if (this._inOverflow) {\n                    this.setAttribute(\"textoverflow\", side);\n                  }\n                });\n              }\n            });\n          } else {\n            this.removeAttribute(\"textoverflow\");\n          }\n        ]]></body>\n      </method>\n\n      <!--\n        onBeforeTextValueGet is called by the base-binding's .textValue getter.\n        It should return the value that the getter should use.\n      -->\n      <method name=\"onBeforeTextValueGet\">\n        <body><![CDATA[\n          return { value: this.inputField.value };\n        ]]></body>\n      </method>\n\n      <!--\n        onBeforeTextValueSet is called by the base-binding's .textValue setter.\n        It should return the value that the setter should use.\n      -->\n      <method name=\"onBeforeTextValueSet\">\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          let val = aValue;\n          let uri;\n          try {\n            uri = makeURI(val);\n          } catch (ex) {}\n\n          if (uri) {\n            // Do not touch moz-action URIs at all.  They depend on being\n            // properly encoded and decoded and will break if decoded\n            // unexpectedly.\n            if (!this._parseActionUrl(val)) {\n              val = losslessDecodeURI(uri);\n            }\n          }\n\n          return val;\n        ]]></body>\n      </method>\n\n      <method name=\"_parseActionUrl\">\n        <parameter name=\"aUrl\"/>\n        <body><![CDATA[\n          const MOZ_ACTION_REGEX = /^moz-action:([^,]+),(.*)$/;\n          if (!MOZ_ACTION_REGEX.test(aUrl))\n            return null;\n\n          // URL is in the format moz-action:ACTION,PARAMS\n          // Where PARAMS is a JSON encoded object.\n          let [, type, params] = aUrl.match(MOZ_ACTION_REGEX);\n\n          let action = {\n            type,\n          };\n\n          action.params = JSON.parse(params);\n          for (let key in action.params) {\n            action.params[key] = decodeURIComponent(action.params[key]);\n          }\n\n          if (\"url\" in action.params) {\n            let uri;\n            try {\n              uri = makeURI(action.params.url);\n              action.params.displayUrl = losslessDecodeURI(uri);\n            } catch (e) {\n              action.params.displayUrl = action.params.url;\n            }\n          }\n\n          return action;\n        ]]></body>\n      </method>\n\n      <property name=\"_noActionKeys\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.__noActionKeys) {\n            this.__noActionKeys = new Set([\n              KeyEvent.DOM_VK_ALT,\n              KeyEvent.DOM_VK_SHIFT,\n            ]);\n            let modifier = AppConstants.platform == \"macosx\" ?\n                           KeyEvent.DOM_VK_META :\n                           KeyEvent.DOM_VK_CONTROL;\n            this.__noActionKeys.add(modifier);\n          }\n          return this.__noActionKeys;\n        ]]></getter>\n      </property>\n\n      <field name=\"_pressedNoActionKeys\"><![CDATA[\n        new Set()\n      ]]></field>\n\n      <method name=\"_clearNoActions\">\n        <parameter name=\"aURL\"/>\n        <body><![CDATA[\n          this._pressedNoActionKeys.clear();\n          this.popup.removeAttribute(\"noactions\");\n          let action = this._parseActionUrl(this._value);\n          if (action)\n            this.setAttribute(\"actiontype\", action.type);\n        ]]></body>\n      </method>\n\n      <method name=\"onInput\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this.mIgnoreInput && this.mController.input == this) {\n            this._value = this.inputField.value;\n            gBrowser.userTypedValue = this.value;\n            this.valueIsTyped = true;\n            if (this.inputField.value) {\n              this.setAttribute(\"usertyping\", \"true\");\n            } else {\n              this.removeAttribute(\"usertyping\");\n            }\n            // If the popup already had accessibility focus, bring it back to\n            // the input, since the user is editing.\n            if (!this.popup.richlistbox.suppressMenuItemEvent &&\n                this.popup.richlistbox.currentItem) {\n              this.popup.richlistbox._fireEvent(\n                this.popup.richlistbox.currentItem, \"DOMMenuItemInactive\");\n            }\n            // The user is typing, so don't give accessibility focus to the\n            // popup, even if an item gets automatically selected.\n            this.popup.richlistbox.suppressMenuItemEvent = true;\n            // Only wait for a result when we are sure to get one.  In some\n            // cases, like when pasting the same exact text, we may not fire\n            // a new search and we won't get a result.\n            this._onInputHandledText = this.mController.handleText();\n            if (this._onInputHandledText) {\n              this.gotResultForCurrentQuery = false;\n              this._searchStartDate = Cu.now();\n              this._deferredKeyEventQueue = [];\n              if (this._deferredKeyEventTimeout) {\n                clearTimeout(this._deferredKeyEventTimeout);\n                this._deferredKeyEventTimeout = null;\n              }\n            }\n          }\n          this.resetActionType();\n        ]]></body>\n      </method>\n\n      <method name=\"handleEnter\">\n        <parameter name=\"event\"/>\n        <parameter name=\"options\"/>\n        <body><![CDATA[\n          // We need to ensure we're using a selected autocomplete result.\n          // A result should automatically be selected by default,\n          // however autocomplete is async and therefore we may not\n          // have a result set relating to the current input yet. If that\n          // happens, we need to mark that when the first result does get added,\n          // it needs to be handled as if enter was pressed with that first\n          // result selected.\n          // If anything other than the default (first) result is selected, then\n          // it must have been manually selected by the human. We let this\n          // explicit choice be used, even if it may be related to a previous\n          // input.\n          // However, if the default result is automatically selected, we\n          // ensure that it corresponds to the current input.\n\n          // Store the current search string so it can be used in handleCommand,\n          // which will be called as a result of mController.handleEnter().\n          this.handleEnterSearchString = this.mController.searchString;\n\n          let noDefer = options && options.noDefer;\n          if (!noDefer && this._shouldDeferKeyEvent(event)) {\n            // Defer the event until the first non-heuristic result comes in.\n            this._deferKeyEvent(event, \"handleEnter\");\n            return false;\n          }\n\n          let canonizeValue = this.value;\n          if (event.ctrlKey) {\n            let action = this._parseActionUrl(canonizeValue);\n            if (action && \"searchSuggestion\" in action.params) {\n              canonizeValue = action.params.searchSuggestion;\n            } else if (this.popup.selectedIndex === 0 &&\n                       this.mController.getStyleAt(0).includes(\"autofill\")) {\n              canonizeValue = this.handleEnterSearchString;\n            }\n          }\n          this.maybeCanonizeURL(event, canonizeValue);\n          let handled = this.mController.handleEnter(false, event);\n          this.handleEnterSearchString = null;\n          this.popup.overrideValue = null;\n          return handled;\n        ]]></body>\n      </method>\n\n      <method name=\"handleDelete\">\n        <body><![CDATA[\n          // If the heuristic result is selected, then the autocomplete\n          // controller's handleDelete implementation will remove it, which is\n          // not what we want.  So in that case, call handleText so it acts as\n          // a backspace on the text value instead of removing the result.\n          if (this.popup.selectedIndex == 0 &&\n              this.popup._isFirstResultHeuristic) {\n            this.mController.handleText();\n            return false;\n          }\n          return this.mController.handleDelete();\n        ]]></body>\n      </method>\n\n      <property name=\"_userMadeSearchSuggestionsChoice\" readonly=\"true\">\n        <getter><![CDATA[\n          return this._prefs.getBoolPref(\"userMadeSearchSuggestionsChoice\") ||\n                 this._defaultPrefs.getBoolPref(\"suggest.searches\") != this._prefs.getBoolPref(\"suggest.searches\");\n        ]]></getter>\n      </property>\n\n      <property name=\"whichSearchSuggestionsNotification\" readonly=\"true\">\n        <getter><![CDATA[\n          // Once we return \"none\" once, we'll always return \"none\".\n          // If available, use the cached value, rather than running all of the\n          // checks again at every locationbar focus.\n          if (this._whichSearchSuggestionsNotification) {\n            return this._whichSearchSuggestionsNotification;\n          }\n\n          if (this.browserSearchSuggestEnabled && !this.inPrivateContext &&\n              // In any case, if the user made a choice we should not nag him.\n              !this._userMadeSearchSuggestionsChoice) {\n            if (this._defaultPrefs.getBoolPref(\"suggest.searches\") &&\n                this.urlbarSearchSuggestEnabled && // Has not been switched off.\n                this._prefs.getIntPref(\"timesBeforeHidingSuggestionsHint\")) {\n              return \"opt-out\";\n            }\n          }\n          return this._whichSearchSuggestionsNotification = \"none\";\n        ]]></getter>\n      </property>\n\n      <method name=\"updateSearchSuggestionsNotificationImpressions\">\n        <parameter name=\"whichNotification\"/>\n        <body><![CDATA[\n          if (whichNotification == \"none\") {\n            throw new Error(\"Unexpected notification type\");\n          }\n\n          let remaining = this._prefs.getIntPref(\"timesBeforeHidingSuggestionsHint\");\n          if (remaining > 0) {\n            this._prefs.setIntPref(\"timesBeforeHidingSuggestionsHint\", remaining - 1);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"maybeShowSearchSuggestionsNotificationOnFocus\">\n        <parameter name=\"mouseFocused\"/>\n        <body><![CDATA[\n          let whichNotification = this.whichSearchSuggestionsNotification;\n          if (this._showSearchSuggestionNotificationOnMouseFocus &&\n              mouseFocused) {\n            // Force showing the opt-out notification.\n            this._whichSearchSuggestionsNotification = whichNotification = \"opt-out\";\n          }\n          if (whichNotification == \"opt-out\") {\n            try {\n              this.popup.openAutocompletePopup(this, this);\n            } finally {\n              if (mouseFocused) {\n                delete this._whichSearchSuggestionsNotification;\n                this._showSearchSuggestionNotificationOnMouseFocus = false;\n              }\n            }\n          }\n        ]]></body>\n      </method>\n\n      <!--\n        Sets the input's value, starts a search, and opens the popup.\n\n        @param  value\n                The input's value will be set to this value, and the search will\n                use it as its query.\n      -->\n      <method name=\"search\">\n        <parameter name=\"value\"/>\n        <body><![CDATA[\n          // Hide the suggestions notification if the search uses an \"@engine\"\n          // search engine alias.\n          if (value.trim()[0] == \"@\") {\n            let which = this.whichSearchSuggestionsNotification;\n            this._whichSearchSuggestionsNotification = \"none\";\n            this.popup.addEventListener(\"popuphidden\", () => {\n              this._whichSearchSuggestionsNotification = which;\n            }, {once: true});\n          }\n\n          // We want the value to be treated as text that the user typed.  It\n          // should go through the controller.handleText() path in onInput() so\n          // that gBrowser.userTypedValue, this.valueIsTyped, etc. are set and\n          // nsAutoCompleteController::HandleText() is called.  Set this.value\n          // and fire an input event to do that.  (If we set this.textValue we'd\n          // get an input event for free, but it would also set mIgnoreInput,\n          // skipping all of the above requirements.)\n          focusAndSelectUrlBar();\n\n          // If the value is a restricted token, append a space.\n          if (Object.values(UrlbarTokenizer.RESTRICT).includes(value)) {\n            this.inputField.value = value + \" \";\n          } else {\n            this.inputField.value = value;\n          }\n\n          // Avoid selecting the text if this method is called twice in a row.\n          this.selectionStart = -1;\n\n          let event = document.createEvent(\"Events\");\n          event.initEvent(\"input\", true, true);\n          this.inputField.dispatchEvent(event);\n\n          // handleText() ignores the value if it's the same as the previous\n          // value, but we want consecutive searches with the same value to be\n          // possible.  If handleText() returned false, then manually start a\n          // new search here.\n          if (!this._onInputHandledText) {\n            this.gotResultForCurrentQuery = false;\n            this.controller.startSearch(value);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"removeHiddenFocus\">\n        <body><![CDATA[\n          this.classList.remove(\"hidden-focus\");\n        ]]></body>\n      </method>\n\n      <method name=\"setHiddenFocus\">\n        <body><![CDATA[\n          this.classList.add(\"hidden-focus\");\n          this.focus();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"keydown\"><![CDATA[\n        if (this._noActionKeys.has(event.keyCode) &&\n            this.popup.selectedIndex >= 0 &&\n            !this._pressedNoActionKeys.has(event.keyCode)) {\n          if (this._pressedNoActionKeys.size == 0) {\n            this.popup.setAttribute(\"noactions\", \"true\");\n            this.removeAttribute(\"actiontype\");\n          }\n          this._pressedNoActionKeys.add(event.keyCode);\n        }\n      ]]></handler>\n\n      <handler event=\"keyup\"><![CDATA[\n        if (this._noActionKeys.has(event.keyCode) &&\n            this._pressedNoActionKeys.has(event.keyCode)) {\n          this._pressedNoActionKeys.delete(event.keyCode);\n          if (this._pressedNoActionKeys.size == 0)\n            this._clearNoActions();\n        }\n      ]]></handler>\n\n      <handler event=\"mousedown\"><![CDATA[\n        if (event.button == 0) {\n          if (event.originalTarget.getAttribute(\"anonid\") == \"historydropmarker\") {\n            this.toggleHistoryPopup();\n          }\n\n          // Eventually show the opt-out notification even if the location bar is\n          // empty, focused, and the user clicks on it.\n          if (this.focused && this.textValue == \"\") {\n            this.maybeShowSearchSuggestionsNotificationOnFocus(true);\n          }\n        }\n      ]]></handler>\n\n      <handler event=\"focus\"><![CDATA[\n        if (event.originalTarget == this.inputField) {\n          this._updateUrlTooltip();\n          this.formatValue();\n          if (this.getAttribute(\"pageproxystate\") != \"valid\") {\n            UpdatePopupNotificationsVisibility();\n          }\n\n          // We show the opt-out notification when the mouse/keyboard focus the\n          // urlbar, but in any case we want to enforce at least one\n          // notification when the user focuses it with the mouse.\n          let whichNotification = this.whichSearchSuggestionsNotification;\n          if (whichNotification == \"opt-out\" &&\n              this._showSearchSuggestionNotificationOnMouseFocus === undefined) {\n            this._showSearchSuggestionNotificationOnMouseFocus = true;\n          }\n\n          // Check whether the focus change came from a keyboard/mouse action.\n          let focusMethod = Services.focus.getLastFocusMethod(window);\n          // If it's a focus started by code and the primary user intention was\n          // not to go to the location bar, don't show a notification.\n          if (!focusMethod && !this.userInitiatedFocus) {\n            return;\n          }\n\n          let mouseFocused = !!(focusMethod & Services.focus.FLAG_BYMOUSE);\n          this.maybeShowSearchSuggestionsNotificationOnFocus(mouseFocused);\n        }\n      ]]></handler>\n\n      <handler event=\"blur\"><![CDATA[\n        if (event.originalTarget == this.inputField) {\n          this._clearNoActions();\n          this.formatValue();\n          if (this.getAttribute(\"pageproxystate\") != \"valid\") {\n            UpdatePopupNotificationsVisibility();\n          }\n        }\n        if (this.ExtensionSearchHandler.hasActiveInputSession()) {\n          this.ExtensionSearchHandler.handleInputCancelled();\n        }\n        if (this._deferredKeyEventTimeout) {\n          clearTimeout(this._deferredKeyEventTimeout);\n          this._deferredKeyEventTimeout = null;\n        }\n        this._deferredKeyEventQueue = [];\n      ]]></handler>\n\n      <handler event=\"dragstart\" phase=\"capturing\"><![CDATA[\n        // Drag only if the gesture starts from the input field.\n        if (this.inputField != event.originalTarget &&\n            !(this.inputField.compareDocumentPosition(event.originalTarget) &\n              Node.DOCUMENT_POSITION_CONTAINED_BY))\n          return;\n\n        // Drag only if the entire value is selected and it's a valid URI.\n        var isFullSelection = this.selectionStart == 0 &&\n                              this.selectionEnd == this.textLength;\n        if (!isFullSelection ||\n            this.getAttribute(\"pageproxystate\") != \"valid\")\n          return;\n\n        var urlString = gBrowser.selectedBrowser.currentURI.displaySpec;\n        var title = gBrowser.selectedBrowser.contentTitle || urlString;\n        var htmlString = \"<a href=\\\"\" + urlString + \"\\\">\" + urlString + \"</a>\";\n\n        var dt = event.dataTransfer;\n        dt.setData(\"text/x-moz-url\", urlString + \"\\n\" + title);\n        dt.setData(\"text/unicode\", urlString);\n        dt.setData(\"text/html\", htmlString);\n\n        dt.effectAllowed = \"copyLink\";\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\" phase=\"capturing\" action=\"this.onDragOver(event, this);\"/>\n      <handler event=\"drop\" phase=\"capturing\" action=\"this.onDrop(event, this);\"/>\n      <handler event=\"select\"><![CDATA[\n        if (!Cc[\"@mozilla.org/widget/clipboard;1\"]\n               .getService(Ci.nsIClipboard)\n               .supportsSelectionClipboard())\n          return;\n\n        if (!window.windowUtils.isHandlingUserInput)\n          return;\n\n        var val = this._getSelectedValueForClipboard();\n        if (!val)\n          return;\n\n        Cc[\"@mozilla.org/widget/clipboardhelper;1\"]\n          .getService(Ci.nsIClipboardHelper)\n          .copyStringToClipboard(val, Ci.nsIClipboard.kSelectionClipboard);\n      ]]></handler>\n    </handlers>\n\n  </binding>\n\n  <binding id=\"urlbar-rich-result-popup\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup\">\n\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\"\n             aria-owns=\"richlistbox\">\n      <xul:deck anonid=\"search-suggestions-notification\"\n                align=\"center\"\n                role=\"alert\"\n                selectedIndex=\"0\">\n        <!-- OPT-OUT -->\n        <xul:hbox flex=\"1\" align=\"center\" anonid=\"search-suggestions-opt-out\">\n          <xul:image class=\"ac-site-icon\" type=\"searchengine\"/>\n          <xul:hbox anonid=\"search-suggestions-hint-typing\">\n            <xul:description class=\"ac-title-text\">FROM-DTD.brandShortName;</xul:description>\n          </xul:hbox>\n          <xul:hbox anonid=\"search-suggestions-hint-box\" flex=\"1\">\n            <xul:description id=\"search-suggestions-hint\">\n              <html:span class=\"prefix\">&#x1f4a1; FROM-DTD.urlbar.searchSuggestionsNotification.hintPrefix;</html:span>\n              <html:span>FROM-DTD.urlbar.searchSuggestionsNotification.hint;</html:span>\n            </xul:description>\n          </xul:hbox>\n          <xul:label id=\"search-suggestions-change-settings\"\n                     is=\"text-link\"\n                     role=\"link\"\n\n                     value=\"FROM-DTD.urlbar.searchSuggestionsNotification.changeSettingsWin;\"\n                     accesskey=\"FROM-DTD.urlbar.searchSuggestionsNotification.changeSettingsWin.accesskey;\"\n\n                     onclick=\"openPreferences('paneSearch');\"\n                     control=\"search-suggestions-change-settings\"/>\n        </xul:hbox>\n      </xul:deck>\n      <xul:richlistbox anonid=\"richlistbox\" class=\"autocomplete-richlistbox\"\n                       flex=\"1\"/>\n      <xul:hbox anonid=\"footer\">\n        <children/>\n        <xul:hbox anonid=\"one-off-search-buttons\"\n                  class=\"search-one-offs\"\n                  compact=\"true\"\n                  includecurrentengine=\"true\"\n                  disabletab=\"true\"\n                  flex=\"1\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <!--\n        For performance reasons we want to limit the size of the text runs we\n        build and show to the user.\n      -->\n      <field name=\"textRunsMaxLen\">255</field>\n\n      <field name=\"_maxResults\">0</field>\n\n      <field name=\"_bundle\" readonly=\"true\">\n        Cc[\"@mozilla.org/intl/stringbundle;1\"].\n          getService(Ci.nsIStringBundleService).\n          createBundle(\"chrome://browser/locale/places/places.properties\");\n      </field>\n\n      <field name=\"searchSuggestionsNotification\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(\n          this, \"anonid\", \"search-suggestions-notification\"\n        );\n      </field>\n\n      <field name=\"footer\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"footer\");\n      </field>\n\n      <field name=\"shrinkDelay\" readonly=\"true\">\n        250\n      </field>\n\n      <field name=\"oneOffSearchButtons\" readonly=\"true\">\n        new SearchOneOffs(\n          document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                  \"one-off-search-buttons\"));\n      </field>\n\n      <field name=\"_overrideValue\">null</field>\n      <property name=\"overrideValue\"\n                onget=\"return this._overrideValue;\"\n                onset=\"this._overrideValue = val; return val;\"/>\n\n      <method name=\"onPopupClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.button == 2) {\n            // Ignore right-clicks.\n            return;\n          }\n          // Otherwise \"call super\" -- do what autocomplete-base-popup does.\n          this.input.controller.handleEnter(true, aEvent);\n        ]]></body>\n      </method>\n\n      <field name=\"_oneOffSearchesEnabledByReason\">new Map()</field>\n\n      <method name=\"toggleOneOffSearches\">\n        <parameter name=\"enable\"/>\n        <parameter name=\"reason\"/>\n        <body><![CDATA[\n          this._oneOffSearchesEnabledByReason.set(reason || \"runtime\", enable);\n          this._syncOneOffSearchesEnabled();\n        ]]></body>\n      </method>\n\n      <method name=\"_syncOneOffSearchesEnabled\">\n        <body><![CDATA[\n          // If the popup hasn't ever been opened yet, then don't actually do\n          // anything.  (The popup will still be hidden in that case.)  The\n          // input adds a popupshowing listener that will call this method back\n          // and lazily initialize the one-off buttons the first time the popup\n          // opens.  There are performance tests that fail if we don't do this.\n          if (this.hidden) {\n            return;\n          }\n\n          let enable = Array.from(this._oneOffSearchesEnabledByReason.values())\n                            .every(v => v);\n          if (enable) {\n            this.oneOffSearchButtons.telemetryOrigin = \"urlbar\";\n            this.oneOffSearchButtons.style.display = \"-moz-box\";\n            // Set .textbox first, since the popup setter will cause\n            // a _rebuild call that uses it.\n            this.oneOffSearchButtons.textbox = this.input;\n            this.oneOffSearchButtons.popup = this;\n          } else {\n            this.oneOffSearchButtons.telemetryOrigin = null;\n            this.oneOffSearchButtons.style.display = \"none\";\n            this.oneOffSearchButtons.textbox = null;\n            this.oneOffSearchButtons.popup = null;\n          }\n        ]]></body>\n      </method>\n\n      <property name=\"oneOffSearchesEnabled\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.oneOffSearchButtons.style.display != \"none\";\n        ]]></getter>\n      </property>\n\n      <!-- Override this so that navigating between items results in an item\n           always being selected. -->\n      <method name=\"getNextIndex\">\n        <parameter name=\"reverse\"/>\n        <parameter name=\"amount\"/>\n        <parameter name=\"index\"/>\n        <parameter name=\"maxRow\"/>\n        <body><![CDATA[\n          if (maxRow < 0)\n            return -1;\n\n          let newIndex = index + (reverse ? -1 : 1) * amount;\n\n          // We only want to wrap if navigation is in any direction by one item,\n          // otherwise we clamp to one end of the list.\n          // ie, hitting page-down will only cause is to wrap if we're already\n          // at one end of the list.\n\n          // Allow the selection to be removed if the first result is not a\n          // heuristic result.\n          if (!this._isFirstResultHeuristic) {\n            if (reverse && index == -1 || newIndex > maxRow && index != maxRow)\n              newIndex = maxRow;\n            else if (!reverse && index == -1 || newIndex < 0 && index != 0)\n              newIndex = 0;\n\n            if (newIndex < 0 && index == 0 || newIndex > maxRow && index == maxRow)\n              newIndex = -1;\n\n            return newIndex;\n          }\n\n          // Otherwise do not allow the selection to be removed.\n          if (newIndex < 0) {\n            newIndex = index > 0 ? 0 : maxRow;\n          } else if (newIndex > maxRow) {\n            newIndex = index < maxRow ? maxRow : 0;\n          }\n          return newIndex;\n        ]]></body>\n      </method>\n\n      <property name=\"_isFirstResultHeuristic\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            // The popup usually has a special \"heuristic\" first result (added\n            // by UnifiedComplete.js) that is automatically selected when the\n            // popup opens.\n            return this.input.mController.matchCount > 0 &&\n                   this.input.mController\n                             .getStyleAt(0)\n                             .split(/\\s+/).indexOf(\"heuristic\") > 0;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"maxResults\">\n        <getter>\n          <![CDATA[\n            if (!this._maxResults) {\n              this._maxResults = Services.prefs.getIntPref(\"browser.urlbar.maxRichResults\");\n            }\n            return this._maxResults;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            return this._maxResults = parseInt(val);\n          ]]>\n        </setter>\n      </property>\n\n      <!-- This is set either to undefined or to a new object containing\n           { start, end } margin values in pixels. These are used to align the\n           results to the input field. -->\n      <property name=\"margins\"\n                onget=\"return this._margins;\">\n        <setter>\n          <![CDATA[\n          this._margins = val;\n\n          if (val) {\n            /* eslint-disable no-multi-spaces */\n            let paddingInCSS =\n                3   // .autocomplete-richlistbox padding-left/right\n              + 6   // .ac-site-icon margin-inline-start\n              + 16  // .ac-site-icon width\n              + 6;  // .ac-site-icon margin-inline-end\n            /* eslint-enable no-multi-spaces */\n            let actualVal = Math.round(val.start) - paddingInCSS;\n            let actualValEnd = Math.round(val.end);\n            this.style.setProperty(\"--item-padding-start\", actualVal + \"px\");\n            this.style.setProperty(\"--item-padding-end\", actualValEnd + \"px\");\n          } else {\n            this.style.removeProperty(\"--item-padding-start\");\n            this.style.removeProperty(\"--item-padding-end\");\n          }\n\n          return val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          // initially the panel is hidden\n          // to avoid impacting startup / new window performance\n          aInput.popup.hidden = false;\n\n          this._openAutocompletePopup(aInput, aElement);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body><![CDATA[\n          if (this.mPopupOpen) {\n            return;\n          }\n\n          // Explicitly set the direction of the popup because automplete.xml\n          // expects this.\n          this.style.direction = (RTL_UI ? \"rtl\" : \"ltr\");\n\n          // Make the popup span the width of the window.  First, set its width.\n          let documentRect =\n            window.windowUtils\n                .getBoundsWithoutFlushing(window.document.documentElement);\n          let width = documentRect.right - documentRect.left;\n          this.setAttribute(\"width\", width);\n\n          // Now make its starting margin negative so that its leading edge\n          // aligns with the window border.\n          let elementRect =\n            window.windowUtils.getBoundsWithoutFlushing(aElement);\n          if (RTL_UI) {\n            let offset = elementRect.right - documentRect.right;\n            this.style.marginRight = offset + \"px\";\n          } else {\n            let offset = documentRect.left - elementRect.left;\n            this.style.marginLeft = offset + \"px\";\n          }\n\n          // Keep the popup items' site icons aligned with the urlbar's identity\n          // icon if it's not too far from the edge of the window.  We define\n          // \"too far\" as \"more than 30% of the window's width AND more than\n          // 250px\".  Do this *before* adding any items because when the new\n          // value of the margins are different from the previous value, over-\n          // and underflow must be handled for each item already in the popup.\n          let needsHandleOverUnderflow = false;\n          let boundToCheck = RTL_UI ? \"right\" : \"left\";\n          let inputRect = window.windowUtils.getBoundsWithoutFlushing(aInput);\n          let startOffset = Math.abs(inputRect[boundToCheck] - documentRect[boundToCheck]);\n          let alignSiteIcons = startOffset / width <= 0.3 || startOffset <= 250;\n          if (alignSiteIcons) {\n            // Calculate the end margin if we have a start margin.\n            let boundToCheckEnd = RTL_UI ? \"left\" : \"right\";\n            let endOffset = Math.abs(inputRect[boundToCheckEnd] -\n                                     documentRect[boundToCheckEnd]);\n            if (endOffset > startOffset * 2) {\n              // Provide more space when aligning would result in an unbalanced\n              // margin. This allows the location bar to be moved to the start\n              // of the navigation toolbar to reclaim space for results.\n              endOffset = startOffset;\n            }\n            let identityIcon = document.getElementById(\"identity-icon\");\n            let identityRect =\n              window.windowUtils.getBoundsWithoutFlushing(identityIcon);\n            let start = RTL_UI ?\n                        documentRect.right - identityRect.right :\n                        identityRect.left;\n            if (!this.margins || start != this.margins.start ||\n                                 endOffset != this.margins.end ||\n                                 width != this.margins.width) {\n              this.margins = { start, end: endOffset, width };\n              needsHandleOverUnderflow = true;\n            }\n          } else if (this.margins) {\n            // Reset the alignment so that the site icons are positioned\n            // according to whatever's in the CSS.\n            this.margins = undefined;\n            needsHandleOverUnderflow = true;\n          }\n\n          // Now that the margins have been set, start adding items (via\n          // _invalidate).\n          this.mInput = aInput;\n          this.input.controller.setInitiallySelectedIndex(this._isFirstResultHeuristic ? 0 : -1);\n          this.input.userSelectionBehavior = \"none\";\n          this._invalidate();\n\n          try {\n            let whichNotification = aInput.whichSearchSuggestionsNotification;\n            if (whichNotification != \"none\") {\n              // Update the impressions count on real popupshown, since there's\n              // no guarantee openPopup will be respected by the platform.\n              // Though, we must ensure the handled event is the expected one.\n              let impressionId = this._searchSuggestionsImpressionId = {};\n              this.addEventListener(\"popupshown\", () => {\n                if (this._searchSuggestionsImpressionId == impressionId)\n                  aInput.updateSearchSuggestionsNotificationImpressions(whichNotification);\n              }, {once: true});\n              this._showSearchSuggestionsNotification(whichNotification);\n            } else if (this.classList.contains(\"showSearchSuggestionsNotification\")) {\n              this._hideSearchSuggestionsNotification();\n            }\n          } catch (ex) {\n            // Not critical for the urlbar functionality, just report the error.\n            Cu.reportError(ex);\n          }\n\n          // Position the popup below the navbar.  To get the y-coordinate,\n          // which is an offset from the bottom of the input, subtract the\n          // bottom of the navbar from the buttom of the input.\n          let yOffset = Math.round(\n            window.windowUtils.getBoundsWithoutFlushing(document.getElementById(\"nav-bar\")).bottom -\n            window.windowUtils.getBoundsWithoutFlushing(aInput).bottom);\n\n          if (!this.richlistbox.suppressMenuItemEvent && this.richlistbox.currentItem) {\n            // The richlistbox fired a DOMMenuItemActive for accessibility,\n            // but because the popup isn't open yet, accessibility will ignore\n            // it. Therefore, fire it again once the popup opens.\n            this.addEventListener(\"popupshown\", () => {\n              this.richlistbox._fireEvent(this.richlistbox.currentItem,\n                \"DOMMenuItemActive\");\n            }, {once: true});\n          }\n\n          this.openPopup(aElement, \"after_start\", 0, yOffset, false, false);\n\n          // Do this immediately after we've requested the popup to open. This\n          // will cause sync reflows but prevents flickering.\n          if (needsHandleOverUnderflow) {\n            for (let item of this.richlistbox.children) {\n              item.handleOverUnderflow();\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"adjustHeight\">\n        <body>\n          <![CDATA[\n          // If we were going to shrink later, cancel that for now:\n          if (this._shrinkTimeout) {\n            clearTimeout(this._shrinkTimeout);\n            this._shrinkTimeout = null;\n          }\n          let lastRowCount = this._lastRowCount;\n          // Figure out how many rows to show\n          let rows = this.richlistbox.children;\n          this._lastRowCount = rows.length;\n          let numRows = Math.min(this.matchCount, this.maxRows, rows.length);\n\n          // If we're going from 0 to non-0 rows, we might need to remove\n          // the height attribute to allow the popup to size. The attribute\n          // is set from XUL popup management code.\n          if (!lastRowCount && rows.length) {\n            this.removeAttribute(\"height\");\n          }\n\n          // Default the height to 0 if we have no rows to show\n          let height = 0;\n          if (numRows) {\n            if (!this._rowHeight) {\n              window.promiseDocumentFlushed(() => {\n                if (window.closed) {\n                  return;\n                }\n                this._rowHeight = rows[0].getBoundingClientRect().height;\n                let style = window.getComputedStyle(this.richlistbox);\n\n                let paddingTop = parseInt(style.paddingTop) || 0;\n                let paddingBottom = parseInt(style.paddingBottom) || 0;\n                this._rlbPadding = paddingTop + paddingBottom;\n                // Then re-run - but don't dirty layout from inside this callback.\n                window.requestAnimationFrame(() => this.adjustHeight());\n              });\n              return;\n            }\n\n            // Calculate the height to have the first row to last row shown\n            height = (this._rowHeight * numRows) + this._rlbPadding;\n          }\n\n          let animate = this.getAttribute(\"dontanimate\") != \"true\";\n          let currentHeight =\n            parseFloat(this.richlistbox.getAttribute(\"height\"), 10) ||\n            parseFloat(this.richlistbox.style.height, 10) ||\n            0; // It's possible we get here when we haven't set height on the richlistbox\n               // yet, which means parseFloat will return NaN. It should return 0 instead.\n          if (height > currentHeight) {\n            // Grow immediately.\n            if (animate) {\n              this.richlistbox.removeAttribute(\"height\");\n              this.richlistbox.style.height = height + \"px\";\n            } else {\n              this.richlistbox.style.removeProperty(\"height\");\n              this.richlistbox.height = height;\n            }\n          } else if (height < currentHeight) { // Don't shrink if height matches exactly\n            // Delay shrinking to avoid flicker.\n            this._shrinkTimeout = setTimeout(() => {\n              this._collapseUnusedItems();\n              if (animate) {\n                this.richlistbox.removeAttribute(\"height\");\n                this.richlistbox.style.height = height + \"px\";\n              } else {\n                this.richlistbox.style.removeProperty(\"height\");\n                this.richlistbox.height = height;\n              }\n            }, this.shrinkDelay);\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_showSearchSuggestionsNotification\">\n        <parameter name=\"whichNotification\"/>\n        <body>\n          <![CDATA[\n          if (whichNotification == \"opt-out\") {\n            if (this.margins) {\n              this.searchSuggestionsNotification.style.paddingInlineStart =\n                this.margins.start + \"px\";\n            } else {\n              this.searchSuggestionsNotification.style.removeProperty(\"padding-inline-start\");\n            }\n\n            // We want to animate the opt-out hint only once.\n            if (!this._firstSearchSuggestionsNotification) {\n              this._firstSearchSuggestionsNotification = true;\n              this.searchSuggestionsNotification.setAttribute(\"animate\", \"true\");\n            }\n          }\n\n          this.searchSuggestionsNotification.setAttribute(\"aria-describedby\",\n                                                          \"search-suggestions-hint\");\n\n          // With the notification shown, the listbox's height can sometimes be\n          // too small when it's flexed, as it normally is.  Also, it can start\n          // out slightly scrolled down.  Both problems appear together, most\n          // often when the popup is very narrow and the notification's text\n          // must wrap.  Work around them by removing the flex.\n          //\n          // But without flexing the listbox, the listbox's height animation\n          // sometimes fails to complete, leaving the popup too tall.  Work\n          // around that problem by disabling the listbox animation.\n          this.richlistbox.flex = 0;\n          this.setAttribute(\"dontanimate\", \"true\");\n\n          this.classList.add(\"showSearchSuggestionsNotification\");\n          // Don't show the one-off buttons if we are showing onboarding and\n          // there's no result, since it would be ugly and pointless.\n          this.footer.collapsed = this.matchCount == 0;\n          this.input.tabScrolling = this.matchCount != 0;\n\n          // This event allows accessibility APIs to see the notification.\n          if (!this.popupOpen) {\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"AlertActive\", true, true);\n            this.searchSuggestionsNotification.dispatchEvent(event);\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_hideSearchSuggestionsNotification\">\n        <body>\n          <![CDATA[\n          this.classList.remove(\"showSearchSuggestionsNotification\");\n          this.richlistbox.flex = 1;\n          this.removeAttribute(\"dontanimate\");\n          this.searchSuggestionsNotification.removeAttribute(\"animate\");\n          if (this.matchCount) {\n            // Update popup height.\n            this._invalidate();\n          } else {\n            this.closePopup();\n          }\n          ]]>\n        </body>\n      </method>\n\n      <!-- This handles keypress changes to the selection among the one-off\n           search buttons and between the one-offs and the listbox.  It returns\n           true if the keypress was consumed and false if not. -->\n      <method name=\"handleKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          this.oneOffSearchButtons.handleKeyPress(aEvent, this.matchCount,\n                                                  !this._isFirstResultHeuristic,\n                                                  gBrowser.userTypedValue);\n          return aEvent.defaultPrevented && !aEvent.urlbarDeferred;\n        ]]></body>\n      </method>\n\n      <!-- This is called when a one-off is clicked and when \"search in new tab\"\n           is selected from a one-off context menu. -->\n      <method name=\"handleOneOffSearch\">\n        <parameter name=\"event\"/>\n        <parameter name=\"engine\"/>\n        <parameter name=\"where\"/>\n        <parameter name=\"params\"/>\n        <body><![CDATA[\n          this.input.handleCommand(event, where, params);\n        ]]></body>\n      </method>\n\n      <!-- Result listitems call this to determine which search engine they\n           should show in their labels and include in their url attributes. -->\n      <property name=\"overrideSearchEngineName\" readonly=\"true\">\n        <getter><![CDATA[\n          let button = this.oneOffSearchButtons.selectedButton;\n          return button && button.engine && button.engine.name;\n        ]]></getter>\n      </property>\n\n      <method name=\"createResultLabel\">\n        <parameter name=\"item\"/>\n        <parameter name=\"proposedLabel\"/>\n        <body>\n          <![CDATA[\n            let parts = [proposedLabel];\n\n            let action = this.input._parseActionUrl(item.getAttribute(\"url\"));\n            if (action) {\n              switch (action.type) {\n              case \"searchengine\":\n                parts = [\n                  action.params.searchSuggestion || action.params.searchQuery,\n                  action.params.engineName,\n                ];\n                break;\n              case \"switchtab\":\n              case \"remotetab\":\n                parts = [\n                  item.getAttribute(\"title\"),\n                  item.getAttribute(\"displayurl\"),\n                ];\n                break;\n              }\n            }\n\n            let types = item.getAttribute(\"type\").split(/\\s+/);\n            let type = types.find(t => t != \"action\" && t != \"heuristic\");\n            try {\n              // Some types intentionally do not map to strings, which is not\n              // an error.\n              parts.push(this._bundle.GetStringFromName(type + \"ResultLabel\"));\n            } catch (e) {}\n\n            return parts.filter(str => str).join(\" \");\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"onResultsAdded\">\n        <body>\n          <![CDATA[\n            // If nothing is selected yet, select the first result if it is a\n            // pre-selected \"heuristic\" result.  (See UnifiedComplete.js.)\n            let selectHeuristic =\n              this.selectedIndex == -1 && this._isFirstResultHeuristic;\n            if (selectHeuristic) {\n              this.input.controller.setInitiallySelectedIndex(0);\n            }\n\n            // If this is the heuristic result of a new search, format its\n            // search alias in the input or remove the formatting of the\n            // previous alias, as necessary.  We need to check selectHeuristic\n            // because the result may have already been added but only now is\n            // being selected, and we need to check gotResultForCurrentQuery\n            // because the result may be from the previous search and already\n            // selected and is now being reused.\n            if (selectHeuristic || !this.input.gotResultForCurrentQuery) {\n              this.input.formatValue();\n\n              // Also, hide the one-off search buttons if the user is using, or\n              // starting to use, an \"@engine\" search engine alias, or typed\n              // only the search restriction character.\n              let trimmedValue = this.input.value.trim();\n              this.toggleOneOffSearches(\n                trimmedValue[0] != \"@\" &&\n                (trimmedValue[0] != UrlbarTokenizer.RESTRICT.SEARCH ||\n                 trimmedValue.length != 1)\n              );\n            }\n\n            if (this.matchCount > 0) {\n              // If this is the first time we get the result from the current\n              // search and we are not in the private context, we can speculatively\n              // connect to the intended site as a performance optimization.\n              if (!this.input.gotResultForCurrentQuery &&\n                  !this.input.inPrivateContext) {\n                let firstStyle = this.input.mController.getStyleAt(0);\n                if (firstStyle.includes(\"autofill\")) {\n                  let uri = this.input.mController.getFinalCompleteValueAt(0);\n                  UrlbarUtils.setupSpeculativeConnection(uri, window);\n                } else if (firstStyle.includes(\"searchengine\") &&\n                          this.input.browserSearchSuggestEnabled &&\n                          this.input.urlbarSearchSuggestEnabled) {\n                  // Preconnect to the current search engine only if the search\n                  // suggestions are enabled.\n                  let engine = Services.search.defaultEngine;\n                  UrlbarUtils.setupSpeculativeConnection(engine, window);\n                }\n              }\n\n              // When a result is present the footer should always be visible.\n              this.footer.collapsed = false;\n            }\n\n            this.input.tabScrolling = true;\n            this.input.gotResultForCurrentQuery = true;\n            this.input.replaySafeDeferredKeyEvents();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_onSearchBegin\">\n        <body><![CDATA[\n          // Set the selected index to 0 (heuristic) until a result comes back\n          // and we can evaluate it better.\n          //\n          // This is required to properly manage delayed handleEnter:\n          // 1. if a search starts we set selectedIndex to 0 here, and it will\n          //    be updated by onResultsAdded. Since selectedIndex is 0,\n          //    handleEnter will delay the action if a result didn't arrive yet.\n          // 2. if a search doesn't start (for example if autocomplete is\n          //    disabled), this won't be called, and the selectedIndex will be\n          //    the default -1 value. Then handleEnter will know it should not\n          //    delay the action, cause a result wont't ever arrive.\n          this.input.controller.setInitiallySelectedIndex(0);\n\n          // Since we are starting a new search, reset the currently selected\n          // one-off button, to cover those cases where the oneoff buttons\n          // binding won't receive an actual DOM event. For example, a search\n          // could be started without an actual input event, and the popup may\n          // not have been closed from the previous search.\n          this.oneOffSearchButtons.selectedButton = null;\n        ]]></body>\n      </method>\n\n      <field name=\"_addonIframe\">null</field>\n      <field name=\"_addonIframeOwner\">null</field>\n      <field name=\"_addonIframeOverriddenFunctionsByName\">{}</field>\n\n      <!-- These methods must be overridden and properly handled by the API\n           runtime so that it doesn't break the popup.  If any of these methods\n           is not overridden, then initAddonIframe should throw. -->\n      <field name=\"_addonIframeOverrideFunctionNames\">[\n        \"_invalidate\",\n      ]</field>\n\n      <field name=\"_addonIframeHiddenAnonids\">[\n        \"search-suggestions-notification\",\n        \"richlistbox\",\n        \"one-off-search-buttons\",\n      ]</field>\n      <field name=\"_addonIframeHiddenDisplaysByAnonid\">{}</field>\n\n      <method name=\"initAddonIframe\">\n        <parameter name=\"owner\"/>\n        <parameter name=\"overrides\"/>\n        <body><![CDATA[\n          if (this._addonIframeOwner) {\n            // Another add-on has already requested the iframe.  Return null to\n            // signal to the calling add-on that it should not take over the\n            // popup.  First add-on wins for now.\n            return null;\n          }\n          // Make sure all overrides are provided before doing anything.\n          for (let name of this._addonIframeOverrideFunctionNames) {\n            if (typeof(overrides[name]) != \"function\") {\n              throw new Error(\n                \"Override for method '\" + name + \"' must be given\"\n              );\n            }\n          }\n          // OK, insert the iframe.\n          this._addonIframeOwner = owner;\n          this._addonIframe = this._makeAddonIframe();\n          this._addonIframeOverriddenFunctionsByName = {};\n          for (let name of this._addonIframeOverrideFunctionNames) {\n            this._addonIframeOverriddenFunctionsByName[name] = this[name];\n            this[name] = overrides[name];\n          }\n          return this._addonIframe;\n        ]]></body>\n      </method>\n\n      <method name=\"destroyAddonIframe\">\n        <parameter name=\"owner\"/>\n        <body><![CDATA[\n          if (this._addonIframeOwner != owner) {\n            throw new Error(\"You're not the iframe owner\");\n          }\n          this._addonIframeOwner = null;\n          this._addonIframe.remove();\n          this._addonIframe = null;\n          for (let anonid of this._addonIframeHiddenAnonids) {\n            let child = document.getAnonymousElementByAttribute(\n              this, \"anonid\", anonid\n            );\n            child.style.display =\n              this._addonIframeHiddenDisplaysByAnonid[anonid];\n          }\n          for (let name in this._addonIframeOverriddenFunctionsByName) {\n            this[name] = this._addonIframeOverriddenFunctionsByName[name];\n          }\n          this._addonIframeOverriddenFunctionsByName = {};\n        ]]></body>\n      </method>\n\n      <method name=\"_makeAddonIframe\">\n        <body><![CDATA[\n          this._addonIframeHiddenDisplaysByAnonid = {};\n          for (let anonid of this._addonIframeHiddenAnonids) {\n            let child = document.getAnonymousElementByAttribute(\n              this, \"anonid\", anonid\n            );\n            this._addonIframeHiddenDisplaysByAnonid[anonid] =\n              child.style.display;\n            child.style.display = \"none\";\n          }\n          let iframe = document.createXULElement(\"iframe\");\n          iframe.setAttribute(\"type\", \"content\");\n          iframe.setAttribute(\"flex\", \"1\");\n          iframe.style.transition = \"height 100ms\";\n          this.appendChild(iframe);\n          return iframe;\n        ]]></body>\n      </method>\n\n    </implementation>\n    <handlers>\n\n      <handler event=\"SelectedOneOffButtonChanged\"><![CDATA[\n        // Update all searchengine result items to use the newly selected\n        // engine.\n        for (let item of this.richlistbox.children) {\n          if (item.collapsed) {\n            break;\n          }\n          let url = item.getAttribute(\"url\");\n          if (url) {\n            let action = item._parseActionUrl(url);\n            if (action && action.type == \"searchengine\") {\n              item._adjustAcItem();\n            }\n          }\n        }\n\n        // If the selection moved from the results to the one-off settings\n        // button, then call formatValue to remove the formatting of the search\n        // alias in the input, if any.  In all other cases the alias formatting\n        // is removed when the input's value setter calls formatValue, but in\n        // this specific case, at the time that formatValue is called,\n        // oneOffSearchButtons.selectedButton is still null, so the formatting\n        // is not removed.  The settings button is selected right after that.\n        if (this.oneOffSearchButtons.selectedButton ==\n              this.oneOffSearchButtons.settingsButtonCompact &&\n            (!event.detail || !event.detail.previousSelectedButton)) {\n          this.input.formatValue();\n        }\n      ]]></handler>\n\n      <handler event=\"mousedown\"><![CDATA[\n        // Required to make the xul:label.text-link elements in the search\n        // suggestions notification work correctly when clicked on Linux.\n        // This is copied from the mousedown handler in\n        // browser-search-autocomplete-result-popup, which apparently had a\n        // similar problem.\n        event.preventDefault();\n\n        if (event.button == 2) {\n          // Right mouse button currently allows to select.\n          this.input.userSelectionBehavior = \"rightClick\";\n          // Ignore right-clicks.\n          return;\n        }\n\n        if (!UrlbarPrefs.get(\"speculativeConnect.enabled\")) {\n          return;\n        }\n\n        // Ensure the user is clicking on an url instead of other buttons\n        // on the popup.\n        let elt = event.originalTarget;\n        while (elt && elt.localName != \"richlistitem\" && elt != this) {\n          elt = elt.parentNode;\n        }\n        if (!elt || elt.localName != \"richlistitem\") {\n          return;\n        }\n        // The user might click on a ghost entry which was removed because of\n        // the coming new results.\n        if (this.input.controller.matchCount <= this.selectedIndex) {\n          return;\n        }\n\n        // Whitelist the cases that we want to speculative connect, and ignore\n        // other moz-action uris or fancy protocols.\n        // Note that it's likely we've speculatively connected to the first\n        // url because it is a heuristic \"autofill\" result (see bug 1348275).\n        // \"moz-action:searchengine\" is also the same case. (see bug 1355443)\n        // So we won't duplicate the effort here.\n        let url = this.input.controller.getFinalCompleteValueAt(this.selectedIndex);\n        if (url.startsWith(\"http\") && this.selectedIndex > 0) {\n          UrlbarUtils.setupSpeculativeConnection(url, window);\n        } else if (url.startsWith(\"moz-action:remotetab\")) {\n          let action = PlacesUtils.parseActionUrl(url);\n          if (action && action.params.url) {\n            UrlbarUtils.setupSpeculativeConnection(action.params.url, window);\n          }\n        }\n      ]]></handler>\n\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"menu.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- import-globals-from controller.js -->\n\n<bindings id=\"placesMenuBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"places-popup-base\"\n           extends=\"chrome://global/content/bindings/popup.xml#popup\">\n    <content>\n      <xul:hbox flex=\"1\">\n        <xul:vbox class=\"menupopup-drop-indicator-bar\" hidden=\"true\">\n          <xul:image class=\"menupopup-drop-indicator\" mousethrough=\"always\"/>\n        </xul:vbox>\n        <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                            smoothscroll=\"false\">\n          <children/>\n        </xul:arrowscrollbox>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n\n      <field name=\"AppConstants\" readonly=\"true\">\n        (ChromeUtils.import(\"resource://gre/modules/AppConstants.jsm\", {})).AppConstants;\n      </field>\n\n      <field name=\"_indicatorBar\">\n        document.getAnonymousElementByAttribute(this, \"class\",\n                                                \"menupopup-drop-indicator-bar\");\n      </field>\n\n      <field name=\"_scrollBox\">\n        document.getAnonymousElementByAttribute(this, \"class\",\n                                                \"popup-internal-box\");\n      </field>\n\n      <!-- This is the view that manage the popup -->\n      <field name=\"_rootView\">PlacesUIUtils.getViewForNode(this);</field>\n\n      <!-- Check if we should hide the drop indicator for the target -->\n      <method name=\"_hideDropIndicator\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let target = aEvent.target;\n\n          // Don't draw the drop indicator outside of markers or if current\n          // node is not a Places node.\n          let betweenMarkers =\n            (this._startMarker.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_FOLLOWING) &&\n            (this._endMarker.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_PRECEDING);\n\n          // Hide the dropmarker if current node is not a Places node.\n          return !(target && target._placesNode && betweenMarkers);\n        ]]></body>\n      </method>\n\n      <!-- This function returns information about where to drop when\n           dragging over this popup insertion point -->\n      <method name=\"_getDropPoint\">\n        <parameter name=\"aEvent\"/>\n          <body><![CDATA[\n            // Can't drop if the menu isn't a folder\n            let resultNode = this._placesNode;\n\n            if (!PlacesUtils.nodeIsFolder(resultNode) ||\n                this._rootView.controller.disallowInsertion(resultNode)) {\n              return null;\n            }\n\n            var dropPoint = { ip: null, folderElt: null };\n\n            // The element we are dragging over\n            let elt = aEvent.target;\n            if (elt.localName == \"menupopup\")\n              elt = elt.parentNode;\n\n            let eventY = aEvent.clientY;\n            let {y: eltY, height: eltHeight} = elt.getBoundingClientRect();\n\n            if (!elt._placesNode) {\n              // If we are dragging over a non places node drop at the end.\n              dropPoint.ip = new PlacesInsertionPoint({\n                parentId: PlacesUtils.getConcreteItemId(resultNode),\n                parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n              });\n              // We can set folderElt if we are dropping over a static menu that\n              // has an internal placespopup.\n              let isMenu = elt.localName == \"menu\" ||\n                 (elt.localName == \"toolbarbutton\" &&\n                  elt.getAttribute(\"type\") == \"menu\");\n              if (isMenu && elt.lastElementChild &&\n                  elt.lastElementChild.hasAttribute(\"placespopup\"))\n                dropPoint.folderElt = elt;\n              return dropPoint;\n            }\n\n            let tagName = PlacesUtils.nodeIsTagQuery(elt._placesNode) ?\n                            elt._placesNode.title : null;\n            if ((PlacesUtils.nodeIsFolder(elt._placesNode) &&\n                 !PlacesUIUtils.isFolderReadOnly(elt._placesNode)) ||\n                PlacesUtils.nodeIsTagQuery(elt._placesNode)) {\n              // This is a folder or a tag container.\n              if (eventY - eltY < eltHeight * 0.20) {\n                // If mouse is in the top part of the element, drop above folder.\n                dropPoint.ip = new PlacesInsertionPoint({\n                  parentId: PlacesUtils.getConcreteItemId(resultNode),\n                  parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n                  orientation: Ci.nsITreeView.DROP_BEFORE,\n                  tagName,\n                  dropNearNode: elt._placesNode,\n                });\n                return dropPoint;\n              } else if (eventY - eltY < eltHeight * 0.80) {\n                // If mouse is in the middle of the element, drop inside folder.\n                dropPoint.ip = new PlacesInsertionPoint({\n                  parentId: PlacesUtils.getConcreteItemId(elt._placesNode),\n                  parentGuid: PlacesUtils.getConcreteItemGuid(elt._placesNode),\n                  tagName,\n                });\n                dropPoint.folderElt = elt;\n                return dropPoint;\n              }\n            } else if (eventY - eltY <= eltHeight / 2) {\n              // This is a non-folder node or a readonly folder.\n              // If the mouse is above the middle, drop above this item.\n              dropPoint.ip = new PlacesInsertionPoint({\n                parentId: PlacesUtils.getConcreteItemId(resultNode),\n                parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n                orientation: Ci.nsITreeView.DROP_BEFORE,\n                tagName,\n                dropNearNode: elt._placesNode,\n              });\n              return dropPoint;\n            }\n\n            // Drop below the item.\n            dropPoint.ip = new PlacesInsertionPoint({\n              parentId: PlacesUtils.getConcreteItemId(resultNode),\n              parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n              orientation: Ci.nsITreeView.DROP_AFTER,\n              tagName,\n              dropNearNode: elt._placesNode,\n            });\n            return dropPoint;\n        ]]></body>\n      </method>\n\n      <!-- Sub-menus should be opened when the mouse drags over them, and closed\n           when the mouse drags off.  The overFolder object manages opening and\n           closing of folders when the mouse hovers. -->\n      <field name=\"_overFolder\"><![CDATA[({\n        _self: this,\n        _folder: {elt: null,\n                  openTimer: null,\n                  hoverTime: 350,\n                  closeTimer: null},\n        _closeMenuTimer: null,\n\n        get elt() {\n          return this._folder.elt;\n        },\n        set elt(val) {\n          return this._folder.elt = val;\n        },\n\n        get openTimer() {\n          return this._folder.openTimer;\n        },\n        set openTimer(val) {\n          return this._folder.openTimer = val;\n        },\n\n        get hoverTime() {\n          return this._folder.hoverTime;\n        },\n        set hoverTime(val) {\n          return this._folder.hoverTime = val;\n        },\n\n        get closeTimer() {\n          return this._folder.closeTimer;\n        },\n        set closeTimer(val) {\n          return this._folder.closeTimer = val;\n        },\n\n        get closeMenuTimer() {\n          return this._closeMenuTimer;\n        },\n        set closeMenuTimer(val) {\n          return this._closeMenuTimer = val;\n        },\n\n        setTimer: function OF__setTimer(aTime) {\n          var timer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n          timer.initWithCallback(this, aTime, timer.TYPE_ONE_SHOT);\n          return timer;\n        },\n\n        notify: function OF__notify(aTimer) {\n          // Function to process all timer notifications.\n\n          if (aTimer == this._folder.openTimer) {\n            // Timer to open a submenu that's being dragged over.\n            this._folder.elt.lastElementChild.setAttribute(\"autoopened\", \"true\");\n            this._folder.elt.lastElementChild.openPopup();\n            this._folder.openTimer = null;\n          } else if (aTimer == this._folder.closeTimer) {\n            // Timer to close a submenu that's been dragged off of.\n            // Only close the submenu if the mouse isn't being dragged over any\n            // of its child menus.\n            var draggingOverChild = PlacesControllerDragHelper\n                                    .draggingOverChildNode(this._folder.elt);\n            if (draggingOverChild)\n              this._folder.elt = null;\n            this.clear();\n\n            // Close any parent folders which aren't being dragged over.\n            // (This is necessary because of the above code that keeps a folder\n            // open while its children are being dragged over.)\n            if (!draggingOverChild)\n              this.closeParentMenus();\n          } else if (aTimer == this.closeMenuTimer) {\n            // Timer to close this menu after the drag exit.\n            var popup = this._self;\n            // if we are no more dragging we can leave the menu open to allow\n            // for better D&D bookmark organization\n            if (PlacesControllerDragHelper.getSession() &&\n                !PlacesControllerDragHelper.draggingOverChildNode(popup.parentNode)) {\n              popup.hidePopup();\n              // Close any parent menus that aren't being dragged over;\n              // otherwise they'll stay open because they couldn't close\n              // while this menu was being dragged over.\n              this.closeParentMenus();\n            }\n            this._closeMenuTimer = null;\n          }\n        },\n\n        //  Helper function to close all parent menus of this menu,\n        //  as long as none of the parent's children are currently being\n        //  dragged over.\n        closeParentMenus: function OF__closeParentMenus() {\n          var popup = this._self;\n          var parent = popup.parentNode;\n          while (parent) {\n            if (parent.localName == \"menupopup\" && parent._placesNode) {\n              if (PlacesControllerDragHelper.draggingOverChildNode(parent.parentNode))\n                break;\n              parent.hidePopup();\n            }\n            parent = parent.parentNode;\n          }\n        },\n\n        //  The mouse is no longer dragging over the stored menubutton.\n        //  Close the menubutton, clear out drag styles, and clear all\n        //  timers for opening/closing it.\n        clear: function OF__clear() {\n          if (this._folder.elt && this._folder.elt.lastElementChild) {\n            if (!this._folder.elt.lastElementChild.hasAttribute(\"dragover\"))\n              this._folder.elt.lastElementChild.hidePopup();\n            // remove menuactive style\n            this._folder.elt.removeAttribute(\"_moz-menuactive\");\n            this._folder.elt = null;\n          }\n          if (this._folder.openTimer) {\n            this._folder.openTimer.cancel();\n            this._folder.openTimer = null;\n          }\n          if (this._folder.closeTimer) {\n            this._folder.closeTimer.cancel();\n            this._folder.closeTimer = null;\n          }\n        },\n      })]]></field>\n\n      <method name=\"_cleanupDragDetails\">\n        <body><![CDATA[\n          // Called on dragend and drop.\n          PlacesControllerDragHelper.currentDropTarget = null;\n          this._rootView._draggedElt = null;\n          this.removeAttribute(\"dragover\");\n          this.removeAttribute(\"dragstart\");\n          this._indicatorBar.hidden = true;\n        ]]></body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"DOMMenuItemActive\"><![CDATA[\n        let elt = event.target;\n        if (elt.parentNode != this)\n          return;\n\n        if (this.AppConstants.platform === \"macosx\") {\n          // XXX: The following check is a temporary hack until bug 420033 is\n          // resolved.\n          let parentElt = elt.parent;\n          while (parentElt) {\n            if (parentElt.id == \"bookmarksMenuPopup\" ||\n                parentElt.id == \"goPopup\")\n              return;\n\n            parentElt = parentElt.parentNode;\n          }\n        }\n\n        if (window.XULBrowserWindow) {\n          let placesNode = elt._placesNode;\n\n          var linkURI;\n          if (placesNode && PlacesUtils.nodeIsURI(placesNode))\n            linkURI = placesNode.uri;\n          else if (elt.hasAttribute(\"targetURI\"))\n            linkURI = elt.getAttribute(\"targetURI\");\n\n          if (linkURI)\n            window.XULBrowserWindow.setOverLink(linkURI, null);\n        }\n      ]]></handler>\n\n      <handler event=\"DOMMenuItemInactive\"><![CDATA[\n        let elt = event.target;\n        if (elt.parentNode != this)\n          return;\n\n        if (window.XULBrowserWindow)\n          window.XULBrowserWindow.setOverLink(\"\", null);\n      ]]></handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        let elt = event.target;\n        if (!elt._placesNode)\n          return;\n\n        let draggedElt = elt._placesNode;\n\n        // Force a copy action if parent node is a query or we are dragging a\n        // not-removable node.\n        if (!this._rootView.controller.canMoveNode(draggedElt))\n          event.dataTransfer.effectAllowed = \"copyLink\";\n\n        // Activate the view and cache the dragged element.\n        this._rootView._draggedElt = draggedElt;\n        this._rootView.controller.setDataTransfer(event);\n        this.setAttribute(\"dragstart\", \"true\");\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"drop\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = event.target;\n\n        let dropPoint = this._getDropPoint(event);\n        if (dropPoint && dropPoint.ip) {\n          PlacesControllerDragHelper.onDrop(dropPoint.ip, event.dataTransfer)\n                                    .catch(Cu.reportError);\n          event.preventDefault();\n        }\n\n        this._cleanupDragDetails();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = event.target;\n        let dt = event.dataTransfer;\n\n        let dropPoint = this._getDropPoint(event);\n        if (!dropPoint || !dropPoint.ip ||\n            !PlacesControllerDragHelper.canDrop(dropPoint.ip, dt)) {\n          this._indicatorBar.hidden = true;\n          event.stopPropagation();\n          return;\n        }\n\n        // Mark this popup as being dragged over.\n        this.setAttribute(\"dragover\", \"true\");\n\n        if (dropPoint.folderElt) {\n          // We are dragging over a folder.\n          // _overFolder should take the care of opening it on a timer.\n          if (this._overFolder.elt &&\n              this._overFolder.elt != dropPoint.folderElt) {\n            // We are dragging over a new folder, let's clear old values\n            this._overFolder.clear();\n          }\n          if (!this._overFolder.elt) {\n            this._overFolder.elt = dropPoint.folderElt;\n            // Create the timer to open this folder.\n            this._overFolder.openTimer = this._overFolder\n                                             .setTimer(this._overFolder.hoverTime);\n          }\n          // Since we are dropping into a folder set the corresponding style.\n          dropPoint.folderElt.setAttribute(\"_moz-menuactive\", true);\n        } else {\n          // We are not dragging over a folder.\n          // Clear out old _overFolder information.\n          this._overFolder.clear();\n        }\n\n        // Autoscroll the popup strip if we drag over the scroll buttons.\n        let anonid = event.originalTarget.getAttribute(\"anonid\");\n        let scrollDir = 0;\n        if (anonid == \"scrollbutton-up\") {\n          scrollDir = -1;\n        } else if (anonid == \"scrollbutton-down\") {\n          scrollDir = 1;\n        }\n        if (scrollDir != 0) {\n          this._scrollBox.scrollByIndex(scrollDir, true);\n        }\n\n        // Check if we should hide the drop indicator for this target.\n        if (dropPoint.folderElt || this._hideDropIndicator(event)) {\n          this._indicatorBar.hidden = true;\n          event.preventDefault();\n          event.stopPropagation();\n          return;\n        }\n\n        // We should display the drop indicator relative to the arrowscrollbox.\n        let scrollRect = this._scrollBox.getBoundingClientRect();\n        let newMarginTop = 0;\n        if (scrollDir == 0) {\n          let elt = this.firstElementChild;\n          while (elt && event.screenY > elt.screenY +\n                                        elt.getBoundingClientRect().height / 2)\n            elt = elt.nextElementSibling;\n          newMarginTop = elt ? elt.screenY - this._scrollBox.screenY :\n                               scrollRect.height;\n        } else if (scrollDir == 1) {\n          newMarginTop = scrollRect.height;\n        }\n\n        // Set the new marginTop based on arrowscrollbox.\n        newMarginTop += scrollRect.y - this._scrollBox.getBoundingClientRect().y;\n        this._indicatorBar.firstElementChild.style.marginTop = newMarginTop + \"px\";\n        this._indicatorBar.hidden = false;\n\n        event.preventDefault();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragexit\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = null;\n        this.removeAttribute(\"dragover\");\n\n        // If we have not moved to a valid new target clear the drop indicator\n        // this happens when moving out of the popup.\n        let target = event.relatedTarget;\n        if (!target || !this.contains(target))\n          this._indicatorBar.hidden = true;\n\n        // Close any folder being hovered over\n        if (this._overFolder.elt) {\n          this._overFolder.closeTimer = this._overFolder\n                                            .setTimer(this._overFolder.hoverTime);\n        }\n\n        // The autoopened attribute is set when this folder was automatically\n        // opened after the user dragged over it.  If this attribute is set,\n        // auto-close the folder on drag exit.\n        // We should also try to close this popup if the drag has started\n        // from here, the timer will check if we are dragging over a child.\n        if (this.hasAttribute(\"autoopened\") ||\n            this.hasAttribute(\"dragstart\")) {\n          this._overFolder.closeMenuTimer = this._overFolder\n                                                .setTimer(this._overFolder.hoverTime);\n        }\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragend\"><![CDATA[\n        this._cleanupDragDetails();\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n  <!-- Most of this is copied from the arrowpanel binding in popup.xml -->\n  <binding id=\"places-popup-arrow\"\n           extends=\"chrome://browser/content/places/menu.xml#places-popup-base\">\n    <content flip=\"both\" side=\"top\" position=\"bottomcenter topright\">\n      <xul:vbox anonid=\"container\" class=\"panel-arrowcontainer\" flex=\"1\"\n               xbl:inherits=\"side,panelopen\">\n        <xul:box anonid=\"arrowbox\" class=\"panel-arrowbox\">\n          <xul:image anonid=\"arrow\" class=\"panel-arrow\" xbl:inherits=\"side\"/>\n        </xul:box>\n        <xul:box class=\"panel-arrowcontent\" xbl:inherits=\"side,align,dir,orient,pack\" flex=\"1\">\n          <xul:vbox class=\"menupopup-drop-indicator-bar\" hidden=\"true\">\n            <xul:image class=\"menupopup-drop-indicator\" mousethrough=\"always\"/>\n          </xul:vbox>\n          <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                              smoothscroll=\"false\">\n            <children/>\n          </xul:arrowscrollbox>\n        </xul:box>\n      </xul:vbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this.style.pointerEvents = \"none\";\n      ]]></constructor>\n      <method name=\"adjustArrowPosition\">\n        <body><![CDATA[\n          var arrow = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrow\");\n\n          var anchor = this.anchorNode;\n          if (!anchor) {\n            arrow.hidden = true;\n            return;\n          }\n\n          var container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n          var arrowbox = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\");\n\n          var position = this.alignmentPosition;\n          var offset = this.alignmentOffset;\n\n          this.setAttribute(\"arrowposition\", position);\n\n          // if this panel has a \"sliding\" arrow, we may have previously set margins...\n          arrowbox.style.removeProperty(\"transform\");\n          if (position.indexOf(\"start_\") == 0 || position.indexOf(\"end_\") == 0) {\n            container.orient = \"horizontal\";\n            arrowbox.orient = \"vertical\";\n            if (position.indexOf(\"_after\") > 0) {\n              arrowbox.pack = \"end\";\n            } else {\n              arrowbox.pack = \"start\";\n            }\n            arrowbox.style.transform = \"translate(0, \" + -offset + \"px)\";\n\n            // The assigned side stays the same regardless of direction.\n            let isRTL = this.matches(\":-moz-locale-dir(rtl)\");\n\n            if (position.indexOf(\"start_\") == 0) {\n              container.dir = \"reverse\";\n              this.setAttribute(\"side\", isRTL ? \"left\" : \"right\");\n            } else {\n              container.dir = \"\";\n              this.setAttribute(\"side\", isRTL ? \"right\" : \"left\");\n            }\n          } else if (position.indexOf(\"before_\") == 0 || position.indexOf(\"after_\") == 0) {\n            container.orient = \"\";\n            arrowbox.orient = \"\";\n            if (position.indexOf(\"_end\") > 0) {\n              arrowbox.pack = \"end\";\n            } else {\n              arrowbox.pack = \"start\";\n            }\n            arrowbox.style.transform = \"translate(\" + -offset + \"px, 0)\";\n\n            if (position.indexOf(\"before_\") == 0) {\n              container.dir = \"reverse\";\n              this.setAttribute(\"side\", \"bottom\");\n            } else {\n              container.dir = \"\";\n              this.setAttribute(\"side\", \"top\");\n            }\n          }\n\n          arrow.hidden = false;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\"><![CDATA[\n        this.adjustArrowPosition();\n        this.setAttribute(\"animate\", \"open\");\n      ]]></handler>\n      <handler event=\"popupshown\" phase=\"target\"><![CDATA[\n        this.setAttribute(\"panelopen\", \"true\");\n        let disablePointerEvents;\n        if (!this.hasAttribute(\"disablepointereventsfortransition\")) {\n          let container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n          let cs = getComputedStyle(container);\n          let transitionProp = cs.transitionProperty;\n          let transitionTime = parseFloat(cs.transitionDuration);\n          disablePointerEvents = (transitionProp.includes(\"transform\") ||\n                                  transitionProp == \"all\") &&\n                                 transitionTime > 0;\n          this.setAttribute(\"disablepointereventsfortransition\", disablePointerEvents);\n        } else {\n          disablePointerEvents = this.getAttribute(\"disablepointereventsfortransition\") == \"true\";\n        }\n        if (!disablePointerEvents) {\n          this.style.removeProperty(\"pointer-events\");\n        }\n      ]]></handler>\n      <handler event=\"transitionend\"><![CDATA[\n        if (event.originalTarget.getAttribute(\"anonid\") == \"container\" &&\n            (event.propertyName == \"transform\" || event.propertyName == \"-moz-window-transform\")) {\n          this.style.removeProperty(\"pointer-events\");\n        }\n      ]]></handler>\n      <handler event=\"popuphiding\" phase=\"target\"><![CDATA[\n        this.setAttribute(\"animate\", \"cancel\");\n      ]]></handler>\n      <handler event=\"popuphidden\" phase=\"target\"><![CDATA[\n        this.removeAttribute(\"panelopen\");\n        if (this.getAttribute(\"disablepointereventsfortransition\") == \"true\") {\n          this.style.pointerEvents = \"none\";\n        }\n        this.removeAttribute(\"animate\");\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"autocomplete.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"autocompleteBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"autocomplete\"\n           extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content sizetopopup=\"pref\">\n      <children includes=\"image|box\"/>\n\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\">\n        <children/>\n        <html:input anonid=\"input\" class=\"textbox-input\"\n                    allowevents=\"true\"\n                    autocomplete=\"off\"\n                    xbl:inherits=\"value,type=inputtype,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,mozactionhint\"/>\n      </xul:moz-input-box>\n      <children includes=\"hbox\"/>\n\n      <xul:popupset anonid=\"popupset\" class=\"autocomplete-result-popupset\"/>\n    </content>\n\n    <implementation implements=\"nsIAutoCompleteInput, nsIDOMXULMenuListElement\">\n      <field name=\"mController\">null</field>\n      <field name=\"mSearchNames\">null</field>\n      <field name=\"mIgnoreInput\">false</field>\n      <field name=\"noRollupOnEmptySearch\">false</field>\n\n      <field name=\"_searchBeginHandler\">null</field>\n      <field name=\"_searchCompleteHandler\">null</field>\n      <field name=\"_textEnteredHandler\">null</field>\n      <field name=\"_textRevertedHandler\">null</field>\n\n      <constructor><![CDATA[\n        this.mController = Cc[\"@mozilla.org/autocomplete/controller;1\"].\n          getService(Ci.nsIAutoCompleteController);\n\n        this._searchBeginHandler = this.initEventHandler(\"searchbegin\");\n        this._searchCompleteHandler = this.initEventHandler(\"searchcomplete\");\n        this._textEnteredHandler = this.initEventHandler(\"textentered\");\n        this._textRevertedHandler = this.initEventHandler(\"textreverted\");\n      ]]></constructor>\n\n      <!-- =================== nsIAutoCompleteInput =================== -->\n\n      <field name=\"_popup\">null</field>\n      <property name=\"popup\" readonly=\"true\">\n        <getter><![CDATA[\n          // Memoize the result in a field rather than replacing this property,\n          // so that it can be reset along with the binding.\n          if (this._popup) {\n            return this._popup;\n          }\n\n          let popup = null;\n          let popupId = this.getAttribute(\"autocompletepopup\");\n          if (popupId) {\n            popup = document.getElementById(popupId);\n          }\n          if (!popup) {\n            popup = document.createXULElement(\"panel\", { is: \"autocomplete-richlistbox-popup\" });\n            popup.setAttribute(\"type\", \"autocomplete-richlistbox\");\n            popup.setAttribute(\"noautofocus\", \"true\");\n\n            let popupset = document.getAnonymousElementByAttribute(this, \"anonid\", \"popupset\");\n            popupset.appendChild(popup);\n          }\n          popup.mInput = this;\n\n          return this._popup = popup;\n        ]]></getter>\n      </property>\n      <property name=\"popupElement\" readonly=\"true\"\n                onget=\"return this.popup;\"/>\n\n      <property name=\"controller\" onget=\"return this.mController;\" readonly=\"true\"/>\n\n      <property name=\"popupOpen\"\n                onget=\"return this.popup.popupOpen;\"\n                onset=\"if (val) this.openPopup(); else this.closePopup();\"/>\n\n      <property name=\"disableAutoComplete\"\n                onset=\"this.setAttribute('disableautocomplete', val); return val;\"\n                onget=\"return this.getAttribute('disableautocomplete') == 'true';\"/>\n\n      <property name=\"completeDefaultIndex\"\n                onset=\"this.setAttribute('completedefaultindex', val); return val;\"\n                onget=\"return this.getAttribute('completedefaultindex') == 'true';\"/>\n\n      <property name=\"completeSelectedIndex\"\n                onset=\"this.setAttribute('completeselectedindex', val); return val;\"\n                onget=\"return this.getAttribute('completeselectedindex') == 'true';\"/>\n\n      <property name=\"forceComplete\"\n                onset=\"this.setAttribute('forcecomplete', val); return val;\"\n                onget=\"return this.getAttribute('forcecomplete') == 'true';\"/>\n\n      <property name=\"minResultsForPopup\"\n                onset=\"this.setAttribute('minresultsforpopup', val); return val;\"\n                onget=\"var m = parseInt(this.getAttribute('minresultsforpopup')); return isNaN(m) ? 1 : m;\"/>\n\n      <property name=\"timeout\"\n                onset=\"this.setAttribute('timeout', val); return val;\"\n                onget=\"var t = parseInt(this.getAttribute('timeout')); return isNaN(t) ? 50 : t;\"/>\n\n      <property name=\"searchParam\"\n                onget=\"return this.getAttribute('autocompletesearchparam') || '';\"\n                onset=\"this.setAttribute('autocompletesearchparam', val); return val;\"/>\n\n      <property name=\"searchCount\" readonly=\"true\"\n                onget=\"this.initSearchNames(); return this.mSearchNames.length;\"/>\n\n      <property name=\"PrivateBrowsingUtils\" readonly=\"true\">\n        <getter><![CDATA[\n          let module = {};\n          ChromeUtils.import(\"resource://gre/modules/PrivateBrowsingUtils.jsm\", module);\n          Object.defineProperty(this, \"PrivateBrowsingUtils\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: module.PrivateBrowsingUtils,\n          });\n          return module.PrivateBrowsingUtils;\n        ]]></getter>\n      </property>\n\n      <property name=\"inPrivateContext\" readonly=\"true\"\n                onget=\"return this.PrivateBrowsingUtils.isWindowPrivate(window);\"/>\n\n      <property name=\"noRollupOnCaretMove\" readonly=\"true\"\n                onget=\"return this.popup.getAttribute('norolluponanchor') == 'true'\"/>\n\n      <!-- This is the maximum number of drop-down rows we get when we\n            hit the drop marker beside fields that have it (like the URLbar).-->\n      <field name=\"maxDropMarkerRows\" readonly=\"true\">14</field>\n\n      <method name=\"getSearchAt\">\n        <parameter name=\"aIndex\"/>\n        <body><![CDATA[\n          this.initSearchNames();\n          return this.mSearchNames[aIndex];\n        ]]></body>\n      </method>\n\n      <method name=\"setTextValueWithReason\">\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aReason\"/>\n        <body><![CDATA[\n          if (aReason == Ci.nsIAutoCompleteInput\n                           .TEXTVALUE_REASON_COMPLETEDEFAULT) {\n            this._textValueSetByCompleteDefault = true;\n          }\n          this.textValue = aValue;\n          this._textValueSetByCompleteDefault = false;\n        ]]></body>\n      </method>\n\n      <property name=\"textValue\">\n        <getter><![CDATA[\n          if (typeof this.onBeforeTextValueGet == \"function\") {\n            let result = this.onBeforeTextValueGet();\n            if (result) {\n              return result.value;\n            }\n          }\n          return this.value;\n        ]]></getter>\n        <setter><![CDATA[\n          if (typeof this.onBeforeTextValueSet == \"function\" &&\n              !this._textValueSetByCompleteDefault) {\n            val = this.onBeforeTextValueSet(val);\n          }\n\n          // \"input\" event is automatically dispatched by the editor if\n          // necessary.\n          this._setValueInternal(val, true);\n\n          return this.value;\n        ]]></setter>\n      </property>\n\n      <method name=\"selectTextRange\">\n        <parameter name=\"aStartIndex\"/>\n        <parameter name=\"aEndIndex\"/>\n        <body><![CDATA[\n          this.inputField.setSelectionRange(aStartIndex, aEndIndex);\n        ]]></body>\n      </method>\n\n      <method name=\"onSearchBegin\">\n        <body><![CDATA[\n          if (this.popup && typeof this.popup.onSearchBegin == \"function\")\n            this.popup.onSearchBegin();\n          if (this._searchBeginHandler)\n            this._searchBeginHandler();\n        ]]></body>\n      </method>\n\n      <method name=\"onSearchComplete\">\n        <body><![CDATA[\n          if (this.mController.matchCount == 0)\n            this.setAttribute(\"nomatch\", \"true\");\n          else\n            this.removeAttribute(\"nomatch\");\n\n          if (this.ignoreBlurWhileSearching && !this.focused) {\n            this.handleEnter();\n            this.detachController();\n          }\n\n          if (this._searchCompleteHandler)\n            this._searchCompleteHandler();\n        ]]></body>\n      </method>\n\n      <method name=\"onTextEntered\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let rv = false;\n          if (this._textEnteredHandler) {\n            rv = this._textEnteredHandler(event);\n          }\n          return rv;\n        ]]></body>\n      </method>\n\n      <method name=\"onTextReverted\">\n        <body><![CDATA[\n          if (this._textRevertedHandler)\n            return this._textRevertedHandler();\n          return false;\n        ]]></body>\n      </method>\n\n      <!-- =================== nsIDOMXULMenuListElement =================== -->\n\n      <property name=\"editable\" readonly=\"true\"\n                onget=\"return true;\" />\n\n      <property name=\"crop\"\n                onset=\"this.setAttribute('crop',val); return val;\"\n                onget=\"return this.getAttribute('crop');\"/>\n\n      <property name=\"open\"\n                onget=\"return this.getAttribute('open') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.showHistoryPopup();\n          else\n            this.closePopup();\n        ]]></setter>\n      </property>\n\n      <!-- =================== PUBLIC MEMBERS =================== -->\n\n      <field name=\"valueIsTyped\">false</field>\n      <field name=\"_textValueSetByCompleteDefault\">false</field>\n      <property name=\"value\"\n                onset=\"return this._setValueInternal(val, false);\">\n        <getter><![CDATA[\n          if (typeof this.onBeforeValueGet == \"function\") {\n            var result = this.onBeforeValueGet();\n            if (result)\n              return result.value;\n          }\n          return this.inputField.value;\n        ]]></getter>\n      </property>\n\n      <property name=\"focused\" readonly=\"true\"\n                onget=\"return this.getAttribute('focused') == 'true';\"/>\n\n      <!-- maximum number of rows to display at a time -->\n      <property name=\"maxRows\"\n                onset=\"this.setAttribute('maxrows', val); return val;\"\n                onget=\"return parseInt(this.getAttribute('maxrows')) || 0;\"/>\n\n      <!-- option to allow scrolling through the list via the tab key, rather than\n           tab moving focus out of the textbox -->\n      <property name=\"tabScrolling\"\n                onset=\"this.setAttribute('tabscrolling', val); return val;\"\n                onget=\"return this.getAttribute('tabscrolling') == 'true';\"/>\n\n      <!-- option to completely ignore any blur events while searches are\n           still going on. -->\n      <property name=\"ignoreBlurWhileSearching\"\n                onset=\"this.setAttribute('ignoreblurwhilesearching', val); return val;\"\n                onget=\"return this.getAttribute('ignoreblurwhilesearching') == 'true';\"/>\n\n      <!-- option to highlight entries that don't have any matches -->\n      <property name=\"highlightNonMatches\"\n                onset=\"this.setAttribute('highlightnonmatches', val); return val;\"\n                onget=\"return this.getAttribute('highlightnonmatches') == 'true';\"/>\n\n      <!-- =================== PRIVATE MEMBERS =================== -->\n\n      <!-- ::::::::::::: autocomplete controller ::::::::::::: -->\n\n      <method name=\"attachController\">\n        <body><![CDATA[\n          this.mController.input = this;\n        ]]></body>\n      </method>\n\n      <method name=\"detachController\">\n        <body><![CDATA[\n          if (this.mController.input == this)\n            this.mController.input = null;\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: popup opening ::::::::::::: -->\n\n      <method name=\"openPopup\">\n        <body><![CDATA[\n          if (this.focused)\n            this.popup.openAutocompletePopup(this, this);\n        ]]></body>\n      </method>\n\n      <method name=\"closePopup\">\n        <body><![CDATA[\n          this.popup.closePopup();\n        ]]></body>\n      </method>\n\n      <method name=\"showHistoryPopup\">\n        <body><![CDATA[\n          // Store our \"normal\" maxRows on the popup, so that it can reset the\n          // value when the popup is hidden.\n          this.popup._normalMaxRows = this.maxRows;\n\n          // Increase our maxRows temporarily, since we want the dropdown to\n          // be bigger in this case. The popup's popupshowing/popuphiding\n          // handlers will take care of resetting this.\n          this.maxRows = this.maxDropMarkerRows;\n\n          // Ensure that we have focus.\n          if (!this.focused)\n            this.focus();\n          this.attachController();\n          this.mController.startSearch(\"\");\n        ]]></body>\n      </method>\n\n      <method name=\"toggleHistoryPopup\">\n        <body><![CDATA[\n          if (!this.popup.popupOpen)\n            this.showHistoryPopup();\n          else\n            this.closePopup();\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: event dispatching ::::::::::::: -->\n\n      <method name=\"initEventHandler\">\n        <parameter name=\"aEventType\"/>\n        <body><![CDATA[\n          let handlerString = this.getAttribute(\"on\" + aEventType);\n          if (handlerString) {\n            return (new Function(\"eventType\", \"param\", handlerString)).bind(this, aEventType);\n          }\n          return null;\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: key handling ::::::::::::: -->\n\n      <field name=\"_selectionDetails\">null</field>\n      <method name=\"onKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          return this.handleKeyPress(aEvent);\n        ]]></body>\n      </method>\n\n      <method name=\"handleKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aOptions\"/>\n        <body><![CDATA[\n          if (aEvent.target.localName != \"textbox\")\n            return true; // Let child buttons of autocomplete take input\n\n          // Re: urlbarDeferred, see the comment in urlbarBindings.xml.\n          if (aEvent.defaultPrevented && !aEvent.urlbarDeferred) {\n            return false;\n          }\n\n          const isMac = /Mac/.test(navigator.platform);\n          var cancel = false;\n\n          // Catch any keys that could potentially move the caret. Ctrl can be\n          // used in combination with these keys on Windows and Linux; and Alt\n          // can be used on OS X, so make sure the unused one isn't used.\n          let metaKey = isMac ? aEvent.ctrlKey : aEvent.altKey;\n          if (!metaKey) {\n            switch (aEvent.keyCode) {\n              case KeyEvent.DOM_VK_LEFT:\n              case KeyEvent.DOM_VK_RIGHT:\n              case KeyEvent.DOM_VK_HOME:\n                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);\n                break;\n            }\n          }\n\n          // Handle keys that are not part of a keyboard shortcut (no Ctrl or Alt)\n          if (!aEvent.ctrlKey && !aEvent.altKey) {\n            switch (aEvent.keyCode) {\n              case KeyEvent.DOM_VK_TAB:\n                if (this.tabScrolling && this.popup.popupOpen)\n                  cancel = this.mController.handleKeyNavigation(aEvent.shiftKey ?\n                                                                KeyEvent.DOM_VK_UP :\n                                                                KeyEvent.DOM_VK_DOWN);\n                else if (this.forceComplete && this.mController.matchCount >= 1)\n                  this.mController.handleTab();\n                break;\n              case KeyEvent.DOM_VK_UP:\n              case KeyEvent.DOM_VK_DOWN:\n              case KeyEvent.DOM_VK_PAGE_UP:\n              case KeyEvent.DOM_VK_PAGE_DOWN:\n                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);\n                break;\n            }\n          }\n\n          // Handle readline/emacs-style navigation bindings on Mac.\n          if (isMac &&\n              this.popup.popupOpen &&\n              aEvent.ctrlKey &&\n              (aEvent.key === \"n\" || aEvent.key === \"p\")) {\n            const effectiveKey = (aEvent.key === \"p\") ?\n                                 KeyEvent.DOM_VK_UP :\n                                 KeyEvent.DOM_VK_DOWN;\n            cancel = this.mController.handleKeyNavigation(effectiveKey);\n          }\n\n          // Handle keys we know aren't part of a shortcut, even with Alt or\n          // Ctrl.\n          switch (aEvent.keyCode) {\n            case KeyEvent.DOM_VK_ESCAPE:\n              cancel = this.mController.handleEscape();\n              break;\n            case KeyEvent.DOM_VK_RETURN:\n              if (isMac) {\n                // Prevent the default action, since it will beep on Mac\n                if (aEvent.metaKey)\n                  aEvent.preventDefault();\n              }\n              if (this.popup.selectedIndex >= 0) {\n                this._selectionDetails = {\n                  index: this.popup.selectedIndex,\n                  kind: \"key\",\n                };\n              }\n              cancel = this.handleEnter(aEvent, aOptions);\n              break;\n            case KeyEvent.DOM_VK_DELETE:\n              if (isMac && !aEvent.shiftKey) {\n                break;\n              }\n              cancel = this.handleDelete();\n              break;\n            case KeyEvent.DOM_VK_BACK_SPACE:\n              if (isMac && aEvent.shiftKey) {\n                cancel = this.handleDelete();\n              }\n              break;\n            case KeyEvent.DOM_VK_DOWN:\n            case KeyEvent.DOM_VK_UP:\n              if (aEvent.altKey)\n                this.toggleHistoryPopup();\n              break;\n            case KeyEvent.DOM_VK_F4:\n              if (!isMac) {\n                this.toggleHistoryPopup();\n              }\n              break;\n          }\n\n          if (cancel) {\n            aEvent.stopPropagation();\n            aEvent.preventDefault();\n          }\n\n          return true;\n        ]]></body>\n      </method>\n\n      <method name=\"handleEnter\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          return this.mController.handleEnter(false, event || null);\n        ]]></body>\n      </method>\n\n      <method name=\"handleDelete\">\n        <body><![CDATA[\n          return this.mController.handleDelete();\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: miscellaneous ::::::::::::: -->\n\n      <method name=\"initSearchNames\">\n        <body><![CDATA[\n          if (!this.mSearchNames) {\n            var names = this.getAttribute(\"autocompletesearch\");\n            if (!names)\n              this.mSearchNames = [];\n            else\n              this.mSearchNames = names.split(\" \");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_focus\">\n        <!-- doesn't reset this.mController -->\n        <body><![CDATA[\n          this._dontBlur = true;\n          this.focus();\n          this._dontBlur = false;\n        ]]></body>\n      </method>\n\n      <method name=\"resetActionType\">\n        <body><![CDATA[\n          if (this.mIgnoreInput)\n            return;\n          this.removeAttribute(\"actiontype\");\n        ]]></body>\n      </method>\n\n      <method name=\"_setValueInternal\">\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aIsUserInput\"/>\n        <body><![CDATA[\n          this.mIgnoreInput = true;\n\n          if (typeof this.onBeforeValueSet == \"function\")\n            aValue = this.onBeforeValueSet(aValue);\n\n          if (typeof this.trimValue == \"function\" &&\n              !this._textValueSetByCompleteDefault)\n            aValue = this.trimValue(aValue);\n\n          this.valueIsTyped = false;\n          if (aIsUserInput) {\n            this.inputField.setUserInput(aValue);\n          } else {\n            this.inputField.value = aValue;\n          }\n\n          if (typeof this.formatValue == \"function\")\n            this.formatValue();\n\n          this.mIgnoreInput = false;\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"ValueChange\", true, true);\n          this.inputField.dispatchEvent(event);\n          return aValue;\n        ]]></body>\n      </method>\n\n      <method name=\"onInput\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this.mIgnoreInput && this.mController.input == this) {\n            this.valueIsTyped = true;\n            this.mController.handleText();\n          }\n          this.resetActionType();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"input\"><![CDATA[\n        this.onInput(event);\n      ]]></handler>\n\n      <handler event=\"keypress\" phase=\"capturing\" group=\"system\"\n               action=\"return this.onKeyPress(event);\"/>\n\n      <handler event=\"compositionstart\" phase=\"capturing\"\n               action=\"if (this.mController.input == this) this.mController.handleStartComposition();\"/>\n\n      <handler event=\"compositionend\" phase=\"capturing\"\n               action=\"if (this.mController.input == this) this.mController.handleEndComposition();\"/>\n\n      <handler event=\"focus\" phase=\"capturing\"><![CDATA[\n        this.attachController();\n        if (window.gBrowser && window.gBrowser.selectedBrowser.hasAttribute(\"usercontextid\")) {\n          this.userContextId = parseInt(window.gBrowser.selectedBrowser.getAttribute(\"usercontextid\"));\n        } else {\n          this.userContextId = 0;\n        }\n      ]]></handler>\n\n      <handler event=\"blur\" phase=\"capturing\"><![CDATA[\n        if (!this._dontBlur) {\n          if (this.forceComplete && this.mController.matchCount >= 1) {\n            // If forceComplete is requested, we need to call the enter processing\n            // on blur so the input will be forced to the closest match.\n            // Thunderbird is the only consumer of forceComplete and this is used\n            // to force an recipient's email to the exact address book entry.\n            this.mController.handleEnter(true);\n          }\n          if (!this.ignoreBlurWhileSearching)\n            this.detachController();\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autocomplete-rich-result-popup\">\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\">\n      <xul:richlistbox anonid=\"richlistbox\" class=\"autocomplete-richlistbox\" flex=\"1\"/>\n      <xul:hbox>\n        <children/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIAutoCompletePopup\">\n      <field name=\"mInput\">null</field>\n      <field name=\"mPopupOpen\">false</field>\n      <field name=\"_currentIndex\">0</field>\n\n      <constructor><![CDATA[\n        if (!this.listEvents) {\n          this.listEvents = {\n            handleEvent: event => {\n              if (!this.parentNode) {\n                return;\n              }\n\n              switch (event.type) {\n                case \"mouseup\":\n                  // Don't call onPopupClick for the scrollbar buttons, thumb,\n                  // slider, etc. If we hit the richlistbox and not a\n                  // richlistitem, we ignore the event.\n                  if (event.target.closest(\"richlistbox,richlistitem\")\n                                  .localName == \"richlistitem\") {\n                    this.onPopupClick(event);\n                  }\n                  break;\n                case \"mousemove\":\n                  if (Date.now() - this.mLastMoveTime <= 30) {\n                    return;\n                  }\n\n                  let item = event.target.closest(\"richlistbox,richlistitem\");\n\n                  // If we hit the richlistbox and not a richlistitem, we ignore\n                  // the event.\n                  if (item.localName == \"richlistbox\") {\n                    return;\n                  }\n\n                  let index = this.richlistbox.getIndexOfItem(item);\n\n                  this.mousedOverIndex = index;\n\n                  if (item.selectedByMouseOver) {\n                    this.richlistbox.selectedIndex = index;\n                  }\n\n                  this.mLastMoveTime = Date.now();\n                  break;\n              }\n            },\n          };\n          this.richlistbox.addEventListener(\"mouseup\", this.listEvents);\n          this.richlistbox.addEventListener(\"mousemove\", this.listEvents);\n        }\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        if (this.listEvents) {\n          this.richlistbox.removeEventListener(\"mouseup\", this.listEvents);\n          this.richlistbox.removeEventListener(\"mousemove\", this.listEvents);\n          delete this.listEvents;\n        }\n      ]]></destructor>\n\n      <!-- =================== nsIAutoCompletePopup =================== -->\n\n      <property name=\"input\" readonly=\"true\"\n                onget=\"return this.mInput\"/>\n\n      <property name=\"overrideValue\" readonly=\"true\"\n                onget=\"return null;\"/>\n\n      <property name=\"popupOpen\" readonly=\"true\"\n                onget=\"return this.mPopupOpen;\"/>\n\n      <method name=\"closePopup\">\n        <body>\n          <![CDATA[\n          if (this.mPopupOpen) {\n            this.hidePopup();\n            this.removeAttribute(\"width\");\n          }\n        ]]>\n        </body>\n      </method>\n\n      <!-- This is the default number of rows that we give the autocomplete\n           popup when the textbox doesn't have a \"maxrows\" attribute\n           for us to use. -->\n      <field name=\"defaultMaxRows\" readonly=\"true\">6</field>\n\n      <!-- In some cases (e.g. when the input's dropmarker button is clicked),\n           the input wants to display a popup with more rows. In that case, it\n           should increase its maxRows property and store the \"normal\" maxRows\n           in this field. When the popup is hidden, we restore the input's\n           maxRows to the value stored in this field.\n\n           This field is set to -1 between uses so that we can tell when it's\n           been set by the input and when we need to set it in the popupshowing\n           handler. -->\n      <field name=\"_normalMaxRows\">-1</field>\n\n      <property name=\"maxRows\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n          return (this.mInput && this.mInput.maxRows) || this.defaultMaxRows;\n        ]]>\n        </getter>\n      </property>\n\n      <method name=\"getNextIndex\">\n        <parameter name=\"aReverse\"/>\n        <parameter name=\"aAmount\"/>\n        <parameter name=\"aIndex\"/>\n        <parameter name=\"aMaxRow\"/>\n        <body><![CDATA[\n          if (aMaxRow < 0)\n            return -1;\n\n          var newIdx = aIndex + (aReverse ? -1 : 1) * aAmount;\n          if (aReverse && aIndex == -1 || newIdx > aMaxRow && aIndex != aMaxRow)\n            newIdx = aMaxRow;\n          else if (!aReverse && aIndex == -1 || newIdx < 0 && aIndex != 0)\n            newIdx = 0;\n\n          if (newIdx < 0 && aIndex == 0 || newIdx > aMaxRow && aIndex == aMaxRow)\n            aIndex = -1;\n          else\n            aIndex = newIdx;\n\n          return aIndex;\n        ]]></body>\n      </method>\n\n      <method name=\"onPopupClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          this.input.controller.handleEnter(true, aEvent);\n        ]]></body>\n      </method>\n\n      <property name=\"selectedIndex\"\n                onget=\"return this.richlistbox.selectedIndex;\">\n        <setter>\n          <![CDATA[\n          if (val != this.richlistbox.selectedIndex) {\n            this._previousSelectedIndex = this.richlistbox.selectedIndex;\n          }\n          this.richlistbox.selectedIndex = val;\n          // Since ensureElementIsVisible may cause an expensive Layout flush,\n          // invoke it only if there may be a scrollbar, so if we could fetch\n          // more results than we can show at once.\n          // maxResults is the maximum number of fetched results, maxRows is the\n          // maximum number of rows we show at once, without a scrollbar.\n          if (this.mPopupOpen && this.maxResults > this.maxRows) {\n            // when clearing the selection (val == -1, so selectedItem will be\n            // null), we want to scroll back to the top.  see bug #406194\n            this.richlistbox.ensureElementIsVisible(\n              this.richlistbox.selectedItem || this.richlistbox.firstElementChild);\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <field name=\"_previousSelectedIndex\">-1</field>\n      <field name=\"mLastMoveTime\">Date.now()</field>\n      <field name=\"mousedOverIndex\">-1</field>\n\n      <method name=\"onSearchBegin\">\n        <body><![CDATA[\n          this.mousedOverIndex = -1;\n\n          if (typeof this._onSearchBegin == \"function\") {\n            this._onSearchBegin();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          // until we have \"baseBinding\", (see bug #373652) this allows\n          // us to override openAutocompletePopup(), but still call\n          // the method on the base class\n          this._openAutocompletePopup(aInput, aElement);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          if (!this.mPopupOpen) {\n            // It's possible that the panel is hidden initially\n            // to avoid impacting startup / new window performance\n            aInput.popup.hidden = false;\n\n            this.mInput = aInput;\n            // clear any previous selection, see bugs 400671 and 488357\n            this.selectedIndex = -1;\n\n            var width = aElement.getBoundingClientRect().width;\n            this.setAttribute(\"width\", width > 100 ? width : 100);\n            // invalidate() depends on the width attribute\n            this._invalidate();\n\n            this.openPopup(aElement, \"after_start\", 0, 0, false, false);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"invalidate\">\n        <parameter name=\"reason\"/>\n        <body>\n          <![CDATA[\n          // Don't bother doing work if we're not even showing\n          if (!this.mPopupOpen)\n            return;\n\n          this._invalidate(reason);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_invalidate\">\n        <parameter name=\"reason\"/>\n        <body>\n          <![CDATA[\n          // collapsed if no matches\n          this.richlistbox.collapsed = (this.matchCount == 0);\n\n          // Update the richlistbox height.\n          if (this._adjustHeightRAFToken) {\n            cancelAnimationFrame(this._adjustHeightRAFToken);\n            this._adjustHeightRAFToken = null;\n          }\n\n          if (this.mPopupOpen) {\n            delete this._adjustHeightOnPopupShown;\n            this._adjustHeightRAFToken = requestAnimationFrame(() => this.adjustHeight());\n          } else {\n            this._adjustHeightOnPopupShown = true;\n          }\n\n          this._currentIndex = 0;\n          if (this._appendResultTimeout) {\n            clearTimeout(this._appendResultTimeout);\n          }\n          this._appendCurrentResult(reason);\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"maxResults\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            // This is how many richlistitems will be kept around.\n            // Note, this getter may be overridden, or instances\n            // can have the nomaxresults attribute set to have no\n            // limit.\n            if (this.getAttribute(\"nomaxresults\") == \"true\") {\n              return Infinity;\n            }\n\n            return 20;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"matchCount\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n          return Math.min(this.mInput.controller.matchCount, this.maxResults);\n          ]]>\n        </getter>\n      </property>\n\n      <method name=\"_collapseUnusedItems\">\n        <body>\n          <![CDATA[\n            let existingItemsCount = this.richlistbox.children.length;\n            for (let i = this.matchCount; i < existingItemsCount; ++i) {\n              let item = this.richlistbox.children[i];\n\n              item.collapsed = true;\n              if (typeof item._onCollapse == \"function\") {\n                item._onCollapse();\n              }\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"adjustHeight\">\n        <body>\n          <![CDATA[\n          // Figure out how many rows to show\n          let rows = this.richlistbox.children;\n          let numRows = Math.min(this.matchCount, this.maxRows, rows.length);\n\n          // Default the height to 0 if we have no rows to show\n          let height = 0;\n          if (numRows) {\n            let firstRowRect = rows[0].getBoundingClientRect();\n            if (this._rlbPadding == undefined) {\n              let style = window.getComputedStyle(this.richlistbox);\n              let paddingTop = parseInt(style.paddingTop) || 0;\n              let paddingBottom = parseInt(style.paddingBottom) || 0;\n              this._rlbPadding = paddingTop + paddingBottom;\n            }\n\n            // The class `forceHandleUnderflow` is for the item might need to\n            // handle OverUnderflow or Overflow when the height of an item will\n            // be changed dynamically.\n            for (let i = 0; i < numRows; i++) {\n              if (rows[i].classList.contains(\"forceHandleUnderflow\")) {\n                rows[i].handleOverUnderflow();\n              }\n            }\n\n            let lastRowRect = rows[numRows - 1].getBoundingClientRect();\n            // Calculate the height to have the first row to last row shown\n            height = lastRowRect.bottom - firstRowRect.top +\n                     this._rlbPadding;\n          }\n\n          let currentHeight = this.richlistbox.getBoundingClientRect().height;\n          if (height <= currentHeight) {\n            this._collapseUnusedItems();\n          }\n          this.richlistbox.style.removeProperty(\"height\");\n          // We need to get the ceiling of the calculated value to ensure that the box fully contains\n          // all of its contents and doesn't cause a scrollbar since nsIBoxObject only expects a\n          // `long`. e.g. if `height` is 99.5 the richlistbox would render at height 99px with a\n          // scrollbar for the extra 0.5px.\n          this.richlistbox.height = Math.ceil(height);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_appendCurrentResult\">\n        <parameter name=\"invalidateReason\"/>\n        <body>\n          <![CDATA[\n          var controller = this.mInput.controller;\n          var matchCount = this.matchCount;\n          var existingItemsCount = this.richlistbox.children.length;\n\n          // Process maxRows per chunk to improve performance and user experience\n          for (let i = 0; i < this.maxRows; i++) {\n            if (this._currentIndex >= matchCount) {\n              break;\n            }\n            let item;\n            let itemExists = this._currentIndex < existingItemsCount;\n\n            let originalValue, originalText, originalType;\n            let style = controller.getStyleAt(this._currentIndex);\n            let value =\n              style && style.includes(\"autofill\") ?\n              controller.getFinalCompleteValueAt(this._currentIndex) :\n              controller.getValueAt(this._currentIndex);\n            let label = controller.getLabelAt(this._currentIndex);\n            let comment = controller.getCommentAt(this._currentIndex);\n            let image = controller.getImageAt(this._currentIndex);\n            // trim the leading/trailing whitespace\n            let trimmedSearchString = controller.searchString.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n\n            let reusable = false;\n            if (itemExists) {\n              item = this.richlistbox.children[this._currentIndex];\n\n              // Url may be a modified version of value, see _adjustAcItem().\n              originalValue = item.getAttribute(\"url\") || item.getAttribute(\"ac-value\");\n              originalText = item.getAttribute(\"ac-text\");\n              originalType = item.getAttribute(\"originaltype\");\n\n              // The styles on the list which have different <content> structure and overrided\n              // _adjustAcItem() are unreusable.\n              const UNREUSEABLE_STYLES = [\n                \"autofill-profile\",\n                \"autofill-footer\",\n                \"autofill-clear-button\",\n                \"autofill-insecureWarning\",\n                \"generatedPassword\",\n                \"insecureWarning\",\n                \"loginsFooter\",\n                \"loginWithOrigin\",\n              ];\n              // Reuse the item when its style is exactly equal to the previous style or\n              // neither of their style are in the UNREUSEABLE_STYLES.\n              reusable = originalType === style ||\n                !(UNREUSEABLE_STYLES.includes(style) || UNREUSEABLE_STYLES.includes(originalType));\n            }\n\n            // If no reusable item available, then create a new item.\n            if (!reusable) {\n              let options = null;\n              switch (style) {\n                case \"autofill-profile\":\n                  options = { is: \"autocomplete-profile-listitem\" };\n                  break;\n                case \"autofill-footer\":\n                  options = { is: \"autocomplete-profile-listitem-footer\" };\n                  break;\n                case \"autofill-clear-button\":\n                  options = { is: \"autocomplete-profile-listitem-clear-button\" };\n                  break;\n                case \"autofill-insecureWarning\":\n                  options = { is: \"autocomplete-creditcard-insecure-field\" };\n                  break;\n                case \"generatedPassword\":\n                  options = { is: \"autocomplete-two-line-richlistitem\" };\n                  break;\n                case \"insecureWarning\":\n                  options = { is: \"autocomplete-richlistitem-insecure-warning\" };\n                  break;\n                case \"loginsFooter\":\n                  options = { is: \"autocomplete-richlistitem-logins-footer\" };\n                  break;\n                case \"loginWithOrigin\":\n                  options = { is: \"autocomplete-login-richlistitem\" };\n                  break;\n                default:\n                  options = { is: \"autocomplete-richlistitem\" };\n              }\n              item = document.createXULElement(\"richlistitem\", options);\n              item.className = \"autocomplete-richlistitem\";\n            }\n\n            item.setAttribute(\"dir\", this.style.direction);\n            item.setAttribute(\"ac-image\", image);\n            item.setAttribute(\"ac-value\", value);\n            item.setAttribute(\"ac-label\", label);\n            item.setAttribute(\"ac-comment\", comment);\n            item.setAttribute(\"ac-text\", trimmedSearchString);\n\n            // Completely reuse the existing richlistitem for invalidation\n            // due to new results, but only when: the item is the same, *OR*\n            // we are about to replace the currently moused-over item, to\n            // avoid surprising the user.\n            let iface = Ci.nsIAutoCompletePopup;\n            if (reusable &&\n                originalText == trimmedSearchString &&\n                invalidateReason == iface.INVALIDATE_REASON_NEW_RESULT &&\n                (originalValue == value ||\n                 this.mousedOverIndex === this._currentIndex)) {\n              // try to re-use the existing item\n              let reused = item._reuseAcItem();\n              if (reused) {\n                this._currentIndex++;\n                continue;\n              }\n            } else {\n              if (typeof item._cleanup == \"function\") {\n                item._cleanup();\n              }\n              item.setAttribute(\"originaltype\", style);\n            }\n\n            if (reusable) {\n              // Adjust only when the result's type is reusable for existing\n              // item's. Otherwise, we might insensibly call old _adjustAcItem()\n              // as new binding has not been attached yet.\n              // We don't need to worry about switching to new binding, since\n              // _adjustAcItem() will fired by its own constructor accordingly.\n              item._adjustAcItem();\n              item.collapsed = false;\n            } else if (itemExists) {\n              let oldItem = this.richlistbox.children[this._currentIndex];\n              this.richlistbox.replaceChild(item, oldItem);\n            } else {\n              this.richlistbox.appendChild(item);\n            }\n\n            this._currentIndex++;\n          }\n\n          if (typeof this.onResultsAdded == \"function\") {\n            // The items bindings may not be attached yet, so we must delay this\n            // before we can properly handle items properly without breaking\n            // the richlistbox.\n            Services.tm.dispatchToMainThread(() => this.onResultsAdded());\n          }\n\n          if (this._currentIndex < matchCount) {\n            // yield after each batch of items so that typing the url bar is\n            // responsive\n            this._appendResultTimeout = setTimeout(() => this._appendCurrentResult(), 0);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"overflowPadding\"\n                onget=\"return Number(this.getAttribute('overflowpadding'))\"\n                readonly=\"true\" />\n\n      <method name=\"selectBy\">\n        <parameter name=\"aReverse\"/>\n        <parameter name=\"aPage\"/>\n        <body>\n          <![CDATA[\n          try {\n            var amount = aPage ? 5 : 1;\n\n            // because we collapsed unused items, we can't use this.richlistbox.getRowCount(), we need to use the matchCount\n            this.selectedIndex = this.getNextIndex(aReverse, amount, this.selectedIndex, this.matchCount - 1);\n            if (this.selectedIndex == -1) {\n              this.input._focus();\n            }\n          } catch (ex) {\n            // do nothing - occasionally timer-related js errors happen here\n            // e.g. \"this.selectedIndex has no properties\", when you type fast and hit a\n            // navigation key before this popup has opened\n          }\n            ]]>\n        </body>\n      </method>\n\n      <field name=\"richlistbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"richlistbox\");\n      </field>\n\n      <property name=\"view\"\n                onget=\"return this.mInput.controller;\"\n                onset=\"return val;\"/>\n\n    </implementation>\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // If normalMaxRows wasn't already set by the input, then set it here\n        // so that we restore the correct number when the popup is hidden.\n\n        // Null-check this.mInput; see bug 1017914\n        if (this._normalMaxRows < 0 && this.mInput) {\n          this._normalMaxRows = this.mInput.maxRows;\n        }\n\n        // Set an attribute for styling the popup based on the input.\n        let inputID = \"\";\n        if (this.mInput && this.mInput.ownerDocument &&\n            this.mInput.ownerDocument.documentURIObject.schemeIs(\"chrome\")) {\n          inputID = this.mInput.id;\n          // Take care of elements with no id that are inside xbl bindings\n          if (!inputID) {\n            let bindingParent = this.mInput.ownerDocument.getBindingParent(this.mInput);\n            if (bindingParent) {\n              inputID = bindingParent.id;\n            }\n          }\n        }\n        this.setAttribute(\"autocompleteinput\", inputID);\n\n        this.mPopupOpen = true;\n      ]]></handler>\n\n      <handler event=\"popupshown\">\n        <![CDATA[\n          if (this._adjustHeightOnPopupShown) {\n            delete this._adjustHeightOnPopupShown;\n            this.adjustHeight();\n          }\n      ]]>\n      </handler>\n\n      <handler event=\"popuphiding\"><![CDATA[\n        var isListActive = true;\n        if (this.selectedIndex == -1)\n          isListActive = false;\n        this.input.controller.stopSearch();\n\n        this.removeAttribute(\"autocompleteinput\");\n        this.mPopupOpen = false;\n\n        // Reset the maxRows property to the cached \"normal\" value (if there's\n        // any), and reset normalMaxRows so that we can detect whether it was set\n        // by the input when the popupshowing handler runs.\n\n        // Null-check this.mInput; see bug 1017914\n        if (this.mInput && this._normalMaxRows > 0) {\n          this.mInput.maxRows = this._normalMaxRows;\n        }\n        this._normalMaxRows = -1;\n        // If the list was being navigated and then closed, make sure\n        // we fire accessible focus event back to textbox\n\n        // Null-check this.mInput; see bug 1017914\n        if (isListActive && this.mInput) {\n          this.mInput.mIgnoreFocus = true;\n          this.mInput._focus();\n          this.mInput.mIgnoreFocus = false;\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"general.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"generalBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"basecontrol\">\n    <implementation implements=\"nsIDOMXULControlElement\">\n      <!-- public implementation -->\n      <property name=\"disabled\" onset=\"if (val) this.setAttribute('disabled', 'true');\n                                       else this.removeAttribute('disabled');\n                                       return val;\"\n                                onget=\"return this.getAttribute('disabled') == 'true';\"/>\n      <property name=\"tabIndex\" onget=\"return parseInt(this.getAttribute('tabindex')) || 0\"\n                                onset=\"if (val) this.setAttribute('tabindex', val);\n                                       else this.removeAttribute('tabindex'); return val;\"/>\n    </implementation>\n  </binding>\n\n  <binding id=\"basetext\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <implementation>\n      <!-- public implementation -->\n      <property name=\"label\"      onset=\"this.setAttribute('label',val); return val;\"\n                                  onget=\"return this.getAttribute('label');\"/>\n      <property name=\"crop\"       onset=\"this.setAttribute('crop',val); return val;\"\n                                  onget=\"return this.getAttribute('crop');\"/>\n      <property name=\"image\"      onset=\"this.setAttribute('image',val); return val;\"\n                                  onget=\"return this.getAttribute('image');\"/>\n      <property name=\"command\"    onset=\"this.setAttribute('command',val); return val;\"\n                                  onget=\"return this.getAttribute('command');\"/>\n      <property name=\"accessKey\">\n        <getter>\n          <![CDATA[\n            return this.getAttribute(\"accesskey\");\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            // Always store on the control\n            this.setAttribute(\"accesskey\", val);\n            // If there is a label, change the accesskey on the labelElement\n            // if it's also set there\n            let labelElement = document.getElementsByAttribute(\"control\", this.id)[0];\n            if (labelElement) {\n              labelElement.setAttribute(\"accesskey\", val);\n            }\n            return val;\n          ]]>\n        </setter>\n      </property>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"popup.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"popupBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"popup\">\n    <content>\n      <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                          smoothscroll=\"false\">\n        <children/>\n      </xul:arrowscrollbox>\n    </content>\n\n    <implementation>\n      <field name=\"scrollBox\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"class\", \"popup-internal-box\");\n      </field>\n\n      <field name=\"AUTOSCROLL_INTERVAL\">25</field>\n      <field name=\"NOT_DRAGGING\">0</field>\n      <field name=\"DRAG_OVER_BUTTON\">-1</field>\n      <field name=\"DRAG_OVER_POPUP\">1</field>\n\n      <field name=\"_draggingState\">this.NOT_DRAGGING</field>\n      <field name=\"_scrollTimer\">0</field>\n\n      <method name=\"_enableDragScrolling\">\n        <!-- when overItem is true, drag started over menuitem; when false, drag\n             started while the popup was opening.\n          -->\n        <parameter name=\"overItem\"/>\n        <body>\n        <![CDATA[\n          if (!this._draggingState) {\n            this.setCaptureAlways();\n            this._draggingState = overItem ? this.DRAG_OVER_POPUP : this.DRAG_OVER_BUTTON;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_clearScrollTimer\">\n        <body>\n        <![CDATA[\n          if (this._scrollTimer) {\n            this.ownerGlobal.clearInterval(this._scrollTimer);\n            this._scrollTimer = 0;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <constructor><![CDATA[\n        // Enable the drag-to-scroll events only in menulist popups.\n        if (!this.parentNode || this.parentNode.localName != \"menulist\") {\n          return;\n        }\n\n        // XBL bindings might be constructed more than once.\n        if (this.eventListenersAdded) {\n          return;\n        }\n        this.eventListenersAdded = true;\n\n        this.addEventListener(\"popupshown\", () => {\n          // Enable drag scrolling even when the mouse wasn't used. The\n          // mousemove handler will remove it if the mouse isn't down.\n          this._enableDragScrolling(false);\n        });\n\n        this.addEventListener(\"popuphidden\", () => {\n          this._draggingState = this.NOT_DRAGGING;\n          this._clearScrollTimer();\n          this.releaseCapture();\n        });\n\n        this.addEventListener(\"mousedown\", event => {\n          if (event.button != 0) {\n            return;\n          }\n\n          if (this.state == \"open\" &&\n            (event.target.localName == \"menuitem\" ||\n              event.target.localName == \"menu\" ||\n              event.target.localName == \"menucaption\")) {\n            this._enableDragScrolling(true);\n          }\n        });\n\n        this.addEventListener(\"mouseup\", event => {\n          if (event.button != 0) {\n            return;\n          }\n\n          this._draggingState = this.NOT_DRAGGING;\n          this._clearScrollTimer();\n        });\n\n        this.addEventListener(\"mousemove\", event => {\n          if (!this._draggingState) {\n            return;\n          }\n\n          this._clearScrollTimer();\n\n          // If the user released the mouse before the popup opens, we will\n          // still be capturing, so check that the button is still pressed. If\n          // not, release the capture and do nothing else. This also handles if\n          // the dropdown was opened via the keyboard.\n          if (!(event.buttons & 1)) {\n            this._draggingState = this.NOT_DRAGGING;\n            this.releaseCapture();\n            return;\n          }\n\n          // If dragging outside the top or bottom edge of the popup, but within\n          // the popup area horizontally, scroll the list in that direction. The\n          // _draggingState flag is used to ensure that scrolling does not start\n          // until the mouse has moved over the popup first, preventing\n          // scrolling while over the dropdown button.\n          let popupRect = this.getOuterScreenRect();\n          if (event.screenX >= popupRect.left &&\n              event.screenX <= popupRect.right) {\n            if (this._draggingState == this.DRAG_OVER_BUTTON) {\n              if (event.screenY > popupRect.top &&\n                  event.screenY < popupRect.bottom) {\n                this._draggingState = this.DRAG_OVER_POPUP;\n              }\n            }\n\n            if (this._draggingState == this.DRAG_OVER_POPUP &&\n                (event.screenY <= popupRect.top ||\n                 event.screenY >= popupRect.bottom)) {\n              let scrollAmount = event.screenY <= popupRect.top ? -1 : 1;\n              this.scrollBox.scrollByIndex(scrollAmount, true);\n\n              let win = this.ownerGlobal;\n              this._scrollTimer = win.setInterval(() => {\n                this.scrollBox.scrollByIndex(scrollAmount, true);\n              }, this.AUTOSCROLL_INTERVAL);\n            }\n          }\n        });\n      ]]></constructor>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\">\n        <![CDATA[\n          var array = [];\n          var width = 0;\n          for (var menuitem = this.firstElementChild; menuitem; menuitem = menuitem.nextElementSibling) {\n            if (menuitem.localName == \"menuitem\" && menuitem.hasAttribute(\"acceltext\")) {\n              var accel = menuitem.menuAccel;\n              if (accel) {\n                array.push(accel);\n                let accelWidth = accel.getBoundingClientRect().width;\n                if (accelWidth > width) {\n                  width = accelWidth;\n                }\n              }\n            }\n          }\n          for (var i = 0; i < array.length; i++)\n            array[i].width = width;\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"panel\">\n    <implementation>\n      <field name=\"_prevFocus\">0</field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // Capture the previous focus before has a chance to get set inside the panel\n        try {\n          this._prevFocus = Cu\n                            .getWeakReference(document.commandDispatcher.focusedElement);\n          if (this._prevFocus.get())\n            return;\n        } catch (ex) { }\n\n        this._prevFocus = Cu.getWeakReference(document.activeElement);\n      ]]></handler>\n      <handler event=\"popupshown\"><![CDATA[\n        // Fire event for accessibility APIs\n        var alertEvent = document.createEvent(\"Events\");\n        alertEvent.initEvent(\"AlertActive\", true, true);\n        this.dispatchEvent(alertEvent);\n       ]]></handler>\n      <handler event=\"popuphiding\"><![CDATA[\n        try {\n          this._currentFocus = document.commandDispatcher.focusedElement;\n        } catch (e) {\n          this._currentFocus = document.activeElement;\n        }\n      ]]></handler>\n      <handler event=\"popuphidden\"><![CDATA[\n        function doFocus() {\n          // Focus was set on an element inside this panel,\n          // so we need to move it back to where it was previously\n          try {\n            let fm = Cc[\"@mozilla.org/focus-manager;1\"]\n                       .getService(Ci.nsIFocusManager);\n            fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);\n          } catch (e) {\n            prevFocus.focus();\n          }\n        }\n        var currentFocus = this._currentFocus;\n        var prevFocus = this._prevFocus ? this._prevFocus.get() : null;\n        this._currentFocus = null;\n        this._prevFocus = null;\n\n        // Avoid changing focus if focus changed while we hide the popup\n        // (This can happen e.g. if the popup is hiding as a result of a\n        // click/keypress that focused something)\n        let nowFocus;\n        try {\n          nowFocus = document.commandDispatcher.focusedElement;\n        } catch (e) {\n          nowFocus = document.activeElement;\n        }\n        if (nowFocus && nowFocus != currentFocus)\n          return;\n\n        if (prevFocus && this.getAttribute(\"norestorefocus\") != \"true\") {\n          // Try to restore focus\n          try {\n            if (document.commandDispatcher.focusedWindow != window)\n              return; // Focus has already been set to a window outside of this panel\n          } catch (ex) {}\n\n          if (!currentFocus) {\n            doFocus();\n            return;\n          }\n          while (currentFocus) {\n            if (currentFocus == this) {\n              doFocus();\n              return;\n            }\n            currentFocus = currentFocus.parentNode;\n          }\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"arrowpanel\" extends=\"chrome://global/content/bindings/popup.xml#panel\">\n    <content flip=\"both\" side=\"top\" position=\"bottomcenter topleft\" consumeoutsideclicks=\"false\">\n      <xul:vbox anonid=\"container\" class=\"panel-arrowcontainer\" flex=\"1\"\n               xbl:inherits=\"side,panelopen\">\n        <xul:box anonid=\"arrowbox\" class=\"panel-arrowbox\">\n          <xul:image anonid=\"arrow\" class=\"panel-arrow\" xbl:inherits=\"side\"/>\n        </xul:box>\n        <xul:box class=\"panel-arrowcontent\" xbl:inherits=\"side,align,dir,orient,pack\" flex=\"1\">\n          <children/>\n        </xul:box>\n      </xul:vbox>\n    </content>\n    <implementation>\n      <field name=\"_fadeTimer\">null</field>\n      <method name=\"adjustArrowPosition\">\n        <body>\n        <![CDATA[\n        var anchor = this.anchorNode;\n        if (!anchor) {\n          return;\n        }\n\n        var container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n        var arrowbox = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\");\n\n        var position = this.alignmentPosition;\n        var offset = this.alignmentOffset;\n\n        this.setAttribute(\"arrowposition\", position);\n\n        if (position.indexOf(\"start_\") == 0 || position.indexOf(\"end_\") == 0) {\n          container.orient = \"horizontal\";\n          arrowbox.orient = \"vertical\";\n          if (position.indexOf(\"_after\") > 0) {\n            arrowbox.pack = \"end\";\n          } else {\n            arrowbox.pack = \"start\";\n          }\n          arrowbox.style.transform = \"translate(0, \" + -offset + \"px)\";\n\n          // The assigned side stays the same regardless of direction.\n          var isRTL = (window.getComputedStyle(this).direction == \"rtl\");\n\n          if (position.indexOf(\"start_\") == 0) {\n            container.dir = \"reverse\";\n            this.setAttribute(\"side\", isRTL ? \"left\" : \"right\");\n          } else {\n            container.dir = \"\";\n            this.setAttribute(\"side\", isRTL ? \"right\" : \"left\");\n          }\n        } else if (position.indexOf(\"before_\") == 0 || position.indexOf(\"after_\") == 0) {\n          container.orient = \"\";\n          arrowbox.orient = \"\";\n          if (position.indexOf(\"_end\") > 0) {\n            arrowbox.pack = \"end\";\n          } else {\n            arrowbox.pack = \"start\";\n          }\n          arrowbox.style.transform = \"translate(\" + -offset + \"px, 0)\";\n\n          if (position.indexOf(\"before_\") == 0) {\n            container.dir = \"reverse\";\n            this.setAttribute(\"side\", \"bottom\");\n          } else {\n            container.dir = \"\";\n            this.setAttribute(\"side\", \"top\");\n          }\n        }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\">\n      <![CDATA[\n        var arrow = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrow\");\n        arrow.hidden = this.anchorNode == null;\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\")\n                .style.removeProperty(\"transform\");\n\n        if (this.getAttribute(\"animate\") != \"false\") {\n          this.setAttribute(\"animate\", \"open\");\n          // the animating attribute prevents user interaction during transition\n          // it is removed when popupshown fires\n          this.setAttribute(\"animating\", \"true\");\n        }\n\n        // set fading\n        var fade = this.getAttribute(\"fade\");\n        var fadeDelay = 0;\n        if (fade == \"fast\") {\n          fadeDelay = 1;\n        } else if (fade == \"slow\") {\n          fadeDelay = 4000;\n        } else {\n          return;\n        }\n\n        this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);\n      ]]>\n      </handler>\n      <handler event=\"popuphiding\" phase=\"target\">\n        let animate = (this.getAttribute(\"animate\") != \"false\");\n\n        if (this._fadeTimer) {\n          clearTimeout(this._fadeTimer);\n          if (animate) {\n            this.setAttribute(\"animate\", \"fade\");\n          }\n        } else if (animate) {\n          this.setAttribute(\"animate\", \"cancel\");\n        }\n      </handler>\n      <handler event=\"popupshown\" phase=\"target\">\n        this.removeAttribute(\"animating\");\n        this.setAttribute(\"panelopen\", \"true\");\n      </handler>\n      <handler event=\"popuphidden\" phase=\"target\">\n        this.removeAttribute(\"panelopen\");\n        if (this.getAttribute(\"animate\") != \"false\") {\n          this.removeAttribute(\"animate\");\n        }\n      </handler>\n      <handler event=\"popuppositioned\" phase=\"target\">\n        this.adjustArrowPosition();\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"richlistbox.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This file relies on these specific Chrome/XBL globals -->\n<!-- globals ChromeNodeList -->\n\n<bindings id=\"richlistboxBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"richlistitem\"\n           extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <field name=\"selectedByMouseOver\">false</field>\n\n      <destructor>\n        <![CDATA[\n          var control = this.control;\n          if (!control)\n            return;\n          // When we are destructed and we are current or selected, unselect ourselves\n          // so that richlistbox's selection doesn't point to something not in the DOM.\n          // We don't want to reset last-selected, so we set _suppressOnSelect.\n          if (this.selected) {\n            var suppressSelect = control._suppressOnSelect;\n            control._suppressOnSelect = true;\n            control.removeItemFromSelection(this);\n            control._suppressOnSelect = suppressSelect;\n          }\n          if (this.current)\n            control.currentItem = null;\n        ]]>\n      </destructor>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"label\" readonly=\"true\">\n        <!-- Setter purposely not implemented; the getter returns a\n             concatentation of label text to expose via accessibility APIs -->\n        <getter>\n          <![CDATA[\n            const XULNS =\n              \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n            return Array.from(this.getElementsByTagNameNS(XULNS, \"label\"),\n                             label => label.value)\n                        .join(\" \");\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"searchLabel\">\n        <getter>\n          <![CDATA[\n            return this.hasAttribute(\"searchlabel\") ?\n                   this.getAttribute(\"searchlabel\") : this.label;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            if (val !== null)\n              this.setAttribute(\"searchlabel\", val);\n            else\n              // fall back to the label property (default value)\n              this.removeAttribute(\"searchlabel\");\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"value\" onget=\"return this.getAttribute('value');\"\n                             onset=\"this.setAttribute('value', val); return val;\"/>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"selected\" onget=\"return this.getAttribute('selected') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.setAttribute(\"selected\", \"true\");\n          else\n            this.removeAttribute(\"selected\");\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"control\">\n        <getter><![CDATA[\n          var parent = this.parentNode;\n          while (parent) {\n            if (parent.localName == \"richlistbox\")\n              return parent;\n            parent = parent.parentNode;\n          }\n          return null;\n        ]]></getter>\n      </property>\n\n      <property name=\"current\" onget=\"return this.getAttribute('current') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.setAttribute(\"current\", \"true\");\n          else\n            this.removeAttribute(\"current\");\n          return val;\n        ]]></setter>\n      </property>\n    </implementation>\n\n    <handlers>\n      <!-- If there is no modifier key, we select on mousedown, not\n           click, so that drags work correctly. -->\n      <handler event=\"mousedown\">\n        <![CDATA[\n          var control = this.control;\n          if (!control || control.disabled)\n            return;\n          if ((!event.ctrlKey || (/Mac/.test(navigator.platform) && event.button == 2)) &&\n              !event.shiftKey && !event.metaKey) {\n            if (!this.selected) {\n              control.selectItem(this);\n            }\n            control.currentItem = this;\n          }\n        ]]>\n      </handler>\n\n      <!-- On a click (up+down on the same item), deselect everything\n           except this item. -->\n      <handler event=\"click\" button=\"0\">\n        <![CDATA[\n          var control = this.control;\n          if (!control || control.disabled)\n            return;\n          control._userSelecting = true;\n          if (control.selType != \"multiple\") {\n            control.selectItem(this);\n          } else if (event.ctrlKey || event.metaKey) {\n            control.toggleItemSelection(this);\n            control.currentItem = this;\n          } else if (event.shiftKey) {\n            control.selectItemRange(null, this);\n            control.currentItem = this;\n          } else {\n            /* We want to deselect all the selected items except what was\n              clicked, UNLESS it was a right-click.  We have to do this\n              in click rather than mousedown so that you can drag a\n              selected group of items */\n\n            // use selectItemRange instead of selectItem, because this\n            // doesn't de- and reselect this item if it is selected\n            control.selectItemRange(this, this);\n          }\n          control._userSelecting = false;\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"scrollbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"arrowscrollboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"arrowscrollbox\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <content>\n      <xul:toolbarbutton class=\"scrollbutton-up\"\n                         anonid=\"scrollbutton-up\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtostart\"\n                         onclick=\"_onButtonClick(event);\"\n                         onmousedown=\"_onButtonMouseDown(event, -1);\"\n                         onmouseup=\"_onButtonMouseUp(event);\"\n                         onmouseover=\"_onButtonMouseOver(-1);\"\n                         onmouseout=\"_onButtonMouseOut();\"/>\n      <xul:spacer class=\"arrowscrollbox-overflow-start-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtostart\"/>\n      <xul:scrollbox class=\"arrowscrollbox-scrollbox\"\n                     anonid=\"scrollbox\"\n                     flex=\"1\"\n                     xbl:inherits=\"orient,align,pack,dir,smoothscroll\">\n        <children/>\n      </xul:scrollbox>\n      <xul:spacer class=\"arrowscrollbox-overflow-end-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtoend\"/>\n      <xul:toolbarbutton class=\"scrollbutton-down\"\n                         anonid=\"scrollbutton-down\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtoend\"\n                         onclick=\"_onButtonClick(event);\"\n                         onmousedown=\"_onButtonMouseDown(event, 1);\"\n                         onmouseup=\"_onButtonMouseUp(event);\"\n                         onmouseover=\"_onButtonMouseOver(1);\"\n                         onmouseout=\"_onButtonMouseOut();\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (!this.hasAttribute(\"smoothscroll\")) {\n          this.smoothScroll = this._prefBranch\n                                  .getBoolPref(\"toolkit.scrollbox.smoothScroll\", true);\n        }\n\n        this.setAttribute(\"notoverflowing\", \"true\");\n        this._updateScrollButtonsDisabledState();\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // Release timer to avoid reference cycles.\n        if (this._scrollTimer) {\n          this._scrollTimer.cancel();\n          this._scrollTimer = null;\n        }\n      ]]></destructor>\n\n      <field name=\"scrollbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbox\");\n      </field>\n      <field name=\"_scrollButtonUp\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbutton-up\");\n      </field>\n      <field name=\"_scrollButtonDown\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbutton-down\");\n      </field>\n\n      <field name=\"_scrollIndex\">0</field>\n\n      <field name=\"_arrowScrollAnim\"><![CDATA[({\n        scrollbox: this,\n        requestHandle: 0, /* 0 indicates there is no pending request */\n        start: function arrowSmoothScroll_start() {\n          this.lastFrameTime = window.performance.now();\n          if (!this.requestHandle)\n            this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));\n        },\n        stop: function arrowSmoothScroll_stop() {\n          window.cancelAnimationFrame(this.requestHandle);\n          this.requestHandle = 0;\n        },\n        sample: function arrowSmoothScroll_handleEvent(timeStamp) {\n          const scrollIndex = this.scrollbox._scrollIndex;\n          const timePassed = timeStamp - this.lastFrameTime;\n          this.lastFrameTime = timeStamp;\n\n          const scrollDelta = 0.5 * timePassed * scrollIndex;\n          this.scrollbox.scrollByPixels(scrollDelta, true);\n          this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));\n        },\n      })]]></field>\n\n      <property name=\"_clickToScroll\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.hasAttribute(\"clicktoscroll\");\n        ]]></getter>\n      </property>\n\n      <property name=\"_scrollDelay\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._clickToScroll) {\n            return this._prefBranch.getIntPref(\n                            \"toolkit.scrollbox.clickToScroll.scrollDelay\", 150);\n          }\n\n          // Use the same REPEAT_DELAY as \"nsRepeatService.h\".\n          return /Mac/.test(navigator.platform) ? 25 : 50;\n        ]]></getter>\n      </property>\n\n      <field name=\"__prefBranch\">null</field>\n      <property name=\"_prefBranch\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.__prefBranch === null) {\n            this.__prefBranch = Cc[\"@mozilla.org/preferences-service;1\"]\n                                  .getService(Ci.nsIPrefBranch);\n          }\n          return this.__prefBranch;\n        ]]></getter>\n      </property>\n\n      <field name=\"_scrollIncrement\">null</field>\n      <property name=\"scrollIncrement\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._scrollIncrement === null) {\n            this._scrollIncrement = this._prefBranch\n                                        .getIntPref(\"toolkit.scrollbox.scrollIncrement\", 20);\n          }\n          return this._scrollIncrement;\n        ]]></getter>\n      </property>\n\n      <property name=\"smoothScroll\">\n        <getter><![CDATA[\n          return this.getAttribute(\"smoothscroll\") == \"true\";\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"smoothscroll\", !!val);\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"scrollClientRect\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.scrollbox.getBoundingClientRect();\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollClientSize\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this.scrollbox.clientHeight :\n                 this.scrollbox.clientWidth;\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollSize\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this.scrollbox.scrollHeight :\n                 this.scrollbox.scrollWidth;\n        ]]></getter>\n      </property>\n\n      <property name=\"lineScrollAmount\" readonly=\"true\">\n        <getter><![CDATA[\n          // line scroll amout should be the width (at horizontal scrollbox) or\n          // the height (at vertical scrollbox) of the scrolled elements.\n          // However, the elements may have different width or height.  So,\n          // for consistent speed, let's use avalage with of the elements.\n          var elements = this._getScrollableElements();\n          return elements.length && (this.scrollSize / elements.length);\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollPosition\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this.scrollbox.scrollTop :\n                 this.scrollbox.scrollLeft;\n        ]]></getter>\n      </property>\n\n      <field name=\"_startEndProps\"><![CDATA[\n        this.orient == \"vertical\" ? [\"top\", \"bottom\"] : [\"left\", \"right\"];\n      ]]></field>\n\n      <field name=\"_isRTLScrollbox\"><![CDATA[\n        this.orient != \"vertical\" &&\n        document.defaultView.getComputedStyle(this.scrollbox).direction == \"rtl\";\n      ]]></field>\n\n      <method name=\"_onButtonClick\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (this._clickToScroll) {\n            this._distanceScroll(event);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseDown\">\n        <parameter name=\"event\"/>\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._clickToScroll && event.button == 0) {\n            this._startScroll(index);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseUp\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (this._clickToScroll && event.button == 0) {\n            this._stopScroll();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseOver\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._clickToScroll) {\n            this._continueScroll(index);\n          } else {\n            this._startScroll(index);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseOut\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._clickToScroll) {\n            this._pauseScroll();\n          } else {\n            this._stopScroll();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_boundsWithoutFlushing\">\n        <parameter name=\"element\"/>\n        <body><![CDATA[\n          if (!(\"_DOMWindowUtils\" in this)) {\n            this._DOMWindowUtils = window.windowUtils;\n          }\n\n          return this._DOMWindowUtils ?\n                 this._DOMWindowUtils.getBoundsWithoutFlushing(element) :\n                 element.getBoundingClientRect();\n        ]]></body>\n      </method>\n\n      <method name=\"_canScrollToElement\">\n        <parameter name=\"element\"/>\n        <body><![CDATA[\n          if (element.hidden) {\n            return false;\n          }\n\n          // See if the element is hidden via CSS without the hidden attribute.\n          // If we get only zeros for the client rect, this means the element\n          // is hidden. As a performance optimization, we don't flush layout\n          // here which means that on the fly changes aren't fully supported.\n          let rect = this._boundsWithoutFlushing(element);\n          return !!(rect.top || rect.left || rect.width || rect.height);\n        ]]></body>\n      </method>\n\n      <field name=\"_ensureElementIsVisibleAnimationFrame\">0</field>\n      <method name=\"ensureElementIsVisible\">\n        <parameter name=\"element\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (!this._canScrollToElement(element))\n            return;\n\n          if (this._ensureElementIsVisibleAnimationFrame) {\n            window.cancelAnimationFrame(this._ensureElementIsVisibleAnimationFrame);\n          }\n          this._ensureElementIsVisibleAnimationFrame = window.requestAnimationFrame(() => {\n            element.scrollIntoView({ block: \"nearest\",\n                                     behavior: aInstant ? \"instant\" : \"auto\" });\n            this._ensureElementIsVisibleAnimationFrame = 0;\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"scrollByIndex\">\n        <parameter name=\"index\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (index == 0)\n            return;\n\n          var rect = this.scrollClientRect;\n          var [start, end] = this._startEndProps;\n          var x = index > 0 ? rect[end] + 1 : rect[start] - 1;\n          var nextElement = this._elementFromPoint(x, index);\n          if (!nextElement)\n            return;\n\n          var targetElement;\n          if (this._isRTLScrollbox)\n            index *= -1;\n          while (index < 0 && nextElement) {\n            if (this._canScrollToElement(nextElement))\n              targetElement = nextElement;\n            nextElement = nextElement.previousElementSibling;\n            index++;\n          }\n          while (index > 0 && nextElement) {\n            if (this._canScrollToElement(nextElement))\n              targetElement = nextElement;\n            nextElement = nextElement.nextElementSibling;\n            index--;\n          }\n          if (!targetElement)\n            return;\n\n          this.ensureElementIsVisible(targetElement, aInstant);\n        ]]></body>\n      </method>\n\n      <method name=\"_getScrollableElements\">\n        <body><![CDATA[\n          var nodes = this.children;\n          if (nodes.length == 1 &&\n              nodes[0].localName == \"children\" &&\n              nodes[0].namespaceURI == \"http://www.mozilla.org/xbl\") {\n            nodes = document.getBindingParent(this).children;\n          }\n\n          return Array.prototype.filter.call(nodes, this._canScrollToElement, this);\n        ]]></body>\n      </method>\n\n      <method name=\"_elementFromPoint\">\n        <parameter name=\"aX\"/>\n        <parameter name=\"aPhysicalScrollDir\"/>\n        <body><![CDATA[\n          var elements = this._getScrollableElements();\n          if (!elements.length)\n            return null;\n\n          if (this._isRTLScrollbox)\n            elements.reverse();\n\n          var [start, end] = this._startEndProps;\n          var low = 0;\n          var high = elements.length - 1;\n\n          if (aX < elements[low].getBoundingClientRect()[start] ||\n              aX > elements[high].getBoundingClientRect()[end])\n            return null;\n\n          var mid, rect;\n          while (low <= high) {\n            mid = Math.floor((low + high) / 2);\n            rect = elements[mid].getBoundingClientRect();\n            if (rect[start] > aX)\n              high = mid - 1;\n            else if (rect[end] < aX)\n              low = mid + 1;\n            else\n              return elements[mid];\n          }\n\n          // There's no element at the requested coordinate, but the algorithm\n          // from above yields an element next to it, in a random direction.\n          // The desired scrolling direction leads to the correct element.\n\n          if (!aPhysicalScrollDir)\n            return null;\n\n          if (aPhysicalScrollDir < 0 && rect[start] > aX)\n            mid = Math.max(mid - 1, 0);\n          else if (aPhysicalScrollDir > 0 && rect[end] < aX)\n            mid = Math.min(mid + 1, elements.length - 1);\n\n          return elements[mid];\n        ]]></body>\n      </method>\n\n      <method name=\"_startScroll\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._isRTLScrollbox) {\n            index *= -1;\n          }\n\n          if (this._clickToScroll) {\n            this._scrollIndex = index;\n            this._mousedown = true;\n\n            if (this.smoothScroll) {\n              this._arrowScrollAnim.start();\n              return;\n            }\n          }\n\n          if (!this._scrollTimer) {\n            this._scrollTimer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n          } else {\n            this._scrollTimer.cancel();\n          }\n\n          let callback;\n          if (this._clickToScroll) {\n            callback = () => {\n              if (!document && this._scrollTimer) {\n                this._scrollTimer.cancel();\n              }\n              this.scrollByIndex(this._scrollIndex);\n            };\n          } else {\n            callback = () => this.scrollByPixels(this.scrollIncrement * index);\n          }\n\n          this._scrollTimer.initWithCallback(callback, this._scrollDelay,\n                                             Ci.nsITimer.TYPE_REPEATING_SLACK);\n\n          callback();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_stopScroll\">\n        <body><![CDATA[\n          if (this._scrollTimer)\n            this._scrollTimer.cancel();\n\n          if (this._clickToScroll) {\n            this._mousedown = false;\n            if (!this._scrollIndex || !this.smoothScroll)\n              return;\n\n            this.scrollByIndex(this._scrollIndex);\n            this._scrollIndex = 0;\n\n            this._arrowScrollAnim.stop();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_pauseScroll\">\n        <body><![CDATA[\n          if (this._mousedown) {\n            this._stopScroll();\n            this._mousedown = true;\n            document.addEventListener(\"mouseup\", this);\n            document.addEventListener(\"blur\", this, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_continueScroll\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._mousedown)\n            this._startScroll(index);\n        ]]></body>\n      </method>\n\n      <method name=\"_distanceScroll\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.detail < 2 || aEvent.detail > 3)\n            return;\n\n          var scrollBack = (aEvent.originalTarget == this._scrollButtonUp);\n          var scrollLeftOrUp = this._isRTLScrollbox ? !scrollBack : scrollBack;\n          var targetElement;\n\n          if (aEvent.detail == 2) {\n            // scroll by the size of the scrollbox\n            let [start, end] = this._startEndProps;\n            let x;\n            if (scrollLeftOrUp)\n              x = this.scrollClientRect[start] - this.scrollClientSize;\n            else\n              x = this.scrollClientRect[end] + this.scrollClientSize;\n            targetElement = this._elementFromPoint(x, scrollLeftOrUp ? -1 : 1);\n\n            // the next partly-hidden element will become fully visible,\n            // so don't scroll too far\n            if (targetElement)\n              targetElement = scrollBack ?\n                              targetElement.nextElementSibling :\n                              targetElement.previousElementSibling;\n          }\n\n          if (!targetElement) {\n            // scroll to the first resp. last element\n            let elements = this._getScrollableElements();\n            targetElement = scrollBack ?\n                            elements[0] :\n                            elements[elements.length - 1];\n          }\n\n          this.ensureElementIsVisible(targetElement);\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.type == \"mouseup\" ||\n              aEvent.type == \"blur\" && aEvent.target == document) {\n            this._mousedown = false;\n            document.removeEventListener(\"mouseup\", this);\n            document.removeEventListener(\"blur\", this, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"scrollByPixels\">\n        <parameter name=\"aPixels\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          let scrollOptions = { behavior: aInstant ? \"instant\" : \"auto\" };\n          scrollOptions[this._startEndProps[0]] = aPixels;\n          this.scrollbox.scrollBy(scrollOptions);\n        ]]></body>\n      </method>\n\n      <field name=\"_prevMouseScrolls\">[null, null]</field>\n\n      <field name=\"_touchStart\">-1</field>\n\n      <field name=\"_scrollButtonUpdatePending\">false</field>\n      <method name=\"_updateScrollButtonsDisabledState\">\n        <body><![CDATA[\n          if (this.hasAttribute(\"notoverflowing\")) {\n            this.setAttribute(\"scrolledtoend\", \"true\");\n            this.setAttribute(\"scrolledtostart\", \"true\");\n            return;\n          }\n\n          if (this._scrollButtonUpdatePending) {\n            return;\n          }\n          this._scrollButtonUpdatePending = true;\n\n          // Wait until after the next paint to get current layout data from\n          // getBoundsWithoutFlushing.\n          window.requestAnimationFrame(() => {\n            setTimeout(() => {\n              if (!this._startEndProps) {\n                // We've been destroyed in the meantime.\n                return;\n              }\n\n              this._scrollButtonUpdatePending = false;\n\n              let scrolledToStart = false;\n              let scrolledToEnd = false;\n\n              if (this.hasAttribute(\"notoverflowing\")) {\n                scrolledToStart = true;\n                scrolledToEnd = true;\n              } else {\n                let [leftOrTop, rightOrBottom] = this._startEndProps;\n                let leftOrTopEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[leftOrTop]);\n                let rightOrBottomEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[rightOrBottom]);\n\n                let elements = this._getScrollableElements();\n                let [leftOrTopElement, rightOrBottomElement] = [elements[0], elements[elements.length - 1]];\n                if (this._isRTLScrollbox) {\n                  [leftOrTopElement, rightOrBottomElement] = [rightOrBottomElement, leftOrTopElement];\n                }\n\n                if (leftOrTopElement &&\n                    leftOrTopEdge(leftOrTopElement) >= leftOrTopEdge(this.scrollbox)) {\n                  scrolledToStart = !this._isRTLScrollbox;\n                  scrolledToEnd = this._isRTLScrollbox;\n                } else if (rightOrBottomElement &&\n                           rightOrBottomEdge(rightOrBottomElement) <= rightOrBottomEdge(this.scrollbox)) {\n                  scrolledToStart = this._isRTLScrollbox;\n                  scrolledToEnd = !this._isRTLScrollbox;\n                }\n              }\n\n              if (scrolledToEnd) {\n                this.setAttribute(\"scrolledtoend\", \"true\");\n              } else {\n                this.removeAttribute(\"scrolledtoend\");\n              }\n\n              if (scrolledToStart) {\n                this.setAttribute(\"scrolledtostart\", \"true\");\n              } else {\n                this.removeAttribute(\"scrolledtostart\");\n              }\n            }, 0);\n          });\n        ]]></body>\n      </method>\n\n      <field name=\"_isScrolling\">false</field>\n      <field name=\"_destination\">0</field>\n      <field name=\"_direction\">0</field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"wheel\"><![CDATA[\n        // Don't consume the event if we can't scroll.\n        if (this.hasAttribute(\"notoverflowing\")) {\n          return;\n        }\n\n        let doScroll = false;\n        let instant;\n        let scrollAmount = 0;\n        if (this.orient == \"vertical\") {\n          doScroll = true;\n          if (event.deltaMode == event.DOM_DELTA_PIXEL)\n            scrollAmount = event.deltaY;\n          else if (event.deltaMode == event.DOM_DELTA_PAGE)\n            scrollAmount = event.deltaY * this.scrollClientSize;\n          else\n            scrollAmount = event.deltaY * this.lineScrollAmount;\n        } else {\n          // We allow vertical scrolling to scroll a horizontal scrollbox\n          // because many users have a vertical scroll wheel but no\n          // horizontal support.\n          // Because of this, we need to avoid scrolling chaos on trackpads\n          // and mouse wheels that support simultaneous scrolling in both axes.\n          // We do this by scrolling only when the last two scroll events were\n          // on the same axis as the current scroll event.\n          // For diagonal scroll events we only respect the dominant axis.\n          let isVertical = Math.abs(event.deltaY) > Math.abs(event.deltaX);\n          let delta = isVertical ? event.deltaY : event.deltaX;\n          let scrollByDelta = isVertical && this._isRTLScrollbox ? -delta : delta;\n\n          if (this._prevMouseScrolls.every(prev => prev == isVertical)) {\n            doScroll = true;\n            if (event.deltaMode == event.DOM_DELTA_PIXEL) {\n              scrollAmount = scrollByDelta;\n              instant = true;\n            } else if (event.deltaMode == event.DOM_DELTA_PAGE) {\n              scrollAmount = scrollByDelta * this.scrollClientSize;\n            } else {\n              scrollAmount = scrollByDelta * this.lineScrollAmount;\n            }\n          }\n\n          if (this._prevMouseScrolls.length > 1)\n            this._prevMouseScrolls.shift();\n          this._prevMouseScrolls.push(isVertical);\n        }\n\n        if (doScroll) {\n          let direction = scrollAmount < 0 ? -1 : 1;\n          let startPos = this.scrollPosition;\n\n          if (!this._isScrolling || this._direction != direction) {\n            this._destination = startPos + scrollAmount;\n            this._direction = direction;\n          } else {\n            // We were already in the process of scrolling in this direction\n            this._destination = this._destination + scrollAmount;\n            scrollAmount = this._destination - startPos;\n          }\n          this.scrollByPixels(scrollAmount, instant);\n        }\n\n        event.stopPropagation();\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"touchstart\"><![CDATA[\n        if (event.touches.length > 1) {\n          // Multiple touch points detected, abort. In particular this aborts\n          // the panning gesture when the user puts a second finger down after\n          // already panning with one finger. Aborting at this point prevents\n          // the pan gesture from being resumed until all fingers are lifted\n          // (as opposed to when the user is back down to one finger).\n          this._touchStart = -1;\n        } else {\n          this._touchStart = (this.orient == \"vertical\"\n                ? event.touches[0].screenY\n                : event.touches[0].screenX);\n        }\n      ]]></handler>\n\n      <handler event=\"touchmove\"><![CDATA[\n        if (event.touches.length == 1 &&\n            this._touchStart >= 0) {\n          var touchPoint = (this.orient == \"vertical\"\n                ? event.touches[0].screenY\n                : event.touches[0].screenX);\n          var delta = this._touchStart - touchPoint;\n          if (Math.abs(delta) > 0) {\n            this.scrollByPixels(delta, true);\n            this._touchStart = touchPoint;\n          }\n          event.preventDefault();\n        }\n      ]]></handler>\n\n      <handler event=\"touchend\"><![CDATA[\n        this._touchStart = -1;\n      ]]></handler>\n\n      <handler event=\"underflow\" phase=\"capturing\"><![CDATA[\n        // Ignore underflow events:\n        // - from nested scrollable elements\n        // - corresponding to an overflow event that we ignored\n        if (event.target != this ||\n            this.hasAttribute(\"notoverflowing\")) {\n          return;\n        }\n\n        // Ignore events that doesn't match our orientation.\n        // Scrollport event orientation:\n        //   0: vertical\n        //   1: horizontal\n        //   2: both\n        if (this.orient == \"vertical\") {\n          if (event.detail == 1)\n            return;\n        } else if (event.detail == 0) {\n          // horizontal scrollbox\n          return;\n        }\n\n        this.setAttribute(\"notoverflowing\", \"true\");\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"overflow\" phase=\"capturing\"><![CDATA[\n        // Ignore overflow events:\n        // - from nested scrollable elements\n        if (event.target != this) {\n          return;\n        }\n\n        // Ignore events that doesn't match our orientation.\n        // Scrollport event orientation:\n        //   0: vertical\n        //   1: horizontal\n        //   2: both\n        if (this.orient == \"vertical\") {\n          if (event.detail == 1)\n            return;\n        } else if (event.detail == 0) {\n          // horizontal scrollbox\n          return;\n        }\n\n        this.removeAttribute(\"notoverflowing\");\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"scroll\"><![CDATA[\n        this._isScrolling = true;\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"scrollend\"><![CDATA[\n        this._isScrolling = false;\n        this._destination = 0;\n        this._direction = 0;\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"tabbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"tabBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n  <binding id=\"tabs\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <content>\n      <xul:spacer class=\"tabs-left\"/>\n      <children/>\n      <xul:spacer class=\"tabs-right\" flex=\"1\"/>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlElement, nsIDOMXULRelatedElement\">\n      <constructor>\n      <![CDATA[\n\n        if (!this.hasAttribute(\"orient\"))\n          this.setAttribute(\"orient\", \"horizontal\");\n\n        if (this.tabbox && this.tabbox.hasAttribute(\"selectedIndex\")) {\n          let selectedIndex = parseInt(this.tabbox.getAttribute(\"selectedIndex\"));\n          this.selectedIndex = selectedIndex > 0 ? selectedIndex : 0;\n          return;\n        }\n\n        var children = this.children;\n        var length = children.length;\n        for (var i = 0; i < length; i++) {\n          if (children[i].getAttribute(\"selected\") == \"true\") {\n            this.selectedIndex = i;\n            return;\n          }\n        }\n\n        var value = this.value;\n        if (value)\n          this.value = value;\n        else\n          this.selectedIndex = 0;\n      ]]>\n      </constructor>\n\n      <!-- nsIDOMXULRelatedElement -->\n      <method name=\"getRelatedElement\">\n        <parameter name=\"aTabElm\"/>\n        <body>\n        <![CDATA[\n          if (!aTabElm)\n            return null;\n\n          let tabboxElm = this.tabbox;\n          if (!tabboxElm)\n            return null;\n\n          let tabpanelsElm = tabboxElm.tabpanels;\n          if (!tabpanelsElm)\n            return null;\n\n          // Get linked tab panel by 'linkedpanel' attribute on the given tab\n          // element.\n          let linkedPanelId = aTabElm.linkedPanel;\n          if (linkedPanelId) {\n            let ownerDoc = this.ownerDocument;\n\n            // XXX bug 565858: if XUL tab element is anonymous element then\n            // suppose linked tab panel is hosted within the same XBL binding\n            // and search it by ID attribute inside an anonymous content of\n            // the binding. This is not robust assumption since tab elements may\n            // live outside a tabbox element so that for example tab elements\n            // can be explicit content but tab panels can be anonymous.\n\n            let bindingParent = ownerDoc.getBindingParent(aTabElm);\n            if (bindingParent)\n              return ownerDoc.getAnonymousElementByAttribute(bindingParent,\n                                                             \"id\",\n                                                             linkedPanelId);\n\n            return ownerDoc.getElementById(linkedPanelId);\n          }\n\n          // otherwise linked tabpanel element has the same index as the given\n          // tab element.\n          let tabElmIdx = this.getIndexOfItem(aTabElm);\n          return tabpanelsElm.children[tabElmIdx];\n        ]]>\n        </body>\n      </method>\n\n      <!-- nsIDOMXULSelectControlElement -->\n      <property name=\"itemCount\" readonly=\"true\"\n                onget=\"return this.children.length\"/>\n\n      <property name=\"value\" onget=\"return this.getAttribute('value');\">\n        <setter>\n          <![CDATA[\n            this.setAttribute(\"value\", val);\n            var children = this.children;\n            for (var c = children.length - 1; c >= 0; c--) {\n              if (children[c].value == val) {\n                this.selectedIndex = c;\n                break;\n              }\n            }\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <field name=\"_tabbox\">null</field>\n      <property name=\"tabbox\" readonly=\"true\">\n        <getter><![CDATA[\n          // Memoize the result in a field rather than replacing this property,\n          // so that it can be reset along with the binding.\n          if (this._tabbox) {\n            return this._tabbox;\n          }\n\n          let parent = this.parentNode;\n          while (parent) {\n            if (parent.localName == \"tabbox\") {\n              break;\n            }\n            parent = parent.parentNode;\n          }\n\n          return this._tabbox = parent;\n        ]]></getter>\n      </property>\n\n      <!-- _tabbox is deprecated, it exists only for backwards compatibility. -->\n      <field name=\"_tabbox\" readonly=\"true\"><![CDATA[\n        this.tabbox;\n      ]]></field>\n\n      <field name=\"_prefService\" readonly=\"true\"><![CDATA[\n        Cc[\"@mozilla.org/preferences-service;1\"].getService(Ci.nsIPrefBranch);\n      ]]></field>\n\n      <property name=\"selectedIndex\">\n        <getter>\n        <![CDATA[\n          const tabs = this.children;\n          for (var i = 0; i < tabs.length; i++) {\n            if (tabs[i].selected)\n              return i;\n          }\n          return -1;\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          var tab = this.getItemAtIndex(val);\n          if (tab) {\n            for (let otherTab of this.children) {\n              if (otherTab != tab && otherTab.selected) {\n                otherTab._selected = false;\n              }\n            }\n            tab._selected = true;\n\n            this.setAttribute(\"value\", tab.value);\n\n            let linkedPanel = this.getRelatedElement(tab);\n            if (linkedPanel) {\n              this.tabbox.setAttribute(\"selectedIndex\", val);\n\n              // This will cause an onselect event to fire for the tabpanel\n              // element.\n              this.tabbox.tabpanels.selectedPanel = linkedPanel;\n            }\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedItem\">\n        <getter>\n        <![CDATA[\n          const tabs = this.children;\n          for (var i = 0; i < tabs.length; i++) {\n            if (tabs[i].selected)\n              return tabs[i];\n          }\n          return null;\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          if (val && !val.selected)\n            // The selectedIndex setter ignores invalid values\n            // such as -1 if |val| isn't one of our child nodes.\n            this.selectedIndex = this.getIndexOfItem(val);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <field name=\"ACTIVE_DESCENDANT_ID\" readonly=\"true\"><![CDATA[\n        \"keyboard-focused-tab-\" + Math.trunc(Math.random() * 1000000);\n      ]]></field>\n\n      <property name=\"ariaFocusedIndex\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          const tabs = this.children;\n          for (var i = 0; i < tabs.length; i++) {\n            if (tabs[i].id == this.ACTIVE_DESCENDANT_ID)\n              return i;\n          }\n          return -1;\n        ]]>\n        </getter>\n      </property>\n\n      <property name=\"ariaFocusedItem\">\n        <getter>\n        <![CDATA[\n          return document.getElementById(this.ACTIVE_DESCENDANT_ID);\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          let setNewItem = val && this.getIndexOfItem(val) != -1;\n          let clearExistingItem = this.ariaFocusedItem && (!val || setNewItem);\n          if (clearExistingItem) {\n            let ariaFocusedItem = this.ariaFocusedItem;\n            ariaFocusedItem.classList.remove(\"keyboard-focused-tab\");\n            ariaFocusedItem.id = \"\";\n            this.selectedItem.removeAttribute(\"aria-activedescendant\");\n          }\n\n          if (setNewItem) {\n            this.ariaFocusedItem = null;\n            val.id = this.ACTIVE_DESCENDANT_ID;\n            val.classList.add(\"keyboard-focused-tab\");\n            this.selectedItem.setAttribute(\"aria-activedescendant\", this.ACTIVE_DESCENDANT_ID);\n          }\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"item\"/>\n        <body>\n        <![CDATA[\n          return Array.prototype.indexOf.call(this.children, item);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"index\"/>\n        <body>\n        <![CDATA[\n          return this.children.item(index);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_selectNewTab\">\n        <parameter name=\"aNewTab\"/>\n        <parameter name=\"aFallbackDir\"/>\n        <parameter name=\"aWrap\"/>\n        <body>\n        <![CDATA[\n          this.ariaFocusedItem = null;\n\n          var requestedTab = aNewTab;\n          while (aNewTab.hidden || aNewTab.disabled || !this._canAdvanceToTab(aNewTab)) {\n            aNewTab = aFallbackDir == -1 ? aNewTab.previousElementSibling : aNewTab.nextElementSibling;\n            if (!aNewTab && aWrap)\n              aNewTab = aFallbackDir == -1 ? this.children[this.children.length - 1] :\n                                             this.children[0];\n            if (!aNewTab || aNewTab == requestedTab)\n              return;\n          }\n\n          var isTabFocused = false;\n          try {\n            isTabFocused =\n              (document.commandDispatcher.focusedElement == this.selectedItem);\n          } catch (e) {}\n          this.selectedItem = aNewTab;\n          if (isTabFocused) {\n            aNewTab.focus();\n          } else if (this.getAttribute(\"setfocus\") != \"false\") {\n            let selectedPanel = this.tabbox.selectedPanel;\n            document.commandDispatcher.advanceFocusIntoSubtree(selectedPanel);\n\n            // Make sure that the focus doesn't move outside the tabbox\n            if (this.tabbox) {\n              try {\n                let el = document.commandDispatcher.focusedElement;\n                while (el && el != this.tabbox.tabpanels) {\n                  if (el == this.tabbox || el == selectedPanel)\n                    return;\n                  el = el.parentNode;\n                }\n                aNewTab.focus();\n              } catch (e) {\n              }\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_canAdvanceToTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          return true;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"advanceSelectedTab\">\n        <parameter name=\"aDir\"/>\n        <parameter name=\"aWrap\"/>\n        <body>\n        <![CDATA[\n          var startTab = this.ariaFocusedItem || this.selectedItem;\n          var next = startTab[(aDir == -1 ? \"previous\" : \"next\") + \"ElementSibling\"];\n          if (!next && aWrap) {\n            next = aDir == -1 ? this.children[this.children.length - 1] :\n                                this.children[0];\n          }\n          if (next && next != startTab) {\n            this._selectNewTab(next, aDir, aWrap);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"appendItem\">\n        <parameter name=\"label\"/>\n        <parameter name=\"value\"/>\n        <body>\n        <![CDATA[\n          var tab = document.createXULElement(\"tab\");\n          tab.setAttribute(\"label\", label);\n          tab.setAttribute(\"value\", value);\n          this.appendChild(tab);\n          return tab;\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"DOMMouseScroll\">\n      <![CDATA[\n        if (this._prefService.getBoolPref(\"toolkit.tabbox.switchByScrolling\")) {\n          if (event.detail > 0) {\n            this.advanceSelectedTab(1, false);\n          } else {\n            this.advanceSelectedTab(-1, false);\n          }\n          event.stopPropagation();\n        }\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"textbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This files relies on these specific Chrome/XBL globals -->\n<!-- globals ChromeWindow -->\n\n\n<!DOCTYPE bindings [\n  <!ENTITY % textcontextDTD SYSTEM \"chrome://global/locale/textcontext.dtd\" >\n  %textcontextDTD;\n]>\n\n<bindings id=\"textboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"textbox\">\n    <content>\n      <children/>\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\" xbl:inherits=\"context,spellcheck\">\n        <html:input class=\"textbox-input\" anonid=\"input\"\n                    xbl:inherits=\"value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,noinitialfocus,mozactionhint,spellcheck\"/>\n      </xul:moz-input-box>\n    </content>\n\n    <implementation>\n      <!-- nsIDOMXULLabeledControlElement -->\n      <field name=\"crop\">\"\"</field>\n      <field name=\"image\">\"\"</field>\n      <field name=\"command\">\"\"</field>\n      <field name=\"accessKey\">\"\"</field>\n\n      <field name=\"mInputField\">null</field>\n      <field name=\"mIgnoreClick\">false</field>\n      <field name=\"mIgnoreFocus\">false</field>\n      <field name=\"mEditor\">null</field>\n\n      <property name=\"inputField\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.mInputField)\n            this.mInputField = document.getAnonymousElementByAttribute(this, \"anonid\", \"input\");\n          return this.mInputField;\n        ]]></getter>\n      </property>\n\n      <property name=\"value\"      onset=\"this.inputField.value = val; return val;\"\n                                  onget=\"return this.inputField.value;\"/>\n      <property name=\"defaultValue\" onset=\"this.inputField.defaultValue = val; return val;\"\n                                  onget=\"return this.inputField.defaultValue;\"/>\n      <property name=\"label\"      onset=\"this.setAttribute('label', val); return val;\"\n                                  onget=\"return this.getAttribute('label') || this.placeholder;\" />\n      <property name=\"placeholder\" onset=\"this.inputField.placeholder = val; return val;\"\n                                  onget=\"return this.inputField.placeholder;\"/>\n      <property name=\"emptyText\"  onset=\"this.placeholder = val; return val;\"\n                                  onget=\"return this.placeholder;\"/>\n      <property name=\"type\"       onset=\"if (val) this.setAttribute('type', val);\n                                         else this.removeAttribute('type'); return val;\"\n                                  onget=\"return this.getAttribute('type');\"/>\n      <property name=\"maxLength\"  onset=\"this.inputField.maxLength = val; return val;\"\n                                  onget=\"return this.inputField.maxLength;\"/>\n      <property name=\"disabled\"   onset=\"this.inputField.disabled = val;\n                                         if (val) this.setAttribute('disabled', 'true');\n                                         else this.removeAttribute('disabled'); return val;\"\n                                  onget=\"return this.inputField.disabled;\"/>\n      <property name=\"tabIndex\"   onget=\"return parseInt(this.getAttribute('tabindex'));\"\n                                  onset=\"this.inputField.tabIndex = val;\n                                         if (val) this.setAttribute('tabindex', val);\n                                         else this.removeAttribute('tabindex'); return val;\"/>\n      <property name=\"size\"       onset=\"this.inputField.size = val; return val;\"\n                                  onget=\"return this.inputField.size;\"/>\n      <property name=\"readOnly\"   onset=\"this.inputField.readOnly = val;\n                                         if (val) this.setAttribute('readonly', 'true');\n                                         else this.removeAttribute('readonly'); return val;\"\n                                  onget=\"return this.inputField.readOnly;\"/>\n      <property name=\"clickSelectsAll\"\n                onget=\"return this.getAttribute('clickSelectsAll') == 'true';\"\n                onset=\"if (val) this.setAttribute('clickSelectsAll', 'true');\n                       else this.removeAttribute('clickSelectsAll'); return val;\" />\n\n      <property name=\"editor\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.mEditor) {\n            this.mEditor = this.inputField.editor;\n          }\n          return this.mEditor;\n        ]]></getter>\n      </property>\n\n      <method name=\"reset\">\n        <body><![CDATA[\n          this.value = this.defaultValue;\n          try {\n            this.editor.transactionManager.clear();\n            return true;\n          } catch (e) {}\n          return false;\n        ]]></body>\n      </method>\n\n      <method name=\"select\">\n        <body>\n          this.inputField.select();\n        </body>\n      </method>\n\n      <method name=\"setUserInput\">\n        <parameter name=\"value\"/>\n        <body><![CDATA[\n          this.inputField.setUserInput(value);\n        ]]></body>\n      </method>\n\n      <property name=\"controllers\"    readonly=\"true\" onget=\"return this.inputField.controllers\"/>\n      <property name=\"textLength\"     readonly=\"true\"\n                                      onget=\"return this.inputField.textLength;\"/>\n      <property name=\"selectionStart\" onset=\"this.inputField.selectionStart = val; return val;\"\n                                      onget=\"return this.inputField.selectionStart;\"/>\n      <property name=\"selectionEnd\"   onset=\"this.inputField.selectionEnd = val; return val;\"\n                                      onget=\"return this.inputField.selectionEnd;\"/>\n\n      <method name=\"setSelectionRange\">\n        <parameter name=\"aSelectionStart\"/>\n        <parameter name=\"aSelectionEnd\"/>\n        <body>\n          // According to https://html.spec.whatwg.org/#do-not-apply,\n          // setSelectionRange() is only available on a limited set of input types.\n          if (this.inputField.type == \"text\") {\n            this.inputField.setSelectionRange( aSelectionStart, aSelectionEnd );\n          }\n        </body>\n      </method>\n\n      <method name=\"_setNewlineHandling\">\n        <body><![CDATA[\n          var str = this.getAttribute(\"newlines\");\n          if (str && this.editor) {\n            const nsIPlaintextEditor = Ci.nsIPlaintextEditor;\n            for (var x in nsIPlaintextEditor) {\n              if (/^eNewlines/.test(x)) {\n                if (str == RegExp.rightContext.toLowerCase()) {\n                  this.editor.QueryInterface(nsIPlaintextEditor)\n                      .newlineHandling = nsIPlaintextEditor[x];\n                  break;\n                }\n              }\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_maybeSelectAll\">\n        <body><![CDATA[\n          if (!this.mIgnoreClick && this.clickSelectsAll &&\n              document.activeElement == this.inputField &&\n              this.inputField.selectionStart == this.inputField.selectionEnd)\n            this.editor.selectAll();\n        ]]></body>\n      </method>\n\n      <constructor><![CDATA[\n        var str = this._cachedInputFieldValue;\n        if (str) {\n          this.inputField.value = str;\n          delete this._cachedInputFieldValue;\n        }\n\n        this._setNewlineHandling();\n\n        if (this.hasAttribute(\"emptytext\"))\n          this.placeholder = this.getAttribute(\"emptytext\");\n      ]]></constructor>\n\n      <destructor>\n        <![CDATA[\n          var field = this.inputField;\n          if (field && field.value) {\n            this._cachedInputFieldValue = field.value;\n          }\n\n          this.mInputField = null;\n        ]]>\n      </destructor>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"focus\" phase=\"capturing\">\n        <![CDATA[\n          if (this.hasAttribute(\"focused\"))\n            return;\n\n          switch (event.originalTarget) {\n            case this:\n              // Forward focus to actual HTML input\n              this.inputField.focus();\n              this.setAttribute(\"focused\", \"true\");\n              break;\n            case this.inputField:\n              if (this.mIgnoreFocus) {\n                this.mIgnoreFocus = false;\n              } else if (this.clickSelectsAll) {\n                try {\n                  if (!this.editor || !this.editor.composing)\n                    this.editor.selectAll();\n                } catch (e) {}\n              }\n              this.setAttribute(\"focused\", \"true\");\n              break;\n            default:\n              // Otherwise, allow other children (e.g. URL bar buttons) to get focus\n              break;\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"blur\" phase=\"capturing\">\n        <![CDATA[\n          this.removeAttribute(\"focused\");\n\n          // don't trigger clickSelectsAll when switching application windows\n          if (window == window.top &&\n              window.isChromeWindow &&\n              document.activeElement == this.inputField)\n            this.mIgnoreFocus = true;\n        ]]>\n      </handler>\n\n      <handler event=\"mousedown\">\n        <![CDATA[\n          this.mIgnoreClick = this.hasAttribute(\"focused\");\n\n          if (!this.mIgnoreClick) {\n            this.mIgnoreFocus = true;\n            this.setSelectionRange(0, 0);\n            if (event.originalTarget == this ||\n                event.originalTarget == this.inputField.parentNode)\n              this.inputField.focus();\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"click\" action=\"this._maybeSelectAll();\"/>\n\n\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"wizard.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"wizardBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"wizard\">\n    <content>\n      <xul:hbox class=\"wizard-header\" anonid=\"Header\"/>\n\n      <xul:deck class=\"wizard-page-box\" flex=\"1\" anonid=\"Deck\">\n        <children includes=\"wizardpage\"/>\n      </xul:deck>\n      <children/>\n\n      <xul:wizard-buttons class=\"wizard-buttons\" anonid=\"Buttons\" xbl:inherits=\"pagestep,firstpage,lastpage\"/>\n    </content>\n\n    <implementation>\n      <property name=\"title\" onget=\"return document.title;\"\n                             onset=\"return document.title = val;\"/>\n\n      <property name=\"canAdvance\" onget=\"return this._canAdvance;\"\n                                  onset=\"this.getButton('next').disabled = !val; return this._canAdvance = val;\"/>\n      <property name=\"canRewind\" onget=\"return this._canRewind;\"\n                                 onset=\"this.getButton('back').disabled = !val; return this._canRewind = val;\"/>\n\n      <property name=\"pageStep\" readonly=\"true\" onget=\"return this._pageStack.length\"/>\n\n      <field name=\"pageCount\">0</field>\n\n      <field name=\"_accessMethod\">null</field>\n      <field name=\"_pageStack\">null</field>\n      <field name=\"_currentPage\">null</field>\n\n      <property name=\"wizardPages\">\n        <getter>\n        <![CDATA[\n          var xulns = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          return this.getElementsByTagNameNS(xulns, \"wizardpage\");\n        ]]>\n        </getter>\n      </property>\n\n      <property name=\"currentPage\" onget=\"return this._currentPage\">\n        <setter>\n        <![CDATA[\n          if (!val)\n            return val;\n\n          this._currentPage = val;\n\n          // Setting this attribute allows wizard's clients to dynamically\n          // change the styles of each page based on purpose of the page.\n          this.setAttribute(\"currentpageid\", val.pageid);\n          if (this.onFirstPage) {\n            this.canRewind = false;\n            this.setAttribute(\"firstpage\", \"true\");\n            if (/Linux/.test(navigator.platform)) {\n              this.getButton(\"back\").setAttribute(\"hidden\", \"true\");\n            }\n          } else {\n            this.canRewind = true;\n            this.setAttribute(\"firstpage\", \"false\");\n            if (/Linux/.test(navigator.platform)) {\n              this.getButton(\"back\").setAttribute(\"hidden\", \"false\");\n            }\n          }\n\n          if (this.onLastPage) {\n            this.canAdvance = true;\n            this.setAttribute(\"lastpage\", \"true\");\n          } else {\n            this.setAttribute(\"lastpage\", \"false\");\n          }\n\n          this._deck.setAttribute(\"selectedIndex\", val.pageIndex);\n          this._advanceFocusToPage(val);\n\n          this._adjustWizardHeader();\n          this._wizardButtons.onPageChange();\n\n          this._fireEvent(val, \"pageshow\");\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"pageIndex\"\n                onget=\"return this._currentPage ? this._currentPage.pageIndex : -1;\">\n        <setter>\n        <![CDATA[\n          if (val < 0 || val >= this.pageCount)\n            return val;\n\n          var page = this.wizardPages[val];\n          this._pageStack[this._pageStack.length-1] = page;\n          this.currentPage = page;\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"onFirstPage\" readonly=\"true\"\n                onget=\"return this._pageStack.length == 1;\"/>\n\n      <property name=\"onLastPage\" readonly=\"true\">\n        <getter><![CDATA[\n          var cp = this.currentPage;\n          return cp && ((this._accessMethod == \"sequential\" && cp.pageIndex == this.pageCount-1) ||\n                       (this._accessMethod == \"random\" && cp.next == \"\"));\n         ]]></getter>\n      </property>\n\n      <method name=\"getButton\">\n        <parameter name=\"aDlgType\"/>\n        <body>\n        <![CDATA[\n          return this._wizardButtons.getButton(aDlgType);\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"_canAdvance\"/>\n      <field name=\"_canRewind\"/>\n      <field name=\"_wizardHeader\"/>\n      <field name=\"_wizardButtons\"/>\n      <field name=\"_deck\"/>\n\n      <constructor><![CDATA[\n        this._canAdvance = true;\n        this._canRewind = false;\n        this._hasLoaded = false;\n\n        this._pageStack = [];\n\n        try {\n          // need to create string bundle manually instead of using <xul:stringbundle/>\n          // see bug 63370 for details\n          this._bundle = Cc[\"@mozilla.org/intl/stringbundle;1\"]\n                           .getService(Ci.nsIStringBundleService)\n                           .createBundle(\"chrome://global/locale/wizard.properties\");\n        } catch (e) {\n          // This fails in remote XUL, which has to provide titles for all pages\n          // see bug 142502\n        }\n\n        // get anonymous content references\n        this._wizardHeader = document.getAnonymousElementByAttribute(this, \"anonid\", \"Header\");\n\n        this._wizardHeader.appendChild(\n          MozXULElement.parseXULToFragment(/Mac/.test(navigator.platform) ?\n            `<stack class=\"wizard-header-stack\" flex=\"1\">\n              <vbox class=\"wizard-header-box-1\">\n                <vbox class=\"wizard-header-box-text\">\n                  <label class=\"wizard-header-label\"/>\n                </vbox>\n              </vbox>\n              <hbox class=\"wizard-header-box-icon\">\n                <spacer flex=\"1\"/>\n                <image class=\"wizard-header-icon\"/>\n              </hbox>\n            </stack>` :\n            `<hbox class=\"wizard-header-box-1\" flex=\"1\">\n              <vbox class=\"wizard-header-box-text\" flex=\"1\">\n                <label class=\"wizard-header-label\"/>\n                <label class=\"wizard-header-description\"/>\n              </vbox>\n              <image class=\"wizard-header-icon\"/>\n            </hbox>`\n          )\n        );\n\n        this._wizardButtons = document.getAnonymousElementByAttribute(this, \"anonid\", \"Buttons\");\n        customElements.upgrade(this._wizardButtons);\n\n        this._deck = document.getAnonymousElementByAttribute(this, \"anonid\", \"Deck\");\n\n        this._initPages();\n\n        window.addEventListener(\"close\", (event) => {\n          if (document.documentElement.cancel()) {\n            event.preventDefault();\n          }\n        });\n\n        // start off on the first page\n        this.pageCount = this.wizardPages.length;\n        this.advance();\n\n        // give focus to the first focusable element in the dialog\n        window.addEventListener(\"load\", this._setInitialFocus);\n      ]]></constructor>\n\n      <method name=\"getPageById\">\n        <parameter name=\"aPageId\"/>\n        <body><![CDATA[\n          var els = this.getElementsByAttribute(\"pageid\", aPageId);\n          return els.item(0);\n        ]]></body>\n      </method>\n\n      <method name=\"extra1\">\n        <body><![CDATA[\n          if (this.currentPage)\n            this._fireEvent(this.currentPage, \"extra1\");\n        ]]></body>\n      </method>\n\n      <method name=\"extra2\">\n        <body><![CDATA[\n          if (this.currentPage)\n            this._fireEvent(this.currentPage, \"extra2\");\n        ]]></body>\n      </method>\n\n      <method name=\"rewind\">\n        <body><![CDATA[\n          if (!this.canRewind)\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pagehide\"))\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pagerewound\"))\n            return;\n\n          if (!this._fireEvent(this, \"wizardback\"))\n            return;\n\n\n          this._pageStack.pop();\n          this.currentPage = this._pageStack[this._pageStack.length-1];\n          this.setAttribute(\"pagestep\", this._pageStack.length);\n        ]]></body>\n      </method>\n\n      <method name=\"advance\">\n        <parameter name=\"aPageId\"/>\n        <body><![CDATA[\n          if (!this.canAdvance)\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pagehide\"))\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pageadvanced\"))\n            return;\n\n          if (this.onLastPage && !aPageId) {\n            if (this._fireEvent(this, \"wizardfinish\"))\n              window.setTimeout(function() {window.close();}, 1);\n          } else {\n            if (!this._fireEvent(this, \"wizardnext\"))\n              return;\n\n            var page;\n            if (aPageId)\n              page = this.getPageById(aPageId);\n            else {\n              if (this.currentPage) {\n                if (this._accessMethod == \"random\")\n                  page = this.getPageById(this.currentPage.next);\n                else\n                  page = this.wizardPages[this.currentPage.pageIndex+1];\n              } else\n                page = this.wizardPages[0];\n            }\n\n            if (page) {\n              this._pageStack.push(page);\n              this.setAttribute(\"pagestep\", this._pageStack.length);\n\n              this.currentPage = page;\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"goTo\">\n        <parameter name=\"aPageId\"/>\n        <body><![CDATA[\n          var page = this.getPageById(aPageId);\n          if (page) {\n            this._pageStack[this._pageStack.length-1] = page;\n            this.currentPage = page;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"cancel\">\n        <body><![CDATA[\n          if (!this._fireEvent(this, \"wizardcancel\"))\n            return true;\n\n          window.close();\n          window.setTimeout(function() {window.close();}, 1);\n          return false;\n        ]]></body>\n      </method>\n\n      <method name=\"_setInitialFocus\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          document.documentElement._hasLoaded = true;\n          var focusInit =\n            function() {\n              // give focus to the first focusable element in the dialog\n              if (!document.commandDispatcher.focusedElement)\n                document.commandDispatcher.advanceFocusIntoSubtree(document.documentElement);\n\n              try {\n                var button =\n                      document.documentElement._wizardButtons.defaultButton;\n                if (button)\n                  window.notifyDefaultButtonLoaded(button);\n              } catch (e) { }\n            };\n\n          // Give focus after onload completes, see bug 103197.\n          setTimeout(focusInit, 0);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_advanceFocusToPage\">\n        <parameter name=\"aPage\"/>\n        <body>\n        <![CDATA[\n          if (!this._hasLoaded)\n            return;\n\n          document.commandDispatcher.advanceFocusIntoSubtree(aPage);\n\n          // if advanceFocusIntoSubtree tries to focus one of our\n          // dialog buttons, then remove it and put it on the root\n          var focused = document.commandDispatcher.focusedElement;\n          if (focused && focused.hasAttribute(\"dlgtype\"))\n            this.focus();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_initPages\">\n        <body><![CDATA[\n          var meth = \"sequential\";\n          var pages = this.wizardPages;\n          for (var i = 0; i < pages.length; ++i) {\n            var page = pages[i];\n            page.pageIndex = i;\n            if (page.next != \"\")\n              meth = \"random\";\n          }\n          this._accessMethod = meth;\n        ]]></body>\n      </method>\n\n      <method name=\"_adjustWizardHeader\">\n        <body><![CDATA[\n          var label = this.currentPage.getAttribute(\"label\");\n          if (!label && this.onFirstPage && this._bundle) {\n            if (/Mac/.test(navigator.platform)) {\n              label = this._bundle.GetStringFromName(\"default-first-title-mac\");\n            } else {\n              label = this._bundle.formatStringFromName(\"default-first-title\", [this.title], 1);\n            }\n          } else if (!label && this.onLastPage && this._bundle) {\n            if (/Mac/.test(navigator.platform)) {\n              label = this._bundle.GetStringFromName(\"default-last-title-mac\");\n            } else {\n              label = this._bundle.formatStringFromName(\"default-last-title\", [this.title], 1);\n            }\n          }\n          this._wizardHeader.\n            querySelector(\".wizard-header-label\").textContent = label;\n          let headerDescEl =\n            this._wizardHeader.querySelector(\".wizard-header-description\");\n          if (headerDescEl) {\n            headerDescEl.textContent =\n              this.currentPage.getAttribute(\"description\");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_hitEnter\">\n        <parameter name=\"evt\"/>\n        <body>\n        <![CDATA[\n          if (!evt.defaultPrevented)\n            this.advance();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_fireEvent\">\n        <parameter name=\"aTarget\"/>\n        <parameter name=\"aType\"/>\n        <body>\n        <![CDATA[\n          var event = document.createEvent(\"Events\");\n          event.initEvent(aType, true, true);\n\n          // handle dom event handlers\n          return aTarget.dispatchEvent(event);\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\"\n               group=\"system\" action=\"this._hitEnter(event)\"/>\n      <handler event=\"keypress\" keycode=\"VK_ESCAPE\" group=\"system\">\n        if (!event.defaultPrevented)\n          this.cancel();\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"extensions.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE page [\n<!ENTITY % extensionsDTD SYSTEM \"chrome://mozapps/locale/extensions/extensions.dtd\">\n%extensionsDTD;\n]>\n\n<!-- import-globals-from extensions.js -->\n\n<bindings id=\"addonBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\">\n\n\n  <!-- Rating - displays current/average rating, allows setting user rating -->\n  <binding id=\"rating\">\n    <content>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(1);\"\n                 onclick=\"document.getBindingParent(this).userRating = 1;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(2);\"\n                 onclick=\"document.getBindingParent(this).userRating = 2;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(3);\"\n                 onclick=\"document.getBindingParent(this).userRating = 3;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(4);\"\n                 onclick=\"document.getBindingParent(this).userRating = 4;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(5);\"\n                 onclick=\"document.getBindingParent(this).userRating = 5;\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._updateStars();\n      ]]></constructor>\n\n      <property name=\"stars\" readonly=\"true\">\n        <getter><![CDATA[\n          return document.getAnonymousNodes(this);\n        ]]></getter>\n      </property>\n\n      <property name=\"averageRating\">\n        <getter><![CDATA[\n          if (this.hasAttribute(\"averagerating\"))\n            return this.getAttribute(\"averagerating\");\n          return -1;\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"averagerating\", val);\n          if (this.showRating == \"average\")\n            this._updateStars();\n        ]]></setter>\n      </property>\n\n      <property name=\"userRating\">\n        <getter><![CDATA[\n          if (this.hasAttribute(\"userrating\"))\n            return this.getAttribute(\"userrating\");\n          return -1;\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.showRating != \"user\")\n            return;\n          this.setAttribute(\"userrating\", val);\n          if (this.showRating == \"user\")\n            this._updateStars();\n        ]]></setter>\n      </property>\n\n      <property name=\"showRating\">\n        <getter><![CDATA[\n          if (this.hasAttribute(\"showrating\"))\n            return this.getAttribute(\"showrating\");\n          return \"average\";\n        ]]></getter>\n        <setter><![CDATA[\n          if (val != \"average\" || val != \"user\")\n            throw Components.Exception(\"Invalid value\", Cr.NS_ERROR_ILLEGAL_VALUE);\n          this.setAttribute(\"showrating\", val);\n          this._updateStars();\n        ]]></setter>\n      </property>\n\n      <method name=\"_updateStars\">\n        <body><![CDATA[\n          var stars = this.stars;\n          var rating = this[this.showRating + \"Rating\"];\n          // average ratings can be non-whole numbers, round them so they\n          // match to their closest star\n          rating = Math.round(rating);\n          for (let i = 0; i < stars.length; i++)\n            stars[i].setAttribute(\"on\", rating > i);\n        ]]></body>\n      </method>\n\n      <method name=\"_hover\">\n        <parameter name=\"aScore\"/>\n        <body><![CDATA[\n          if (this.showRating != \"user\")\n            return;\n          var stars = this.stars;\n          for (let i = 0; i < stars.length; i++)\n            stars[i].setAttribute(\"on\", i <= (aScore - 1));\n        ]]></body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"mouseout\">\n        this._updateStars();\n      </handler>\n    </handlers>\n  </binding>\n\n  <!-- Download progress - shows graphical progress of download and any\n       related status message. -->\n  <binding id=\"download-progress\">\n    <content>\n      <xul:stack flex=\"1\">\n        <xul:hbox flex=\"1\">\n          <xul:hbox class=\"start-cap\"/>\n          <html:progress anonid=\"progress\" class=\"progress\" max=\"100\"/>\n          <xul:hbox class=\"end-cap\"/>\n        </xul:hbox>\n        <xul:hbox class=\"status-container\">\n          <xul:spacer flex=\"1\"/>\n          <xul:label anonid=\"status\" class=\"status\"/>\n          <xul:spacer flex=\"1\"/>\n          <xul:button anonid=\"cancel-btn\" class=\"cancel\"\n                      tooltiptext=\"FROM-DTD.progress.cancel.tooltip;\"\n                      oncommand=\"document.getBindingParent(this).cancel();\"/>\n        </xul:hbox>\n      </xul:stack>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        var progress = 0;\n        if (this.hasAttribute(\"progress\"))\n          progress = parseInt(this.getAttribute(\"progress\"));\n        this.progress = progress;\n      ]]></constructor>\n\n      <field name=\"_progress\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"progress\");\n      </field>\n      <field name=\"_cancel\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"cancel-btn\");\n      </field>\n      <field name=\"_status\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"status\");\n      </field>\n\n      <property name=\"progress\">\n        <setter><![CDATA[\n          // This property is always updated after maxProgress.\n          if (this.getAttribute(\"mode\") == \"determined\") {\n            this._progress.value = val;\n          }\n          if (val == this._progress.max)\n            this.setAttribute(\"complete\", true);\n          else\n            this.removeAttribute(\"complete\");\n        ]]></setter>\n      </property>\n\n      <property name=\"maxProgress\">\n        <setter><![CDATA[\n          if (val == -1) {\n            this.setAttribute(\"mode\", \"undetermined\");\n            this._progress.removeAttribute(\"value\");\n          } else {\n            this.setAttribute(\"mode\", \"determined\");\n            this._progress.setAttribute(\"max\", val);\n          }\n        ]]></setter>\n      </property>\n\n      <property name=\"status\">\n        <getter><![CDATA[\n          return this._status.value;\n        ]]></getter>\n        <setter><![CDATA[\n          this._status.value = val;\n        ]]></setter>\n      </property>\n\n      <method name=\"cancel\">\n        <body><![CDATA[\n          this.mInstall.cancel();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n  <!-- Category item - an item in the category list. -->\n  <binding id=\"category\"\n           extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <content align=\"center\">\n      <xul:image anonid=\"icon\" class=\"category-icon\"/>\n      <xul:label anonid=\"name\" class=\"category-name\" crop=\"end\" flex=\"1\" xbl:inherits=\"value=name\"/>\n      <xul:label anonid=\"badge\" class=\"category-badge\" xbl:inherits=\"value=count\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (!this.hasAttribute(\"count\"))\n          this.setAttribute(\"count\", 0);\n      ]]></constructor>\n\n      <property name=\"badgeCount\">\n        <getter><![CDATA[\n          return this.getAttribute(\"count\");\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.getAttribute(\"count\") == val)\n            return;\n\n          this.setAttribute(\"count\", val);\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"CategoryBadgeUpdated\", true, true);\n          this.dispatchEvent(event);\n        ]]></setter>\n      </property>\n    </implementation>\n  </binding>\n\n\n  <!-- Creator link - Name of a user/developer, providing a link if relevant. -->\n  <binding id=\"creator-link\">\n    <content>\n      <xul:label anonid=\"label\" value=\"FROM-DTD.addon.createdBy.label;\"/>\n      <xul:label anonid=\"creator-link\" class=\"creator-link\" is=\"text-link\"/>\n      <xul:label anonid=\"creator-name\" class=\"creator-name\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (this.hasAttribute(\"nameonly\") &&\n            this.getAttribute(\"nameonly\") == \"true\") {\n          this._label.hidden = true;\n        }\n      ]]></constructor>\n\n      <field name=\"_label\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"label\");\n      </field>\n      <field name=\"_creatorLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"creator-link\");\n      </field>\n      <field name=\"_creatorName\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"creator-name\");\n      </field>\n\n      <method name=\"setCreator\">\n        <parameter name=\"aCreator\"/>\n        <parameter name=\"aHomepageURL\"/>\n        <body><![CDATA[\n          if (!aCreator) {\n            this.collapsed = true;\n            return;\n          }\n          this.collapsed = false;\n          var url = aCreator.url || aHomepageURL;\n          var showLink = !!url;\n          if (showLink) {\n            this._creatorLink.value = aCreator.name;\n            this._creatorLink.href = url;\n          } else {\n            this._creatorName.value = aCreator.name;\n          }\n          this._creatorLink.hidden = !showLink;\n          this._creatorName.hidden = showLink;\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Install status - Displays the status of an install/upgrade. -->\n  <binding id=\"install-status\">\n    <content>\n      <xul:label anonid=\"message\"/>\n      <xul:box anonid=\"progress\" class=\"download-progress\"/>\n      <xul:button anonid=\"install-remote-btn\" hidden=\"true\"\n                  class=\"addon-control install\" label=\"FROM-DTD.addon.install.label;\"\n                  tooltiptext=\"FROM-DTD.addon.install.tooltip;\"\n                  oncommand=\"document.getBindingParent(this).installRemote();\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (this.mInstall)\n          this.initWithInstall(this.mInstall);\n        else if (this.mControl.mAddon.install)\n          this.initWithInstall(this.mControl.mAddon.install);\n        else\n          this.refreshState();\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        if (this.mInstall)\n          this.mInstall.removeListener(this);\n      ]]></destructor>\n\n      <field name=\"_message\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"message\");\n      </field>\n      <field name=\"_progress\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"progress\");\n      </field>\n      <field name=\"_installRemote\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"install-remote-btn\");\n      </field>\n      <field name=\"_undo\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"undo-btn\");\n      </field>\n\n      <method name=\"initWithInstall\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          if (this.mInstall) {\n            this.mInstall.removeListener(this);\n            this.mInstall = null;\n          }\n          this.mInstall = aInstall;\n          this._progress.mInstall = aInstall;\n          this.refreshState();\n          this.mInstall.addListener(this);\n        ]]></body>\n      </method>\n\n      <method name=\"refreshState\">\n        <body><![CDATA[\n          var showInstallRemote = false;\n\n          if (this.mInstall) {\n            switch (this.mInstall.state) {\n              case AddonManager.STATE_AVAILABLE:\n                if (this.mControl.getAttribute(\"remote\") != \"true\")\n                  break;\n\n                this._progress.hidden = true;\n                showInstallRemote = true;\n                break;\n              case AddonManager.STATE_DOWNLOADING:\n                this.showMessage(\"installDownloading\");\n                break;\n              case AddonManager.STATE_CHECKING:\n                this.showMessage(\"installVerifying\");\n                break;\n              case AddonManager.STATE_DOWNLOADED:\n                this.showMessage(\"installDownloaded\");\n                break;\n              case AddonManager.STATE_DOWNLOAD_FAILED:\n                // XXXunf expose what error occured (bug 553487)\n                this.showMessage(\"installDownloadFailed\", true);\n                break;\n              case AddonManager.STATE_INSTALLING:\n                this.showMessage(\"installInstalling\");\n                break;\n              case AddonManager.STATE_INSTALL_FAILED:\n                // XXXunf expose what error occured (bug 553487)\n                this.showMessage(\"installFailed\", true);\n                break;\n              case AddonManager.STATE_CANCELLED:\n                this.showMessage(\"installCancelled\", true);\n                break;\n            }\n          }\n\n          this._installRemote.hidden = !showInstallRemote;\n\n          if (\"refreshInfo\" in this.mControl)\n            this.mControl.refreshInfo();\n        ]]></body>\n      </method>\n\n      <method name=\"showMessage\">\n        <parameter name=\"aMsgId\"/>\n        <parameter name=\"aHideProgress\"/>\n        <body><![CDATA[\n          this._message.setAttribute(\"hidden\", !aHideProgress);\n          this._progress.setAttribute(\"hidden\", !!aHideProgress);\n\n          var msg = gStrings.ext.GetStringFromName(aMsgId);\n          if (aHideProgress)\n            this._message.value = msg;\n          else\n            this._progress.status = msg;\n        ]]></body>\n      </method>\n\n      <method name=\"installRemote\">\n        <body><![CDATA[\n          if (this.mControl.getAttribute(\"remote\") != \"true\")\n            return;\n\n          delete this.mControl.mAddon;\n          this.mControl.mInstall = this.mInstall;\n          this.mControl.setAttribute(\"status\", \"installing\");\n          let prompt = Services.prefs.getBoolPref(\"extensions.webextPermissionPrompts\", false);\n          if (prompt) {\n            this.mInstall.promptHandler = info => new Promise((resolve, reject) => {\n              // Skip prompts for non-webextensions\n              if (!info.addon.userPermissions) {\n                resolve();\n                return;\n              }\n              let subject = {\n                wrappedJSObject: {\n                  target: window.docShell.chromeEventHandler,\n                  info: {\n                    addon: info.addon,\n                    source: \"AMO\",\n                    icon: info.addon.iconURL,\n                    permissions: info.addon.userPermissions,\n                    resolve,\n                    reject,\n                  },\n                },\n              };\n              Services.obs.notifyObservers(subject, \"webextension-permission-prompt\");\n            });\n          }\n          this.mInstall.install();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadStarted\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadEnded\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadFailed\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadProgress\">\n        <body><![CDATA[\n          this._progress.maxProgress = this.mInstall.maxProgress;\n          this._progress.progress = this.mInstall.progress;\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallStarted\">\n        <body><![CDATA[\n          this._progress.progress = 0;\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallEnded\">\n        <body><![CDATA[\n          this.refreshState();\n          if (\"onInstallCompleted\" in this.mControl)\n            this.mControl.onInstallCompleted();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallFailed\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Addon - base - parent binding of any item representing an addon. -->\n  <binding id=\"addon-base\"\n           extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <implementation>\n      <property name=\"isLegacy\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.mAddon.install) {\n            return false;\n          }\n          return isLegacyExtension(this.mAddon);\n        ]]></getter>\n      </property>\n\n      <method name=\"hasPermission\">\n        <parameter name=\"aPerm\"/>\n        <body><![CDATA[\n          var perm = AddonManager[\"PERM_CAN_\" + aPerm.toUpperCase()];\n          return !!(this.mAddon.permissions & perm);\n        ]]></body>\n      </method>\n\n      <method name=\"isPending\">\n        <parameter name=\"aAction\"/>\n        <body><![CDATA[\n          var action = AddonManager[\"PENDING_\" + aAction.toUpperCase()];\n          return !!(this.mAddon.pendingOperations & action);\n        ]]></body>\n      </method>\n\n      <method name=\"typeHasFlag\">\n        <parameter name=\"aFlag\"/>\n        <body><![CDATA[\n          let flag = AddonManager[\"TYPE_\" + aFlag];\n          let type = AddonManager.addonTypes[this.mAddon.type];\n\n          return !!(type.flags & flag);\n        ]]></body>\n      </method>\n\n      <method name=\"onUninstalled\">\n        <body><![CDATA[\n          this.remove();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Addon - generic - A normal addon item, or an update to one -->\n  <binding id=\"addon-generic\"\n           extends=\"chrome://mozapps/content/extensions/extensions.xml#addon-base\">\n    <content tooltiptext=\"FROM-DTD.addon.details.tooltip;\">\n      <xul:hbox anonid=\"warning-container\"\n                class=\"warning\">\n        <xul:image class=\"warning-icon\"/>\n        <xul:label anonid=\"warning\" flex=\"1\"/>\n        <xul:label anonid=\"warning-link\" is=\"text-link\"/>\n        <xul:button anonid=\"warning-btn\" class=\"button-link\" hidden=\"true\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n      <xul:hbox anonid=\"error-container\"\n                class=\"error\">\n        <xul:image class=\"error-icon\"/>\n        <xul:label anonid=\"error\" flex=\"1\"/>\n        <xul:label anonid=\"error-link\" hidden=\"true\" is=\"text-link\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n      <xul:hbox anonid=\"pending-container\"\n                class=\"pending\">\n        <xul:image class=\"pending-icon\"/>\n        <xul:label anonid=\"pending\" flex=\"1\"/>\n        <xul:button anonid=\"undo-btn\" class=\"button-link\"\n                    label=\"FROM-DTD.addon.undoAction.label;\"\n                    tooltipText=\"FROM-DTD.addon.undoAction.tooltip;\"\n                    oncommand=\"document.getBindingParent(this).undo();\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n\n      <xul:image class=\"card-heading-image\" anonid=\"theme-screenshot\" xbl:inherits=\"src=previewURL\"/>\n\n      <xul:hbox class=\"content-container\">\n        <xul:vbox class=\"icon-container\">\n          <xul:image anonid=\"icon\" class=\"icon\"/>\n        </xul:vbox>\n        <xul:vbox class=\"content-inner-container\" flex=\"1\">\n          <xul:hbox class=\"basicinfo-container\">\n              <xul:hbox class=\"name-container\">\n                <xul:label anonid=\"name\" class=\"name\" crop=\"end\" flex=\"1\"\n                           tooltip=\"addonitem-tooltip\" xbl:inherits=\"xbl:text=name\"/>\n                <xul:label anonid=\"legacy\" class=\"legacy-warning\" value=\"FROM-DTD.addon.legacy.label;\" is=\"text-link\"/>\n                <xul:label class=\"disabled-postfix\" value=\"FROM-DTD.addon.disabled.postfix;\"/>\n                <xul:label class=\"update-postfix\" value=\"FROM-DTD.addon.update.postfix;\"/>\n                <xul:spacer flex=\"5000\"/> <!-- Necessary to make the name crop -->\n              </xul:hbox>\n            <xul:label anonid=\"date-updated\" class=\"date-updated\"\n                       unknown=\"FROM-DTD.addon.unknownDate;\"/>\n          </xul:hbox>\n\n          <xul:hbox class=\"advancedinfo-container\" flex=\"1\">\n            <xul:vbox class=\"description-outer-container\" flex=\"1\">\n              <xul:hbox class=\"description-container\">\n                <xul:label anonid=\"description\" class=\"description\" crop=\"end\" flex=\"1\"/>\n                <xul:spacer flex=\"5000\"/> <!-- Necessary to make the description crop -->\n              </xul:hbox>\n              <xul:hbox class=\"relnotes-toggle-container\">\n                <xul:button anonid=\"relnotes-toggle-btn\" class=\"relnotes-toggle\"\n                            hidden=\"true\" label=\"FROM-DTD.cmd.showReleaseNotes.label;\"\n                            tooltiptext=\"FROM-DTD.cmd.showReleaseNotes.tooltip;\"\n                            showlabel=\"FROM-DTD.cmd.showReleaseNotes.label;\"\n                            showtooltip=\"FROM-DTD.cmd.showReleaseNotes.tooltip;\"\n                            hidelabel=\"FROM-DTD.cmd.hideReleaseNotes.label;\"\n                            hidetooltip=\"FROM-DTD.cmd.hideReleaseNotes.tooltip;\"\n                            oncommand=\"document.getBindingParent(this).toggleReleaseNotes();\"/>\n              </xul:hbox>\n              <xul:vbox anonid=\"relnotes-container\" class=\"relnotes-container\">\n                <xul:label class=\"relnotes-header\" value=\"FROM-DTD.addon.releaseNotes.label;\"/>\n                <xul:label anonid=\"relnotes-loading\" value=\"FROM-DTD.addon.loadingReleaseNotes.label;\"/>\n                <xul:label anonid=\"relnotes-error\" hidden=\"true\"\n                           value=\"FROM-DTD.addon.errorLoadingReleaseNotes.label;\"/>\n                <xul:vbox anonid=\"relnotes\" class=\"relnotes\"/>\n              </xul:vbox>\n            </xul:vbox>\n          </xul:hbox>\n        </xul:vbox>\n        <xul:vbox class=\"status-control-wrapper\">\n          <xul:hbox class=\"status-container\">\n            <xul:hbox anonid=\"checking-update\" hidden=\"true\">\n              <xul:image class=\"spinner\"/>\n              <xul:label value=\"FROM-DTD.addon.checkingForUpdates.label;\"/>\n            </xul:hbox>\n            <xul:vbox anonid=\"update-available\" class=\"update-available\"\n                      hidden=\"true\">\n              <xul:checkbox anonid=\"include-update\" class=\"include-update\"\n                            label=\"FROM-DTD.addon.includeUpdate.label;\" checked=\"true\"\n                            oncommand=\"document.getBindingParent(this).onIncludeUpdateChanged();\"/>\n              <xul:hbox class=\"update-info-container\">\n                <xul:label class=\"update-available-notice\"\n                           value=\"FROM-DTD.addon.updateAvailable.label;\"/>\n                <xul:button anonid=\"update-btn\" class=\"addon-control update\"\n                            label=\"FROM-DTD.addon.updateNow.label;\"\n                            tooltiptext=\"FROM-DTD.addon.updateNow.tooltip;\"\n                            oncommand=\"document.getBindingParent(this).upgrade();\"/>\n              </xul:hbox>\n            </xul:vbox>\n            <xul:hbox anonid=\"install-status\" class=\"install-status\"\n                      hidden=\"true\"/>\n          </xul:hbox>\n          <xul:hbox anonid=\"control-container\" class=\"control-container\" flex=\"1\">\n            <xul:button anonid=\"preferences-btn\"\n                        class=\"addon-control preferences\"\n\n                        label=\"FROM-DTD.cmd.showPreferencesWin.label;\"\n                        tooltiptext=\"FROM-DTD.cmd.showPreferencesWin.tooltip;\"\n\n                        oncommand=\"document.getBindingParent(this).showPreferences();\"/>\n            <xul:button anonid=\"enable-btn\"  class=\"addon-control enable\"\n                        label=\"FROM-DTD.cmd.enableAddon.label;\"\n                        oncommand=\"document.getBindingParent(this).userDisabled = false;\"/>\n            <xul:button anonid=\"disable-btn\" class=\"addon-control disable\"\n                        label=\"FROM-DTD.cmd.disableAddon.label;\"\n                        oncommand=\"document.getBindingParent(this).userDisabled = true;\"/>\n            <xul:button anonid=\"replacement-btn\" class=\"addon-control replacement\"\n                        label=\"FROM-DTD.cmd.findReplacement.label;\"\n                        oncommand=\"document.getBindingParent(this).findReplacement();\"/>\n            <xul:button anonid=\"remove-btn\" class=\"addon-control remove\"\n                        label=\"FROM-DTD.cmd.uninstallAddon.label;\"\n                        oncommand=\"document.getBindingParent(this).uninstall();\"/>\n            <xul:menulist anonid=\"state-menulist\"\n                          class=\"addon-control state\"\n                          flex=\"1\"\n                          tooltiptext=\"FROM-DTD.cmd.stateMenu.tooltip;\">\n              <xul:menupopup>\n                <xul:menuitem anonid=\"ask-to-activate-menuitem\"\n                              class=\"addon-control\"\n                              label=\"FROM-DTD.cmd.askToActivate.label;\"\n                              tooltiptext=\"FROM-DTD.cmd.askToActivate.tooltip;\"\n                              oncommand=\"document.getBindingParent(this).userDisabled = AddonManager.STATE_ASK_TO_ACTIVATE;\"/>\n                <xul:menuitem anonid=\"always-activate-menuitem\"\n                              class=\"addon-control\"\n                              label=\"FROM-DTD.cmd.alwaysActivate.label;\"\n                              tooltiptext=\"FROM-DTD.cmd.alwaysActivate.tooltip;\"\n                              oncommand=\"document.getBindingParent(this).userDisabled = false;\"/>\n                <xul:menuitem anonid=\"never-activate-menuitem\"\n                              class=\"addon-control\"\n                              label=\"FROM-DTD.cmd.neverActivate.label;\"\n                              tooltiptext=\"FROM-DTD.cmd.neverActivate.tooltip;\"\n                              oncommand=\"document.getBindingParent(this).userDisabled = true;\"/>\n              </xul:menupopup>\n            </xul:menulist>\n          </xul:hbox>\n        </xul:vbox>\n      </xul:hbox>\n      <xul:hbox class=\"description-container privateBrowsing-notice-container\">\n        <xul:label anonid=\"privateBrowsing\" class=\"description privateBrowsing-notice\" value=\"FROM-DTD.addon.privateBrowsing.label;\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        window.customElements.upgrade(this._stateMenulist);\n        window.customElements.upgrade(this._enableBtn);\n        window.customElements.upgrade(this._disableBtn);\n        window.customElements.upgrade(this._askToActivateMenuitem);\n        window.customElements.upgrade(this._alwaysActivateMenuitem);\n        window.customElements.upgrade(this._neverActivateMenuitem);\n\n        this._installStatus = document.getAnonymousElementByAttribute(this, \"anonid\", \"install-status\");\n        this._installStatus.mControl = this;\n\n        this.setAttribute(\"contextmenu\", \"addonitem-popup\");\n\n        this._showStatus(\"none\");\n\n        this._initWithAddon(this.mAddon);\n\n        gEventManager.registerAddonListener(this, this.mAddon.id);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        gEventManager.unregisterAddonListener(this, this.mAddon.id);\n      ]]></destructor>\n\n      <field name=\"_warningContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning-container\");\n      </field>\n      <field name=\"_warning\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning\");\n      </field>\n      <field name=\"_warningLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning-link\");\n      </field>\n      <field name=\"_warningBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning-btn\");\n      </field>\n      <field name=\"_errorContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"error-container\");\n      </field>\n      <field name=\"_error\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"error\");\n      </field>\n      <field name=\"_errorLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"error-link\");\n      </field>\n      <field name=\"_pendingContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"pending-container\");\n      </field>\n      <field name=\"_pending\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"pending\");\n      </field>\n      <field name=\"_infoContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"info-container\");\n      </field>\n      <field name=\"_info\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"info\");\n      </field>\n      <field name=\"_icon\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"icon\");\n      </field>\n      <field name=\"_dateUpdated\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"date-updated\");\n      </field>\n      <field name=\"_description\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"description\");\n      </field>\n      <field name=\"_stateMenulist\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"state-menulist\");\n      </field>\n      <field name=\"_askToActivateMenuitem\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"ask-to-activate-menuitem\");\n      </field>\n      <field name=\"_alwaysActivateMenuitem\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"always-activate-menuitem\");\n      </field>\n      <field name=\"_neverActivateMenuitem\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"never-activate-menuitem\");\n      </field>\n      <field name=\"_preferencesBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"preferences-btn\");\n      </field>\n      <field name=\"_enableBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"enable-btn\");\n      </field>\n      <field name=\"_disableBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"disable-btn\");\n      </field>\n      <field name=\"_removeBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"remove-btn\");\n      </field>\n      <field name=\"_updateBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"update-btn\");\n      </field>\n      <field name=\"_controlContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"control-container\");\n      </field>\n      <field name=\"_installStatus\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"install-status\");\n      </field>\n      <field name=\"_checkingUpdate\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"checking-update\");\n      </field>\n      <field name=\"_updateAvailable\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"update-available\");\n      </field>\n      <field name=\"_includeUpdate\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"include-update\");\n      </field>\n      <field name=\"_relNotesLoaded\">false</field>\n      <field name=\"_relNotesToggle\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-toggle-btn\");\n      </field>\n      <field name=\"_relNotesLoading\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-loading\");\n      </field>\n      <field name=\"_relNotesError\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-error\");\n      </field>\n      <field name=\"_relNotesContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-container\");\n      </field>\n      <field name=\"_relNotes\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes\");\n      </field>\n\n      <property name=\"userDisabled\">\n        <getter><![CDATA[\n          return this.mAddon.userDisabled;\n        ]]></getter>\n        <setter><![CDATA[\n          if (val === true) {\n            gViewController.commands.cmd_disableItem.doCommand(this.mAddon);\n          } else if (val === false) {\n            gViewController.commands.cmd_enableItem.doCommand(this.mAddon);\n          } else {\n            this.mAddon.userDisabled = val;\n          }\n        ]]></setter>\n      </property>\n\n      <property name=\"includeUpdate\">\n        <getter><![CDATA[\n          return this._includeUpdate.checked && !!this.mManualUpdate;\n        ]]></getter>\n        <setter><![CDATA[\n          // XXXunf Eventually, we'll want to persist this for individual\n          //        updates - see bug 594619.\n          this._includeUpdate.checked = !!val;\n        ]]></setter>\n      </property>\n\n      <method name=\"_initWithAddon\">\n        <parameter name=\"aAddon\"/>\n        <body><![CDATA[\n          this.mAddon = aAddon;\n\n          this._installStatus.mAddon = this.mAddon;\n          this._updateDates();\n          this._updateState();\n\n          this.setAttribute(\"name\", aAddon.name);\n\n          var iconURL = AddonManager.getPreferredIconURL(aAddon, 24, window);\n          if (iconURL)\n            this._icon.src = iconURL;\n          else\n            this._icon.src = \"\";\n\n          if (this.mAddon.description)\n            this._description.value = this.mAddon.description;\n          else\n            this._description.hidden = true;\n\n          // Set a previewURL for themes if one exists.\n          let previewURL = this.mAddon.type == \"theme\" &&\n            this.mAddon.screenshots &&\n            this.mAddon.screenshots[0] &&\n            this.mAddon.screenshots[0].url;\n          this.setAttribute(\"previewURL\", previewURL ? previewURL : \"\");\n          this.setAttribute(\"hasPreview\", previewURL ? \"true\" : \"fase\");\n\n          let legacyWarning = legacyExtensionsEnabled && !this.mAddon.install &&\n            isLegacyExtension(this.mAddon);\n          this.setAttribute(\"legacy\", legacyWarning);\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"legacy\").href = SUPPORT_URL + \"webextensions\";\n\n          if (!allowPrivateBrowsingByDefault && this.mAddon.type === \"extension\") {\n            ExtensionPermissions.get(this.mAddon.id).then((perms) => {\n              let allowed = perms.permissions.includes(\"internal:privateBrowsingAllowed\");\n              this.setAttribute(\"privateBrowsing\", allowed);\n              if (!allowed && PrivateBrowsingUtils.isContentWindowPrivate(window)) {\n                // Hide the preferences button if the current window is\n                // private and the addon is not allowed to access it.\n                this._preferencesBtn.hidden = true;\n              }\n            });\n          }\n\n          if (!(\"applyBackgroundUpdates\" in this.mAddon) ||\n              (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DISABLE ||\n               (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DEFAULT &&\n                !AddonManager.autoUpdateDefault))) {\n            AddonManager.getAllInstalls().then(aInstallsList => {\n              // This can return after the binding has been destroyed,\n              // so try to detect that and return early\n              if (!(\"onNewInstall\" in this))\n                return;\n              for (let install of aInstallsList) {\n                if (install.existingAddon &&\n                    install.existingAddon.id == this.mAddon.id &&\n                    install.state == AddonManager.STATE_AVAILABLE) {\n                  this.onNewInstall(install);\n                  this.onIncludeUpdateChanged();\n                }\n              }\n            });\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_showStatus\">\n        <parameter name=\"aType\"/>\n        <body><![CDATA[\n          this._controlContainer.hidden = aType != \"none\" &&\n                                          !(aType == \"update-available\" && !this.hasAttribute(\"upgrade\"));\n\n          this._installStatus.hidden = aType != \"progress\";\n          if (aType == \"progress\")\n            this._installStatus.refreshState();\n          this._checkingUpdate.hidden = aType != \"checking-update\";\n          this._updateAvailable.hidden = aType != \"update-available\";\n          this._relNotesToggle.hidden = !(this.mManualUpdate ?\n                                          this.mManualUpdate.releaseNotesURI :\n                                          this.mAddon.releaseNotesURI);\n        ]]></body>\n      </method>\n\n      <method name=\"_updateDates\">\n        <body><![CDATA[\n          function formatDate(aDate) {\n            const dtOptions = { year: \"numeric\", month: \"long\", day: \"numeric\" };\n            return aDate.toLocaleDateString(undefined, dtOptions);\n          }\n\n          if (this.mAddon.updateDate)\n            this._dateUpdated.value = formatDate(this.mAddon.updateDate);\n          else\n            this._dateUpdated.value = this._dateUpdated.getAttribute(\"unknown\");\n        ]]></body>\n      </method>\n\n      <method name=\"_updateState\">\n        <body><![CDATA[\n          if (this.parentNode.selectedItem == this)\n            gViewController.updateCommands();\n\n          var pending = this.mAddon.pendingOperations;\n          if (pending & AddonManager.PENDING_UNINSTALL) {\n            this.removeAttribute(\"notification\");\n\n            // We don't care about pending operations other than uninstall.\n            // They're transient, and cannot be undone.\n            this.setAttribute(\"pending\", \"uninstall\");\n            this._pending.textContent = gStrings.ext.formatStringFromName(\n              \"notification.restartless-uninstall\",\n              [this.mAddon.name], 1);\n          } else {\n            this.removeAttribute(\"pending\");\n\n            var isUpgrade = this.hasAttribute(\"upgrade\");\n            var install = this._installStatus.mInstall;\n\n            if (install && install.state == AddonManager.STATE_DOWNLOAD_FAILED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.downloadError\",\n                [this.mAddon.name], 1\n              );\n              this._warningBtn.label = gStrings.ext.GetStringFromName(\"notification.downloadError.retry\");\n              this._warningBtn.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n              this._warningBtn.setAttribute(\"oncommand\", \"document.getBindingParent(this).retryInstall();\");\n              this._warningBtn.hidden = false;\n              this._warningLink.hidden = true;\n            } else if (install && install.state == AddonManager.STATE_INSTALL_FAILED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.installError\",\n                [this.mAddon.name], 1\n              );\n              this._warningBtn.label = gStrings.ext.GetStringFromName(\"notification.installError.retry\");\n              this._warningBtn.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n              this._warningBtn.setAttribute(\"oncommand\", \"document.getBindingParent(this).retryInstall();\");\n              this._warningBtn.hidden = false;\n              this._warningLink.hidden = true;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_BLOCKED) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.blocked\",\n                [this.mAddon.name], 1\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.blocked.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._errorLink.href = url;\n                this._errorLink.hidden = false;\n              });\n            } else if (!isUpgrade && isDisabledUnsigned(this.mAddon)) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.unsignedAndDisabled\", [this.mAddon.name, gStrings.brandShortName], 2\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.unsigned.link\");\n              this._errorLink.href = SUPPORT_URL + \"unsigned-addons\";\n              this._errorLink.hidden = false;\n            } else if ((!isUpgrade && !this.mAddon.isCompatible) && (AddonManager.checkCompatibility\n            || (this.mAddon.blocklistState != Ci.nsIBlocklistService.STATE_SOFTBLOCKED))) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.incompatible\",\n                [this.mAddon.name, gStrings.brandShortName, gStrings.appVersion], 3\n              );\n              this._warningLink.hidden = true;\n              this._warningBtn.hidden = true;\n            } else if (!isUpgrade && !isCorrectlySigned(this.mAddon)) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.unsigned\", [this.mAddon.name, gStrings.brandShortName], 2\n              );\n              this._warningLink.value = gStrings.ext.GetStringFromName(\"notification.unsigned.link\");\n              this._warningLink.href = SUPPORT_URL + \"unsigned-addons\";\n              this._warningLink.hidden = false;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_SOFTBLOCKED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.softblocked\",\n                [this.mAddon.name], 1\n              );\n              this._warningLink.value = gStrings.ext.GetStringFromName(\"notification.softblocked.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._warningLink.href = url;\n                this._warningLink.hidden = false;\n              });\n              this._warningBtn.hidden = true;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_OUTDATED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.outdated\",\n                [this.mAddon.name], 1\n              );\n              this._warningLink.value = gStrings.ext.GetStringFromName(\"notification.outdated.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._warningLink.href = url;\n                this._warningLink.hidden = false;\n              });\n              this._warningBtn.hidden = true;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_VULNERABLE_UPDATE_AVAILABLE) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.vulnerableUpdatable\",\n                [this.mAddon.name], 1\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.vulnerableUpdatable.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._errorLink.href = url;\n                this._errorLink.hidden = false;\n              });\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_VULNERABLE_NO_UPDATE) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.vulnerableNoUpdate\",\n                [this.mAddon.name], 1\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.vulnerableNoUpdate.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._errorLink.href = url;\n                this._errorLink.hidden = false;\n              });\n            } else if (this.mAddon.isGMPlugin && !this.mAddon.isInstalled &&\n                       this.mAddon.isActive) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent =\n                gStrings.ext.formatStringFromName(\"notification.gmpPending\",\n                                                  [this.mAddon.name], 1);\n            } else {\n              this.removeAttribute(\"notification\");\n            }\n          }\n\n          this._preferencesBtn.hidden = !this.mAddon.optionsType && this.mAddon.type != \"plugin\";\n\n          if (this.typeHasFlag(\"SUPPORTS_ASK_TO_ACTIVATE\")) {\n            this._enableBtn.disabled = true;\n            this._disableBtn.disabled = true;\n            this._askToActivateMenuitem.disabled = !this.hasPermission(\"ask_to_activate\");\n            this._alwaysActivateMenuitem.disabled = !this.hasPermission(\"enable\");\n            this._neverActivateMenuitem.disabled = !this.hasPermission(\"disable\");\n            if (!this.mAddon.isActive) {\n              this._stateMenulist.selectedItem = this._neverActivateMenuitem;\n            } else if (this.mAddon.userDisabled == AddonManager.STATE_ASK_TO_ACTIVATE) {\n              this._stateMenulist.selectedItem = this._askToActivateMenuitem;\n            } else {\n              this._stateMenulist.selectedItem = this._alwaysActivateMenuitem;\n            }\n            let hasActivatePermission =\n              [\"ask_to_activate\", \"enable\", \"disable\"].some(perm => this.hasPermission(perm));\n            this._stateMenulist.disabled = !hasActivatePermission;\n            this._stateMenulist.hidden = false;\n            this._stateMenulist.classList.add(\"no-auto-hide\");\n          } else {\n            this._stateMenulist.hidden = true;\n\n            let enableTooltip = gViewController.commands.cmd_enableItem\n                                               .getTooltip(this.mAddon);\n            this._enableBtn.setAttribute(\"tooltiptext\", enableTooltip);\n            if (this.hasPermission(\"enable\")) {\n              this._enableBtn.hidden = false;\n            } else {\n              this._enableBtn.hidden = true;\n            }\n\n            let disableTooltip = gViewController.commands.cmd_disableItem\n                                                .getTooltip(this.mAddon);\n            this._disableBtn.setAttribute(\"tooltiptext\", disableTooltip);\n            if (this.hasPermission(\"disable\")) {\n              this._disableBtn.hidden = false;\n            } else {\n              this._disableBtn.hidden = true;\n            }\n          }\n\n          let uninstallTooltip = gViewController.commands.cmd_uninstallItem\n                                                .getTooltip(this.mAddon);\n          this._removeBtn.setAttribute(\"tooltiptext\", uninstallTooltip);\n          if (this.hasPermission(\"uninstall\")) {\n            this._removeBtn.hidden = false;\n          } else {\n            this._removeBtn.hidden = true;\n          }\n\n          this.setAttribute(\"active\", this.mAddon.isActive);\n\n          var showProgress = (this.mAddon.install &&\n                              this.mAddon.install.state != AddonManager.STATE_INSTALLED);\n          this._showStatus(showProgress ? \"progress\" : \"none\");\n        ]]></body>\n      </method>\n\n      <method name=\"_fetchReleaseNotes\">\n        <parameter name=\"aURI\"/>\n        <body><![CDATA[\n          let sendToggleEvent = () => {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"RelNotesToggle\", true, true);\n            this.dispatchEvent(event);\n          };\n\n          if (!aURI || this._relNotesLoaded) {\n            sendToggleEvent();\n            return;\n          }\n\n          this._relNotesLoaded = true;\n          this._relNotesLoading.hidden = false;\n          this._relNotesError.hidden = true;\n\n          loadReleaseNotes(aURI).then(fragment => {\n            this._relNotesLoading.hidden = true;\n            this._relNotes.appendChild(fragment);\n            if (this.hasAttribute(\"show-relnotes\")) {\n              var container = this._relNotesContainer;\n              container.style.height = container.scrollHeight + \"px\";\n            }\n            sendToggleEvent();\n          }, () => {\n            this._relNotesLoading.hidden = true;\n            this._relNotesError.hidden = false;\n            this._relNotesLoaded = false; // allow loading to be re-tried\n            sendToggleEvent();\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"toggleReleaseNotes\">\n        <body><![CDATA[\n          if (this.hasAttribute(\"show-relnotes\")) {\n            this._relNotesContainer.style.height = \"0px\";\n            this.removeAttribute(\"show-relnotes\");\n            this._relNotesToggle.setAttribute(\n              \"label\",\n              this._relNotesToggle.getAttribute(\"showlabel\")\n            );\n            this._relNotesToggle.setAttribute(\n              \"tooltiptext\",\n              this._relNotesToggle.getAttribute(\"showtooltip\")\n            );\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"RelNotesToggle\", true, true);\n            this.dispatchEvent(event);\n          } else {\n            this._relNotesContainer.style.height = this._relNotesContainer.scrollHeight +\n                                                   \"px\";\n            this.setAttribute(\"show-relnotes\", true);\n            this._relNotesToggle.setAttribute(\n              \"label\",\n              this._relNotesToggle.getAttribute(\"hidelabel\")\n            );\n            this._relNotesToggle.setAttribute(\n              \"tooltiptext\",\n              this._relNotesToggle.getAttribute(\"hidetooltip\")\n            );\n            var uri = this.mManualUpdate ?\n                      this.mManualUpdate.releaseNotesURI :\n                      this.mAddon.releaseNotesURI;\n            this._fetchReleaseNotes(uri);\n\n            // Dispatch an event so extensions.js can record telemetry.\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"RelNotesShow\", true, true);\n            this.dispatchEvent(event);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"undo\">\n        <body><![CDATA[\n          gViewController.commands.cmd_cancelOperation.doCommand(this.mAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"uninstall\">\n        <body><![CDATA[\n          // If the type doesn't support undoing of restartless uninstalls,\n          // then we fake it by just disabling it it, and doing the real\n          // uninstall later.\n          if (this.typeHasFlag(\"SUPPORTS_UNDO_RESTARTLESS_UNINSTALL\")) {\n            this.mAddon.uninstall(true);\n          } else {\n            this.setAttribute(\"wasDisabled\", this.mAddon.userDisabled);\n\n            // We must set userDisabled to true first, this will call\n            // _updateState which will clear any pending attribute set.\n            this.mAddon.disable().then(() => {\n              // This won't update any other add-on manager views (bug 582002)\n              this.setAttribute(\"pending\", \"uninstall\");\n            });\n          }\n\n          // Dispatch an event so extensions.js can track telemetry.\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"Uninstall\", true, true);\n          this.dispatchEvent(event);\n        ]]></body>\n      </method>\n\n      <method name=\"showPreferences\">\n        <body><![CDATA[\n          gViewController.doCommand(\"cmd_showItemPreferences\", this.mAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"upgrade\">\n        <body><![CDATA[\n          var install = this.mManualUpdate;\n          delete this.mManualUpdate;\n          install.install();\n        ]]></body>\n      </method>\n\n      <method name=\"retryInstall\">\n        <body><![CDATA[\n          var install = this._installStatus.mInstall;\n          if (!install)\n            return;\n          if (install.state != AddonManager.STATE_DOWNLOAD_FAILED &&\n              install.state != AddonManager.STATE_INSTALL_FAILED)\n            return;\n          install.install();\n        ]]></body>\n      </method>\n\n      <method name=\"showInDetailView\">\n        <body><![CDATA[\n          gViewController.loadView(\"addons://detail/\" +\n                                   encodeURIComponent(this.mAddon.id));\n        ]]></body>\n      </method>\n\n      <method name=\"findReplacement\">\n        <body><![CDATA[\n          let url = (this.mAddon.type == \"theme\") ?\n            SUPPORT_URL + \"complete-themes\" :\n            `https://addons.mozilla.org/find-replacement/?guid=${this.mAddon.id}`;\n            openURL(url);\n        ]]></body>\n      </method>\n\n      <method name=\"onIncludeUpdateChanged\">\n        <body><![CDATA[\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"IncludeUpdateChanged\", true, true);\n          this.dispatchEvent(event);\n        ]]></body>\n      </method>\n\n      <method name=\"onEnabling\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onEnabled\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDisabling\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDisabled\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onUninstalling\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onOperationCancelled\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onPropertyChanged\">\n        <parameter name=\"aProperties\"/>\n        <body><![CDATA[\n          if (aProperties.includes(\"appDisabled\") ||\n              aProperties.includes(\"signedState\") ||\n              aProperties.includes(\"userDisabled\"))\n            this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onUpdateAvailable\">\n        <body><![CDATA[\n          this._showStatus(\"update-available\");\n        ]]></body>\n      </method>\n\n      <method name=\"onNoUpdateAvailable\">\n        <body><![CDATA[\n          this._showStatus(\"none\");\n        ]]></body>\n      </method>\n\n      <method name=\"onCheckingUpdate\">\n        <body><![CDATA[\n          this._showStatus(\"checking-update\");\n        ]]></body>\n      </method>\n\n      <method name=\"onCompatibilityUpdateAvailable\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onExternalInstall\">\n        <parameter name=\"aAddon\"/>\n        <parameter name=\"aExistingAddon\"/>\n        <body><![CDATA[\n          if (aExistingAddon.id != this.mAddon.id)\n            return;\n\n          this._initWithAddon(aAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"onNewInstall\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          if (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_ENABLE)\n            return;\n          if (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DEFAULT &&\n              AddonManager.autoUpdateDefault)\n            return;\n\n          this.mManualUpdate = aInstall;\n          this._showStatus(\"update-available\");\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadStarted\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          this._updateState();\n          this._showStatus(\"progress\");\n          this._installStatus.initWithInstall(aInstall);\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallStarted\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          this._updateState();\n          this._showStatus(\"progress\");\n          this._installStatus.initWithInstall(aInstall);\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallEnded\">\n        <parameter name=\"aInstall\"/>\n        <parameter name=\"aAddon\"/>\n        <body><![CDATA[\n          this._initWithAddon(aAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadFailed\">\n        <body><![CDATA[\n            this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallFailed\">\n        <body><![CDATA[\n            this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallCancelled\">\n        <body><![CDATA[\n            this._updateState();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        if (![\"button\", \"checkbox\", \"menulist\", \"menuitem\"].includes(event.originalTarget.localName) &&\n            !event.originalTarget.classList.contains(\"text-link\") &&\n            // Treat the relnotes container as embedded text instead of a click target.\n            !event.originalTarget.closest(\".relnotes-container\")) {\n          this.showInDetailView();\n        } else if (event.originalTarget.localName == \"a\" &&\n                   event.originalTarget.closest(\".relnotes-container\") &&\n                   event.originalTarget.href) {\n          event.preventDefault();\n          event.stopPropagation();\n          openURL(event.originalTarget.href);\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n\n  <!-- Addon - uninstalled - An uninstalled addon that can be re-installed. -->\n  <binding id=\"addon-uninstalled\"\n           extends=\"chrome://mozapps/content/extensions/extensions.xml#addon-base\">\n    <content>\n      <xul:hbox class=\"pending\">\n        <xul:image class=\"pending-icon\"/>\n        <xul:label anonid=\"notice\" flex=\"1\"/>\n        <xul:button anonid=\"undo-btn\" class=\"button-link\"\n                    label=\"FROM-DTD.addon.undoRemove.label;\"\n                    tooltiptext=\"FROM-DTD.addon.undoRemove.tooltip;\"\n                    oncommand=\"document.getBindingParent(this).cancelUninstall();\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._notice.textContent = gStrings.ext.formatStringFromName(\"uninstallNotice\",\n                                                                     [this.mAddon.name],\n                                                                     1);\n\n        gEventManager.registerAddonListener(this, this.mAddon.id);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        gEventManager.unregisterAddonListener(this, this.mAddon.id);\n      ]]></destructor>\n\n      <field name=\"_notice\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"notice\");\n      </field>\n\n      <method name=\"cancelUninstall\">\n        <body><![CDATA[\n          // This assumes that disabling does not require a restart when\n          // uninstalling doesn't. Things will still work if not, the add-on\n          // will just still be active until finally getting uninstalled.\n\n          if (this.isPending(\"uninstall\"))\n            this.mAddon.cancelUninstall();\n          else if (this.getAttribute(\"wasDisabled\") != \"true\")\n            this.mAddon.enable();\n\n          // Dispatch an event so extensions.js can record telemetry.\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"Undo\", true, true);\n          this.dispatchEvent(event);\n\n          this.removeAttribute(\"pending\");\n        ]]></body>\n      </method>\n\n      <method name=\"onExternalInstall\">\n        <parameter name=\"aAddon\"/>\n        <parameter name=\"aExistingAddon\"/>\n        <body><![CDATA[\n          if (aExistingAddon.id != this.mAddon.id)\n            return;\n\n          // Make sure any newly installed add-on has the correct disabled state\n          if (this.hasAttribute(\"wasDisabled\")) {\n            if (this.getAttribute(\"wasDisabled\") == \"true\")\n              aAddon.disable();\n            else\n              aAddon.enable();\n          }\n\n          this.mAddon = aAddon;\n\n          this.removeAttribute(\"pending\");\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallStarted\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          // Make sure any newly installed add-on has the correct disabled state\n          if (this.hasAttribute(\"wasDisabled\")) {\n            if (this.getAttribute(\"wasDisabled\") == \"true\")\n              aInstall.addon.disable();\n            else\n              aInstall.addon.enable();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallEnded\">\n        <parameter name=\"aInstall\"/>\n        <parameter name=\"aAddon\"/>\n        <body><![CDATA[\n          this.mAddon = aAddon;\n\n          this.removeAttribute(\"pending\");\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Addon - installing - an addon item that is currently being installed -->\n  <binding id=\"addon-installing\"\n           extends=\"chrome://mozapps/content/extensions/extensions.xml#addon-base\">\n    <content>\n      <xul:hbox anonid=\"warning-container\" class=\"warning\">\n        <xul:image class=\"warning-icon\"/>\n        <xul:label anonid=\"warning\" flex=\"1\"/>\n        <xul:button anonid=\"warning-link\" class=\"button-link\"\n                   oncommand=\"document.getBindingParent(this).retryInstall();\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n      <xul:hbox class=\"content-container\">\n        <xul:vbox class=\"icon-outer-container\">\n          <xul:vbox class=\"icon-container\">\n            <xul:image anonid=\"icon\" class=\"icon\"/>\n          </xul:vbox>\n        </xul:vbox>\n        <xul:vbox class=\"fade name-outer-container\" flex=\"1\">\n          <xul:hbox class=\"name-container\">\n            <xul:label anonid=\"name\" class=\"name\" crop=\"end\" tooltip=\"addonitem-tooltip\"/>\n          </xul:hbox>\n        </xul:vbox>\n        <xul:vbox class=\"install-status-container\">\n          <xul:hbox anonid=\"install-status\" class=\"install-status\"/>\n        </xul:vbox>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._installStatus.mControl = this;\n        this._installStatus.mInstall = this.mInstall;\n        this.refreshInfo();\n      ]]></constructor>\n\n      <field name=\"_icon\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"icon\");\n      </field>\n      <field name=\"_name\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"name\");\n      </field>\n      <field name=\"_warning\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"warning\");\n      </field>\n      <field name=\"_warningLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"warning-link\");\n      </field>\n      <field name=\"_installStatus\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"install-status\");\n      </field>\n\n      <method name=\"onInstallCompleted\">\n        <body><![CDATA[\n          this.mAddon = this.mInstall.addon;\n          this.setAttribute(\"name\", this.mAddon.name);\n          this.setAttribute(\"value\", this.mAddon.id);\n          this.setAttribute(\"status\", \"installed\");\n        ]]></body>\n      </method>\n\n      <method name=\"refreshInfo\">\n        <body><![CDATA[\n          this.mAddon = this.mAddon || this.mInstall.addon;\n          if (this.mAddon) {\n            this._icon.src = this.mAddon.iconURL ||\n                             (this.mInstall ? this.mInstall.iconURL : \"\");\n            this._name.value = this.mAddon.name;\n          } else {\n            this._icon.src = this.mInstall.iconURL;\n            // AddonInstall.name isn't always available - fallback to filename\n            if (this.mInstall.name) {\n              this._name.value = this.mInstall.name;\n            } else if (this.mInstall.sourceURI) {\n              var url = Cc[\"@mozilla.org/network/standard-url-mutator;1\"]\n                          .createInstance(Ci.nsIStandardURLMutator)\n                          .init(Ci.nsIStandardURL.URLTYPE_STANDARD,\n                                80, this.mInstall.sourceURI.spec,\n                                null, null)\n                          .finalize()\n                          .QueryInterface(Ci.nsIURL);\n              this._name.value = url.fileName;\n            }\n          }\n\n          if (this.mInstall.state == AddonManager.STATE_DOWNLOAD_FAILED) {\n            this.setAttribute(\"notification\", \"warning\");\n            this._warning.textContent = gStrings.ext.formatStringFromName(\n              \"notification.downloadError\",\n              [this._name.value], 1\n            );\n            this._warningLink.label = gStrings.ext.GetStringFromName(\"notification.downloadError.retry\");\n            this._warningLink.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n          } else if (this.mInstall.state == AddonManager.STATE_INSTALL_FAILED) {\n            this.setAttribute(\"notification\", \"warning\");\n            this._warning.textContent = gStrings.ext.formatStringFromName(\n              \"notification.installError\",\n              [this._name.value], 1\n            );\n            this._warningLink.label = gStrings.ext.GetStringFromName(\"notification.installError.retry\");\n            this._warningLink.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n          } else {\n            this.removeAttribute(\"notification\");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"retryInstall\">\n        <body><![CDATA[\n          this.mInstall.install();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"detail-row\">\n    <content>\n      <xul:label class=\"detail-row-label\" xbl:inherits=\"value=label\"/>\n      <xul:label class=\"detail-row-value\" xbl:inherits=\"value\"/>\n    </content>\n\n    <implementation>\n      <property name=\"value\">\n        <getter><![CDATA[\n          return this.getAttribute(\"value\");\n        ]]></getter>\n        <setter><![CDATA[\n          if (!val)\n            this.removeAttribute(\"value\");\n          else\n            this.setAttribute(\"value\", val);\n        ]]></setter>\n      </property>\n    </implementation>\n  </binding>\n\n</bindings>\n"}];
    </script>
  </head>
  <body>
  <main>
  <header>
  <div id="links">
    <a href="../">Home</a>
    <a href="https://github.com/bgrins/xbl-analysis">Code</a>
  </div>
  <h1>XBL To Custom Element Converter</h1>
  </header>
  <div id="converter">
    <ul>
    <li><a href='#' data-index=0>tabbrowser.xml</a></li>
<li><a href='#' data-index=1>urlbarBindings.xml</a></li>
<li><a href='#' data-index=2>menu.xml</a></li>
<li><a href='#' data-index=3>autocomplete.xml</a></li>
<li><a href='#' data-index=4>general.xml</a></li>
<li><a href='#' data-index=5>popup.xml</a></li>
<li><a href='#' data-index=6>richlistbox.xml</a></li>
<li><a href='#' data-index=7>scrollbox.xml</a></li>
<li><a href='#' data-index=8>tabbox.xml</a></li>
<li><a href='#' data-index=9>textbox.xml</a></li>
<li><a href='#' data-index=10>wizard.xml</a></li>
<li><a href='#' data-index=11>extensions.xml</a></li>
    </ul>
    <textarea>
    <?xml version="1.0"?>
<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<bindings id="autocompleteBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="autocomplete"
           extends="chrome://global/content/bindings/textbox.xml#textbox">
    <content sizetopopup="pref">
      <children includes="image|box"/>

      <xul:moz-input-box anonid="moz-input-box" flex="1">
        <children/>
        <html:input anonid="input" class="textbox-input"
                    allowevents="true"
                    autocomplete="off"
                    xbl:inherits="value,type=inputtype,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,mozactionhint"/>
      </xul:moz-input-box>
      <children includes="hbox"/>

      <xul:popupset anonid="popupset" class="autocomplete-result-popupset"/>
    </content>

    <implementation implements="nsIAutoCompleteInput, nsIDOMXULMenuListElement">
      <field name="mController">null</field>
      <field name="mSearchNames">null</field>
      <field name="mIgnoreInput">false</field>
      <field name="noRollupOnEmptySearch">false</field>

      <field name="_searchBeginHandler">null</field>
      <field name="_searchCompleteHandler">null</field>
      <field name="_textEnteredHandler">null</field>
      <field name="_textRevertedHandler">null</field>

      <constructor><![CDATA[
        this.mController = Cc["@mozilla.org/autocomplete/controller;1"].
          getService(Ci.nsIAutoCompleteController);

        this._searchBeginHandler = this.initEventHandler("searchbegin");
        this._searchCompleteHandler = this.initEventHandler("searchcomplete");
        this._textEnteredHandler = this.initEventHandler("textentered");
        this._textRevertedHandler = this.initEventHandler("textreverted");
      ]]></constructor>

      <!-- =================== nsIAutoCompleteInput =================== -->

      <field name="_popup">null</field>
      <property name="popup" readonly="true">
        <getter><![CDATA[
          // Memoize the result in a field rather than replacing this property,
          // so that it can be reset along with the binding.
          if (this._popup) {
            return this._popup;
          }

          let popup = null;
          let popupId = this.getAttribute("autocompletepopup");
          if (popupId) {
            popup = document.getElementById(popupId);
          }
          if (!popup) {
            popup = document.createXULElement("panel", { is: "autocomplete-richlistbox-popup" });
            popup.setAttribute("type", "autocomplete-richlistbox");
            popup.setAttribute("noautofocus", "true");

            let popupset = document.getAnonymousElementByAttribute(this, "anonid", "popupset");
            popupset.appendChild(popup);
          }
          popup.mInput = this;

          return this._popup = popup;
        ]]></getter>
      </property>
      <property name="popupElement" readonly="true"
                onget="return this.popup;"/>

      <property name="controller" onget="return this.mController;" readonly="true"/>

      <property name="popupOpen"
                onget="return this.popup.popupOpen;"
                onset="if (val) this.openPopup(); else this.closePopup();"/>

      <property name="disableAutoComplete"
                onset="this.setAttribute('disableautocomplete', val); return val;"
                onget="return this.getAttribute('disableautocomplete') == 'true';"/>

      <property name="completeDefaultIndex"
                onset="this.setAttribute('completedefaultindex', val); return val;"
                onget="return this.getAttribute('completedefaultindex') == 'true';"/>

      <property name="completeSelectedIndex"
                onset="this.setAttribute('completeselectedindex', val); return val;"
                onget="return this.getAttribute('completeselectedindex') == 'true';"/>

      <property name="forceComplete"
                onset="this.setAttribute('forcecomplete', val); return val;"
                onget="return this.getAttribute('forcecomplete') == 'true';"/>

      <property name="minResultsForPopup"
                onset="this.setAttribute('minresultsforpopup', val); return val;"
                onget="var m = parseInt(this.getAttribute('minresultsforpopup')); return isNaN(m) ? 1 : m;"/>

      <property name="timeout"
                onset="this.setAttribute('timeout', val); return val;"
                onget="var t = parseInt(this.getAttribute('timeout')); return isNaN(t) ? 50 : t;"/>

      <property name="searchParam"
                onget="return this.getAttribute('autocompletesearchparam') || '';"
                onset="this.setAttribute('autocompletesearchparam', val); return val;"/>

      <property name="searchCount" readonly="true"
                onget="this.initSearchNames(); return this.mSearchNames.length;"/>

      <property name="PrivateBrowsingUtils" readonly="true">
        <getter><![CDATA[
          let module = {};
          ChromeUtils.import("resource://gre/modules/PrivateBrowsingUtils.jsm", module);
          Object.defineProperty(this, "PrivateBrowsingUtils", {
            configurable: true,
            enumerable: true,
            writable: true,
            value: module.PrivateBrowsingUtils,
          });
          return module.PrivateBrowsingUtils;
        ]]></getter>
      </property>

      <property name="inPrivateContext" readonly="true"
                onget="return this.PrivateBrowsingUtils.isWindowPrivate(window);"/>

      <property name="noRollupOnCaretMove" readonly="true"
                onget="return this.popup.getAttribute('norolluponanchor') == 'true'"/>

      <!-- This is the maximum number of drop-down rows we get when we
            hit the drop marker beside fields that have it (like the URLbar).-->
      <field name="maxDropMarkerRows" readonly="true">14</field>

      <method name="getSearchAt">
        <parameter name="aIndex"/>
        <body><![CDATA[
          this.initSearchNames();
          return this.mSearchNames[aIndex];
        ]]></body>
      </method>

      <method name="setTextValueWithReason">
        <parameter name="aValue"/>
        <parameter name="aReason"/>
        <body><![CDATA[
          if (aReason == Ci.nsIAutoCompleteInput
                           .TEXTVALUE_REASON_COMPLETEDEFAULT) {
            this._textValueSetByCompleteDefault = true;
          }
          this.textValue = aValue;
          this._textValueSetByCompleteDefault = false;
        ]]></body>
      </method>

      <property name="textValue">
        <getter><![CDATA[
          if (typeof this.onBeforeTextValueGet == "function") {
            let result = this.onBeforeTextValueGet();
            if (result) {
              return result.value;
            }
          }
          return this.value;
        ]]></getter>
        <setter><![CDATA[
          if (typeof this.onBeforeTextValueSet == "function" &&
              !this._textValueSetByCompleteDefault) {
            val = this.onBeforeTextValueSet(val);
          }

          // "input" event is automatically dispatched by the editor if
          // necessary.
          this._setValueInternal(val, true);

          return this.value;
        ]]></setter>
      </property>

      <method name="selectTextRange">
        <parameter name="aStartIndex"/>
        <parameter name="aEndIndex"/>
        <body><![CDATA[
          this.inputField.setSelectionRange(aStartIndex, aEndIndex);
        ]]></body>
      </method>

      <method name="onSearchBegin">
        <body><![CDATA[
          if (this.popup && typeof this.popup.onSearchBegin == "function")
            this.popup.onSearchBegin();
          if (this._searchBeginHandler)
            this._searchBeginHandler();
        ]]></body>
      </method>

      <method name="onSearchComplete">
        <body><![CDATA[
          if (this.mController.matchCount == 0)
            this.setAttribute("nomatch", "true");
          else
            this.removeAttribute("nomatch");

          if (this.ignoreBlurWhileSearching && !this.focused) {
            this.handleEnter();
            this.detachController();
          }

          if (this._searchCompleteHandler)
            this._searchCompleteHandler();
        ]]></body>
      </method>

      <method name="onTextEntered">
        <parameter name="event"/>
        <body><![CDATA[
          let rv = false;
          if (this._textEnteredHandler) {
            rv = this._textEnteredHandler(event);
          }
          return rv;
        ]]></body>
      </method>

      <method name="onTextReverted">
        <body><![CDATA[
          if (this._textRevertedHandler)
            return this._textRevertedHandler();
          return false;
        ]]></body>
      </method>

      <!-- =================== nsIDOMXULMenuListElement =================== -->

      <property name="editable" readonly="true"
                onget="return true;" />

      <property name="crop"
                onset="this.setAttribute('crop',val); return val;"
                onget="return this.getAttribute('crop');"/>

      <property name="open"
                onget="return this.getAttribute('open') == 'true';">
        <setter><![CDATA[
          if (val)
            this.showHistoryPopup();
          else
            this.closePopup();
        ]]></setter>
      </property>

      <!-- =================== PUBLIC MEMBERS =================== -->

      <field name="valueIsTyped">false</field>
      <field name="_textValueSetByCompleteDefault">false</field>
      <property name="value"
                onset="return this._setValueInternal(val, false);">
        <getter><![CDATA[
          if (typeof this.onBeforeValueGet == "function") {
            var result = this.onBeforeValueGet();
            if (result)
              return result.value;
          }
          return this.inputField.value;
        ]]></getter>
      </property>

      <property name="focused" readonly="true"
                onget="return this.getAttribute('focused') == 'true';"/>

      <!-- maximum number of rows to display at a time -->
      <property name="maxRows"
                onset="this.setAttribute('maxrows', val); return val;"
                onget="return parseInt(this.getAttribute('maxrows')) || 0;"/>

      <!-- option to allow scrolling through the list via the tab key, rather than
           tab moving focus out of the textbox -->
      <property name="tabScrolling"
                onset="this.setAttribute('tabscrolling', val); return val;"
                onget="return this.getAttribute('tabscrolling') == 'true';"/>

      <!-- option to completely ignore any blur events while searches are
           still going on. -->
      <property name="ignoreBlurWhileSearching"
                onset="this.setAttribute('ignoreblurwhilesearching', val); return val;"
                onget="return this.getAttribute('ignoreblurwhilesearching') == 'true';"/>

      <!-- option to highlight entries that don't have any matches -->
      <property name="highlightNonMatches"
                onset="this.setAttribute('highlightnonmatches', val); return val;"
                onget="return this.getAttribute('highlightnonmatches') == 'true';"/>

      <!-- =================== PRIVATE MEMBERS =================== -->

      <!-- ::::::::::::: autocomplete controller ::::::::::::: -->

      <method name="attachController">
        <body><![CDATA[
          this.mController.input = this;
        ]]></body>
      </method>

      <method name="detachController">
        <body><![CDATA[
          if (this.mController.input == this)
            this.mController.input = null;
        ]]></body>
      </method>

      <!-- ::::::::::::: popup opening ::::::::::::: -->

      <method name="openPopup">
        <body><![CDATA[
          if (this.focused)
            this.popup.openAutocompletePopup(this, this);
        ]]></body>
      </method>

      <method name="closePopup">
        <body><![CDATA[
          this.popup.closePopup();
        ]]></body>
      </method>

      <method name="showHistoryPopup">
        <body><![CDATA[
          // Store our "normal" maxRows on the popup, so that it can reset the
          // value when the popup is hidden.
          this.popup._normalMaxRows = this.maxRows;

          // Increase our maxRows temporarily, since we want the dropdown to
          // be bigger in this case. The popup's popupshowing/popuphiding
          // handlers will take care of resetting this.
          this.maxRows = this.maxDropMarkerRows;

          // Ensure that we have focus.
          if (!this.focused)
            this.focus();
          this.attachController();
          this.mController.startSearch("");
        ]]></body>
      </method>

      <method name="toggleHistoryPopup">
        <body><![CDATA[
          if (!this.popup.popupOpen)
            this.showHistoryPopup();
          else
            this.closePopup();
        ]]></body>
      </method>

      <!-- ::::::::::::: event dispatching ::::::::::::: -->

      <method name="initEventHandler">
        <parameter name="aEventType"/>
        <body><![CDATA[
          let handlerString = this.getAttribute("on" + aEventType);
          if (handlerString) {
            return (new Function("eventType", "param", handlerString)).bind(this, aEventType);
          }
          return null;
        ]]></body>
      </method>

      <!-- ::::::::::::: key handling ::::::::::::: -->

      <field name="_selectionDetails">null</field>
      <method name="onKeyPress">
        <parameter name="aEvent"/>
        <body><![CDATA[
          return this.handleKeyPress(aEvent);
        ]]></body>
      </method>

      <method name="handleKeyPress">
        <parameter name="aEvent"/>
        <parameter name="aOptions"/>
        <body><![CDATA[
          if (aEvent.target.localName != "textbox")
            return true; // Let child buttons of autocomplete take input

          // Re: urlbarDeferred, see the comment in urlbarBindings.xml.
          if (aEvent.defaultPrevented && !aEvent.urlbarDeferred) {
            return false;
          }

          const isMac = /Mac/.test(navigator.platform);
          var cancel = false;

          // Catch any keys that could potentially move the caret. Ctrl can be
          // used in combination with these keys on Windows and Linux; and Alt
          // can be used on OS X, so make sure the unused one isn't used.
          let metaKey = isMac ? aEvent.ctrlKey : aEvent.altKey;
          if (!metaKey) {
            switch (aEvent.keyCode) {
              case KeyEvent.DOM_VK_LEFT:
              case KeyEvent.DOM_VK_RIGHT:
              case KeyEvent.DOM_VK_HOME:
                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);
                break;
            }
          }

          // Handle keys that are not part of a keyboard shortcut (no Ctrl or Alt)
          if (!aEvent.ctrlKey && !aEvent.altKey) {
            switch (aEvent.keyCode) {
              case KeyEvent.DOM_VK_TAB:
                if (this.tabScrolling && this.popup.popupOpen)
                  cancel = this.mController.handleKeyNavigation(aEvent.shiftKey ?
                                                                KeyEvent.DOM_VK_UP :
                                                                KeyEvent.DOM_VK_DOWN);
                else if (this.forceComplete && this.mController.matchCount >= 1)
                  this.mController.handleTab();
                break;
              case KeyEvent.DOM_VK_UP:
              case KeyEvent.DOM_VK_DOWN:
              case KeyEvent.DOM_VK_PAGE_UP:
              case KeyEvent.DOM_VK_PAGE_DOWN:
                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);
                break;
            }
          }

          // Handle readline/emacs-style navigation bindings on Mac.
          if (isMac &&
              this.popup.popupOpen &&
              aEvent.ctrlKey &&
              (aEvent.key === "n" || aEvent.key === "p")) {
            const effectiveKey = (aEvent.key === "p") ?
                                 KeyEvent.DOM_VK_UP :
                                 KeyEvent.DOM_VK_DOWN;
            cancel = this.mController.handleKeyNavigation(effectiveKey);
          }

          // Handle keys we know aren't part of a shortcut, even with Alt or
          // Ctrl.
          switch (aEvent.keyCode) {
            case KeyEvent.DOM_VK_ESCAPE:
              cancel = this.mController.handleEscape();
              break;
            case KeyEvent.DOM_VK_RETURN:
              if (isMac) {
                // Prevent the default action, since it will beep on Mac
                if (aEvent.metaKey)
                  aEvent.preventDefault();
              }
              if (this.popup.selectedIndex >= 0) {
                this._selectionDetails = {
                  index: this.popup.selectedIndex,
                  kind: "key",
                };
              }
              cancel = this.handleEnter(aEvent, aOptions);
              break;
            case KeyEvent.DOM_VK_DELETE:
              if (isMac && !aEvent.shiftKey) {
                break;
              }
              cancel = this.handleDelete();
              break;
            case KeyEvent.DOM_VK_BACK_SPACE:
              if (isMac && aEvent.shiftKey) {
                cancel = this.handleDelete();
              }
              break;
            case KeyEvent.DOM_VK_DOWN:
            case KeyEvent.DOM_VK_UP:
              if (aEvent.altKey)
                this.toggleHistoryPopup();
              break;
            case KeyEvent.DOM_VK_F4:
              if (!isMac) {
                this.toggleHistoryPopup();
              }
              break;
          }

          if (cancel) {
            aEvent.stopPropagation();
            aEvent.preventDefault();
          }

          return true;
        ]]></body>
      </method>

      <method name="handleEnter">
        <parameter name="event"/>
        <body><![CDATA[
          return this.mController.handleEnter(false, event || null);
        ]]></body>
      </method>

      <method name="handleDelete">
        <body><![CDATA[
          return this.mController.handleDelete();
        ]]></body>
      </method>

      <!-- ::::::::::::: miscellaneous ::::::::::::: -->

      <method name="initSearchNames">
        <body><![CDATA[
          if (!this.mSearchNames) {
            var names = this.getAttribute("autocompletesearch");
            if (!names)
              this.mSearchNames = [];
            else
              this.mSearchNames = names.split(" ");
          }
        ]]></body>
      </method>

      <method name="_focus">
        <!-- doesn't reset this.mController -->
        <body><![CDATA[
          this._dontBlur = true;
          this.focus();
          this._dontBlur = false;
        ]]></body>
      </method>

      <method name="resetActionType">
        <body><![CDATA[
          if (this.mIgnoreInput)
            return;
          this.removeAttribute("actiontype");
        ]]></body>
      </method>

      <method name="_setValueInternal">
        <parameter name="aValue"/>
        <parameter name="aIsUserInput"/>
        <body><![CDATA[
          this.mIgnoreInput = true;

          if (typeof this.onBeforeValueSet == "function")
            aValue = this.onBeforeValueSet(aValue);

          if (typeof this.trimValue == "function" &&
              !this._textValueSetByCompleteDefault)
            aValue = this.trimValue(aValue);

          this.valueIsTyped = false;
          if (aIsUserInput) {
            this.inputField.setUserInput(aValue);
          } else {
            this.inputField.value = aValue;
          }

          if (typeof this.formatValue == "function")
            this.formatValue();

          this.mIgnoreInput = false;
          var event = document.createEvent("Events");
          event.initEvent("ValueChange", true, true);
          this.inputField.dispatchEvent(event);
          return aValue;
        ]]></body>
      </method>

      <method name="onInput">
        <parameter name="aEvent"/>
        <body><![CDATA[
          if (!this.mIgnoreInput && this.mController.input == this) {
            this.valueIsTyped = true;
            this.mController.handleText();
          }
          this.resetActionType();
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="input"><![CDATA[
        this.onInput(event);
      ]]></handler>

      <handler event="keypress" phase="capturing" group="system"
               action="return this.onKeyPress(event);"/>

      <handler event="compositionstart" phase="capturing"
               action="if (this.mController.input == this) this.mController.handleStartComposition();"/>

      <handler event="compositionend" phase="capturing"
               action="if (this.mController.input == this) this.mController.handleEndComposition();"/>

      <handler event="focus" phase="capturing"><![CDATA[
        this.attachController();
        if (window.gBrowser && window.gBrowser.selectedBrowser.hasAttribute("usercontextid")) {
          this.userContextId = parseInt(window.gBrowser.selectedBrowser.getAttribute("usercontextid"));
        } else {
          this.userContextId = 0;
        }
      ]]></handler>

      <handler event="blur" phase="capturing"><![CDATA[
        if (!this._dontBlur) {
          if (this.forceComplete && this.mController.matchCount >= 1) {
            // If forceComplete is requested, we need to call the enter processing
            // on blur so the input will be forced to the closest match.
            // Thunderbird is the only consumer of forceComplete and this is used
            // to force an recipient's email to the exact address book entry.
            this.mController.handleEnter(true);
          }
          if (!this.ignoreBlurWhileSearching)
            this.detachController();
        }
      ]]></handler>
    </handlers>
  </binding>

  <binding id="autocomplete-rich-result-popup">
    <content ignorekeys="true" level="top" consumeoutsideclicks="never">
      <xul:richlistbox anonid="richlistbox" class="autocomplete-richlistbox" flex="1"/>
      <xul:hbox>
        <children/>
      </xul:hbox>
    </content>

    <implementation implements="nsIAutoCompletePopup">
      <field name="mInput">null</field>
      <field name="mPopupOpen">false</field>
      <field name="_currentIndex">0</field>

      <constructor><![CDATA[
        if (!this.listEvents) {
          this.listEvents = {
            handleEvent: event => {
              if (!this.parentNode) {
                return;
              }

              switch (event.type) {
                case "mouseup":
                  // Don't call onPopupClick for the scrollbar buttons, thumb,
                  // slider, etc. If we hit the richlistbox and not a
                  // richlistitem, we ignore the event.
                  if (event.target.closest("richlistbox,richlistitem")
                                  .localName == "richlistitem") {
                    this.onPopupClick(event);
                  }
                  break;
                case "mousemove":
                  if (Date.now() - this.mLastMoveTime <= 30) {
                    return;
                  }

                  let item = event.target.closest("richlistbox,richlistitem");

                  // If we hit the richlistbox and not a richlistitem, we ignore
                  // the event.
                  if (item.localName == "richlistbox") {
                    return;
                  }

                  let index = this.richlistbox.getIndexOfItem(item);

                  this.mousedOverIndex = index;

                  if (item.selectedByMouseOver) {
                    this.richlistbox.selectedIndex = index;
                  }

                  this.mLastMoveTime = Date.now();
                  break;
              }
            },
          };
          this.richlistbox.addEventListener("mouseup", this.listEvents);
          this.richlistbox.addEventListener("mousemove", this.listEvents);
        }
      ]]></constructor>

      <destructor><![CDATA[
        if (this.listEvents) {
          this.richlistbox.removeEventListener("mouseup", this.listEvents);
          this.richlistbox.removeEventListener("mousemove", this.listEvents);
          delete this.listEvents;
        }
      ]]></destructor>

      <!-- =================== nsIAutoCompletePopup =================== -->

      <property name="input" readonly="true"
                onget="return this.mInput"/>

      <property name="overrideValue" readonly="true"
                onget="return null;"/>

      <property name="popupOpen" readonly="true"
                onget="return this.mPopupOpen;"/>

      <method name="closePopup">
        <body>
          <![CDATA[
          if (this.mPopupOpen) {
            this.hidePopup();
            this.removeAttribute("width");
          }
        ]]>
        </body>
      </method>

      <!-- This is the default number of rows that we give the autocomplete
           popup when the textbox doesn't have a "maxrows" attribute
           for us to use. -->
      <field name="defaultMaxRows" readonly="true">6</field>

      <!-- In some cases (e.g. when the input's dropmarker button is clicked),
           the input wants to display a popup with more rows. In that case, it
           should increase its maxRows property and store the "normal" maxRows
           in this field. When the popup is hidden, we restore the input's
           maxRows to the value stored in this field.

           This field is set to -1 between uses so that we can tell when it's
           been set by the input and when we need to set it in the popupshowing
           handler. -->
      <field name="_normalMaxRows">-1</field>

      <property name="maxRows" readonly="true">
        <getter>
          <![CDATA[
          return (this.mInput && this.mInput.maxRows) || this.defaultMaxRows;
        ]]>
        </getter>
      </property>

      <method name="getNextIndex">
        <parameter name="aReverse"/>
        <parameter name="aAmount"/>
        <parameter name="aIndex"/>
        <parameter name="aMaxRow"/>
        <body><![CDATA[
          if (aMaxRow < 0)
            return -1;

          var newIdx = aIndex + (aReverse ? -1 : 1) * aAmount;
          if (aReverse && aIndex == -1 || newIdx > aMaxRow && aIndex != aMaxRow)
            newIdx = aMaxRow;
          else if (!aReverse && aIndex == -1 || newIdx < 0 && aIndex != 0)
            newIdx = 0;

          if (newIdx < 0 && aIndex == 0 || newIdx > aMaxRow && aIndex == aMaxRow)
            aIndex = -1;
          else
            aIndex = newIdx;

          return aIndex;
        ]]></body>
      </method>

      <method name="onPopupClick">
        <parameter name="aEvent"/>
        <body><![CDATA[
          this.input.controller.handleEnter(true, aEvent);
        ]]></body>
      </method>

      <property name="selectedIndex"
                onget="return this.richlistbox.selectedIndex;">
        <setter>
          <![CDATA[
          if (val != this.richlistbox.selectedIndex) {
            this._previousSelectedIndex = this.richlistbox.selectedIndex;
          }
          this.richlistbox.selectedIndex = val;
          // Since ensureElementIsVisible may cause an expensive Layout flush,
          // invoke it only if there may be a scrollbar, so if we could fetch
          // more results than we can show at once.
          // maxResults is the maximum number of fetched results, maxRows is the
          // maximum number of rows we show at once, without a scrollbar.
          if (this.mPopupOpen && this.maxResults > this.maxRows) {
            // when clearing the selection (val == -1, so selectedItem will be
            // null), we want to scroll back to the top.  see bug #406194
            this.richlistbox.ensureElementIsVisible(
              this.richlistbox.selectedItem || this.richlistbox.firstElementChild);
          }
          return val;
        ]]>
        </setter>
      </property>

      <field name="_previousSelectedIndex">-1</field>
      <field name="mLastMoveTime">Date.now()</field>
      <field name="mousedOverIndex">-1</field>

      <method name="onSearchBegin">
        <body><![CDATA[
          this.mousedOverIndex = -1;

          if (typeof this._onSearchBegin == "function") {
            this._onSearchBegin();
          }
        ]]></body>
      </method>

      <method name="openAutocompletePopup">
        <parameter name="aInput"/>
        <parameter name="aElement"/>
        <body>
          <![CDATA[
          // until we have "baseBinding", (see bug #373652) this allows
          // us to override openAutocompletePopup(), but still call
          // the method on the base class
          this._openAutocompletePopup(aInput, aElement);
        ]]>
        </body>
      </method>

      <method name="_openAutocompletePopup">
        <parameter name="aInput"/>
        <parameter name="aElement"/>
        <body>
          <![CDATA[
          if (!this.mPopupOpen) {
            // It's possible that the panel is hidden initially
            // to avoid impacting startup / new window performance
            aInput.popup.hidden = false;

            this.mInput = aInput;
            // clear any previous selection, see bugs 400671 and 488357
            this.selectedIndex = -1;

            var width = aElement.getBoundingClientRect().width;
            this.setAttribute("width", width > 100 ? width : 100);
            // invalidate() depends on the width attribute
            this._invalidate();

            this.openPopup(aElement, "after_start", 0, 0, false, false);
          }
        ]]>
        </body>
      </method>

      <method name="invalidate">
        <parameter name="reason"/>
        <body>
          <![CDATA[
          // Don't bother doing work if we're not even showing
          if (!this.mPopupOpen)
            return;

          this._invalidate(reason);
          ]]>
        </body>
      </method>

      <method name="_invalidate">
        <parameter name="reason"/>
        <body>
          <![CDATA[
          // collapsed if no matches
          this.richlistbox.collapsed = (this.matchCount == 0);

          // Update the richlistbox height.
          if (this._adjustHeightRAFToken) {
            cancelAnimationFrame(this._adjustHeightRAFToken);
            this._adjustHeightRAFToken = null;
          }

          if (this.mPopupOpen) {
            delete this._adjustHeightOnPopupShown;
            this._adjustHeightRAFToken = requestAnimationFrame(() => this.adjustHeight());
          } else {
            this._adjustHeightOnPopupShown = true;
          }

          this._currentIndex = 0;
          if (this._appendResultTimeout) {
            clearTimeout(this._appendResultTimeout);
          }
          this._appendCurrentResult(reason);
        ]]>
        </body>
      </method>

      <property name="maxResults" readonly="true">
        <getter>
          <![CDATA[
            // This is how many richlistitems will be kept around.
            // Note, this getter may be overridden, or instances
            // can have the nomaxresults attribute set to have no
            // limit.
            if (this.getAttribute("nomaxresults") == "true") {
              return Infinity;
            }

            return 20;
          ]]>
        </getter>
      </property>

      <property name="matchCount" readonly="true">
        <getter>
          <![CDATA[
          return Math.min(this.mInput.controller.matchCount, this.maxResults);
          ]]>
        </getter>
      </property>

      <method name="_collapseUnusedItems">
        <body>
          <![CDATA[
            let existingItemsCount = this.richlistbox.children.length;
            for (let i = this.matchCount; i < existingItemsCount; ++i) {
              let item = this.richlistbox.children[i];

              item.collapsed = true;
              if (typeof item._onCollapse == "function") {
                item._onCollapse();
              }
            }
          ]]>
        </body>
      </method>

      <method name="adjustHeight">
        <body>
          <![CDATA[
          // Figure out how many rows to show
          let rows = this.richlistbox.children;
          let numRows = Math.min(this.matchCount, this.maxRows, rows.length);

          // Default the height to 0 if we have no rows to show
          let height = 0;
          if (numRows) {
            let firstRowRect = rows[0].getBoundingClientRect();
            if (this._rlbPadding == undefined) {
              let style = window.getComputedStyle(this.richlistbox);
              let paddingTop = parseInt(style.paddingTop) || 0;
              let paddingBottom = parseInt(style.paddingBottom) || 0;
              this._rlbPadding = paddingTop + paddingBottom;
            }

            // The class `forceHandleUnderflow` is for the item might need to
            // handle OverUnderflow or Overflow when the height of an item will
            // be changed dynamically.
            for (let i = 0; i < numRows; i++) {
              if (rows[i].classList.contains("forceHandleUnderflow")) {
                rows[i].handleOverUnderflow();
              }
            }

            let lastRowRect = rows[numRows - 1].getBoundingClientRect();
            // Calculate the height to have the first row to last row shown
            height = lastRowRect.bottom - firstRowRect.top +
                     this._rlbPadding;
          }

          let currentHeight = this.richlistbox.getBoundingClientRect().height;
          if (height <= currentHeight) {
            this._collapseUnusedItems();
          }
          this.richlistbox.style.removeProperty("height");
          // We need to get the ceiling of the calculated value to ensure that the box fully contains
          // all of its contents and doesn't cause a scrollbar since nsIBoxObject only expects a
          // `long`. e.g. if `height` is 99.5 the richlistbox would render at height 99px with a
          // scrollbar for the extra 0.5px.
          this.richlistbox.height = Math.ceil(height);
          ]]>
        </body>
      </method>

      <method name="_appendCurrentResult">
        <parameter name="invalidateReason"/>
        <body>
          <![CDATA[
          var controller = this.mInput.controller;
          var matchCount = this.matchCount;
          var existingItemsCount = this.richlistbox.children.length;

          // Process maxRows per chunk to improve performance and user experience
          for (let i = 0; i < this.maxRows; i++) {
            if (this._currentIndex >= matchCount) {
              break;
            }
            let item;
            let itemExists = this._currentIndex < existingItemsCount;

            let originalValue, originalText, originalType;
            let style = controller.getStyleAt(this._currentIndex);
            let value =
              style && style.includes("autofill") ?
              controller.getFinalCompleteValueAt(this._currentIndex) :
              controller.getValueAt(this._currentIndex);
            let label = controller.getLabelAt(this._currentIndex);
            let comment = controller.getCommentAt(this._currentIndex);
            let image = controller.getImageAt(this._currentIndex);
            // trim the leading/trailing whitespace
            let trimmedSearchString = controller.searchString.replace(/^\s+/, "").replace(/\s+$/, "");

            let reusable = false;
            if (itemExists) {
              item = this.richlistbox.children[this._currentIndex];

              // Url may be a modified version of value, see _adjustAcItem().
              originalValue = item.getAttribute("url") || item.getAttribute("ac-value");
              originalText = item.getAttribute("ac-text");
              originalType = item.getAttribute("originaltype");

              // The styles on the list which have different <content> structure and overrided
              // _adjustAcItem() are unreusable.
              const UNREUSEABLE_STYLES = [
                "autofill-profile",
                "autofill-footer",
                "autofill-clear-button",
                "autofill-insecureWarning",
                "generatedPassword",
                "insecureWarning",
                "loginsFooter",
                "loginWithOrigin",
              ];
              // Reuse the item when its style is exactly equal to the previous style or
              // neither of their style are in the UNREUSEABLE_STYLES.
              reusable = originalType === style ||
                !(UNREUSEABLE_STYLES.includes(style) || UNREUSEABLE_STYLES.includes(originalType));
            }

            // If no reusable item available, then create a new item.
            if (!reusable) {
              let options = null;
              switch (style) {
                case "autofill-profile":
                  options = { is: "autocomplete-profile-listitem" };
                  break;
                case "autofill-footer":
                  options = { is: "autocomplete-profile-listitem-footer" };
                  break;
                case "autofill-clear-button":
                  options = { is: "autocomplete-profile-listitem-clear-button" };
                  break;
                case "autofill-insecureWarning":
                  options = { is: "autocomplete-creditcard-insecure-field" };
                  break;
                case "generatedPassword":
                  options = { is: "autocomplete-two-line-richlistitem" };
                  break;
                case "insecureWarning":
                  options = { is: "autocomplete-richlistitem-insecure-warning" };
                  break;
                case "loginsFooter":
                  options = { is: "autocomplete-richlistitem-logins-footer" };
                  break;
                case "loginWithOrigin":
                  options = { is: "autocomplete-login-richlistitem" };
                  break;
                default:
                  options = { is: "autocomplete-richlistitem" };
              }
              item = document.createXULElement("richlistitem", options);
              item.className = "autocomplete-richlistitem";
            }

            item.setAttribute("dir", this.style.direction);
            item.setAttribute("ac-image", image);
            item.setAttribute("ac-value", value);
            item.setAttribute("ac-label", label);
            item.setAttribute("ac-comment", comment);
            item.setAttribute("ac-text", trimmedSearchString);

            // Completely reuse the existing richlistitem for invalidation
            // due to new results, but only when: the item is the same, *OR*
            // we are about to replace the currently moused-over item, to
            // avoid surprising the user.
            let iface = Ci.nsIAutoCompletePopup;
            if (reusable &&
                originalText == trimmedSearchString &&
                invalidateReason == iface.INVALIDATE_REASON_NEW_RESULT &&
                (originalValue == value ||
                 this.mousedOverIndex === this._currentIndex)) {
              // try to re-use the existing item
              let reused = item._reuseAcItem();
              if (reused) {
                this._currentIndex++;
                continue;
              }
            } else {
              if (typeof item._cleanup == "function") {
                item._cleanup();
              }
              item.setAttribute("originaltype", style);
            }

            if (reusable) {
              // Adjust only when the result's type is reusable for existing
              // item's. Otherwise, we might insensibly call old _adjustAcItem()
              // as new binding has not been attached yet.
              // We don't need to worry about switching to new binding, since
              // _adjustAcItem() will fired by its own constructor accordingly.
              item._adjustAcItem();
              item.collapsed = false;
            } else if (itemExists) {
              let oldItem = this.richlistbox.children[this._currentIndex];
              this.richlistbox.replaceChild(item, oldItem);
            } else {
              this.richlistbox.appendChild(item);
            }

            this._currentIndex++;
          }

          if (typeof this.onResultsAdded == "function") {
            // The items bindings may not be attached yet, so we must delay this
            // before we can properly handle items properly without breaking
            // the richlistbox.
            Services.tm.dispatchToMainThread(() => this.onResultsAdded());
          }

          if (this._currentIndex < matchCount) {
            // yield after each batch of items so that typing the url bar is
            // responsive
            this._appendResultTimeout = setTimeout(() => this._appendCurrentResult(), 0);
          }
        ]]>
        </body>
      </method>

      <property name="overflowPadding"
                onget="return Number(this.getAttribute('overflowpadding'))"
                readonly="true" />

      <method name="selectBy">
        <parameter name="aReverse"/>
        <parameter name="aPage"/>
        <body>
          <![CDATA[
          try {
            var amount = aPage ? 5 : 1;

            // because we collapsed unused items, we can't use this.richlistbox.getRowCount(), we need to use the matchCount
            this.selectedIndex = this.getNextIndex(aReverse, amount, this.selectedIndex, this.matchCount - 1);
            if (this.selectedIndex == -1) {
              this.input._focus();
            }
          } catch (ex) {
            // do nothing - occasionally timer-related js errors happen here
            // e.g. "this.selectedIndex has no properties", when you type fast and hit a
            // navigation key before this popup has opened
          }
            ]]>
        </body>
      </method>

      <field name="richlistbox">
        document.getAnonymousElementByAttribute(this, "anonid", "richlistbox");
      </field>

      <property name="view"
                onget="return this.mInput.controller;"
                onset="return val;"/>

    </implementation>
    <handlers>
      <handler event="popupshowing"><![CDATA[
        // If normalMaxRows wasn't already set by the input, then set it here
        // so that we restore the correct number when the popup is hidden.

        // Null-check this.mInput; see bug 1017914
        if (this._normalMaxRows < 0 && this.mInput) {
          this._normalMaxRows = this.mInput.maxRows;
        }

        // Set an attribute for styling the popup based on the input.
        let inputID = "";
        if (this.mInput && this.mInput.ownerDocument &&
            this.mInput.ownerDocument.documentURIObject.schemeIs("chrome")) {
          inputID = this.mInput.id;
          // Take care of elements with no id that are inside xbl bindings
          if (!inputID) {
            let bindingParent = this.mInput.ownerDocument.getBindingParent(this.mInput);
            if (bindingParent) {
              inputID = bindingParent.id;
            }
          }
        }
        this.setAttribute("autocompleteinput", inputID);

        this.mPopupOpen = true;
      ]]></handler>

      <handler event="popupshown">
        <![CDATA[
          if (this._adjustHeightOnPopupShown) {
            delete this._adjustHeightOnPopupShown;
            this.adjustHeight();
          }
      ]]>
      </handler>

      <handler event="popuphiding"><![CDATA[
        var isListActive = true;
        if (this.selectedIndex == -1)
          isListActive = false;
        this.input.controller.stopSearch();

        this.removeAttribute("autocompleteinput");
        this.mPopupOpen = false;

        // Reset the maxRows property to the cached "normal" value (if there's
        // any), and reset normalMaxRows so that we can detect whether it was set
        // by the input when the popupshowing handler runs.

        // Null-check this.mInput; see bug 1017914
        if (this.mInput && this._normalMaxRows > 0) {
          this.mInput.maxRows = this._normalMaxRows;
        }
        this._normalMaxRows = -1;
        // If the list was being navigated and then closed, make sure
        // we fire accessible focus event back to textbox

        // Null-check this.mInput; see bug 1017914
        if (isListActive && this.mInput) {
          this.mInput.mIgnoreFocus = true;
          this.mInput._focus();
          this.mInput.mIgnoreFocus = false;
        }
      ]]></handler>
    </handlers>
  </binding>
</bindings>

    </textarea>
    <pre></pre>
  </div>
  </main>
    <script>
    function getJSForBinding(binding) {
  let js = [];
  let elementName = binding.attrs.id;
  let className = 'Moz' + titleCase(elementName);
  let hasExtends = !!formatExtends(binding.attrs.extends);
  js.push(`class ${className} `);
  if (hasExtends) {
    js.push(`extends Moz${formatExtends(binding.attrs.extends)} `);
  } else {
    js.push(`extends MozXULElement `);
  }

  js.push('{')

  let childMarkup = [];
  let content = binding.find("content");
  if (content.length === 0) {
    content = binding.find("xbl:content");
  }
  if (content.length > 1) {
    throw "Unexpected second content field";
  } else if (content.length === 1) {
    function printChild(child, depth) {
      let attrs = '';
      for (var attr in child.attrs) {
        attrs += ' ' + attr.replace('xbl:', '') + '="' + child.attrs[attr].replace('"', '\"').replace(/xbl\:/g, '') + '"';
      }
      let name = child.name.replace('xul:', '');
      let padding = (new Array(depth + 3)).join("  ");
      childMarkup.push(`\n${padding}<${name}${attrs}>`);
      child.children.forEach(c => printChild(c, depth+1));
      let closePadding = child.children.length ? `\n${padding}` : '';
      childMarkup.push(`${closePadding}</${name}>`);
    }
    content[0].children.forEach(c => printChild(c, 1));
  } else {
    console.log("No content for binding", binding.attrs.id);
  }

  let innerHTML = "";

  if (content.length) {
    innerHTML += 'this.textContent = "";\n';
    innerHTML += "this.appendChild(MozXULElement.parseXULToFragment(`" + childMarkup.join('') + "\n    `));\n";

    if (childMarkup.join("").includes("inherits=")) {
      innerHTML += "// XXX: Implement `this.inheritAttribute()` for the [inherits] attribute in the markup above!\n";
    }
  }

  let xblconstructor = (binding.find("constructor") || [])[0];
  let xblconstructorComment = xblconstructor ? formatComment(xblconstructor.comment) : null;
  xblconstructor = xblconstructor ? `${xblconstructor.cdata || xblconstructor.value}` : '';
  if (xblconstructorComment) {
    xblconstructor = xblconstructorComment + "\n" + xblconstructor;
  }
  // Or, try / catch since many components will fail when loaded in a tab due to chrome references
  // xblconstructor = xblconstructor ? `try { ${xblconstructor.cdata} } catch(e) { }` : '';

  let xbldestructor = (binding.find("destructor") || [])[0];
  let xbldestructorComment = xbldestructor ? formatComment(xbldestructor.comment) : null;
  xbldestructor = xbldestructor ? `${xbldestructor.cdata || xbldestructor.value}` : '';
  // Or, try / catch since many components will fail when loaded in a tab due to chrome references
  // xbldestructor = xbldestructor ? `try { ${xbldestructor.cdata} } catch(e) { }` : '';
  if (xbldestructor != '') {
    xbldestructor = `disconnectedCallback() { ${xbldestructor} }`
    if (xblconstructorComment) {
      xbldestructor = xblconstructorComment + "\n" + xbldestructor;
    }
  }

  let handlers = [];
console.log(binding.attrs.id);
if (binding.attrs.id == "browser") {
  console.log("BROWSER", binding.find('handler').length);
}
  // <handler>
  for (let handler of binding.find('handler')) {
    let comment = formatComment(handler.comment);
    if (comment) {
      handlers.push(comment);
    }

    let secondParam = "";
    let isCapturing = handler.attrs.phase === "capturing";
    if (handler.attrs.group === "system") {
      if (isCapturing) {
        secondParam = `, { capture: true, mozSystemGroup: true }`;
      } else {
        secondParam = `, { mozSystemGroup: true }`;
      }
    } else if (isCapturing) {
      secondParam = ", true";
    }
    let keycode = handler.attrs.keycode ?
`
if (event.keyCode != KeyEvent.DOM_${handler.attrs.keycode}) {
  return;
}
` : "";
    let button = handler.attrs.button ?
`
if (event.button != ${handler.attrs.button}) {
  return;
}
` : "";

// console.log("BROWSER", binding.attrs.id);
// if (binding.attrs.id == "browser") {
//   console.log("BROWSER", keycode);
// }
    handlers.push(`this.addEventListener("${handler.attrs.event}", (event) => {${keycode}${button} ${handler.cdata || handler.value || handler.attrs.action}}${secondParam});\n`);
  }


  // <field>
  let fields = [];
  for (let field of binding.find('field')) {
    // Work around fields like _weekStart in the datepicker where the value is coming from a dtd.
    // Just print an empty string in that case.
    let data = (field.cdata || field.value || "").trim();
    if (data.startsWith("FROM-DTD")) {
      data = `"${data}"`
    }
    data = (data.length === 0) ? '""' : data;

    // Remove leading comments, which would cause the 'return' to be on a different line
    // than the expression.
    let leadingComments = [];
    let expressions = data.split("\n");
    for (var i = 0; i < expressions.length; i++) {
      if (expressions[i].trim().startsWith("//")) {
        leadingComments.push(expressions[i]);
      } else {
        expressions = expressions.slice(i);
        break;
      }
    }

    let expr = expressions.join("\n");
    if (expr[expr.length - 1] !== ";") {
      expr += ";";
    }
    // Strip away parens that were only needed for XBL
    if (expr[0] === "(" && expr[expr.length - 2] === ")") {
      expr = expr.substring(1, expr.length - 2) + ";";
    }

    let comment = formatComment(field.comment);
    if (comment) {
      fields.push(comment);
    }

    if (leadingComments.length) {
      fields.push(leadingComments.join("\n"));
    }

    fields.push(`this.${field.attrs.name} = ${expr}\n`);

    // let setter = field.attrs.readonly ? '' :
    // `set(val) {
    //     delete this.${field.attrs.name};
    //     return this.${field.attrs.name} = val;
    // },`;

    // fields.push(`Object.defineProperty(this, "${field.attrs.name}", {
    //   configurable: true,
    //   enumerable: true,
    //   get() {
    //     ${comments.join('\n')}
    //     delete this.${field.attrs.name};
    //     return this.${field.attrs.name} = ${expressions.join('\n')}
    //   },
    //   ${setter}
    // })`);
  }

  if (handlers.length) {
    js.push(`
      constructor() {
        super();

        ${handlers.join("\n")}
      }
    `)
  }

  js.push(`
    connectedCallback() {
      if (this.delayConnectedCallback()) {
        return;
      }
      ${innerHTML}
      ${fields.join("\n")}

      ${xblconstructor}
    }
  `);

  // <property>
  for (let property of binding.find('property')) {
    let comment = formatComment(property.comment);
    if (comment) {
      js.push(comment);
    }
    if (property.attrs.onset) {
      js.push(`
        set ${property.attrs.name}(val) {
          ${property.attrs.onset}
        }
      `);
    } else if(property.find('setter').length) {
      js.push(`
        set ${property.attrs.name}(val) {${property.find('setter')[0].cdata || property.find('setter')[0].value}}
      `);
    }
    if (property.attrs.onget) {
      js.push(`
        get ${property.attrs.name}() {
          ${property.attrs.onget}
        }
      `);
    } else if(property.find('getter').length) {
      js.push(`
        get ${property.attrs.name}() {${property.find('getter')[0].cdata || property.find('getter')[0].value}}
      `);
    }
  }

  // <method>
  for (let method of binding.find('method')) {
    js.push('\n');
    let comment = formatComment(method.comment);
    if (comment) {
      js.push(comment);
    }
    js.push(`${method.attrs.name}(`);
    js.push(`${method.find('parameter').map(p => p.attrs.name).join(',')}`);
    js.push(`) {`);
    js.push(method.find('body')[0].cdata || method.find('body')[0].value);
    js.push(`}\n`);
  }

  js.push(`${xbldestructor}`);

  js.push("}\n\n");

  let implements =
    binding.find("implementation").length &&
    binding.find("implementation")[0].attrs.implements
  if (implements) {
    implements = implements.split(",").map(i=>"Ci." + i.trim()).join(", ");
    js.push(`MozXULElement.implementCustomInterface(${className}, [${implements}]);`)
  }



  js.push(`customElements.define("${elementName}", ${className});
  `)
  return js.join(' ');
}
    function titleCase(str) {
  if (str == "basecontrol") {
    // Special case so we don't end up with Basecontrol:
    return "BaseControl";
  }
  return str[0].toUpperCase() + str.substr(1).replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
}
    function formatExtends(ext) {
  if (!ext || ext.startsWith("xul:")) {
    return null;
  }
  return titleCase(ext.split('#')[1]);
}
    function formatComment(comment, spaces = 2) {
  if (!comment) {
    return '';
  }

  let spacesStr = new Array(spaces).join(" ");
  let commentArr = comment.split("\n").map(s=> s.trim());
  if (!commentArr[0]) { commentArr.shift(); }
  if (!commentArr[commentArr.length - 1]) { commentArr.pop(); }
  let commentFormatted = commentArr
    .map(s => (s ? `${spacesStr}* ${s}` : `${spacesStr}*`))
    .join("\n");

  return `${spacesStr}/**\n${commentFormatted}\n${spacesStr}*/`;
}
    function getFormattedJSForBinding(binding) {
  let js = [];
  js.push(
`/* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

"use strict";

// This is loaded into all XUL windows. Wrap in a block to prevent
// leaking to window scope.
{

`);

  js.push(js_beautify(
    getJSForBinding(binding),
    {
      indent_size: 2,
      // preserve_newlines: false,
      max_preserve_newlines: 2,
      brace_style: "preserve-inline"
      // keep_array_indentation: true
    }
  ));

  js.push(`

}
`);

  return js.join("");
}

    var textarea = document.querySelector("textarea");
    var pre = document.querySelector("pre");
    function createPreview() {
      var body = textarea.value;
      body = body.replace(/&([a-z0-9-]+);/gi, "FROM-DTD-$1"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2-$3"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2-$3-$4"); // Replace DTD entities
      var parsed = xmlom.parseString(body, {
        xmlns: true,
      });
      parsed.then(doc => {
        console.log(doc, doc.find("binding"));
        let js = doc.find("binding").map(binding => {
          return getFormattedJSForBinding(binding);
        }).join("\n");
        pre.textContent = js;
      }).catch(e => {
        pre.textContent =  "Error parsing XML:\n" + e;
      });
    }
    textarea.addEventListener("input", createPreview);
    createPreview();

    document.querySelector("ul").addEventListener("click", function(e) {
      if (e.originalTarget.localName === "a") {
        e.preventDefault();
        textarea.value = files[e.originalTarget.dataset.index].body;
        createPreview();
      }
    });
    </script>
  </body>
  </html>
