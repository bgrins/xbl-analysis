
  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8">
    <title>XBL To Custom Element Converter</title>
    <link rel="stylesheet" href="../static/styles.css" />
    <script src="../static/xmlom.js"></script>
    <script src="../static/beautify.js"></script>
    <style>
    main {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
      width: 100vw;
      position: absolute;
      top: 0;
      left: 0;
    }
    #converter {
      font-family: monospace;
      display: grid;
      overflow: hidden;
      grid-template-columns: auto 1fr 1fr;
      grid-gap: 10px;
    }
    textarea, pre {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: monospace;
      font-size: 12px;
    }
    ul {
      min-width: 100px;
      margin: 0;
      padding: 0;
      overflow: scroll;
      font-size: smaller;
    }
    li {
      margin: 0;
      padding: 0;
      list-style: none;
      word-break: keep-all;
    }
    </style>
    <script>
      var files = [{"file":"menu.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- import-globals-from controller.js -->\n\n<bindings id=\"placesMenuBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"places-popup-base\"\n           extends=\"chrome://global/content/bindings/popup.xml#popup\">\n    <content>\n      <xul:hbox flex=\"1\">\n        <xul:vbox class=\"menupopup-drop-indicator-bar\" hidden=\"true\">\n          <xul:image class=\"menupopup-drop-indicator\" mousethrough=\"always\"/>\n        </xul:vbox>\n        <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                            smoothscroll=\"false\">\n          <children/>\n        </xul:arrowscrollbox>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n\n      <field name=\"AppConstants\" readonly=\"true\">\n        (ChromeUtils.import(\"resource://gre/modules/AppConstants.jsm\", {})).AppConstants;\n      </field>\n\n      <field name=\"_indicatorBar\">\n        document.getAnonymousElementByAttribute(this, \"class\",\n                                                \"menupopup-drop-indicator-bar\");\n      </field>\n\n      <field name=\"_scrollBox\">\n        document.getAnonymousElementByAttribute(this, \"class\",\n                                                \"popup-internal-box\");\n      </field>\n\n      <!-- This is the view that manage the popup -->\n      <field name=\"_rootView\">PlacesUIUtils.getViewForNode(this);</field>\n\n      <!-- Check if we should hide the drop indicator for the target -->\n      <method name=\"_hideDropIndicator\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let target = aEvent.target;\n\n          // Don't draw the drop indicator outside of markers or if current\n          // node is not a Places node.\n          let betweenMarkers =\n            (this._startMarker.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_FOLLOWING) &&\n            (this._endMarker.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_PRECEDING);\n\n          // Hide the dropmarker if current node is not a Places node.\n          return !(target && target._placesNode && betweenMarkers);\n        ]]></body>\n      </method>\n\n      <!-- This function returns information about where to drop when\n           dragging over this popup insertion point -->\n      <method name=\"_getDropPoint\">\n        <parameter name=\"aEvent\"/>\n          <body><![CDATA[\n            // Can't drop if the menu isn't a folder\n            let resultNode = this._placesNode;\n\n            if (!PlacesUtils.nodeIsFolder(resultNode) ||\n                this._rootView.controller.disallowInsertion(resultNode)) {\n              return null;\n            }\n\n            var dropPoint = { ip: null, folderElt: null };\n\n            // The element we are dragging over\n            let elt = aEvent.target;\n            if (elt.localName == \"menupopup\")\n              elt = elt.parentNode;\n\n            let eventY = aEvent.clientY;\n            let {y: eltY, height: eltHeight} = elt.getBoundingClientRect();\n\n            if (!elt._placesNode) {\n              // If we are dragging over a non places node drop at the end.\n              dropPoint.ip = new PlacesInsertionPoint({\n                parentId: PlacesUtils.getConcreteItemId(resultNode),\n                parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n              });\n              // We can set folderElt if we are dropping over a static menu that\n              // has an internal placespopup.\n              let isMenu = elt.localName == \"menu\" ||\n                 (elt.localName == \"toolbarbutton\" &&\n                  elt.getAttribute(\"type\") == \"menu\");\n              if (isMenu && elt.lastElementChild &&\n                  elt.lastElementChild.hasAttribute(\"placespopup\"))\n                dropPoint.folderElt = elt;\n              return dropPoint;\n            }\n\n            let tagName = PlacesUtils.nodeIsTagQuery(elt._placesNode) ?\n                            elt._placesNode.title : null;\n            if ((PlacesUtils.nodeIsFolder(elt._placesNode) &&\n                 !PlacesUIUtils.isFolderReadOnly(elt._placesNode)) ||\n                PlacesUtils.nodeIsTagQuery(elt._placesNode)) {\n              // This is a folder or a tag container.\n              if (eventY - eltY < eltHeight * 0.20) {\n                // If mouse is in the top part of the element, drop above folder.\n                dropPoint.ip = new PlacesInsertionPoint({\n                  parentId: PlacesUtils.getConcreteItemId(resultNode),\n                  parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n                  orientation: Ci.nsITreeView.DROP_BEFORE,\n                  tagName,\n                  dropNearNode: elt._placesNode,\n                });\n                return dropPoint;\n              } else if (eventY - eltY < eltHeight * 0.80) {\n                // If mouse is in the middle of the element, drop inside folder.\n                dropPoint.ip = new PlacesInsertionPoint({\n                  parentId: PlacesUtils.getConcreteItemId(elt._placesNode),\n                  parentGuid: PlacesUtils.getConcreteItemGuid(elt._placesNode),\n                  tagName,\n                });\n                dropPoint.folderElt = elt;\n                return dropPoint;\n              }\n            } else if (eventY - eltY <= eltHeight / 2) {\n              // This is a non-folder node or a readonly folder.\n              // If the mouse is above the middle, drop above this item.\n              dropPoint.ip = new PlacesInsertionPoint({\n                parentId: PlacesUtils.getConcreteItemId(resultNode),\n                parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n                orientation: Ci.nsITreeView.DROP_BEFORE,\n                tagName,\n                dropNearNode: elt._placesNode,\n              });\n              return dropPoint;\n            }\n\n            // Drop below the item.\n            dropPoint.ip = new PlacesInsertionPoint({\n              parentId: PlacesUtils.getConcreteItemId(resultNode),\n              parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n              orientation: Ci.nsITreeView.DROP_AFTER,\n              tagName,\n              dropNearNode: elt._placesNode,\n            });\n            return dropPoint;\n        ]]></body>\n      </method>\n\n      <!-- Sub-menus should be opened when the mouse drags over them, and closed\n           when the mouse drags off.  The overFolder object manages opening and\n           closing of folders when the mouse hovers. -->\n      <field name=\"_overFolder\"><![CDATA[({\n        _self: this,\n        _folder: {elt: null,\n                  openTimer: null,\n                  hoverTime: 350,\n                  closeTimer: null},\n        _closeMenuTimer: null,\n\n        get elt() {\n          return this._folder.elt;\n        },\n        set elt(val) {\n          return this._folder.elt = val;\n        },\n\n        get openTimer() {\n          return this._folder.openTimer;\n        },\n        set openTimer(val) {\n          return this._folder.openTimer = val;\n        },\n\n        get hoverTime() {\n          return this._folder.hoverTime;\n        },\n        set hoverTime(val) {\n          return this._folder.hoverTime = val;\n        },\n\n        get closeTimer() {\n          return this._folder.closeTimer;\n        },\n        set closeTimer(val) {\n          return this._folder.closeTimer = val;\n        },\n\n        get closeMenuTimer() {\n          return this._closeMenuTimer;\n        },\n        set closeMenuTimer(val) {\n          return this._closeMenuTimer = val;\n        },\n\n        setTimer: function OF__setTimer(aTime) {\n          var timer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n          timer.initWithCallback(this, aTime, timer.TYPE_ONE_SHOT);\n          return timer;\n        },\n\n        notify: function OF__notify(aTimer) {\n          // Function to process all timer notifications.\n\n          if (aTimer == this._folder.openTimer) {\n            // Timer to open a submenu that's being dragged over.\n            this._folder.elt.lastElementChild.setAttribute(\"autoopened\", \"true\");\n            this._folder.elt.lastElementChild.openPopup();\n            this._folder.openTimer = null;\n          } else if (aTimer == this._folder.closeTimer) {\n            // Timer to close a submenu that's been dragged off of.\n            // Only close the submenu if the mouse isn't being dragged over any\n            // of its child menus.\n            var draggingOverChild = PlacesControllerDragHelper\n                                    .draggingOverChildNode(this._folder.elt);\n            if (draggingOverChild)\n              this._folder.elt = null;\n            this.clear();\n\n            // Close any parent folders which aren't being dragged over.\n            // (This is necessary because of the above code that keeps a folder\n            // open while its children are being dragged over.)\n            if (!draggingOverChild)\n              this.closeParentMenus();\n          } else if (aTimer == this.closeMenuTimer) {\n            // Timer to close this menu after the drag exit.\n            var popup = this._self;\n            // if we are no more dragging we can leave the menu open to allow\n            // for better D&D bookmark organization\n            if (PlacesControllerDragHelper.getSession() &&\n                !PlacesControllerDragHelper.draggingOverChildNode(popup.parentNode)) {\n              popup.hidePopup();\n              // Close any parent menus that aren't being dragged over;\n              // otherwise they'll stay open because they couldn't close\n              // while this menu was being dragged over.\n              this.closeParentMenus();\n            }\n            this._closeMenuTimer = null;\n          }\n        },\n\n        //  Helper function to close all parent menus of this menu,\n        //  as long as none of the parent's children are currently being\n        //  dragged over.\n        closeParentMenus: function OF__closeParentMenus() {\n          var popup = this._self;\n          var parent = popup.parentNode;\n          while (parent) {\n            if (parent.localName == \"menupopup\" && parent._placesNode) {\n              if (PlacesControllerDragHelper.draggingOverChildNode(parent.parentNode))\n                break;\n              parent.hidePopup();\n            }\n            parent = parent.parentNode;\n          }\n        },\n\n        //  The mouse is no longer dragging over the stored menubutton.\n        //  Close the menubutton, clear out drag styles, and clear all\n        //  timers for opening/closing it.\n        clear: function OF__clear() {\n          if (this._folder.elt && this._folder.elt.lastElementChild) {\n            if (!this._folder.elt.lastElementChild.hasAttribute(\"dragover\"))\n              this._folder.elt.lastElementChild.hidePopup();\n            // remove menuactive style\n            this._folder.elt.removeAttribute(\"_moz-menuactive\");\n            this._folder.elt = null;\n          }\n          if (this._folder.openTimer) {\n            this._folder.openTimer.cancel();\n            this._folder.openTimer = null;\n          }\n          if (this._folder.closeTimer) {\n            this._folder.closeTimer.cancel();\n            this._folder.closeTimer = null;\n          }\n        },\n      })]]></field>\n\n      <method name=\"_cleanupDragDetails\">\n        <body><![CDATA[\n          // Called on dragend and drop.\n          PlacesControllerDragHelper.currentDropTarget = null;\n          this._rootView._draggedElt = null;\n          this.removeAttribute(\"dragover\");\n          this.removeAttribute(\"dragstart\");\n          this._indicatorBar.hidden = true;\n        ]]></body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"DOMMenuItemActive\"><![CDATA[\n        let elt = event.target;\n        if (elt.parentNode != this)\n          return;\n\n        if (this.AppConstants.platform === \"macosx\") {\n          // XXX: The following check is a temporary hack until bug 420033 is\n          // resolved.\n          let parentElt = elt.parent;\n          while (parentElt) {\n            if (parentElt.id == \"bookmarksMenuPopup\" ||\n                parentElt.id == \"goPopup\")\n              return;\n\n            parentElt = parentElt.parentNode;\n          }\n        }\n\n        if (window.XULBrowserWindow) {\n          let placesNode = elt._placesNode;\n\n          var linkURI;\n          if (placesNode && PlacesUtils.nodeIsURI(placesNode))\n            linkURI = placesNode.uri;\n          else if (elt.hasAttribute(\"targetURI\"))\n            linkURI = elt.getAttribute(\"targetURI\");\n\n          if (linkURI)\n            window.XULBrowserWindow.setOverLink(linkURI, null);\n        }\n      ]]></handler>\n\n      <handler event=\"DOMMenuItemInactive\"><![CDATA[\n        let elt = event.target;\n        if (elt.parentNode != this)\n          return;\n\n        if (window.XULBrowserWindow)\n          window.XULBrowserWindow.setOverLink(\"\", null);\n      ]]></handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        let elt = event.target;\n        if (!elt._placesNode)\n          return;\n\n        let draggedElt = elt._placesNode;\n\n        // Force a copy action if parent node is a query or we are dragging a\n        // not-removable node.\n        if (!this._rootView.controller.canMoveNode(draggedElt))\n          event.dataTransfer.effectAllowed = \"copyLink\";\n\n        // Activate the view and cache the dragged element.\n        this._rootView._draggedElt = draggedElt;\n        this._rootView.controller.setDataTransfer(event);\n        this.setAttribute(\"dragstart\", \"true\");\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"drop\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = event.target;\n\n        let dropPoint = this._getDropPoint(event);\n        if (dropPoint && dropPoint.ip) {\n          PlacesControllerDragHelper.onDrop(dropPoint.ip, event.dataTransfer)\n                                    .catch(Cu.reportError);\n          event.preventDefault();\n        }\n\n        this._cleanupDragDetails();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = event.target;\n        let dt = event.dataTransfer;\n\n        let dropPoint = this._getDropPoint(event);\n        if (!dropPoint || !dropPoint.ip ||\n            !PlacesControllerDragHelper.canDrop(dropPoint.ip, dt)) {\n          this._indicatorBar.hidden = true;\n          event.stopPropagation();\n          return;\n        }\n\n        // Mark this popup as being dragged over.\n        this.setAttribute(\"dragover\", \"true\");\n\n        if (dropPoint.folderElt) {\n          // We are dragging over a folder.\n          // _overFolder should take the care of opening it on a timer.\n          if (this._overFolder.elt &&\n              this._overFolder.elt != dropPoint.folderElt) {\n            // We are dragging over a new folder, let's clear old values\n            this._overFolder.clear();\n          }\n          if (!this._overFolder.elt) {\n            this._overFolder.elt = dropPoint.folderElt;\n            // Create the timer to open this folder.\n            this._overFolder.openTimer = this._overFolder\n                                             .setTimer(this._overFolder.hoverTime);\n          }\n          // Since we are dropping into a folder set the corresponding style.\n          dropPoint.folderElt.setAttribute(\"_moz-menuactive\", true);\n        } else {\n          // We are not dragging over a folder.\n          // Clear out old _overFolder information.\n          this._overFolder.clear();\n        }\n\n        // Autoscroll the popup strip if we drag over the scroll buttons.\n        let anonid = event.originalTarget.getAttribute(\"anonid\");\n        let scrollDir = 0;\n        if (anonid == \"scrollbutton-up\") {\n          scrollDir = -1;\n        } else if (anonid == \"scrollbutton-down\") {\n          scrollDir = 1;\n        }\n        if (scrollDir != 0) {\n          this._scrollBox.scrollByIndex(scrollDir, true);\n        }\n\n        // Check if we should hide the drop indicator for this target.\n        if (dropPoint.folderElt || this._hideDropIndicator(event)) {\n          this._indicatorBar.hidden = true;\n          event.preventDefault();\n          event.stopPropagation();\n          return;\n        }\n\n        // We should display the drop indicator relative to the arrowscrollbox.\n        let scrollRect = this._scrollBox.getBoundingClientRect();\n        let newMarginTop = 0;\n        if (scrollDir == 0) {\n          let elt = this.firstElementChild;\n          while (elt && event.screenY > elt.screenY +\n                                        elt.getBoundingClientRect().height / 2)\n            elt = elt.nextElementSibling;\n          newMarginTop = elt ? elt.screenY - this._scrollBox.screenY :\n                               scrollRect.height;\n        } else if (scrollDir == 1) {\n          newMarginTop = scrollRect.height;\n        }\n\n        // Set the new marginTop based on arrowscrollbox.\n        newMarginTop += scrollRect.y - this._scrollBox.getBoundingClientRect().y;\n        this._indicatorBar.firstElementChild.style.marginTop = newMarginTop + \"px\";\n        this._indicatorBar.hidden = false;\n\n        event.preventDefault();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragexit\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = null;\n        this.removeAttribute(\"dragover\");\n\n        // If we have not moved to a valid new target clear the drop indicator\n        // this happens when moving out of the popup.\n        let target = event.relatedTarget;\n        if (!target || !this.contains(target))\n          this._indicatorBar.hidden = true;\n\n        // Close any folder being hovered over\n        if (this._overFolder.elt) {\n          this._overFolder.closeTimer = this._overFolder\n                                            .setTimer(this._overFolder.hoverTime);\n        }\n\n        // The autoopened attribute is set when this folder was automatically\n        // opened after the user dragged over it.  If this attribute is set,\n        // auto-close the folder on drag exit.\n        // We should also try to close this popup if the drag has started\n        // from here, the timer will check if we are dragging over a child.\n        if (this.hasAttribute(\"autoopened\") ||\n            this.hasAttribute(\"dragstart\")) {\n          this._overFolder.closeMenuTimer = this._overFolder\n                                                .setTimer(this._overFolder.hoverTime);\n        }\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragend\"><![CDATA[\n        this._cleanupDragDetails();\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n  <!-- Most of this is copied from the arrowpanel binding in popup.xml -->\n  <binding id=\"places-popup-arrow\"\n           extends=\"chrome://browser/content/places/menu.xml#places-popup-base\">\n    <content flip=\"both\" side=\"top\" position=\"bottomcenter topright\">\n      <xul:vbox anonid=\"container\" class=\"panel-arrowcontainer\" flex=\"1\"\n               xbl:inherits=\"side,panelopen\">\n        <xul:box anonid=\"arrowbox\" class=\"panel-arrowbox\">\n          <xul:image anonid=\"arrow\" class=\"panel-arrow\" xbl:inherits=\"side\"/>\n        </xul:box>\n        <xul:box class=\"panel-arrowcontent\" xbl:inherits=\"side,align,dir,orient,pack\" flex=\"1\">\n          <xul:vbox class=\"menupopup-drop-indicator-bar\" hidden=\"true\">\n            <xul:image class=\"menupopup-drop-indicator\" mousethrough=\"always\"/>\n          </xul:vbox>\n          <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                              smoothscroll=\"false\">\n            <children/>\n          </xul:arrowscrollbox>\n        </xul:box>\n      </xul:vbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this.style.pointerEvents = \"none\";\n      ]]></constructor>\n      <method name=\"adjustArrowPosition\">\n        <body><![CDATA[\n          var arrow = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrow\");\n\n          var anchor = this.anchorNode;\n          if (!anchor) {\n            arrow.hidden = true;\n            return;\n          }\n\n          var container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n          var arrowbox = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\");\n\n          var position = this.alignmentPosition;\n          var offset = this.alignmentOffset;\n\n          this.setAttribute(\"arrowposition\", position);\n\n          // if this panel has a \"sliding\" arrow, we may have previously set margins...\n          arrowbox.style.removeProperty(\"transform\");\n          if (position.indexOf(\"start_\") == 0 || position.indexOf(\"end_\") == 0) {\n            container.orient = \"horizontal\";\n            arrowbox.orient = \"vertical\";\n            if (position.indexOf(\"_after\") > 0) {\n              arrowbox.pack = \"end\";\n            } else {\n              arrowbox.pack = \"start\";\n            }\n            arrowbox.style.transform = \"translate(0, \" + -offset + \"px)\";\n\n            // The assigned side stays the same regardless of direction.\n            let isRTL = this.matches(\":-moz-locale-dir(rtl)\");\n\n            if (position.indexOf(\"start_\") == 0) {\n              container.dir = \"reverse\";\n              this.setAttribute(\"side\", isRTL ? \"left\" : \"right\");\n            } else {\n              container.dir = \"\";\n              this.setAttribute(\"side\", isRTL ? \"right\" : \"left\");\n            }\n          } else if (position.indexOf(\"before_\") == 0 || position.indexOf(\"after_\") == 0) {\n            container.orient = \"\";\n            arrowbox.orient = \"\";\n            if (position.indexOf(\"_end\") > 0) {\n              arrowbox.pack = \"end\";\n            } else {\n              arrowbox.pack = \"start\";\n            }\n            arrowbox.style.transform = \"translate(\" + -offset + \"px, 0)\";\n\n            if (position.indexOf(\"before_\") == 0) {\n              container.dir = \"reverse\";\n              this.setAttribute(\"side\", \"bottom\");\n            } else {\n              container.dir = \"\";\n              this.setAttribute(\"side\", \"top\");\n            }\n          }\n\n          arrow.hidden = false;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\"><![CDATA[\n        this.adjustArrowPosition();\n        this.setAttribute(\"animate\", \"open\");\n      ]]></handler>\n      <handler event=\"popupshown\" phase=\"target\"><![CDATA[\n        this.setAttribute(\"panelopen\", \"true\");\n        let disablePointerEvents;\n        if (!this.hasAttribute(\"disablepointereventsfortransition\")) {\n          let container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n          let cs = getComputedStyle(container);\n          let transitionProp = cs.transitionProperty;\n          let transitionTime = parseFloat(cs.transitionDuration);\n          disablePointerEvents = (transitionProp.includes(\"transform\") ||\n                                  transitionProp == \"all\") &&\n                                 transitionTime > 0;\n          this.setAttribute(\"disablepointereventsfortransition\", disablePointerEvents);\n        } else {\n          disablePointerEvents = this.getAttribute(\"disablepointereventsfortransition\") == \"true\";\n        }\n        if (!disablePointerEvents) {\n          this.style.removeProperty(\"pointer-events\");\n        }\n      ]]></handler>\n      <handler event=\"transitionend\"><![CDATA[\n        if (event.originalTarget.getAttribute(\"anonid\") == \"container\" &&\n            (event.propertyName == \"transform\" || event.propertyName == \"-moz-window-transform\")) {\n          this.style.removeProperty(\"pointer-events\");\n        }\n      ]]></handler>\n      <handler event=\"popuphiding\" phase=\"target\"><![CDATA[\n        this.setAttribute(\"animate\", \"cancel\");\n      ]]></handler>\n      <handler event=\"popuphidden\" phase=\"target\"><![CDATA[\n        this.removeAttribute(\"panelopen\");\n        if (this.getAttribute(\"disablepointereventsfortransition\") == \"true\") {\n          this.style.pointerEvents = \"none\";\n        }\n        this.removeAttribute(\"animate\");\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"autocomplete.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"autocompleteBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"autocomplete\"\n           extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content sizetopopup=\"pref\">\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\">\n        <html:input anonid=\"input\" class=\"textbox-input\"\n                    allowevents=\"true\"\n                    autocomplete=\"off\"\n                    xbl:inherits=\"value,type=inputtype,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,mozactionhint\"/>\n      </xul:moz-input-box>\n      <xul:popupset anonid=\"popupset\" class=\"autocomplete-result-popupset\"/>\n    </content>\n\n    <implementation implements=\"nsIAutoCompleteInput, nsIDOMXULMenuListElement\">\n      <field name=\"mController\">null</field>\n      <field name=\"mSearchNames\">null</field>\n      <field name=\"mIgnoreInput\">false</field>\n      <field name=\"noRollupOnEmptySearch\">false</field>\n\n      <field name=\"_searchBeginHandler\">null</field>\n      <field name=\"_searchCompleteHandler\">null</field>\n      <field name=\"_textEnteredHandler\">null</field>\n      <field name=\"_textRevertedHandler\">null</field>\n\n      <constructor><![CDATA[\n        this.mController = Cc[\"@mozilla.org/autocomplete/controller;1\"].\n          getService(Ci.nsIAutoCompleteController);\n\n        this._searchBeginHandler = this.initEventHandler(\"searchbegin\");\n        this._searchCompleteHandler = this.initEventHandler(\"searchcomplete\");\n        this._textEnteredHandler = this.initEventHandler(\"textentered\");\n        this._textRevertedHandler = this.initEventHandler(\"textreverted\");\n      ]]></constructor>\n\n      <!-- =================== nsIAutoCompleteInput =================== -->\n\n      <field name=\"_popup\">null</field>\n      <property name=\"popup\" readonly=\"true\">\n        <getter><![CDATA[\n          // Memoize the result in a field rather than replacing this property,\n          // so that it can be reset along with the binding.\n          if (this._popup) {\n            return this._popup;\n          }\n\n          let popup = null;\n          let popupId = this.getAttribute(\"autocompletepopup\");\n          if (popupId) {\n            popup = document.getElementById(popupId);\n          }\n          if (!popup) {\n            popup = document.createXULElement(\"panel\", { is: \"autocomplete-richlistbox-popup\" });\n            popup.setAttribute(\"type\", \"autocomplete-richlistbox\");\n            popup.setAttribute(\"noautofocus\", \"true\");\n\n            let popupset = document.getAnonymousElementByAttribute(this, \"anonid\", \"popupset\");\n            popupset.appendChild(popup);\n          }\n          popup.mInput = this;\n\n          return this._popup = popup;\n        ]]></getter>\n      </property>\n      <property name=\"popupElement\" readonly=\"true\"\n                onget=\"return this.popup;\"/>\n\n      <property name=\"controller\" onget=\"return this.mController;\" readonly=\"true\"/>\n\n      <property name=\"popupOpen\"\n                onget=\"return this.popup.popupOpen;\"\n                onset=\"if (val) this.openPopup(); else this.closePopup();\"/>\n\n      <property name=\"disableAutoComplete\"\n                onset=\"this.setAttribute('disableautocomplete', val); return val;\"\n                onget=\"return this.getAttribute('disableautocomplete') == 'true';\"/>\n\n      <property name=\"completeDefaultIndex\"\n                onset=\"this.setAttribute('completedefaultindex', val); return val;\"\n                onget=\"return this.getAttribute('completedefaultindex') == 'true';\"/>\n\n      <property name=\"completeSelectedIndex\"\n                onset=\"this.setAttribute('completeselectedindex', val); return val;\"\n                onget=\"return this.getAttribute('completeselectedindex') == 'true';\"/>\n\n      <property name=\"forceComplete\"\n                onset=\"this.setAttribute('forcecomplete', val); return val;\"\n                onget=\"return this.getAttribute('forcecomplete') == 'true';\"/>\n\n      <property name=\"minResultsForPopup\"\n                onset=\"this.setAttribute('minresultsforpopup', val); return val;\"\n                onget=\"var m = parseInt(this.getAttribute('minresultsforpopup')); return isNaN(m) ? 1 : m;\"/>\n\n      <property name=\"timeout\"\n                onset=\"this.setAttribute('timeout', val); return val;\"\n                onget=\"var t = parseInt(this.getAttribute('timeout')); return isNaN(t) ? 50 : t;\"/>\n\n      <property name=\"searchParam\"\n                onget=\"return this.getAttribute('autocompletesearchparam') || '';\"\n                onset=\"this.setAttribute('autocompletesearchparam', val); return val;\"/>\n\n      <property name=\"searchCount\" readonly=\"true\"\n                onget=\"this.initSearchNames(); return this.mSearchNames.length;\"/>\n\n      <property name=\"PrivateBrowsingUtils\" readonly=\"true\">\n        <getter><![CDATA[\n          let module = {};\n          ChromeUtils.import(\"resource://gre/modules/PrivateBrowsingUtils.jsm\", module);\n          Object.defineProperty(this, \"PrivateBrowsingUtils\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: module.PrivateBrowsingUtils,\n          });\n          return module.PrivateBrowsingUtils;\n        ]]></getter>\n      </property>\n\n      <property name=\"inPrivateContext\" readonly=\"true\"\n                onget=\"return this.PrivateBrowsingUtils.isWindowPrivate(window);\"/>\n\n      <property name=\"noRollupOnCaretMove\" readonly=\"true\"\n                onget=\"return this.popup.getAttribute('norolluponanchor') == 'true'\"/>\n\n      <!-- This is the maximum number of drop-down rows we get when we\n            hit the drop marker beside fields that have it (like the URLbar).-->\n      <field name=\"maxDropMarkerRows\" readonly=\"true\">14</field>\n\n      <method name=\"getSearchAt\">\n        <parameter name=\"aIndex\"/>\n        <body><![CDATA[\n          this.initSearchNames();\n          return this.mSearchNames[aIndex];\n        ]]></body>\n      </method>\n\n      <method name=\"setTextValueWithReason\">\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aReason\"/>\n        <body><![CDATA[\n          if (aReason == Ci.nsIAutoCompleteInput\n                           .TEXTVALUE_REASON_COMPLETEDEFAULT) {\n            this._textValueSetByCompleteDefault = true;\n          }\n          this.textValue = aValue;\n          this._textValueSetByCompleteDefault = false;\n        ]]></body>\n      </method>\n\n      <property name=\"textValue\">\n        <getter><![CDATA[\n          if (typeof this.onBeforeTextValueGet == \"function\") {\n            let result = this.onBeforeTextValueGet();\n            if (result) {\n              return result.value;\n            }\n          }\n          return this.value;\n        ]]></getter>\n        <setter><![CDATA[\n          if (typeof this.onBeforeTextValueSet == \"function\" &&\n              !this._textValueSetByCompleteDefault) {\n            val = this.onBeforeTextValueSet(val);\n          }\n\n          // \"input\" event is automatically dispatched by the editor if\n          // necessary.\n          this._setValueInternal(val, true);\n\n          return this.value;\n        ]]></setter>\n      </property>\n\n      <method name=\"selectTextRange\">\n        <parameter name=\"aStartIndex\"/>\n        <parameter name=\"aEndIndex\"/>\n        <body><![CDATA[\n          this.inputField.setSelectionRange(aStartIndex, aEndIndex);\n        ]]></body>\n      </method>\n\n      <method name=\"onSearchBegin\">\n        <body><![CDATA[\n          if (this.popup && typeof this.popup.onSearchBegin == \"function\")\n            this.popup.onSearchBegin();\n          if (this._searchBeginHandler)\n            this._searchBeginHandler();\n        ]]></body>\n      </method>\n\n      <method name=\"onSearchComplete\">\n        <body><![CDATA[\n          if (this.mController.matchCount == 0)\n            this.setAttribute(\"nomatch\", \"true\");\n          else\n            this.removeAttribute(\"nomatch\");\n\n          if (this.ignoreBlurWhileSearching && !this.focused) {\n            this.handleEnter();\n            this.detachController();\n          }\n\n          if (this._searchCompleteHandler)\n            this._searchCompleteHandler();\n        ]]></body>\n      </method>\n\n      <method name=\"onTextEntered\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let rv = false;\n          if (this._textEnteredHandler) {\n            rv = this._textEnteredHandler(event);\n          }\n          return rv;\n        ]]></body>\n      </method>\n\n      <method name=\"onTextReverted\">\n        <body><![CDATA[\n          if (this._textRevertedHandler)\n            return this._textRevertedHandler();\n          return false;\n        ]]></body>\n      </method>\n\n      <!-- =================== nsIDOMXULMenuListElement =================== -->\n\n      <property name=\"editable\" readonly=\"true\"\n                onget=\"return true;\" />\n\n      <property name=\"crop\"\n                onset=\"this.setAttribute('crop',val); return val;\"\n                onget=\"return this.getAttribute('crop');\"/>\n\n      <property name=\"open\"\n                onget=\"return this.getAttribute('open') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.showHistoryPopup();\n          else\n            this.closePopup();\n        ]]></setter>\n      </property>\n\n      <!-- =================== PUBLIC MEMBERS =================== -->\n\n      <field name=\"valueIsTyped\">false</field>\n      <field name=\"_textValueSetByCompleteDefault\">false</field>\n      <property name=\"value\"\n                onset=\"return this._setValueInternal(val, false);\">\n        <getter><![CDATA[\n          if (typeof this.onBeforeValueGet == \"function\") {\n            var result = this.onBeforeValueGet();\n            if (result)\n              return result.value;\n          }\n          return this.inputField.value;\n        ]]></getter>\n      </property>\n\n      <property name=\"focused\" readonly=\"true\"\n                onget=\"return this.getAttribute('focused') == 'true';\"/>\n\n      <!-- maximum number of rows to display at a time -->\n      <property name=\"maxRows\"\n                onset=\"this.setAttribute('maxrows', val); return val;\"\n                onget=\"return parseInt(this.getAttribute('maxrows')) || 0;\"/>\n\n      <!-- option to allow scrolling through the list via the tab key, rather than\n           tab moving focus out of the textbox -->\n      <property name=\"tabScrolling\"\n                onset=\"this.setAttribute('tabscrolling', val); return val;\"\n                onget=\"return this.getAttribute('tabscrolling') == 'true';\"/>\n\n      <!-- option to completely ignore any blur events while searches are\n           still going on. -->\n      <property name=\"ignoreBlurWhileSearching\"\n                onset=\"this.setAttribute('ignoreblurwhilesearching', val); return val;\"\n                onget=\"return this.getAttribute('ignoreblurwhilesearching') == 'true';\"/>\n\n      <!-- option to highlight entries that don't have any matches -->\n      <property name=\"highlightNonMatches\"\n                onset=\"this.setAttribute('highlightnonmatches', val); return val;\"\n                onget=\"return this.getAttribute('highlightnonmatches') == 'true';\"/>\n\n      <!-- =================== PRIVATE MEMBERS =================== -->\n\n      <!-- ::::::::::::: autocomplete controller ::::::::::::: -->\n\n      <method name=\"attachController\">\n        <body><![CDATA[\n          this.mController.input = this;\n        ]]></body>\n      </method>\n\n      <method name=\"detachController\">\n        <body><![CDATA[\n          if (this.mController.input == this)\n            this.mController.input = null;\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: popup opening ::::::::::::: -->\n\n      <method name=\"openPopup\">\n        <body><![CDATA[\n          if (this.focused)\n            this.popup.openAutocompletePopup(this, this);\n        ]]></body>\n      </method>\n\n      <method name=\"closePopup\">\n        <body><![CDATA[\n          this.popup.closePopup();\n        ]]></body>\n      </method>\n\n      <method name=\"showHistoryPopup\">\n        <body><![CDATA[\n          // Store our \"normal\" maxRows on the popup, so that it can reset the\n          // value when the popup is hidden.\n          this.popup._normalMaxRows = this.maxRows;\n\n          // Increase our maxRows temporarily, since we want the dropdown to\n          // be bigger in this case. The popup's popupshowing/popuphiding\n          // handlers will take care of resetting this.\n          this.maxRows = this.maxDropMarkerRows;\n\n          // Ensure that we have focus.\n          if (!this.focused)\n            this.focus();\n          this.attachController();\n          this.mController.startSearch(\"\");\n        ]]></body>\n      </method>\n\n      <method name=\"toggleHistoryPopup\">\n        <body><![CDATA[\n          if (!this.popup.popupOpen)\n            this.showHistoryPopup();\n          else\n            this.closePopup();\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: event dispatching ::::::::::::: -->\n\n      <method name=\"initEventHandler\">\n        <parameter name=\"aEventType\"/>\n        <body><![CDATA[\n          let handlerString = this.getAttribute(\"on\" + aEventType);\n          if (handlerString) {\n            return (new Function(\"eventType\", \"param\", handlerString)).bind(this, aEventType);\n          }\n          return null;\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: key handling ::::::::::::: -->\n\n      <field name=\"_selectionDetails\">null</field>\n      <method name=\"onKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          return this.handleKeyPress(aEvent);\n        ]]></body>\n      </method>\n\n      <method name=\"handleKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aOptions\"/>\n        <body><![CDATA[\n          if (aEvent.target.localName != \"textbox\")\n            return true; // Let child buttons of autocomplete take input\n\n          // Re: urlbarDeferred, see the comment in urlbarBindings.xml.\n          if (aEvent.defaultPrevented && !aEvent.urlbarDeferred) {\n            return false;\n          }\n\n          const isMac = /Mac/.test(navigator.platform);\n          var cancel = false;\n\n          // Catch any keys that could potentially move the caret. Ctrl can be\n          // used in combination with these keys on Windows and Linux; and Alt\n          // can be used on OS X, so make sure the unused one isn't used.\n          let metaKey = isMac ? aEvent.ctrlKey : aEvent.altKey;\n          if (!metaKey) {\n            switch (aEvent.keyCode) {\n              case KeyEvent.DOM_VK_LEFT:\n              case KeyEvent.DOM_VK_RIGHT:\n              case KeyEvent.DOM_VK_HOME:\n                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);\n                break;\n            }\n          }\n\n          // Handle keys that are not part of a keyboard shortcut (no Ctrl or Alt)\n          if (!aEvent.ctrlKey && !aEvent.altKey) {\n            switch (aEvent.keyCode) {\n              case KeyEvent.DOM_VK_TAB:\n                if (this.tabScrolling && this.popup.popupOpen)\n                  cancel = this.mController.handleKeyNavigation(aEvent.shiftKey ?\n                                                                KeyEvent.DOM_VK_UP :\n                                                                KeyEvent.DOM_VK_DOWN);\n                else if (this.forceComplete && this.mController.matchCount >= 1)\n                  this.mController.handleTab();\n                break;\n              case KeyEvent.DOM_VK_UP:\n              case KeyEvent.DOM_VK_DOWN:\n              case KeyEvent.DOM_VK_PAGE_UP:\n              case KeyEvent.DOM_VK_PAGE_DOWN:\n                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);\n                break;\n            }\n          }\n\n          // Handle readline/emacs-style navigation bindings on Mac.\n          if (isMac &&\n              this.popup.popupOpen &&\n              aEvent.ctrlKey &&\n              (aEvent.key === \"n\" || aEvent.key === \"p\")) {\n            const effectiveKey = (aEvent.key === \"p\") ?\n                                 KeyEvent.DOM_VK_UP :\n                                 KeyEvent.DOM_VK_DOWN;\n            cancel = this.mController.handleKeyNavigation(effectiveKey);\n          }\n\n          // Handle keys we know aren't part of a shortcut, even with Alt or\n          // Ctrl.\n          switch (aEvent.keyCode) {\n            case KeyEvent.DOM_VK_ESCAPE:\n              cancel = this.mController.handleEscape();\n              break;\n            case KeyEvent.DOM_VK_RETURN:\n              if (isMac) {\n                // Prevent the default action, since it will beep on Mac\n                if (aEvent.metaKey)\n                  aEvent.preventDefault();\n              }\n              if (this.popup.selectedIndex >= 0) {\n                this._selectionDetails = {\n                  index: this.popup.selectedIndex,\n                  kind: \"key\",\n                };\n              }\n              cancel = this.handleEnter(aEvent, aOptions);\n              break;\n            case KeyEvent.DOM_VK_DELETE:\n              if (isMac && !aEvent.shiftKey) {\n                break;\n              }\n              cancel = this.handleDelete();\n              break;\n            case KeyEvent.DOM_VK_BACK_SPACE:\n              if (isMac && aEvent.shiftKey) {\n                cancel = this.handleDelete();\n              }\n              break;\n            case KeyEvent.DOM_VK_DOWN:\n            case KeyEvent.DOM_VK_UP:\n              if (aEvent.altKey)\n                this.toggleHistoryPopup();\n              break;\n            case KeyEvent.DOM_VK_F4:\n              if (!isMac) {\n                this.toggleHistoryPopup();\n              }\n              break;\n          }\n\n          if (cancel) {\n            aEvent.stopPropagation();\n            aEvent.preventDefault();\n          }\n\n          return true;\n        ]]></body>\n      </method>\n\n      <method name=\"handleEnter\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          return this.mController.handleEnter(false, event || null);\n        ]]></body>\n      </method>\n\n      <method name=\"handleDelete\">\n        <body><![CDATA[\n          return this.mController.handleDelete();\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: miscellaneous ::::::::::::: -->\n\n      <method name=\"initSearchNames\">\n        <body><![CDATA[\n          if (!this.mSearchNames) {\n            var names = this.getAttribute(\"autocompletesearch\");\n            if (!names)\n              this.mSearchNames = [];\n            else\n              this.mSearchNames = names.split(\" \");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_focus\">\n        <!-- doesn't reset this.mController -->\n        <body><![CDATA[\n          this._dontBlur = true;\n          this.focus();\n          this._dontBlur = false;\n        ]]></body>\n      </method>\n\n      <method name=\"resetActionType\">\n        <body><![CDATA[\n          if (this.mIgnoreInput)\n            return;\n          this.removeAttribute(\"actiontype\");\n        ]]></body>\n      </method>\n\n      <method name=\"_setValueInternal\">\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aIsUserInput\"/>\n        <body><![CDATA[\n          this.mIgnoreInput = true;\n\n          if (typeof this.onBeforeValueSet == \"function\")\n            aValue = this.onBeforeValueSet(aValue);\n\n          if (typeof this.trimValue == \"function\" &&\n              !this._textValueSetByCompleteDefault)\n            aValue = this.trimValue(aValue);\n\n          this.valueIsTyped = false;\n          if (aIsUserInput) {\n            this.inputField.setUserInput(aValue);\n          } else {\n            this.inputField.value = aValue;\n          }\n\n          if (typeof this.formatValue == \"function\")\n            this.formatValue();\n\n          this.mIgnoreInput = false;\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"ValueChange\", true, true);\n          this.inputField.dispatchEvent(event);\n          return aValue;\n        ]]></body>\n      </method>\n\n      <method name=\"onInput\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this.mIgnoreInput && this.mController.input == this) {\n            this.valueIsTyped = true;\n            this.mController.handleText();\n          }\n          this.resetActionType();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"input\"><![CDATA[\n        this.onInput(event);\n      ]]></handler>\n\n      <handler event=\"keypress\" phase=\"capturing\" group=\"system\"\n               action=\"return this.onKeyPress(event);\"/>\n\n      <handler event=\"compositionstart\" phase=\"capturing\"\n               action=\"if (this.mController.input == this) this.mController.handleStartComposition();\"/>\n\n      <handler event=\"compositionend\" phase=\"capturing\"\n               action=\"if (this.mController.input == this) this.mController.handleEndComposition();\"/>\n\n      <handler event=\"focus\" phase=\"capturing\"><![CDATA[\n        this.attachController();\n        if (window.gBrowser && window.gBrowser.selectedBrowser.hasAttribute(\"usercontextid\")) {\n          this.userContextId = parseInt(window.gBrowser.selectedBrowser.getAttribute(\"usercontextid\"));\n        } else {\n          this.userContextId = 0;\n        }\n      ]]></handler>\n\n      <handler event=\"blur\" phase=\"capturing\"><![CDATA[\n        if (!this._dontBlur) {\n          if (this.forceComplete && this.mController.matchCount >= 1) {\n            // If forceComplete is requested, we need to call the enter processing\n            // on blur so the input will be forced to the closest match.\n            // Thunderbird is the only consumer of forceComplete and this is used\n            // to force an recipient's email to the exact address book entry.\n            this.mController.handleEnter(true);\n          }\n          if (!this.ignoreBlurWhileSearching)\n            this.detachController();\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"general.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"generalBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"basecontrol\">\n    <implementation implements=\"nsIDOMXULControlElement\">\n      <!-- public implementation -->\n      <property name=\"disabled\" onset=\"if (val) this.setAttribute('disabled', 'true');\n                                       else this.removeAttribute('disabled');\n                                       return val;\"\n                                onget=\"return this.getAttribute('disabled') == 'true';\"/>\n      <property name=\"tabIndex\" onget=\"return parseInt(this.getAttribute('tabindex')) || 0\"\n                                onset=\"if (val) this.setAttribute('tabindex', val);\n                                       else this.removeAttribute('tabindex'); return val;\"/>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"popup.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"popupBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"popup\">\n    <content>\n      <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                          smoothscroll=\"false\">\n        <children/>\n      </xul:arrowscrollbox>\n    </content>\n\n    <implementation>\n      <field name=\"scrollBox\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"class\", \"popup-internal-box\");\n      </field>\n\n      <field name=\"AUTOSCROLL_INTERVAL\">25</field>\n      <field name=\"NOT_DRAGGING\">0</field>\n      <field name=\"DRAG_OVER_BUTTON\">-1</field>\n      <field name=\"DRAG_OVER_POPUP\">1</field>\n\n      <field name=\"_draggingState\">this.NOT_DRAGGING</field>\n      <field name=\"_scrollTimer\">0</field>\n\n      <method name=\"_enableDragScrolling\">\n        <!-- when overItem is true, drag started over menuitem; when false, drag\n             started while the popup was opening.\n          -->\n        <parameter name=\"overItem\"/>\n        <body>\n        <![CDATA[\n          if (!this._draggingState) {\n            this.setCaptureAlways();\n            this._draggingState = overItem ? this.DRAG_OVER_POPUP : this.DRAG_OVER_BUTTON;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_clearScrollTimer\">\n        <body>\n        <![CDATA[\n          if (this._scrollTimer) {\n            this.ownerGlobal.clearInterval(this._scrollTimer);\n            this._scrollTimer = 0;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <constructor><![CDATA[\n        // Enable the drag-to-scroll events only in menulist popups.\n        if (!this.parentNode || this.parentNode.localName != \"menulist\") {\n          return;\n        }\n\n        // XBL bindings might be constructed more than once.\n        if (this.eventListenersAdded) {\n          return;\n        }\n        this.eventListenersAdded = true;\n\n        this.addEventListener(\"popupshown\", () => {\n          // Enable drag scrolling even when the mouse wasn't used. The\n          // mousemove handler will remove it if the mouse isn't down.\n          this._enableDragScrolling(false);\n        });\n\n        this.addEventListener(\"popuphidden\", () => {\n          this._draggingState = this.NOT_DRAGGING;\n          this._clearScrollTimer();\n          this.releaseCapture();\n        });\n\n        this.addEventListener(\"mousedown\", event => {\n          if (event.button != 0) {\n            return;\n          }\n\n          if (this.state == \"open\" &&\n            (event.target.localName == \"menuitem\" ||\n              event.target.localName == \"menu\" ||\n              event.target.localName == \"menucaption\")) {\n            this._enableDragScrolling(true);\n          }\n        });\n\n        this.addEventListener(\"mouseup\", event => {\n          if (event.button != 0) {\n            return;\n          }\n\n          this._draggingState = this.NOT_DRAGGING;\n          this._clearScrollTimer();\n        });\n\n        this.addEventListener(\"mousemove\", event => {\n          if (!this._draggingState) {\n            return;\n          }\n\n          this._clearScrollTimer();\n\n          // If the user released the mouse before the popup opens, we will\n          // still be capturing, so check that the button is still pressed. If\n          // not, release the capture and do nothing else. This also handles if\n          // the dropdown was opened via the keyboard.\n          if (!(event.buttons & 1)) {\n            this._draggingState = this.NOT_DRAGGING;\n            this.releaseCapture();\n            return;\n          }\n\n          // If dragging outside the top or bottom edge of the popup, but within\n          // the popup area horizontally, scroll the list in that direction. The\n          // _draggingState flag is used to ensure that scrolling does not start\n          // until the mouse has moved over the popup first, preventing\n          // scrolling while over the dropdown button.\n          let popupRect = this.getOuterScreenRect();\n          if (event.screenX >= popupRect.left &&\n              event.screenX <= popupRect.right) {\n            if (this._draggingState == this.DRAG_OVER_BUTTON) {\n              if (event.screenY > popupRect.top &&\n                  event.screenY < popupRect.bottom) {\n                this._draggingState = this.DRAG_OVER_POPUP;\n              }\n            }\n\n            if (this._draggingState == this.DRAG_OVER_POPUP &&\n                (event.screenY <= popupRect.top ||\n                 event.screenY >= popupRect.bottom)) {\n              let scrollAmount = event.screenY <= popupRect.top ? -1 : 1;\n              this.scrollBox.scrollByIndex(scrollAmount, true);\n\n              let win = this.ownerGlobal;\n              this._scrollTimer = win.setInterval(() => {\n                this.scrollBox.scrollByIndex(scrollAmount, true);\n              }, this.AUTOSCROLL_INTERVAL);\n            }\n          }\n        });\n      ]]></constructor>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\">\n        <![CDATA[\n          var array = [];\n          var width = 0;\n          for (var menuitem = this.firstElementChild; menuitem; menuitem = menuitem.nextElementSibling) {\n            if (menuitem.localName == \"menuitem\" && menuitem.hasAttribute(\"acceltext\")) {\n              var accel = menuitem.menuAccel;\n              if (accel) {\n                array.push(accel);\n                let accelWidth = accel.getBoundingClientRect().width;\n                if (accelWidth > width) {\n                  width = accelWidth;\n                }\n              }\n            }\n          }\n          for (var i = 0; i < array.length; i++)\n            array[i].width = width;\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"panel\">\n    <implementation>\n      <field name=\"_prevFocus\">0</field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // Capture the previous focus before has a chance to get set inside the panel\n        try {\n          this._prevFocus = Cu\n                            .getWeakReference(document.commandDispatcher.focusedElement);\n          if (this._prevFocus.get())\n            return;\n        } catch (ex) { }\n\n        this._prevFocus = Cu.getWeakReference(document.activeElement);\n      ]]></handler>\n      <handler event=\"popupshown\"><![CDATA[\n        // Fire event for accessibility APIs\n        var alertEvent = document.createEvent(\"Events\");\n        alertEvent.initEvent(\"AlertActive\", true, true);\n        this.dispatchEvent(alertEvent);\n       ]]></handler>\n      <handler event=\"popuphiding\"><![CDATA[\n        try {\n          this._currentFocus = document.commandDispatcher.focusedElement;\n        } catch (e) {\n          this._currentFocus = document.activeElement;\n        }\n      ]]></handler>\n      <handler event=\"popuphidden\"><![CDATA[\n        function doFocus() {\n          // Focus was set on an element inside this panel,\n          // so we need to move it back to where it was previously\n          try {\n            let fm = Cc[\"@mozilla.org/focus-manager;1\"]\n                       .getService(Ci.nsIFocusManager);\n            fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);\n          } catch (e) {\n            prevFocus.focus();\n          }\n        }\n        var currentFocus = this._currentFocus;\n        var prevFocus = this._prevFocus ? this._prevFocus.get() : null;\n        this._currentFocus = null;\n        this._prevFocus = null;\n\n        // Avoid changing focus if focus changed while we hide the popup\n        // (This can happen e.g. if the popup is hiding as a result of a\n        // click/keypress that focused something)\n        let nowFocus;\n        try {\n          nowFocus = document.commandDispatcher.focusedElement;\n        } catch (e) {\n          nowFocus = document.activeElement;\n        }\n        if (nowFocus && nowFocus != currentFocus)\n          return;\n\n        if (prevFocus && this.getAttribute(\"norestorefocus\") != \"true\") {\n          // Try to restore focus\n          try {\n            if (document.commandDispatcher.focusedWindow != window)\n              return; // Focus has already been set to a window outside of this panel\n          } catch (ex) {}\n\n          if (!currentFocus) {\n            doFocus();\n            return;\n          }\n          while (currentFocus) {\n            if (currentFocus == this) {\n              doFocus();\n              return;\n            }\n            currentFocus = currentFocus.parentNode;\n          }\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"arrowpanel\" extends=\"chrome://global/content/bindings/popup.xml#panel\">\n    <content flip=\"both\" side=\"top\" position=\"bottomcenter topleft\" consumeoutsideclicks=\"false\">\n      <xul:vbox anonid=\"container\" class=\"panel-arrowcontainer\" flex=\"1\"\n               xbl:inherits=\"side,panelopen\">\n        <xul:box anonid=\"arrowbox\" class=\"panel-arrowbox\">\n          <xul:image anonid=\"arrow\" class=\"panel-arrow\" xbl:inherits=\"side\"/>\n        </xul:box>\n        <xul:box class=\"panel-arrowcontent\" xbl:inherits=\"side,align,dir,orient,pack\" flex=\"1\">\n          <children/>\n        </xul:box>\n      </xul:vbox>\n    </content>\n    <implementation>\n      <field name=\"_fadeTimer\">null</field>\n      <method name=\"adjustArrowPosition\">\n        <body>\n        <![CDATA[\n        var anchor = this.anchorNode;\n        if (!anchor) {\n          return;\n        }\n\n        var container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n        var arrowbox = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\");\n\n        var position = this.alignmentPosition;\n        var offset = this.alignmentOffset;\n\n        this.setAttribute(\"arrowposition\", position);\n\n        if (position.indexOf(\"start_\") == 0 || position.indexOf(\"end_\") == 0) {\n          container.orient = \"horizontal\";\n          arrowbox.orient = \"vertical\";\n          if (position.indexOf(\"_after\") > 0) {\n            arrowbox.pack = \"end\";\n          } else {\n            arrowbox.pack = \"start\";\n          }\n          arrowbox.style.transform = \"translate(0, \" + -offset + \"px)\";\n\n          // The assigned side stays the same regardless of direction.\n          var isRTL = (window.getComputedStyle(this).direction == \"rtl\");\n\n          if (position.indexOf(\"start_\") == 0) {\n            container.dir = \"reverse\";\n            this.setAttribute(\"side\", isRTL ? \"left\" : \"right\");\n          } else {\n            container.dir = \"\";\n            this.setAttribute(\"side\", isRTL ? \"right\" : \"left\");\n          }\n        } else if (position.indexOf(\"before_\") == 0 || position.indexOf(\"after_\") == 0) {\n          container.orient = \"\";\n          arrowbox.orient = \"\";\n          if (position.indexOf(\"_end\") > 0) {\n            arrowbox.pack = \"end\";\n          } else {\n            arrowbox.pack = \"start\";\n          }\n          arrowbox.style.transform = \"translate(\" + -offset + \"px, 0)\";\n\n          if (position.indexOf(\"before_\") == 0) {\n            container.dir = \"reverse\";\n            this.setAttribute(\"side\", \"bottom\");\n          } else {\n            container.dir = \"\";\n            this.setAttribute(\"side\", \"top\");\n          }\n        }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\">\n      <![CDATA[\n        var arrow = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrow\");\n        arrow.hidden = this.anchorNode == null;\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\")\n                .style.removeProperty(\"transform\");\n\n        if (this.getAttribute(\"animate\") != \"false\") {\n          this.setAttribute(\"animate\", \"open\");\n          // the animating attribute prevents user interaction during transition\n          // it is removed when popupshown fires\n          this.setAttribute(\"animating\", \"true\");\n        }\n\n        // set fading\n        var fade = this.getAttribute(\"fade\");\n        var fadeDelay = 0;\n        if (fade == \"fast\") {\n          fadeDelay = 1;\n        } else if (fade == \"slow\") {\n          fadeDelay = 4000;\n        } else {\n          return;\n        }\n\n        this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);\n      ]]>\n      </handler>\n      <handler event=\"popuphiding\" phase=\"target\">\n        let animate = (this.getAttribute(\"animate\") != \"false\");\n\n        if (this._fadeTimer) {\n          clearTimeout(this._fadeTimer);\n          if (animate) {\n            this.setAttribute(\"animate\", \"fade\");\n          }\n        } else if (animate) {\n          this.setAttribute(\"animate\", \"cancel\");\n        }\n      </handler>\n      <handler event=\"popupshown\" phase=\"target\">\n        this.removeAttribute(\"animating\");\n        this.setAttribute(\"panelopen\", \"true\");\n      </handler>\n      <handler event=\"popuphidden\" phase=\"target\">\n        this.removeAttribute(\"panelopen\");\n        if (this.getAttribute(\"animate\") != \"false\") {\n          this.removeAttribute(\"animate\");\n        }\n      </handler>\n      <handler event=\"popuppositioned\" phase=\"target\">\n        this.adjustArrowPosition();\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"scrollbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"arrowscrollboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"arrowscrollbox\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <content>\n      <xul:toolbarbutton class=\"scrollbutton-up\"\n                         anonid=\"scrollbutton-up\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtostart\"\n                         onclick=\"_onButtonClick(event);\"\n                         onmousedown=\"_onButtonMouseDown(event, -1);\"\n                         onmouseup=\"_onButtonMouseUp(event);\"\n                         onmouseover=\"_onButtonMouseOver(-1);\"\n                         onmouseout=\"_onButtonMouseOut();\"/>\n      <xul:spacer class=\"arrowscrollbox-overflow-start-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtostart\"/>\n      <xul:scrollbox class=\"arrowscrollbox-scrollbox\"\n                     anonid=\"scrollbox\"\n                     flex=\"1\"\n                     xbl:inherits=\"orient,align,pack,dir,smoothscroll\">\n        <children/>\n      </xul:scrollbox>\n      <xul:spacer class=\"arrowscrollbox-overflow-end-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtoend\"/>\n      <xul:toolbarbutton class=\"scrollbutton-down\"\n                         anonid=\"scrollbutton-down\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtoend\"\n                         onclick=\"_onButtonClick(event);\"\n                         onmousedown=\"_onButtonMouseDown(event, 1);\"\n                         onmouseup=\"_onButtonMouseUp(event);\"\n                         onmouseover=\"_onButtonMouseOver(1);\"\n                         onmouseout=\"_onButtonMouseOut();\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (!this.hasAttribute(\"smoothscroll\")) {\n          this.smoothScroll = this._prefBranch\n                                  .getBoolPref(\"toolkit.scrollbox.smoothScroll\", true);\n        }\n\n        this.setAttribute(\"notoverflowing\", \"true\");\n        this._updateScrollButtonsDisabledState();\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // Release timer to avoid reference cycles.\n        if (this._scrollTimer) {\n          this._scrollTimer.cancel();\n          this._scrollTimer = null;\n        }\n      ]]></destructor>\n\n      <field name=\"scrollbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbox\");\n      </field>\n      <field name=\"_scrollButtonUp\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbutton-up\");\n      </field>\n      <field name=\"_scrollButtonDown\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbutton-down\");\n      </field>\n\n      <field name=\"_scrollIndex\">0</field>\n\n      <field name=\"_arrowScrollAnim\"><![CDATA[({\n        scrollbox: this,\n        requestHandle: 0, /* 0 indicates there is no pending request */\n        start: function arrowSmoothScroll_start() {\n          this.lastFrameTime = window.performance.now();\n          if (!this.requestHandle)\n            this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));\n        },\n        stop: function arrowSmoothScroll_stop() {\n          window.cancelAnimationFrame(this.requestHandle);\n          this.requestHandle = 0;\n        },\n        sample: function arrowSmoothScroll_handleEvent(timeStamp) {\n          const scrollIndex = this.scrollbox._scrollIndex;\n          const timePassed = timeStamp - this.lastFrameTime;\n          this.lastFrameTime = timeStamp;\n\n          const scrollDelta = 0.5 * timePassed * scrollIndex;\n          this.scrollbox.scrollByPixels(scrollDelta, true);\n          this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));\n        },\n      })]]></field>\n\n      <property name=\"_clickToScroll\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.hasAttribute(\"clicktoscroll\");\n        ]]></getter>\n      </property>\n\n      <property name=\"_scrollDelay\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._clickToScroll) {\n            return this._prefBranch.getIntPref(\n                            \"toolkit.scrollbox.clickToScroll.scrollDelay\", 150);\n          }\n\n          // Use the same REPEAT_DELAY as \"nsRepeatService.h\".\n          return /Mac/.test(navigator.platform) ? 25 : 50;\n        ]]></getter>\n      </property>\n\n      <field name=\"__prefBranch\">null</field>\n      <property name=\"_prefBranch\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.__prefBranch === null) {\n            this.__prefBranch = Cc[\"@mozilla.org/preferences-service;1\"]\n                                  .getService(Ci.nsIPrefBranch);\n          }\n          return this.__prefBranch;\n        ]]></getter>\n      </property>\n\n      <field name=\"_scrollIncrement\">null</field>\n      <property name=\"scrollIncrement\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._scrollIncrement === null) {\n            this._scrollIncrement = this._prefBranch\n                                        .getIntPref(\"toolkit.scrollbox.scrollIncrement\", 20);\n          }\n          return this._scrollIncrement;\n        ]]></getter>\n      </property>\n\n      <property name=\"smoothScroll\">\n        <getter><![CDATA[\n          return this.getAttribute(\"smoothscroll\") == \"true\";\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"smoothscroll\", !!val);\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"scrollClientRect\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.scrollbox.getBoundingClientRect();\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollClientSize\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this.scrollbox.clientHeight :\n                 this.scrollbox.clientWidth;\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollSize\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this.scrollbox.scrollHeight :\n                 this.scrollbox.scrollWidth;\n        ]]></getter>\n      </property>\n\n      <property name=\"lineScrollAmount\" readonly=\"true\">\n        <getter><![CDATA[\n          // line scroll amout should be the width (at horizontal scrollbox) or\n          // the height (at vertical scrollbox) of the scrolled elements.\n          // However, the elements may have different width or height.  So,\n          // for consistent speed, let's use avalage with of the elements.\n          var elements = this._getScrollableElements();\n          return elements.length && (this.scrollSize / elements.length);\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollPosition\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this.scrollbox.scrollTop :\n                 this.scrollbox.scrollLeft;\n        ]]></getter>\n      </property>\n\n      <field name=\"_startEndProps\"><![CDATA[\n        this.orient == \"vertical\" ? [\"top\", \"bottom\"] : [\"left\", \"right\"];\n      ]]></field>\n\n      <field name=\"_isRTLScrollbox\"><![CDATA[\n        this.orient != \"vertical\" &&\n        document.defaultView.getComputedStyle(this.scrollbox).direction == \"rtl\";\n      ]]></field>\n\n      <method name=\"_onButtonClick\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (this._clickToScroll) {\n            this._distanceScroll(event);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseDown\">\n        <parameter name=\"event\"/>\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._clickToScroll && event.button == 0) {\n            this._startScroll(index);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseUp\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (this._clickToScroll && event.button == 0) {\n            this._stopScroll();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseOver\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._clickToScroll) {\n            this._continueScroll(index);\n          } else {\n            this._startScroll(index);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseOut\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._clickToScroll) {\n            this._pauseScroll();\n          } else {\n            this._stopScroll();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_boundsWithoutFlushing\">\n        <parameter name=\"element\"/>\n        <body><![CDATA[\n          if (!(\"_DOMWindowUtils\" in this)) {\n            this._DOMWindowUtils = window.windowUtils;\n          }\n\n          return this._DOMWindowUtils ?\n                 this._DOMWindowUtils.getBoundsWithoutFlushing(element) :\n                 element.getBoundingClientRect();\n        ]]></body>\n      </method>\n\n      <method name=\"_canScrollToElement\">\n        <parameter name=\"element\"/>\n        <body><![CDATA[\n          if (element.hidden) {\n            return false;\n          }\n\n          // See if the element is hidden via CSS without the hidden attribute.\n          // If we get only zeros for the client rect, this means the element\n          // is hidden. As a performance optimization, we don't flush layout\n          // here which means that on the fly changes aren't fully supported.\n          let rect = this._boundsWithoutFlushing(element);\n          return !!(rect.top || rect.left || rect.width || rect.height);\n        ]]></body>\n      </method>\n\n      <field name=\"_ensureElementIsVisibleAnimationFrame\">0</field>\n      <method name=\"ensureElementIsVisible\">\n        <parameter name=\"element\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (!this._canScrollToElement(element))\n            return;\n\n          if (this._ensureElementIsVisibleAnimationFrame) {\n            window.cancelAnimationFrame(this._ensureElementIsVisibleAnimationFrame);\n          }\n          this._ensureElementIsVisibleAnimationFrame = window.requestAnimationFrame(() => {\n            element.scrollIntoView({ block: \"nearest\",\n                                     behavior: aInstant ? \"instant\" : \"auto\" });\n            this._ensureElementIsVisibleAnimationFrame = 0;\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"scrollByIndex\">\n        <parameter name=\"index\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (index == 0)\n            return;\n\n          var rect = this.scrollClientRect;\n          var [start, end] = this._startEndProps;\n          var x = index > 0 ? rect[end] + 1 : rect[start] - 1;\n          var nextElement = this._elementFromPoint(x, index);\n          if (!nextElement)\n            return;\n\n          var targetElement;\n          if (this._isRTLScrollbox)\n            index *= -1;\n          while (index < 0 && nextElement) {\n            if (this._canScrollToElement(nextElement))\n              targetElement = nextElement;\n            nextElement = nextElement.previousElementSibling;\n            index++;\n          }\n          while (index > 0 && nextElement) {\n            if (this._canScrollToElement(nextElement))\n              targetElement = nextElement;\n            nextElement = nextElement.nextElementSibling;\n            index--;\n          }\n          if (!targetElement)\n            return;\n\n          this.ensureElementIsVisible(targetElement, aInstant);\n        ]]></body>\n      </method>\n\n      <method name=\"_getScrollableElements\">\n        <body><![CDATA[\n          var nodes = this.children;\n          if (nodes.length == 1 &&\n              nodes[0].localName == \"children\" &&\n              nodes[0].namespaceURI == \"http://www.mozilla.org/xbl\") {\n            nodes = document.getBindingParent(this).children;\n          }\n\n          return Array.prototype.filter.call(nodes, this._canScrollToElement, this);\n        ]]></body>\n      </method>\n\n      <method name=\"_elementFromPoint\">\n        <parameter name=\"aX\"/>\n        <parameter name=\"aPhysicalScrollDir\"/>\n        <body><![CDATA[\n          var elements = this._getScrollableElements();\n          if (!elements.length)\n            return null;\n\n          if (this._isRTLScrollbox)\n            elements.reverse();\n\n          var [start, end] = this._startEndProps;\n          var low = 0;\n          var high = elements.length - 1;\n\n          if (aX < elements[low].getBoundingClientRect()[start] ||\n              aX > elements[high].getBoundingClientRect()[end])\n            return null;\n\n          var mid, rect;\n          while (low <= high) {\n            mid = Math.floor((low + high) / 2);\n            rect = elements[mid].getBoundingClientRect();\n            if (rect[start] > aX)\n              high = mid - 1;\n            else if (rect[end] < aX)\n              low = mid + 1;\n            else\n              return elements[mid];\n          }\n\n          // There's no element at the requested coordinate, but the algorithm\n          // from above yields an element next to it, in a random direction.\n          // The desired scrolling direction leads to the correct element.\n\n          if (!aPhysicalScrollDir)\n            return null;\n\n          if (aPhysicalScrollDir < 0 && rect[start] > aX)\n            mid = Math.max(mid - 1, 0);\n          else if (aPhysicalScrollDir > 0 && rect[end] < aX)\n            mid = Math.min(mid + 1, elements.length - 1);\n\n          return elements[mid];\n        ]]></body>\n      </method>\n\n      <method name=\"_startScroll\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._isRTLScrollbox) {\n            index *= -1;\n          }\n\n          if (this._clickToScroll) {\n            this._scrollIndex = index;\n            this._mousedown = true;\n\n            if (this.smoothScroll) {\n              this._arrowScrollAnim.start();\n              return;\n            }\n          }\n\n          if (!this._scrollTimer) {\n            this._scrollTimer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n          } else {\n            this._scrollTimer.cancel();\n          }\n\n          let callback;\n          if (this._clickToScroll) {\n            callback = () => {\n              if (!document && this._scrollTimer) {\n                this._scrollTimer.cancel();\n              }\n              this.scrollByIndex(this._scrollIndex);\n            };\n          } else {\n            callback = () => this.scrollByPixels(this.scrollIncrement * index);\n          }\n\n          this._scrollTimer.initWithCallback(callback, this._scrollDelay,\n                                             Ci.nsITimer.TYPE_REPEATING_SLACK);\n\n          callback();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_stopScroll\">\n        <body><![CDATA[\n          if (this._scrollTimer)\n            this._scrollTimer.cancel();\n\n          if (this._clickToScroll) {\n            this._mousedown = false;\n            if (!this._scrollIndex || !this.smoothScroll)\n              return;\n\n            this.scrollByIndex(this._scrollIndex);\n            this._scrollIndex = 0;\n\n            this._arrowScrollAnim.stop();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_pauseScroll\">\n        <body><![CDATA[\n          if (this._mousedown) {\n            this._stopScroll();\n            this._mousedown = true;\n            document.addEventListener(\"mouseup\", this);\n            document.addEventListener(\"blur\", this, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_continueScroll\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._mousedown)\n            this._startScroll(index);\n        ]]></body>\n      </method>\n\n      <method name=\"_distanceScroll\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.detail < 2 || aEvent.detail > 3)\n            return;\n\n          var scrollBack = (aEvent.originalTarget == this._scrollButtonUp);\n          var scrollLeftOrUp = this._isRTLScrollbox ? !scrollBack : scrollBack;\n          var targetElement;\n\n          if (aEvent.detail == 2) {\n            // scroll by the size of the scrollbox\n            let [start, end] = this._startEndProps;\n            let x;\n            if (scrollLeftOrUp)\n              x = this.scrollClientRect[start] - this.scrollClientSize;\n            else\n              x = this.scrollClientRect[end] + this.scrollClientSize;\n            targetElement = this._elementFromPoint(x, scrollLeftOrUp ? -1 : 1);\n\n            // the next partly-hidden element will become fully visible,\n            // so don't scroll too far\n            if (targetElement)\n              targetElement = scrollBack ?\n                              targetElement.nextElementSibling :\n                              targetElement.previousElementSibling;\n          }\n\n          if (!targetElement) {\n            // scroll to the first resp. last element\n            let elements = this._getScrollableElements();\n            targetElement = scrollBack ?\n                            elements[0] :\n                            elements[elements.length - 1];\n          }\n\n          this.ensureElementIsVisible(targetElement);\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.type == \"mouseup\" ||\n              aEvent.type == \"blur\" && aEvent.target == document) {\n            this._mousedown = false;\n            document.removeEventListener(\"mouseup\", this);\n            document.removeEventListener(\"blur\", this, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"scrollByPixels\">\n        <parameter name=\"aPixels\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          let scrollOptions = { behavior: aInstant ? \"instant\" : \"auto\" };\n          scrollOptions[this._startEndProps[0]] = aPixels;\n          this.scrollbox.scrollBy(scrollOptions);\n        ]]></body>\n      </method>\n\n      <field name=\"_prevMouseScrolls\">[null, null]</field>\n\n      <field name=\"_touchStart\">-1</field>\n\n      <field name=\"_scrollButtonUpdatePending\">false</field>\n      <method name=\"_updateScrollButtonsDisabledState\">\n        <body><![CDATA[\n          if (this.hasAttribute(\"notoverflowing\")) {\n            this.setAttribute(\"scrolledtoend\", \"true\");\n            this.setAttribute(\"scrolledtostart\", \"true\");\n            return;\n          }\n\n          if (this._scrollButtonUpdatePending) {\n            return;\n          }\n          this._scrollButtonUpdatePending = true;\n\n          // Wait until after the next paint to get current layout data from\n          // getBoundsWithoutFlushing.\n          window.requestAnimationFrame(() => {\n            setTimeout(() => {\n              if (!this._startEndProps) {\n                // We've been destroyed in the meantime.\n                return;\n              }\n\n              this._scrollButtonUpdatePending = false;\n\n              let scrolledToStart = false;\n              let scrolledToEnd = false;\n\n              if (this.hasAttribute(\"notoverflowing\")) {\n                scrolledToStart = true;\n                scrolledToEnd = true;\n              } else {\n                let [leftOrTop, rightOrBottom] = this._startEndProps;\n                let leftOrTopEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[leftOrTop]);\n                let rightOrBottomEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[rightOrBottom]);\n\n                let elements = this._getScrollableElements();\n                let [leftOrTopElement, rightOrBottomElement] = [elements[0], elements[elements.length - 1]];\n                if (this._isRTLScrollbox) {\n                  [leftOrTopElement, rightOrBottomElement] = [rightOrBottomElement, leftOrTopElement];\n                }\n\n                if (leftOrTopElement &&\n                    leftOrTopEdge(leftOrTopElement) >= leftOrTopEdge(this.scrollbox)) {\n                  scrolledToStart = !this._isRTLScrollbox;\n                  scrolledToEnd = this._isRTLScrollbox;\n                } else if (rightOrBottomElement &&\n                           rightOrBottomEdge(rightOrBottomElement) <= rightOrBottomEdge(this.scrollbox)) {\n                  scrolledToStart = this._isRTLScrollbox;\n                  scrolledToEnd = !this._isRTLScrollbox;\n                }\n              }\n\n              if (scrolledToEnd) {\n                this.setAttribute(\"scrolledtoend\", \"true\");\n              } else {\n                this.removeAttribute(\"scrolledtoend\");\n              }\n\n              if (scrolledToStart) {\n                this.setAttribute(\"scrolledtostart\", \"true\");\n              } else {\n                this.removeAttribute(\"scrolledtostart\");\n              }\n            }, 0);\n          });\n        ]]></body>\n      </method>\n\n      <field name=\"_isScrolling\">false</field>\n      <field name=\"_destination\">0</field>\n      <field name=\"_direction\">0</field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"wheel\"><![CDATA[\n        // Don't consume the event if we can't scroll.\n        if (this.hasAttribute(\"notoverflowing\")) {\n          return;\n        }\n\n        let doScroll = false;\n        let instant;\n        let scrollAmount = 0;\n        if (this.orient == \"vertical\") {\n          doScroll = true;\n          if (event.deltaMode == event.DOM_DELTA_PIXEL)\n            scrollAmount = event.deltaY;\n          else if (event.deltaMode == event.DOM_DELTA_PAGE)\n            scrollAmount = event.deltaY * this.scrollClientSize;\n          else\n            scrollAmount = event.deltaY * this.lineScrollAmount;\n        } else {\n          // We allow vertical scrolling to scroll a horizontal scrollbox\n          // because many users have a vertical scroll wheel but no\n          // horizontal support.\n          // Because of this, we need to avoid scrolling chaos on trackpads\n          // and mouse wheels that support simultaneous scrolling in both axes.\n          // We do this by scrolling only when the last two scroll events were\n          // on the same axis as the current scroll event.\n          // For diagonal scroll events we only respect the dominant axis.\n          let isVertical = Math.abs(event.deltaY) > Math.abs(event.deltaX);\n          let delta = isVertical ? event.deltaY : event.deltaX;\n          let scrollByDelta = isVertical && this._isRTLScrollbox ? -delta : delta;\n\n          if (this._prevMouseScrolls.every(prev => prev == isVertical)) {\n            doScroll = true;\n            if (event.deltaMode == event.DOM_DELTA_PIXEL) {\n              scrollAmount = scrollByDelta;\n              instant = true;\n            } else if (event.deltaMode == event.DOM_DELTA_PAGE) {\n              scrollAmount = scrollByDelta * this.scrollClientSize;\n            } else {\n              scrollAmount = scrollByDelta * this.lineScrollAmount;\n            }\n          }\n\n          if (this._prevMouseScrolls.length > 1)\n            this._prevMouseScrolls.shift();\n          this._prevMouseScrolls.push(isVertical);\n        }\n\n        if (doScroll) {\n          let direction = scrollAmount < 0 ? -1 : 1;\n          let startPos = this.scrollPosition;\n\n          if (!this._isScrolling || this._direction != direction) {\n            this._destination = startPos + scrollAmount;\n            this._direction = direction;\n          } else {\n            // We were already in the process of scrolling in this direction\n            this._destination = this._destination + scrollAmount;\n            scrollAmount = this._destination - startPos;\n          }\n          this.scrollByPixels(scrollAmount, instant);\n        }\n\n        event.stopPropagation();\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"touchstart\"><![CDATA[\n        if (event.touches.length > 1) {\n          // Multiple touch points detected, abort. In particular this aborts\n          // the panning gesture when the user puts a second finger down after\n          // already panning with one finger. Aborting at this point prevents\n          // the pan gesture from being resumed until all fingers are lifted\n          // (as opposed to when the user is back down to one finger).\n          this._touchStart = -1;\n        } else {\n          this._touchStart = (this.orient == \"vertical\"\n                ? event.touches[0].screenY\n                : event.touches[0].screenX);\n        }\n      ]]></handler>\n\n      <handler event=\"touchmove\"><![CDATA[\n        if (event.touches.length == 1 &&\n            this._touchStart >= 0) {\n          var touchPoint = (this.orient == \"vertical\"\n                ? event.touches[0].screenY\n                : event.touches[0].screenX);\n          var delta = this._touchStart - touchPoint;\n          if (Math.abs(delta) > 0) {\n            this.scrollByPixels(delta, true);\n            this._touchStart = touchPoint;\n          }\n          event.preventDefault();\n        }\n      ]]></handler>\n\n      <handler event=\"touchend\"><![CDATA[\n        this._touchStart = -1;\n      ]]></handler>\n\n      <handler event=\"underflow\" phase=\"capturing\"><![CDATA[\n        // Ignore underflow events:\n        // - from nested scrollable elements\n        // - corresponding to an overflow event that we ignored\n        if (event.target != this ||\n            this.hasAttribute(\"notoverflowing\")) {\n          return;\n        }\n\n        // Ignore events that doesn't match our orientation.\n        // Scrollport event orientation:\n        //   0: vertical\n        //   1: horizontal\n        //   2: both\n        if (this.orient == \"vertical\") {\n          if (event.detail == 1)\n            return;\n        } else if (event.detail == 0) {\n          // horizontal scrollbox\n          return;\n        }\n\n        this.setAttribute(\"notoverflowing\", \"true\");\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"overflow\" phase=\"capturing\"><![CDATA[\n        // Ignore overflow events:\n        // - from nested scrollable elements\n        if (event.target != this) {\n          return;\n        }\n\n        // Ignore events that doesn't match our orientation.\n        // Scrollport event orientation:\n        //   0: vertical\n        //   1: horizontal\n        //   2: both\n        if (this.orient == \"vertical\") {\n          if (event.detail == 1)\n            return;\n        } else if (event.detail == 0) {\n          // horizontal scrollbox\n          return;\n        }\n\n        this.removeAttribute(\"notoverflowing\");\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"scroll\"><![CDATA[\n        this._isScrolling = true;\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"scrollend\"><![CDATA[\n        this._isScrolling = false;\n        this._destination = 0;\n        this._direction = 0;\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"textbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This files relies on these specific Chrome/XBL globals -->\n<!-- globals ChromeWindow -->\n\n\n<!DOCTYPE bindings [\n  <!ENTITY % textcontextDTD SYSTEM \"chrome://global/locale/textcontext.dtd\" >\n  %textcontextDTD;\n]>\n\n<bindings id=\"textboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"textbox\">\n    <content>\n      <children/>\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\" xbl:inherits=\"context,spellcheck\">\n        <html:input class=\"textbox-input\" anonid=\"input\"\n                    xbl:inherits=\"value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,noinitialfocus,mozactionhint,spellcheck\"/>\n      </xul:moz-input-box>\n    </content>\n\n    <implementation>\n      <!-- nsIDOMXULLabeledControlElement -->\n      <field name=\"crop\">\"\"</field>\n      <field name=\"image\">\"\"</field>\n      <field name=\"command\">\"\"</field>\n      <field name=\"accessKey\">\"\"</field>\n\n      <field name=\"mInputField\">null</field>\n      <field name=\"mIgnoreClick\">false</field>\n      <field name=\"mEditor\">null</field>\n\n      <property name=\"inputField\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.mInputField)\n            this.mInputField = document.getAnonymousElementByAttribute(this, \"anonid\", \"input\");\n          return this.mInputField;\n        ]]></getter>\n      </property>\n\n      <property name=\"value\"      onset=\"this.inputField.value = val; return val;\"\n                                  onget=\"return this.inputField.value;\"/>\n      <property name=\"defaultValue\" onset=\"this.inputField.defaultValue = val; return val;\"\n                                  onget=\"return this.inputField.defaultValue;\"/>\n      <property name=\"label\"      onset=\"this.setAttribute('label', val); return val;\"\n                                  onget=\"return this.getAttribute('label') || this.placeholder;\" />\n      <property name=\"placeholder\" onset=\"this.inputField.placeholder = val; return val;\"\n                                  onget=\"return this.inputField.placeholder;\"/>\n      <property name=\"emptyText\"  onset=\"this.placeholder = val; return val;\"\n                                  onget=\"return this.placeholder;\"/>\n      <property name=\"type\"       onset=\"if (val) this.setAttribute('type', val);\n                                         else this.removeAttribute('type'); return val;\"\n                                  onget=\"return this.getAttribute('type');\"/>\n      <property name=\"maxLength\"  onset=\"this.inputField.maxLength = val; return val;\"\n                                  onget=\"return this.inputField.maxLength;\"/>\n      <property name=\"disabled\"   onset=\"this.inputField.disabled = val;\n                                         if (val) this.setAttribute('disabled', 'true');\n                                         else this.removeAttribute('disabled'); return val;\"\n                                  onget=\"return this.inputField.disabled;\"/>\n      <property name=\"tabIndex\"   onget=\"return parseInt(this.getAttribute('tabindex'));\"\n                                  onset=\"this.inputField.tabIndex = val;\n                                         if (val) this.setAttribute('tabindex', val);\n                                         else this.removeAttribute('tabindex'); return val;\"/>\n      <property name=\"size\"       onset=\"this.inputField.size = val; return val;\"\n                                  onget=\"return this.inputField.size;\"/>\n      <property name=\"readOnly\"   onset=\"this.inputField.readOnly = val;\n                                         if (val) this.setAttribute('readonly', 'true');\n                                         else this.removeAttribute('readonly'); return val;\"\n                                  onget=\"return this.inputField.readOnly;\"/>\n\n      <property name=\"editor\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.mEditor) {\n            this.mEditor = this.inputField.editor;\n          }\n          return this.mEditor;\n        ]]></getter>\n      </property>\n\n      <method name=\"reset\">\n        <body><![CDATA[\n          this.value = this.defaultValue;\n          try {\n            this.editor.transactionManager.clear();\n            return true;\n          } catch (e) {}\n          return false;\n        ]]></body>\n      </method>\n\n      <method name=\"select\">\n        <body>\n          this.inputField.select();\n        </body>\n      </method>\n\n      <method name=\"setUserInput\">\n        <parameter name=\"value\"/>\n        <body><![CDATA[\n          this.inputField.setUserInput(value);\n        ]]></body>\n      </method>\n\n      <property name=\"controllers\"    readonly=\"true\" onget=\"return this.inputField.controllers\"/>\n      <property name=\"textLength\"     readonly=\"true\"\n                                      onget=\"return this.inputField.textLength;\"/>\n      <property name=\"selectionStart\" onset=\"this.inputField.selectionStart = val; return val;\"\n                                      onget=\"return this.inputField.selectionStart;\"/>\n      <property name=\"selectionEnd\"   onset=\"this.inputField.selectionEnd = val; return val;\"\n                                      onget=\"return this.inputField.selectionEnd;\"/>\n\n      <method name=\"setSelectionRange\">\n        <parameter name=\"aSelectionStart\"/>\n        <parameter name=\"aSelectionEnd\"/>\n        <body>\n          // According to https://html.spec.whatwg.org/#do-not-apply,\n          // setSelectionRange() is only available on a limited set of input types.\n          if (this.inputField.type == \"text\") {\n            this.inputField.setSelectionRange( aSelectionStart, aSelectionEnd );\n          }\n        </body>\n      </method>\n\n      <method name=\"_setNewlineHandling\">\n        <body><![CDATA[\n          var str = this.getAttribute(\"newlines\");\n          if (str && this.editor) {\n            const nsIPlaintextEditor = Ci.nsIPlaintextEditor;\n            for (var x in nsIPlaintextEditor) {\n              if (/^eNewlines/.test(x)) {\n                if (str == RegExp.rightContext.toLowerCase()) {\n                  this.editor.QueryInterface(nsIPlaintextEditor)\n                      .newlineHandling = nsIPlaintextEditor[x];\n                  break;\n                }\n              }\n            }\n          }\n        ]]></body>\n      </method>\n\n      <constructor><![CDATA[\n        var str = this._cachedInputFieldValue;\n        if (str) {\n          this.inputField.value = str;\n          delete this._cachedInputFieldValue;\n        }\n\n        this._setNewlineHandling();\n\n        if (this.hasAttribute(\"emptytext\"))\n          this.placeholder = this.getAttribute(\"emptytext\");\n      ]]></constructor>\n\n      <destructor>\n        <![CDATA[\n          var field = this.inputField;\n          if (field && field.value) {\n            this._cachedInputFieldValue = field.value;\n          }\n\n          this.mInputField = null;\n        ]]>\n      </destructor>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"focus\" phase=\"capturing\">\n        <![CDATA[\n          if (this.hasAttribute(\"focused\"))\n            return;\n\n          switch (event.originalTarget) {\n            case this:\n              // Forward focus to actual HTML input\n              this.inputField.focus();\n              this.setAttribute(\"focused\", \"true\");\n              break;\n            case this.inputField:\n              this.setAttribute(\"focused\", \"true\");\n              break;\n            default:\n              // Otherwise, allow other children (e.g. URL bar buttons) to get focus\n              break;\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"blur\" phase=\"capturing\">\n        <![CDATA[\n          this.removeAttribute(\"focused\");\n        ]]>\n      </handler>\n\n      <handler event=\"mousedown\">\n        <![CDATA[\n          this.mIgnoreClick = this.hasAttribute(\"focused\");\n\n          if (!this.mIgnoreClick) {\n            this.setSelectionRange(0, 0);\n            if (event.originalTarget == this ||\n                event.originalTarget == this.inputField.parentNode)\n              this.inputField.focus();\n          }\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"}];
    </script>
  </head>
  <body>
  <main>
  <header>
  <div id="links">
    <a href="../">Home</a>
    <a href="https://github.com/bgrins/xbl-analysis">Code</a>
  </div>
  <h1>XBL To Custom Element Converter</h1>
  </header>
  <div id="converter">
    <ul>
    <li><a href='#' data-index=0>menu.xml</a></li>
<li><a href='#' data-index=1>autocomplete.xml</a></li>
<li><a href='#' data-index=2>general.xml</a></li>
<li><a href='#' data-index=3>popup.xml</a></li>
<li><a href='#' data-index=4>scrollbox.xml</a></li>
<li><a href='#' data-index=5>textbox.xml</a></li>
    </ul>
    <textarea>
    <?xml version="1.0"?>
<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<bindings id="popupBindings"
   xmlns="http://www.mozilla.org/xbl"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
   xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="popup">
    <content>
      <xul:arrowscrollbox class="popup-internal-box" flex="1" orient="vertical"
                          smoothscroll="false">
        <children/>
      </xul:arrowscrollbox>
    </content>

    <implementation>
      <field name="scrollBox" readonly="true">
        document.getAnonymousElementByAttribute(this, "class", "popup-internal-box");
      </field>

      <field name="AUTOSCROLL_INTERVAL">25</field>
      <field name="NOT_DRAGGING">0</field>
      <field name="DRAG_OVER_BUTTON">-1</field>
      <field name="DRAG_OVER_POPUP">1</field>

      <field name="_draggingState">this.NOT_DRAGGING</field>
      <field name="_scrollTimer">0</field>

      <method name="_enableDragScrolling">
        <!-- when overItem is true, drag started over menuitem; when false, drag
             started while the popup was opening.
          -->
        <parameter name="overItem"/>
        <body>
        <![CDATA[
          if (!this._draggingState) {
            this.setCaptureAlways();
            this._draggingState = overItem ? this.DRAG_OVER_POPUP : this.DRAG_OVER_BUTTON;
          }
        ]]>
        </body>
      </method>

      <method name="_clearScrollTimer">
        <body>
        <![CDATA[
          if (this._scrollTimer) {
            this.ownerGlobal.clearInterval(this._scrollTimer);
            this._scrollTimer = 0;
          }
        ]]>
        </body>
      </method>

      <constructor><![CDATA[
        // Enable the drag-to-scroll events only in menulist popups.
        if (!this.parentNode || this.parentNode.localName != "menulist") {
          return;
        }

        // XBL bindings might be constructed more than once.
        if (this.eventListenersAdded) {
          return;
        }
        this.eventListenersAdded = true;

        this.addEventListener("popupshown", () => {
          // Enable drag scrolling even when the mouse wasn't used. The
          // mousemove handler will remove it if the mouse isn't down.
          this._enableDragScrolling(false);
        });

        this.addEventListener("popuphidden", () => {
          this._draggingState = this.NOT_DRAGGING;
          this._clearScrollTimer();
          this.releaseCapture();
        });

        this.addEventListener("mousedown", event => {
          if (event.button != 0) {
            return;
          }

          if (this.state == "open" &&
            (event.target.localName == "menuitem" ||
              event.target.localName == "menu" ||
              event.target.localName == "menucaption")) {
            this._enableDragScrolling(true);
          }
        });

        this.addEventListener("mouseup", event => {
          if (event.button != 0) {
            return;
          }

          this._draggingState = this.NOT_DRAGGING;
          this._clearScrollTimer();
        });

        this.addEventListener("mousemove", event => {
          if (!this._draggingState) {
            return;
          }

          this._clearScrollTimer();

          // If the user released the mouse before the popup opens, we will
          // still be capturing, so check that the button is still pressed. If
          // not, release the capture and do nothing else. This also handles if
          // the dropdown was opened via the keyboard.
          if (!(event.buttons & 1)) {
            this._draggingState = this.NOT_DRAGGING;
            this.releaseCapture();
            return;
          }

          // If dragging outside the top or bottom edge of the popup, but within
          // the popup area horizontally, scroll the list in that direction. The
          // _draggingState flag is used to ensure that scrolling does not start
          // until the mouse has moved over the popup first, preventing
          // scrolling while over the dropdown button.
          let popupRect = this.getOuterScreenRect();
          if (event.screenX >= popupRect.left &&
              event.screenX <= popupRect.right) {
            if (this._draggingState == this.DRAG_OVER_BUTTON) {
              if (event.screenY > popupRect.top &&
                  event.screenY < popupRect.bottom) {
                this._draggingState = this.DRAG_OVER_POPUP;
              }
            }

            if (this._draggingState == this.DRAG_OVER_POPUP &&
                (event.screenY <= popupRect.top ||
                 event.screenY >= popupRect.bottom)) {
              let scrollAmount = event.screenY <= popupRect.top ? -1 : 1;
              this.scrollBox.scrollByIndex(scrollAmount, true);

              let win = this.ownerGlobal;
              this._scrollTimer = win.setInterval(() => {
                this.scrollBox.scrollByIndex(scrollAmount, true);
              }, this.AUTOSCROLL_INTERVAL);
            }
          }
        });
      ]]></constructor>
    </implementation>

    <handlers>
      <handler event="popupshowing" phase="target">
        <![CDATA[
          var array = [];
          var width = 0;
          for (var menuitem = this.firstElementChild; menuitem; menuitem = menuitem.nextElementSibling) {
            if (menuitem.localName == "menuitem" && menuitem.hasAttribute("acceltext")) {
              var accel = menuitem.menuAccel;
              if (accel) {
                array.push(accel);
                let accelWidth = accel.getBoundingClientRect().width;
                if (accelWidth > width) {
                  width = accelWidth;
                }
              }
            }
          }
          for (var i = 0; i < array.length; i++)
            array[i].width = width;
        ]]>
      </handler>
    </handlers>
  </binding>

  <binding id="panel">
    <implementation>
      <field name="_prevFocus">0</field>
    </implementation>

    <handlers>
      <handler event="popupshowing"><![CDATA[
        // Capture the previous focus before has a chance to get set inside the panel
        try {
          this._prevFocus = Cu
                            .getWeakReference(document.commandDispatcher.focusedElement);
          if (this._prevFocus.get())
            return;
        } catch (ex) { }

        this._prevFocus = Cu.getWeakReference(document.activeElement);
      ]]></handler>
      <handler event="popupshown"><![CDATA[
        // Fire event for accessibility APIs
        var alertEvent = document.createEvent("Events");
        alertEvent.initEvent("AlertActive", true, true);
        this.dispatchEvent(alertEvent);
       ]]></handler>
      <handler event="popuphiding"><![CDATA[
        try {
          this._currentFocus = document.commandDispatcher.focusedElement;
        } catch (e) {
          this._currentFocus = document.activeElement;
        }
      ]]></handler>
      <handler event="popuphidden"><![CDATA[
        function doFocus() {
          // Focus was set on an element inside this panel,
          // so we need to move it back to where it was previously
          try {
            let fm = Cc["@mozilla.org/focus-manager;1"]
                       .getService(Ci.nsIFocusManager);
            fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);
          } catch (e) {
            prevFocus.focus();
          }
        }
        var currentFocus = this._currentFocus;
        var prevFocus = this._prevFocus ? this._prevFocus.get() : null;
        this._currentFocus = null;
        this._prevFocus = null;

        // Avoid changing focus if focus changed while we hide the popup
        // (This can happen e.g. if the popup is hiding as a result of a
        // click/keypress that focused something)
        let nowFocus;
        try {
          nowFocus = document.commandDispatcher.focusedElement;
        } catch (e) {
          nowFocus = document.activeElement;
        }
        if (nowFocus && nowFocus != currentFocus)
          return;

        if (prevFocus && this.getAttribute("norestorefocus") != "true") {
          // Try to restore focus
          try {
            if (document.commandDispatcher.focusedWindow != window)
              return; // Focus has already been set to a window outside of this panel
          } catch (ex) {}

          if (!currentFocus) {
            doFocus();
            return;
          }
          while (currentFocus) {
            if (currentFocus == this) {
              doFocus();
              return;
            }
            currentFocus = currentFocus.parentNode;
          }
        }
      ]]></handler>
    </handlers>
  </binding>

  <binding id="arrowpanel" extends="chrome://global/content/bindings/popup.xml#panel">
    <content flip="both" side="top" position="bottomcenter topleft" consumeoutsideclicks="false">
      <xul:vbox anonid="container" class="panel-arrowcontainer" flex="1"
               xbl:inherits="side,panelopen">
        <xul:box anonid="arrowbox" class="panel-arrowbox">
          <xul:image anonid="arrow" class="panel-arrow" xbl:inherits="side"/>
        </xul:box>
        <xul:box class="panel-arrowcontent" xbl:inherits="side,align,dir,orient,pack" flex="1">
          <children/>
        </xul:box>
      </xul:vbox>
    </content>
    <implementation>
      <field name="_fadeTimer">null</field>
      <method name="adjustArrowPosition">
        <body>
        <![CDATA[
        var anchor = this.anchorNode;
        if (!anchor) {
          return;
        }

        var container = document.getAnonymousElementByAttribute(this, "anonid", "container");
        var arrowbox = document.getAnonymousElementByAttribute(this, "anonid", "arrowbox");

        var position = this.alignmentPosition;
        var offset = this.alignmentOffset;

        this.setAttribute("arrowposition", position);

        if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
          container.orient = "horizontal";
          arrowbox.orient = "vertical";
          if (position.indexOf("_after") > 0) {
            arrowbox.pack = "end";
          } else {
            arrowbox.pack = "start";
          }
          arrowbox.style.transform = "translate(0, " + -offset + "px)";

          // The assigned side stays the same regardless of direction.
          var isRTL = (window.getComputedStyle(this).direction == "rtl");

          if (position.indexOf("start_") == 0) {
            container.dir = "reverse";
            this.setAttribute("side", isRTL ? "left" : "right");
          } else {
            container.dir = "";
            this.setAttribute("side", isRTL ? "right" : "left");
          }
        } else if (position.indexOf("before_") == 0 || position.indexOf("after_") == 0) {
          container.orient = "";
          arrowbox.orient = "";
          if (position.indexOf("_end") > 0) {
            arrowbox.pack = "end";
          } else {
            arrowbox.pack = "start";
          }
          arrowbox.style.transform = "translate(" + -offset + "px, 0)";

          if (position.indexOf("before_") == 0) {
            container.dir = "reverse";
            this.setAttribute("side", "bottom");
          } else {
            container.dir = "";
            this.setAttribute("side", "top");
          }
        }
        ]]>
        </body>
      </method>
    </implementation>
    <handlers>
      <handler event="popupshowing" phase="target">
      <![CDATA[
        var arrow = document.getAnonymousElementByAttribute(this, "anonid", "arrow");
        arrow.hidden = this.anchorNode == null;
        document.getAnonymousElementByAttribute(this, "anonid", "arrowbox")
                .style.removeProperty("transform");

        if (this.getAttribute("animate") != "false") {
          this.setAttribute("animate", "open");
          // the animating attribute prevents user interaction during transition
          // it is removed when popupshown fires
          this.setAttribute("animating", "true");
        }

        // set fading
        var fade = this.getAttribute("fade");
        var fadeDelay = 0;
        if (fade == "fast") {
          fadeDelay = 1;
        } else if (fade == "slow") {
          fadeDelay = 4000;
        } else {
          return;
        }

        this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);
      ]]>
      </handler>
      <handler event="popuphiding" phase="target">
        let animate = (this.getAttribute("animate") != "false");

        if (this._fadeTimer) {
          clearTimeout(this._fadeTimer);
          if (animate) {
            this.setAttribute("animate", "fade");
          }
        } else if (animate) {
          this.setAttribute("animate", "cancel");
        }
      </handler>
      <handler event="popupshown" phase="target">
        this.removeAttribute("animating");
        this.setAttribute("panelopen", "true");
      </handler>
      <handler event="popuphidden" phase="target">
        this.removeAttribute("panelopen");
        if (this.getAttribute("animate") != "false") {
          this.removeAttribute("animate");
        }
      </handler>
      <handler event="popuppositioned" phase="target">
        this.adjustArrowPosition();
      </handler>
    </handlers>
  </binding>
</bindings>

    </textarea>
    <pre></pre>
  </div>
  </main>
    <script>
    function getJSForBinding(binding) {
  let js = [];
  let elementName = binding.attrs.id;
  let className = 'Moz' + titleCase(elementName);
  let hasExtends = !!formatExtends(binding.attrs.extends);
  js.push(`class ${className} `);
  if (hasExtends) {
    js.push(`extends Moz${formatExtends(binding.attrs.extends)} `);
  } else {
    js.push(`extends MozXULElement `);
  }

  js.push('{')

  let childMarkup = [];
  let content = binding.find("content");
  if (content.length === 0) {
    content = binding.find("xbl:content");
  }
  if (content.length > 1) {
    throw "Unexpected second content field";
  } else if (content.length === 1) {
    function printChild(child, depth) {
      let attrs = '';
      for (var attr in child.attrs) {
        attrs += ' ' + attr.replace('xbl:', '') + '="' + child.attrs[attr].replace('"', '\"').replace(/xbl\:/g, '') + '"';
      }
      let name = child.name.replace('xul:', '');
      let padding = (new Array(depth + 3)).join("  ");
      childMarkup.push(`\n${padding}<${name}${attrs}>`);
      child.children.forEach(c => printChild(c, depth+1));
      let closePadding = child.children.length ? `\n${padding}` : '';
      childMarkup.push(`${closePadding}</${name}>`);
    }
    content[0].children.forEach(c => printChild(c, 1));
  } else {
    console.log("No content for binding", binding.attrs.id);
  }

  let innerHTML = "";

  if (content.length) {
    innerHTML += 'this.textContent = "";\n';
    innerHTML += "this.appendChild(MozXULElement.parseXULToFragment(`" + childMarkup.join('') + "\n    `));\n";

    if (childMarkup.join("").includes("inherits=")) {
      innerHTML += "// XXX: Implement `this.inheritAttribute()` for the [inherits] attribute in the markup above!\n";
    }
  }

  let xblconstructor = (binding.find("constructor") || [])[0];
  let xblconstructorComment = xblconstructor ? formatComment(xblconstructor.comment) : null;
  xblconstructor = xblconstructor ? `${xblconstructor.cdata || xblconstructor.value}` : '';
  if (xblconstructorComment) {
    xblconstructor = xblconstructorComment + "\n" + xblconstructor;
  }
  // Or, try / catch since many components will fail when loaded in a tab due to chrome references
  // xblconstructor = xblconstructor ? `try { ${xblconstructor.cdata} } catch(e) { }` : '';

  let xbldestructor = (binding.find("destructor") || [])[0];
  let xbldestructorComment = xbldestructor ? formatComment(xbldestructor.comment) : null;
  xbldestructor = xbldestructor ? `${xbldestructor.cdata || xbldestructor.value}` : '';
  // Or, try / catch since many components will fail when loaded in a tab due to chrome references
  // xbldestructor = xbldestructor ? `try { ${xbldestructor.cdata} } catch(e) { }` : '';
  if (xbldestructor != '') {
    xbldestructor = `disconnectedCallback() { ${xbldestructor} }`
    if (xblconstructorComment) {
      xbldestructor = xblconstructorComment + "\n" + xbldestructor;
    }
  }

  let handlers = [];
console.log(binding.attrs.id);
if (binding.attrs.id == "browser") {
  console.log("BROWSER", binding.find('handler').length);
}
  // <handler>
  for (let handler of binding.find('handler')) {
    let comment = formatComment(handler.comment);
    if (comment) {
      handlers.push(comment);
    }

    let secondParam = "";
    let isCapturing = handler.attrs.phase === "capturing";
    if (handler.attrs.group === "system") {
      if (isCapturing) {
        secondParam = `, { capture: true, mozSystemGroup: true }`;
      } else {
        secondParam = `, { mozSystemGroup: true }`;
      }
    } else if (isCapturing) {
      secondParam = ", true";
    }
    let keycode = handler.attrs.keycode ?
`
if (event.keyCode != KeyEvent.DOM_${handler.attrs.keycode}) {
  return;
}
` : "";
    let button = handler.attrs.button ?
`
if (event.button != ${handler.attrs.button}) {
  return;
}
` : "";

// console.log("BROWSER", binding.attrs.id);
// if (binding.attrs.id == "browser") {
//   console.log("BROWSER", keycode);
// }
    handlers.push(`this.addEventListener("${handler.attrs.event}", (event) => {${keycode}${button} ${handler.cdata || handler.value || handler.attrs.action}}${secondParam});\n`);
  }


  // <field>
  let fields = [];
  for (let field of binding.find('field')) {
    // Work around fields like _weekStart in the datepicker where the value is coming from a dtd.
    // Just print an empty string in that case.
    let data = (field.cdata || field.value || "").trim();
    if (data.startsWith("FROM-DTD")) {
      data = `"${data}"`
    }
    data = (data.length === 0) ? '""' : data;

    // Remove leading comments, which would cause the 'return' to be on a different line
    // than the expression.
    let leadingComments = [];
    let expressions = data.split("\n");
    for (var i = 0; i < expressions.length; i++) {
      if (expressions[i].trim().startsWith("//")) {
        leadingComments.push(expressions[i]);
      } else {
        expressions = expressions.slice(i);
        break;
      }
    }

    let expr = expressions.join("\n");
    if (expr[expr.length - 1] !== ";") {
      expr += ";";
    }
    // Strip away parens that were only needed for XBL
    if (expr[0] === "(" && expr[expr.length - 2] === ")") {
      expr = expr.substring(1, expr.length - 2) + ";";
    }

    let comment = formatComment(field.comment);
    if (comment) {
      fields.push(comment);
    }

    if (leadingComments.length) {
      fields.push(leadingComments.join("\n"));
    }

    fields.push(`this.${field.attrs.name} = ${expr}\n`);

    // let setter = field.attrs.readonly ? '' :
    // `set(val) {
    //     delete this.${field.attrs.name};
    //     return this.${field.attrs.name} = val;
    // },`;

    // fields.push(`Object.defineProperty(this, "${field.attrs.name}", {
    //   configurable: true,
    //   enumerable: true,
    //   get() {
    //     ${comments.join('\n')}
    //     delete this.${field.attrs.name};
    //     return this.${field.attrs.name} = ${expressions.join('\n')}
    //   },
    //   ${setter}
    // })`);
  }

  if (handlers.length) {
    js.push(`
      constructor() {
        super();

        ${handlers.join("\n")}
      }
    `)
  }

  js.push(`
    connectedCallback() {
      if (this.delayConnectedCallback()) {
        return;
      }
      ${innerHTML}
      ${fields.join("\n")}

      ${xblconstructor}
    }
  `);

  // <property>
  for (let property of binding.find('property')) {
    let comment = formatComment(property.comment);
    if (comment) {
      js.push(comment);
    }
    if (property.attrs.onset) {
      js.push(`
        set ${property.attrs.name}(val) {
          ${property.attrs.onset}
        }
      `);
    } else if(property.find('setter').length) {
      js.push(`
        set ${property.attrs.name}(val) {${property.find('setter')[0].cdata || property.find('setter')[0].value}}
      `);
    }
    if (property.attrs.onget) {
      js.push(`
        get ${property.attrs.name}() {
          ${property.attrs.onget}
        }
      `);
    } else if(property.find('getter').length) {
      js.push(`
        get ${property.attrs.name}() {${property.find('getter')[0].cdata || property.find('getter')[0].value}}
      `);
    }
  }

  // <method>
  for (let method of binding.find('method')) {
    js.push('\n');
    let comment = formatComment(method.comment);
    if (comment) {
      js.push(comment);
    }
    js.push(`${method.attrs.name}(`);
    js.push(`${method.find('parameter').map(p => p.attrs.name).join(',')}`);
    js.push(`) {`);
    js.push(method.find('body')[0].cdata || method.find('body')[0].value);
    js.push(`}\n`);
  }

  js.push(`${xbldestructor}`);

  js.push("}\n\n");

  let implements =
    binding.find("implementation").length &&
    binding.find("implementation")[0].attrs.implements
  if (implements) {
    implements = implements.split(",").map(i=>"Ci." + i.trim()).join(", ");
    js.push(`MozXULElement.implementCustomInterface(${className}, [${implements}]);`)
  }



  js.push(`customElements.define("${elementName}", ${className});
  `)
  return js.join(' ');
}
    function titleCase(str) {
  if (str == "basecontrol") {
    // Special case so we don't end up with Basecontrol:
    return "BaseControl";
  }
  return str[0].toUpperCase() + str.substr(1).replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
}
    function formatExtends(ext) {
  if (!ext || ext.startsWith("xul:")) {
    return null;
  }
  return titleCase(ext.split('#')[1]);
}
    function formatComment(comment, spaces = 2) {
  if (!comment) {
    return '';
  }

  let spacesStr = new Array(spaces).join(" ");
  let commentArr = comment.split("\n").map(s=> s.trim());
  if (!commentArr[0]) { commentArr.shift(); }
  if (!commentArr[commentArr.length - 1]) { commentArr.pop(); }
  let commentFormatted = commentArr
    .map(s => (s ? `${spacesStr}* ${s}` : `${spacesStr}*`))
    .join("\n");

  return `${spacesStr}/**\n${commentFormatted}\n${spacesStr}*/`;
}
    function getFormattedJSForBinding(binding) {
  let js = [];
  js.push(
`/* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

"use strict";

// This is loaded into all XUL windows. Wrap in a block to prevent
// leaking to window scope.
{

`);

  js.push(js_beautify(
    getJSForBinding(binding),
    {
      indent_size: 2,
      // preserve_newlines: false,
      max_preserve_newlines: 2,
      brace_style: "preserve-inline"
      // keep_array_indentation: true
    }
  ));

  js.push(`

}
`);

  return js.join("");
}

    var textarea = document.querySelector("textarea");
    var pre = document.querySelector("pre");
    function createPreview() {
      var body = textarea.value;
      body = body.replace(/&([a-z0-9-]+);/gi, "FROM-DTD-$1"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2-$3"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2-$3-$4"); // Replace DTD entities
      var parsed = xmlom.parseString(body, {
        xmlns: true,
      });
      parsed.then(doc => {
        console.log(doc, doc.find("binding"));
        let js = doc.find("binding").map(binding => {
          return getFormattedJSForBinding(binding);
        }).join("\n");
        pre.textContent = js;
      }).catch(e => {
        pre.textContent =  "Error parsing XML:\n" + e;
      });
    }
    textarea.addEventListener("input", createPreview);
    createPreview();

    document.querySelector("ul").addEventListener("click", function(e) {
      if (e.originalTarget.localName === "a") {
        e.preventDefault();
        textarea.value = files[e.originalTarget.dataset.index].body;
        createPreview();
      }
    });
    </script>
  </body>
  </html>
