
  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8">
    <title>XBL To Custom Element Converter</title>
    <link rel="stylesheet" href="../static/styles.css" />
    <script src="../static/xmlom.js"></script>
    <style>
    main {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
      width: 100vw;
      position: absolute;
      top: 0;
      left: 0;
    }
    #converter {
      font-family: monospace;
      display: grid;
      overflow: hidden;
      grid-template-columns: auto 1fr 1fr;
      grid-gap: 10px;
    }
    textarea, pre {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: monospace;
      font-size: 12px;
    }
    ul {
      min-width: 100px;
      margin: 0;
      padding: 0;
      overflow: scroll;
      font-size: smaller;
    }
    li {
      margin: 0;
      padding: 0;
      list-style: none;
      word-break: keep-all;
    }
    </style>
    <script>
      var files = [{"file":"browser-tabPreviews.xml","body":"<?xml version=\"1.0\"?>\n\n\n\n\n\n\n<bindings id=\"tabPreviews\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n  <binding id=\"ctrlTab-preview\" extends=\"chrome://global/content/bindings/button.xml#button-base\">\n    <content pack=\"center\">\n      <xul:stack>\n        <xul:vbox class=\"ctrlTab-preview-inner\" align=\"center\" pack=\"center\"\n                  xbl:inherits=\"width=canvaswidth\">\n          <xul:hbox class=\"tabPreview-canvas\" xbl:inherits=\"style=canvasstyle\">\n            <children/>\n          </xul:hbox>\n          <xul:label xbl:inherits=\"value=label\" crop=\"end\" class=\"plain\"/>\n        </xul:vbox>\n        <xul:hbox class=\"ctrlTab-favicon-container\" xbl:inherits=\"hidden=noicon\">\n          <xul:image class=\"ctrlTab-favicon\" xbl:inherits=\"src=image\"/>\n        </xul:hbox>\n      </xul:stack>\n    </content>\n    <handlers>\n      <handler event=\"mouseover\" action=\"ctrlTab._mouseOverFocus(this);\"/>\n      <handler event=\"command\" action=\"ctrlTab.pick(this);\"/>\n      <handler event=\"click\" button=\"1\" action=\"ctrlTab.remove(this);\"/>\n\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"feeds.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings [\n  <!ENTITY % pageInfoDTD SYSTEM \"chrome://browser/locale/pageInfo.dtd\">\n  %pageInfoDTD;\n]>\n\n<bindings id=\"feedBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"feed\" extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <content>\n      <xul:vbox flex=\"1\">\n        <xul:hbox flex=\"1\">\n          <xul:textbox flex=\"1\" readonly=\"true\" xbl:inherits=\"value=name\"\n                       class=\"feedTitle\"/>\n          <xul:label xbl:inherits=\"value=type\"/>\n        </xul:hbox>\n        <xul:vbox>\n          <xul:vbox align=\"start\">\n            <xul:hbox>\n              <xul:label xbl:inherits=\"value=feedURL,tooltiptext=feedURL\" class=\"text-link\" flex=\"1\"\n                         onclick=\"openUILink(this.value, event);\" crop=\"end\"/>\n            </xul:hbox>\n          </xul:vbox>\n        </xul:vbox>\n        <xul:hbox flex=\"1\" class=\"feed-subscribe\">\n          <xul:spacer flex=\"1\"/>\n          <xul:button label=\"FROM-DTD-feedSubscribe\" accesskey=\"FROM-DTD-feedSubscribe-accesskey\"\n                      oncommand=\"onSubscribeFeed()\"/>\n        </xul:hbox> \n      </xul:vbox>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"pageInfo.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"pageInfoBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <!-- based on preferences.xml paneButton -->\n  <binding id=\"viewbutton\" extends=\"chrome://global/content/bindings/radio.xml#radio\" role=\"xullistitem\">\n    <content>\n      <xul:image class=\"viewButtonIcon\" xbl:inherits=\"src\"/>\n      <xul:label class=\"viewButtonLabel\" xbl:inherits=\"value=label\"/>\n    </content>\n  </binding>\n\n</bindings>\n"},{"file":"tabbrowser.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- eslint-env mozilla/browser-window -->\n\n<bindings id=\"tabBrowserBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"tabbrowser\">\n    <resources>\n      <stylesheet src=\"chrome://browser/content/tabbrowser.css\"/>\n    </resources>\n\n    <content>\n      <xul:tabbox anonid=\"tabbox\" class=\"tabbrowser-tabbox\"\n                  flex=\"1\" eventnode=\"document\" xbl:inherits=\"tabcontainer\"\n                  onselect=\"if (event.target.localName == 'tabpanels') this.parentNode.updateCurrentBrowser();\">\n        <xul:tabpanels flex=\"1\" class=\"plain\" selectedIndex=\"0\" anonid=\"panelcontainer\">\n          <xul:notificationbox flex=\"1\" notificationside=\"top\">\n            <xul:hbox flex=\"1\" class=\"browserSidebarContainer\">\n              <xul:vbox flex=\"1\" class=\"browserContainer\">\n                <xul:stack flex=\"1\" class=\"browserStack\" anonid=\"browserStack\">\n                  <xul:browser anonid=\"initialBrowser\" type=\"content\" message=\"true\" messagemanagergroup=\"browsers\"\n                               primary=\"true\" blank=\"true\"\n                               xbl:inherits=\"tooltip=contenttooltip,contextmenu=contentcontextmenu,autocompletepopup,selectmenulist,datetimepicker\"/>\n                </xul:stack>\n              </xul:vbox>\n            </xul:hbox>\n          </xul:notificationbox>\n        </xul:tabpanels>\n      </xul:tabbox>\n      <children/>\n    </content>\n    <implementation implements=\"nsIDOMEventListener, nsIMessageListener, nsIObserver\">\n\n      <property name=\"tabContextMenu\" readonly=\"true\"\n                onget=\"return this.tabContainer.contextMenu;\"/>\n\n      <field name=\"tabContainer\" readonly=\"true\">\n        document.getElementById(this.getAttribute(\"tabcontainer\"));\n      </field>\n      <field name=\"tabs\" readonly=\"true\">\n        this.tabContainer.childNodes;\n      </field>\n\n      <property name=\"visibleTabs\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._visibleTabs)\n            this._visibleTabs = Array.filter(this.tabs,\n                                             tab => !tab.hidden && !tab.closing);\n          return this._visibleTabs;\n        ]]></getter>\n      </property>\n\n      <field name=\"closingTabsEnum\" readonly=\"true\">({ ALL: 0, OTHER: 1, TO_END: 2 });</field>\n\n      <field name=\"_visibleTabs\">null</field>\n\n      <field name=\"mURIFixup\" readonly=\"true\">\n        Components.classes[\"@mozilla.org/docshell/urifixup;1\"]\n                  .getService(Components.interfaces.nsIURIFixup);\n      </field>\n      <field name=\"_unifiedComplete\" readonly=\"true\">\n         Components.classes[\"@mozilla.org/autocomplete/search;1?name=unifiedcomplete\"]\n                   .getService(Components.interfaces.mozIPlacesAutoComplete);\n      </field>\n      <field name=\"mTabBox\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"tabbox\");\n      </field>\n      <field name=\"mPanelContainer\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"panelcontainer\");\n      </field>\n      <field name=\"mCurrentTab\">\n        null\n      </field>\n      <field name=\"_lastRelatedTabMap\">\n        new WeakMap();\n      </field>\n      <field name=\"mCurrentBrowser\">\n        null\n      </field>\n      <field name=\"mProgressListeners\">\n        []\n      </field>\n      <field name=\"mTabsProgressListeners\">\n        []\n      </field>\n      <field name=\"_tabListeners\">\n        new Map()\n      </field>\n      <field name=\"_tabFilters\">\n        new Map()\n      </field>\n      <field name=\"mIsBusy\">\n        false\n      </field>\n      <field name=\"_outerWindowIDBrowserMap\">\n        new Map();\n      </field>\n      <field name=\"arrowKeysShouldWrap\" readonly=\"true\">\n        AppConstants == \"macosx\";\n      </field>\n\n      <field name=\"_autoScrollPopup\">\n        null\n      </field>\n\n      <field name=\"_previewMode\">\n        false\n      </field>\n\n      <field name=\"_lastFindValue\">\n        \"\"\n      </field>\n\n      <field name=\"_contentWaitingCount\">\n        0\n      </field>\n\n      <field name=\"tabAnimationsInProgress\">\n        0\n      </field>\n\n      <property name=\"_numPinnedTabs\" readonly=\"true\">\n        <getter><![CDATA[\n          for (var i = 0; i < this.tabs.length; i++) {\n            if (!this.tabs[i].pinned)\n              break;\n          }\n          return i;\n        ]]></getter>\n      </property>\n\n      <property name=\"popupAnchor\" readonly=\"true\">\n        <getter><![CDATA[\n        if (this.mCurrentTab._popupAnchor) {\n          return this.mCurrentTab._popupAnchor;\n        }\n        let stack = this.mCurrentBrowser.parentNode;\n        // Create an anchor for the popup\n        const NS_XUL = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n        let popupAnchor = document.createElementNS(NS_XUL, \"hbox\");\n        popupAnchor.className = \"popup-anchor\";\n        popupAnchor.hidden = true;\n        stack.appendChild(popupAnchor);\n        return this.mCurrentTab._popupAnchor = popupAnchor;\n        ]]></getter>\n      </property>\n\n      <method name=\"isFindBarInitialized\">\n        <parameter name=\"aTab\"/>\n        <body><![CDATA[\n          return (aTab || this.selectedTab)._findBar != undefined;\n        ]]></body>\n      </method>\n\n      <method name=\"getFindBar\">\n        <parameter name=\"aTab\"/>\n        <body><![CDATA[\n          if (!aTab)\n            aTab = this.selectedTab;\n\n          if (aTab._findBar)\n            return aTab._findBar;\n\n          let findBar = document.createElementNS(this.namespaceURI, \"findbar\");\n          let browser = this.getBrowserForTab(aTab);\n          let browserContainer = this.getBrowserContainer(browser);\n          browserContainer.appendChild(findBar);\n\n          // Force a style flush to ensure that our binding is attached.\n          findBar.clientTop;\n\n          findBar.browser = browser;\n          findBar._findField.value = this._lastFindValue;\n\n          aTab._findBar = findBar;\n\n          let event = document.createEvent(\"Events\");\n          event.initEvent(\"TabFindInitialized\", true, false);\n          aTab.dispatchEvent(event);\n\n          return findBar;\n        ]]></body>\n      </method>\n\n      <method name=\"getStatusPanel\">\n        <body><![CDATA[\n          if (!this._statusPanel) {\n            this._statusPanel = document.createElementNS(this.namespaceURI, \"statuspanel\");\n            this._statusPanel.setAttribute(\"inactive\", \"true\");\n            this._statusPanel.setAttribute(\"layer\", \"true\");\n            this._appendStatusPanel();\n          }\n          return this._statusPanel;\n        ]]></body>\n      </method>\n\n      <method name=\"_appendStatusPanel\">\n        <body><![CDATA[\n          if (this._statusPanel) {\n            let browser = this.selectedBrowser;\n            let browserContainer = this.getBrowserContainer(browser);\n            browserContainer.insertBefore(this._statusPanel, browser.parentNode.nextSibling);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_setCloseKeyState\">\n        <parameter name=\"aEnabled\"/>\n        <body><![CDATA[\n          let keyClose = document.getElementById(\"key_close\");\n          let closeKeyEnabled = keyClose.getAttribute(\"disabled\") != \"true\";\n          if (closeKeyEnabled == aEnabled)\n            return;\n\n          if (aEnabled)\n            keyClose.removeAttribute(\"disabled\");\n          else\n            keyClose.setAttribute(\"disabled\", \"true\");\n\n          // We also want to remove the keyboard shortcut from the file menu\n          // when the shortcut is disabled, and bring it back when it's\n          // renabled.\n          //\n          // Fixing bug 630826 could make that happen automatically.\n          // Fixing bug 630830 could avoid the ugly hack below.\n\n          let closeMenuItem = document.getElementById(\"menu_close\");\n          let parentPopup = closeMenuItem.parentNode;\n          let nextItem = closeMenuItem.nextSibling;\n          let clonedItem = closeMenuItem.cloneNode(true);\n\n          parentPopup.removeChild(closeMenuItem);\n\n          if (aEnabled)\n            clonedItem.setAttribute(\"key\", \"key_close\");\n          else\n            clonedItem.removeAttribute(\"key\");\n\n          parentPopup.insertBefore(clonedItem, nextItem);\n        ]]></body>\n      </method>\n\n      <method name=\"pinTab\">\n        <parameter name=\"aTab\"/>\n        <body><![CDATA[\n          if (aTab.pinned)\n            return;\n\n          if (aTab.hidden)\n            this.showTab(aTab);\n\n          this.moveTabTo(aTab, this._numPinnedTabs);\n          aTab.setAttribute(\"pinned\", \"true\");\n          this.tabContainer._unlockTabSizing();\n          this.tabContainer._positionPinnedTabs();\n          this.tabContainer.adjustTabstrip();\n\n          this.getBrowserForTab(aTab).messageManager.sendAsyncMessage(\"Browser:AppTab\", { isAppTab: true })\n\n          if (aTab.selected)\n            this._setCloseKeyState(false);\n\n          let event = document.createEvent(\"Events\");\n          event.initEvent(\"TabPinned\", true, false);\n          aTab.dispatchEvent(event);\n        ]]></body>\n      </method>\n\n      <method name=\"unpinTab\">\n        <parameter name=\"aTab\"/>\n        <body><![CDATA[\n          if (!aTab.pinned)\n            return;\n\n          this.moveTabTo(aTab, this._numPinnedTabs - 1);\n          aTab.removeAttribute(\"pinned\");\n          aTab.style.marginInlineStart = \"\";\n          this.tabContainer._unlockTabSizing();\n          this.tabContainer._positionPinnedTabs();\n          this.tabContainer.adjustTabstrip();\n\n          this.getBrowserForTab(aTab).messageManager.sendAsyncMessage(\"Browser:AppTab\", { isAppTab: false })\n\n          if (aTab.selected)\n            this._setCloseKeyState(true);\n\n          let event = document.createEvent(\"Events\");\n          event.initEvent(\"TabUnpinned\", true, false);\n          aTab.dispatchEvent(event);\n        ]]></body>\n      </method>\n\n      <method name=\"previewTab\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aCallback\"/>\n        <body>\n          <![CDATA[\n            let currentTab = this.selectedTab;\n            try {\n              // Suppress focus, ownership and selected tab changes\n              this._previewMode = true;\n              this.selectedTab = aTab;\n              aCallback();\n            } finally {\n              this.selectedTab = currentTab;\n              this._previewMode = false;\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getBrowserAtIndex\">\n        <parameter name=\"aIndex\"/>\n        <body>\n          <![CDATA[\n            return this.browsers[aIndex];\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getBrowserIndexForDocument\">\n        <parameter name=\"aDocument\"/>\n        <body>\n          <![CDATA[\n            var tab = this._getTabForContentWindow(aDocument.defaultView);\n            return tab ? tab._tPos : -1;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getBrowserForDocument\">\n        <parameter name=\"aDocument\"/>\n        <body>\n          <![CDATA[\n            var tab = this._getTabForContentWindow(aDocument.defaultView);\n            return tab ? tab.linkedBrowser : null;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getBrowserForContentWindow\">\n        <parameter name=\"aWindow\"/>\n        <body>\n          <![CDATA[\n            var tab = this._getTabForContentWindow(aWindow);\n            return tab ? tab.linkedBrowser : null;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getBrowserForOuterWindowID\">\n        <parameter name=\"aID\"/>\n        <body>\n          <![CDATA[\n            return this._outerWindowIDBrowserMap.get(aID);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_getTabForContentWindow\">\n        <parameter name=\"aWindow\"/>\n        <body>\n        <![CDATA[\n          // When not using remote browsers, we can take a fast path by getting\n          // directly from the content window to the browser without looping\n          // over all browsers.\n          if (!gMultiProcessBrowser) {\n            let browser = aWindow.QueryInterface(Ci.nsIInterfaceRequestor)\n                                 .getInterface(Ci.nsIWebNavigation)\n                                 .QueryInterface(Ci.nsIDocShell)\n                                 .chromeEventHandler;\n            return this.getTabForBrowser(browser);\n          }\n\n          for (let i = 0; i < this.browsers.length; i++) {\n            // NB: We use contentWindowAsCPOW so that this code works both\n            // for remote browsers as well. aWindow may be a CPOW.\n            if (this.browsers[i].contentWindowAsCPOW == aWindow)\n              return this.tabs[i];\n          }\n          return null;\n        ]]>\n        </body>\n      </method>\n\n      <!-- Binding from browser to tab -->\n      <field name=\"_tabForBrowser\" readonly=\"true\">\n      <![CDATA[\n        new WeakMap();\n      ]]>\n      </field>\n\n      <method name=\"getTabForBrowser\">\n        <parameter name=\"aBrowser\"/>\n        <body>\n        <![CDATA[\n          return this._tabForBrowser.get(aBrowser);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getNotificationBox\">\n        <parameter name=\"aBrowser\"/>\n        <body>\n          <![CDATA[\n            return this.getSidebarContainer(aBrowser).parentNode;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getSidebarContainer\">\n        <parameter name=\"aBrowser\"/>\n        <body>\n          <![CDATA[\n            return this.getBrowserContainer(aBrowser).parentNode;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getBrowserContainer\">\n        <parameter name=\"aBrowser\"/>\n        <body>\n          <![CDATA[\n            return (aBrowser || this.mCurrentBrowser).parentNode.parentNode;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getTabModalPromptBox\">\n        <parameter name=\"aBrowser\"/>\n        <body>\n          <![CDATA[\n            let browser = (aBrowser || this.mCurrentBrowser);\n            if (!browser.tabModalPromptBox) {\n              browser.tabModalPromptBox = new TabModalPromptBox(browser);\n            }\n            return browser.tabModalPromptBox;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getTabFromAudioEvent\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          if (!Services.prefs.getBoolPref(\"browser.tabs.showAudioPlayingIcon\") ||\n              !aEvent.isTrusted) {\n            return null;\n          }\n\n          var browser = aEvent.originalTarget;\n          var tab = this.getTabForBrowser(browser);\n          return tab;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_callProgressListeners\">\n        <parameter name=\"aBrowser\"/>\n        <parameter name=\"aMethod\"/>\n        <parameter name=\"aArguments\"/>\n        <parameter name=\"aCallGlobalListeners\"/>\n        <parameter name=\"aCallTabsListeners\"/>\n        <body><![CDATA[\n          var rv = true;\n\n          function callListeners(listeners, args) {\n            for (let p of listeners) {\n              if (aMethod in p) {\n                try {\n                  if (!p[aMethod].apply(p, args))\n                    rv = false;\n                } catch (e) {\n                  // don't inhibit other listeners\n                  Components.utils.reportError(e);\n                }\n              }\n            }\n          }\n\n          if (!aBrowser)\n            aBrowser = this.mCurrentBrowser;\n\n          if (aCallGlobalListeners != false &&\n              aBrowser == this.mCurrentBrowser) {\n            callListeners(this.mProgressListeners, aArguments);\n          }\n\n          if (aCallTabsListeners != false) {\n            aArguments.unshift(aBrowser);\n\n            callListeners(this.mTabsProgressListeners, aArguments);\n          }\n\n          return rv;\n        ]]></body>\n      </method>\n\n      <!-- Determine if a URI is an about: page pointing to a local resource. -->\n      <method name=\"_isLocalAboutURI\">\n        <parameter name=\"aURI\"/>\n        <parameter name=\"aResolvedURI\"/>\n        <body><![CDATA[\n          if (!aURI.schemeIs(\"about\")) {\n            return false;\n          }\n\n          // Specially handle about:blank as local\n          if (aURI.pathQueryRef === \"blank\") {\n            return true;\n          }\n\n          try {\n            // Use the passed in resolvedURI if we have one\n            const resolvedURI = aResolvedURI || Services.io.newChannelFromURI2(\n              aURI,\n              null, // loadingNode\n              Services.scriptSecurityManager.getSystemPrincipal(), // loadingPrincipal\n              null, // triggeringPrincipal\n              Ci.nsILoadInfo.SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL, // securityFlags\n              Ci.nsIContentPolicy.TYPE_OTHER // contentPolicyType\n            ).URI;\n            return resolvedURI.schemeIs(\"jar\") || resolvedURI.schemeIs(\"file\");\n          } catch (ex) {\n            // aURI might be invalid.\n            return false;\n          }\n        ]]></body>\n      </method>\n\n      <!-- A web progress listener object definition for a given tab. -->\n      <method name=\"mTabProgressListener\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aBrowser\"/>\n        <parameter name=\"aStartsBlank\"/>\n        <parameter name=\"aWasPreloadedBrowser\"/>\n        <parameter name=\"aOrigStateFlags\"/>\n        <body>\n        <![CDATA[\n          let stateFlags = aOrigStateFlags || 0;\n          // Initialize mStateFlags to non-zero e.g. when creating a progress\n          // listener for preloaded browsers as there was no progress listener\n          // around when the content started loading. If the content didn't\n          // quite finish loading yet, mStateFlags will very soon be overridden\n          // with the correct value and end up at STATE_STOP again.\n          if (aWasPreloadedBrowser) {\n            stateFlags = Ci.nsIWebProgressListener.STATE_STOP |\n                         Ci.nsIWebProgressListener.STATE_IS_REQUEST;\n          }\n\n          return ({\n            mTabBrowser: this,\n            mTab: aTab,\n            mBrowser: aBrowser,\n            mBlank: aStartsBlank,\n\n            // cache flags for correct status UI update after tab switching\n            mStateFlags: stateFlags,\n            mStatus: 0,\n            mMessage: \"\",\n            mTotalProgress: 0,\n\n            // count of open requests (should always be 0 or 1)\n            mRequestCount: 0,\n\n            destroy() {\n              delete this.mTab;\n              delete this.mBrowser;\n              delete this.mTabBrowser;\n            },\n\n            _callProgressListeners() {\n              Array.unshift(arguments, this.mBrowser);\n              return this.mTabBrowser._callProgressListeners.apply(this.mTabBrowser, arguments);\n            },\n\n            _shouldShowProgress(aRequest) {\n              if (this.mBlank)\n                return false;\n\n              // Don't show progress indicators in tabs for about: URIs\n              // pointing to local resources.\n              if ((aRequest instanceof Ci.nsIChannel) &&\n                  this.mTabBrowser._isLocalAboutURI(aRequest.originalURI, aRequest.URI)) {\n                return false;\n              }\n\n              return true;\n            },\n\n            _isForInitialAboutBlank(aWebProgress, aStateFlags, aLocation) {\n              if (!this.mBlank || !aWebProgress.isTopLevel) {\n                return false;\n              }\n\n              // If the state has STATE_STOP, and no requests were in flight, then this\n              // must be the initial \"stop\" for the initial about:blank document.\n              const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;\n              if (aStateFlags & nsIWebProgressListener.STATE_STOP &&\n                  this.mRequestCount == 0 &&\n                  !aLocation) {\n                return true;\n              }\n\n              let location = aLocation ? aLocation.spec : \"\";\n              return location == \"about:blank\";\n            },\n\n            _syncThrobberAnimations() {\n              const originalTab = this.mTab;\n              BrowserUtils.promiseLayoutFlushed(this.mTab.ownerDocument, \"style\", () => {\n                if (!originalTab.parentNode) {\n                  return;\n                }\n\n                const animations =\n                  Array.from(originalTab.parentNode.getElementsByTagName(\"tab\"))\n                  .map(tab => {\n                    const throbber =\n                      document.getAnonymousElementByAttribute(tab, \"anonid\", \"tab-throbber\");\n                    return throbber ? throbber.getAnimations({ subtree: true }) : [];\n                  })\n                  .reduce((a, b) => a.concat(b))\n                  .filter(anim =>\n                    anim instanceof CSSAnimation &&\n                    (anim.animationName === \"tab-throbber-animation\" ||\n                     anim.animationName === \"tab-throbber-animation-rtl\") &&\n                    (anim.playState === \"running\" || anim.playState === \"pending\"));\n\n                // Synchronize with the oldest running animation, if any.\n                const firstStartTime = Math.min(\n                  ...animations.map(anim => anim.startTime === null ? Infinity : anim.startTime)\n                );\n                if (firstStartTime === Infinity) {\n                  return;\n                }\n                requestAnimationFrame(() => {\n                  for (let animation of animations) {\n                    // If |animation| has been cancelled since this rAF callback\n                    // was scheduled we don't want to set its startTime since\n                    // that would restart it. We check for a cancelled animation\n                    // by looking for a null currentTime rather than checking\n                    // the playState, since reading the playState of\n                    // a CSSAnimation object will flush style.\n                    if (animation.currentTime !== null) {\n                      animation.startTime = firstStartTime;\n                    }\n                  }\n                });\n              });\n            },\n\n            onProgressChange(aWebProgress, aRequest,\n                             aCurSelfProgress, aMaxSelfProgress,\n                             aCurTotalProgress, aMaxTotalProgress) {\n              this.mTotalProgress = aMaxTotalProgress ? aCurTotalProgress / aMaxTotalProgress : 0;\n\n              if (!this._shouldShowProgress(aRequest))\n                return;\n\n              if (this.mTotalProgress && this.mTab.hasAttribute(\"busy\"))\n                this.mTab.setAttribute(\"progress\", \"true\");\n\n              this._callProgressListeners(\"onProgressChange\",\n                                          [aWebProgress, aRequest,\n                                           aCurSelfProgress, aMaxSelfProgress,\n                                           aCurTotalProgress, aMaxTotalProgress]);\n            },\n\n            onProgressChange64(aWebProgress, aRequest,\n                               aCurSelfProgress, aMaxSelfProgress,\n                               aCurTotalProgress, aMaxTotalProgress) {\n              return this.onProgressChange(aWebProgress, aRequest,\n                aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress,\n                aMaxTotalProgress);\n            },\n\n            onStateChange(aWebProgress, aRequest, aStateFlags, aStatus) {\n              if (!aRequest)\n                return;\n\n              const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;\n              const nsIChannel = Components.interfaces.nsIChannel;\n              let location, originalLocation;\n              try {\n                aRequest.QueryInterface(nsIChannel)\n                location = aRequest.URI;\n                originalLocation = aRequest.originalURI;\n              } catch (ex) {}\n\n              let ignoreBlank = this._isForInitialAboutBlank(aWebProgress, aStateFlags,\n                                                             location);\n\n              // If we were ignoring some messages about the initial about:blank, and we\n              // got the STATE_STOP for it, we'll want to pay attention to those messages\n              // from here forward. Similarly, if we conclude that this state change\n              // is one that we shouldn't be ignoring, then stop ignoring.\n              if ((ignoreBlank &&\n                   aStateFlags & nsIWebProgressListener.STATE_STOP &&\n                   aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) ||\n                  !ignoreBlank && this.mBlank) {\n                this.mBlank = false;\n              }\n\n              if (aStateFlags & nsIWebProgressListener.STATE_START) {\n                this.mRequestCount++;\n              } else if (aStateFlags & nsIWebProgressListener.STATE_STOP) {\n                const NS_ERROR_UNKNOWN_HOST = 2152398878;\n                if (--this.mRequestCount > 0 && aStatus == NS_ERROR_UNKNOWN_HOST) {\n                  // to prevent bug 235825: wait for the request handled\n                  // by the automatic keyword resolver\n                  return;\n                }\n                // since we (try to) only handle STATE_STOP of the last request,\n                // the count of open requests should now be 0\n                this.mRequestCount = 0;\n              }\n\n              if (aStateFlags & nsIWebProgressListener.STATE_START &&\n                  aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {\n                if (aWebProgress.isTopLevel) {\n                  // Need to use originalLocation rather than location because things\n                  // like about:home and about:privatebrowsing arrive with nsIRequest\n                  // pointing to their resolved jar: or file: URIs.\n                  if (!(originalLocation && gInitialPages.includes(originalLocation.spec) &&\n                        originalLocation != \"about:blank\" &&\n                        this.mBrowser.initialPageLoadedFromURLBar != originalLocation.spec &&\n                        this.mBrowser.currentURI && this.mBrowser.currentURI.spec == \"about:blank\")) {\n                    // Indicating that we started a load will allow the location\n                    // bar to be cleared when the load finishes.\n                    // In order to not overwrite user-typed content, we avoid it\n                    // (see if condition above) in a very specific case:\n                    // If the load is of an 'initial' page (e.g. about:privatebrowsing,\n                    // about:newtab, etc.), was not explicitly typed in the location\n                    // bar by the user, is not about:blank (because about:blank can be\n                    // loaded by websites under their principal), and the current\n                    // page in the browser is about:blank (indicating it is a newly\n                    // created or re-created browser, e.g. because it just switched\n                    // remoteness or is a new tab/window).\n                    this.mBrowser.urlbarChangeTracker.startedLoad();\n                  }\n                  delete this.mBrowser.initialPageLoadedFromURLBar;\n                  // If the browser is loading it must not be crashed anymore\n                  this.mTab.removeAttribute(\"crashed\");\n                }\n\n                if (this._shouldShowProgress(aRequest)) {\n                  if (!(aStateFlags & nsIWebProgressListener.STATE_RESTORING) &&\n                      aWebProgress && aWebProgress.isTopLevel) {\n                    this.mTab.setAttribute(\"busy\", \"true\");\n                    this.mTab._notselectedsinceload = !this.mTab.selected;\n                    this._syncThrobberAnimations();\n                  }\n\n                  if (this.mTab.selected) {\n                    this.mTabBrowser.mIsBusy = true;\n                  }\n                }\n              } else if (aStateFlags & nsIWebProgressListener.STATE_STOP &&\n                         aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {\n\n                if (this.mTab.hasAttribute(\"busy\")) {\n                  this.mTab.removeAttribute(\"busy\");\n\n                  // Only animate the \"burst\" indicating the page has loaded if\n                  // the top-level page is the one that finished loading.\n                  if (aWebProgress.isTopLevel && !aWebProgress.isLoadingDocument &&\n                      Components.isSuccessCode(aStatus) &&\n                      !this.mTabBrowser.tabAnimationsInProgress &&\n                      Services.prefs.getBoolPref(\"toolkit.cosmeticAnimations.enabled\")) {\n                    if (this.mTab._notselectedsinceload) {\n                      this.mTab.setAttribute(\"notselectedsinceload\", \"true\");\n                    } else {\n                      this.mTab.removeAttribute(\"notselectedsinceload\");\n                    }\n\n                    this.mTab.setAttribute(\"bursting\", \"true\");\n                  }\n\n                  this.mTabBrowser._tabAttrModified(this.mTab, [\"busy\"]);\n                  if (!this.mTab.selected)\n                    this.mTab.setAttribute(\"unread\", \"true\");\n                }\n                this.mTab.removeAttribute(\"progress\");\n\n                if (aWebProgress.isTopLevel) {\n                  let isSuccessful = Components.isSuccessCode(aStatus);\n                  if (!isSuccessful && !isTabEmpty(this.mTab)) {\n                    // Restore the current document's location in case the\n                    // request was stopped (possibly from a content script)\n                    // before the location changed.\n\n                    this.mBrowser.userTypedValue = null;\n\n                    let inLoadURI = this.mBrowser.inLoadURI;\n                    if (this.mTab.selected && gURLBar && !inLoadURI) {\n                      URLBarSetURI();\n                    }\n                  } else if (isSuccessful) {\n                    this.mBrowser.urlbarChangeTracker.finishedLoad();\n                  }\n\n                  if (!this.mBrowser.mIconURL) {\n                    this.mTabBrowser.useDefaultIcon(this.mTab);\n                  }\n                }\n\n                // For keyword URIs clear the user typed value since they will be changed into real URIs\n                if (location.scheme == \"keyword\")\n                  this.mBrowser.userTypedValue = null;\n\n                if (this.mTab.selected)\n                  this.mTabBrowser.mIsBusy = false;\n              }\n\n              if (ignoreBlank) {\n                this._callProgressListeners(\"onUpdateCurrentBrowser\",\n                                            [aStateFlags, aStatus, \"\", 0],\n                                            true, false);\n              } else {\n                this._callProgressListeners(\"onStateChange\",\n                                            [aWebProgress, aRequest, aStateFlags, aStatus],\n                                            true, false);\n              }\n\n              this._callProgressListeners(\"onStateChange\",\n                                          [aWebProgress, aRequest, aStateFlags, aStatus],\n                                          false);\n\n              if (aStateFlags & (nsIWebProgressListener.STATE_START |\n                                 nsIWebProgressListener.STATE_STOP)) {\n                // reset cached temporary values at beginning and end\n                this.mMessage = \"\";\n                this.mTotalProgress = 0;\n              }\n              this.mStateFlags = aStateFlags;\n              this.mStatus = aStatus;\n            },\n\n            onLocationChange(aWebProgress, aRequest, aLocation,\n                             aFlags) {\n              // OnLocationChange is called for both the top-level content\n              // and the subframes.\n              let topLevel = aWebProgress.isTopLevel;\n\n              if (topLevel) {\n                let isSameDocument =\n                  !!(aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_SAME_DOCUMENT);\n                // We need to clear the typed value\n                // if the document failed to load, to make sure the urlbar reflects the\n                // failed URI (particularly for SSL errors). However, don't clear the value\n                // if the error page's URI is about:blank, because that causes complete\n                // loss of urlbar contents for invalid URI errors (see bug 867957).\n                // Another reason to clear the userTypedValue is if this was an anchor\n                // navigation initiated by the user.\n                if (this.mBrowser.didStartLoadSinceLastUserTyping() ||\n                    ((aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_ERROR_PAGE) &&\n                     aLocation.spec != \"about:blank\") ||\n                    (isSameDocument && this.mBrowser.inLoadURI)) {\n                  this.mBrowser.userTypedValue = null;\n                }\n\n                // If the browser was playing audio, we should remove the playing state.\n                if (this.mTab.hasAttribute(\"soundplaying\") && !isSameDocument) {\n                  clearTimeout(this.mTab._soundPlayingAttrRemovalTimer);\n                  this.mTab._soundPlayingAttrRemovalTimer = 0;\n                  this.mTab.removeAttribute(\"soundplaying\");\n                  this.mTabBrowser._tabAttrModified(this.mTab, [\"soundplaying\"]);\n                }\n\n                // If the browser was previously muted, we should restore the muted state.\n                if (this.mTab.hasAttribute(\"muted\")) {\n                  this.mTab.linkedBrowser.mute();\n                }\n\n                if (this.mTabBrowser.isFindBarInitialized(this.mTab)) {\n                  let findBar = this.mTabBrowser.getFindBar(this.mTab);\n\n                  // Close the Find toolbar if we're in old-style TAF mode\n                  if (findBar.findMode != findBar.FIND_NORMAL) {\n                    findBar.close();\n                  }\n                }\n\n                this.mTabBrowser.setTabTitle(this.mTab);\n\n                // Don't clear the favicon if this tab is in the pending\n                // state, as SessionStore will have set the icon for us even\n                // though we're pointed at an about:blank. Also don't clear it\n                // if onLocationChange was triggered by a pushState or a\n                // replaceState (bug 550565) or a hash change (bug 408415).\n                if (!this.mTab.hasAttribute(\"pending\") &&\n                    aWebProgress.isLoadingDocument &&\n                    !isSameDocument) {\n                  this.mBrowser.mIconURL = null;\n                }\n\n                let userContextId = this.mBrowser.getAttribute(\"usercontextid\") || 0;\n                if (this.mBrowser.registeredOpenURI) {\n                  this.mTabBrowser._unifiedComplete\n                                  .unregisterOpenPage(this.mBrowser.registeredOpenURI,\n                                                      userContextId);\n                  delete this.mBrowser.registeredOpenURI;\n                }\n                // Tabs in private windows aren't registered as \"Open\" so\n                // that they don't appear as switch-to-tab candidates.\n                if (!isBlankPageURL(aLocation.spec) &&\n                    (!PrivateBrowsingUtils.isWindowPrivate(window) ||\n                    PrivateBrowsingUtils.permanentPrivateBrowsing)) {\n                  this.mTabBrowser._unifiedComplete\n                                  .registerOpenPage(aLocation, userContextId);\n                  this.mBrowser.registeredOpenURI = aLocation;\n                }\n              }\n\n              if (!this.mBlank) {\n                this._callProgressListeners(\"onLocationChange\",\n                                            [aWebProgress, aRequest, aLocation,\n                                             aFlags]);\n              }\n\n              if (topLevel) {\n                this.mBrowser.lastURI = aLocation;\n                this.mBrowser.lastLocationChange = Date.now();\n              }\n            },\n\n            onStatusChange(aWebProgress, aRequest, aStatus, aMessage) {\n              if (this.mBlank)\n                return;\n\n              this._callProgressListeners(\"onStatusChange\",\n                                          [aWebProgress, aRequest, aStatus, aMessage]);\n\n              this.mMessage = aMessage;\n            },\n\n            onSecurityChange(aWebProgress, aRequest, aState) {\n              this._callProgressListeners(\"onSecurityChange\",\n                                          [aWebProgress, aRequest, aState]);\n            },\n\n            onRefreshAttempted(aWebProgress, aURI, aDelay, aSameURI) {\n              return this._callProgressListeners(\"onRefreshAttempted\",\n                                                 [aWebProgress, aURI, aDelay, aSameURI]);\n            },\n\n            QueryInterface(aIID) {\n              if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||\n                  aIID.equals(Components.interfaces.nsIWebProgressListener2) ||\n                  aIID.equals(Components.interfaces.nsISupportsWeakReference) ||\n                  aIID.equals(Components.interfaces.nsISupports))\n                return this;\n              throw Components.results.NS_NOINTERFACE;\n            }\n          });\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"serializationHelper\">\n        Cc[\"@mozilla.org/network/serialization-helper;1\"]\n          .getService(Ci.nsISerializationHelper);\n      </field>\n\n      <field name=\"mIconLoadingPrincipal\">\n        null\n      </field>\n\n      <method name=\"storeIcon\">\n        <parameter name=\"aBrowser\"/>\n        <parameter name=\"aURI\"/>\n        <parameter name=\"aLoadingPrincipal\"/>\n        <parameter name=\"aRequestContextID\"/>\n        <body>\n          <![CDATA[\n          try {\n            if (!(aURI instanceof Ci.nsIURI)) {\n              aURI = makeURI(aURI);\n            }\n            PlacesUIUtils.loadFavicon(aBrowser, aLoadingPrincipal, aURI, aRequestContextID);\n          } catch (ex) {\n            Components.utils.reportError(ex);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setIcon\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aURI\"/>\n        <parameter name=\"aLoadingPrincipal\"/>\n        <parameter name=\"aRequestContextID\"/>\n        <body>\n          <![CDATA[\n            let browser = this.getBrowserForTab(aTab);\n            browser.mIconURL = aURI instanceof Ci.nsIURI ? aURI.spec : aURI;\n            let loadingPrincipal = aLoadingPrincipal ||\n                                   Services.scriptSecurityManager.getSystemPrincipal();\n            let requestContextID = aRequestContextID || 0;\n            let sizedIconUrl = browser.mIconURL || \"\";\n            if (sizedIconUrl != aTab.getAttribute(\"image\")) {\n              if (sizedIconUrl) {\n                if (!browser.mIconLoadingPrincipal ||\n                    !browser.mIconLoadingPrincipal.equals(loadingPrincipal)) {\n                  aTab.setAttribute(\"iconloadingprincipal\",\n                    this.serializationHelper.serializeToString(loadingPrincipal));\n                  aTab.setAttribute(\"requestcontextid\", requestContextID);\n                  browser.mIconLoadingPrincipal = loadingPrincipal;\n                }\n                aTab.setAttribute(\"image\", sizedIconUrl);\n              } else {\n                aTab.removeAttribute(\"iconloadingprincipal\");\n                delete browser.mIconLoadingPrincipal;\n                aTab.removeAttribute(\"image\");\n              }\n              this._tabAttrModified(aTab, [\"image\"]);\n            }\n\n            this._callProgressListeners(browser, \"onLinkIconAvailable\", [browser.mIconURL]);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getIcon\">\n        <parameter name=\"aTab\"/>\n        <body>\n          <![CDATA[\n            let browser = aTab ? this.getBrowserForTab(aTab) : this.selectedBrowser;\n            return browser.mIconURL;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"setPageInfo\">\n        <parameter name=\"aURL\"/>\n        <parameter name=\"aDescription\"/>\n        <parameter name=\"aPreviewImage\"/>\n        <body>\n          <![CDATA[\n            if (aURL) {\n              let pageInfo = {url: aURL, description: aDescription, previewImageURL: aPreviewImage}\n              PlacesUtils.history.update(pageInfo).catch(Components.utils.reportError);\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"shouldLoadFavIcon\">\n        <parameter name=\"aURI\"/>\n        <body>\n          <![CDATA[\n            return (aURI &&\n                    Services.prefs.getBoolPref(\"browser.chrome.site_icons\") &&\n                    Services.prefs.getBoolPref(\"browser.chrome.favicons\") &&\n                    (\"schemeIs\" in aURI) && (aURI.schemeIs(\"http\") || aURI.schemeIs(\"https\")));\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"useDefaultIcon\">\n        <parameter name=\"aTab\"/>\n        <body>\n          <![CDATA[\n            let browser = this.getBrowserForTab(aTab);\n            let documentURI = browser.documentURI;\n            let requestContextID = browser.contentRequestContextID;\n            let loadingPrincipal = browser.contentPrincipal;\n            let icon = null;\n\n            if (browser.imageDocument) {\n              if (Services.prefs.getBoolPref(\"browser.chrome.site_icons\")) {\n                let sz = Services.prefs.getIntPref(\"browser.chrome.image_icons.max_size\");\n                if (browser.imageDocument.width <= sz &&\n                    browser.imageDocument.height <= sz) {\n                  // Don't try to store the icon in Places, regardless it would\n                  // be skipped (see Bug 403651).\n                  icon = browser.currentURI;\n                }\n              }\n            }\n\n            // Use documentURIObject in the check for shouldLoadFavIcon so that we\n            // do the right thing with about:-style error pages.  Bug 453442\n            if (!icon && this.shouldLoadFavIcon(documentURI)) {\n              let url = documentURI.prePath + \"/favicon.ico\";\n              if (!this.isFailedIcon(url)) {\n                icon = url;\n                this.storeIcon(browser, icon, loadingPrincipal, requestContextID);\n              }\n            }\n\n            this.setIcon(aTab, icon, loadingPrincipal, requestContextID);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"isFailedIcon\">\n        <parameter name=\"aURI\"/>\n        <body>\n          <![CDATA[\n            if (!(aURI instanceof Ci.nsIURI))\n              aURI = makeURI(aURI);\n            return PlacesUtils.favicons.isFailedFavicon(aURI);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getWindowTitleForBrowser\">\n        <parameter name=\"aBrowser\"/>\n        <body>\n          <![CDATA[\n            var newTitle = \"\";\n            var docElement = this.ownerDocument.documentElement;\n            var sep = docElement.getAttribute(\"titlemenuseparator\");\n            let tab = this.getTabForBrowser(aBrowser);\n            let docTitle;\n\n            if (tab._labelIsContentTitle) {\n              // Strip out any null bytes in the content title, since the\n              // underlying widget implementations of nsWindow::SetTitle pass\n              // null-terminated strings to system APIs.\n              docTitle = tab.getAttribute(\"label\").replace(/\\0/g, \"\");\n            }\n\n            if (!docTitle)\n              docTitle = docElement.getAttribute(\"titledefault\");\n\n            var modifier = docElement.getAttribute(\"titlemodifier\");\n            if (docTitle) {\n              newTitle += docElement.getAttribute(\"titlepreface\");\n              newTitle += docTitle;\n              if (modifier)\n                newTitle += sep;\n            }\n            newTitle += modifier;\n\n            // If location bar is hidden and the URL type supports a host,\n            // add the scheme and host to the title to prevent spoofing.\n            // XXX https://bugzilla.mozilla.org/show_bug.cgi?id=22183#c239\n            try {\n              if (docElement.getAttribute(\"chromehidden\").includes(\"location\")) {\n                var uri = this.mURIFixup.createExposableURI(\n                            aBrowser.currentURI);\n                if (uri.scheme == \"about\")\n                  newTitle = uri.spec + sep + newTitle;\n                else\n                  newTitle = uri.prePath + sep + newTitle;\n              }\n            } catch (e) {}\n\n            return newTitle;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"updateTitlebar\">\n        <body>\n          <![CDATA[\n            this.ownerDocument.title = this.getWindowTitleForBrowser(this.mCurrentBrowser);\n          ]]>\n        </body>\n      </method>\n\n      <!-- Holds a unique ID for the tab change that's currently being timed.\n           Used to make sure that multiple, rapid tab switches do not try to\n           create overlapping timers. -->\n      <field name=\"_tabSwitchID\">null</field>\n\n      <method name=\"updateCurrentBrowser\">\n        <parameter name=\"aForceUpdate\"/>\n        <body>\n          <![CDATA[\n            var newBrowser = this.getBrowserAtIndex(this.tabContainer.selectedIndex);\n            if (this.mCurrentBrowser == newBrowser && !aForceUpdate)\n              return;\n\n            if (!aForceUpdate) {\n              document.commandDispatcher.lock();\n\n              TelemetryStopwatch.start(\"FX_TAB_SWITCH_UPDATE_MS\");\n              if (!gMultiProcessBrowser) {\n                // old way of measuring tab paint which is not valid with e10s.\n                // Waiting until the next MozAfterPaint ensures that we capture\n                // the time it takes to paint, upload the textures to the compositor,\n                // and then composite.\n                if (this._tabSwitchID) {\n                  TelemetryStopwatch.cancel(\"FX_TAB_SWITCH_TOTAL_MS\");\n                }\n\n                let tabSwitchID = Symbol();\n\n                TelemetryStopwatch.start(\"FX_TAB_SWITCH_TOTAL_MS\");\n                this._tabSwitchID = tabSwitchID;\n\n                let onMozAfterPaint = () => {\n                  if (this._tabSwitchID === tabSwitchID) {\n                    TelemetryStopwatch.finish(\"FX_TAB_SWITCH_TOTAL_MS\");\n                    this._tabSwitchID = null;\n                  }\n                  window.removeEventListener(\"MozAfterPaint\", onMozAfterPaint);\n                }\n                window.addEventListener(\"MozAfterPaint\", onMozAfterPaint);\n              }\n            }\n\n            var oldTab = this.mCurrentTab;\n\n            // Preview mode should not reset the owner\n            if (!this._previewMode && !oldTab.selected)\n              oldTab.owner = null;\n\n            let lastRelatedTab = this._lastRelatedTabMap.get(oldTab);\n            if (lastRelatedTab) {\n              if (!lastRelatedTab.selected)\n                lastRelatedTab.owner = null;\n            }\n            this._lastRelatedTabMap = new WeakMap();\n\n            var oldBrowser = this.mCurrentBrowser;\n\n            if (!gMultiProcessBrowser) {\n              oldBrowser.removeAttribute(\"primary\");\n              oldBrowser.docShellIsActive = false;\n              newBrowser.setAttribute(\"primary\", \"true\");\n              newBrowser.docShellIsActive =\n                (window.windowState != window.STATE_MINIMIZED &&\n                 !window.isFullyOccluded);\n            }\n\n            var updateBlockedPopups = false;\n            if ((oldBrowser.blockedPopups && !newBrowser.blockedPopups) ||\n                (!oldBrowser.blockedPopups && newBrowser.blockedPopups))\n              updateBlockedPopups = true;\n\n            this.mCurrentBrowser = newBrowser;\n            this.mCurrentTab = this.tabContainer.selectedItem;\n            this.showTab(this.mCurrentTab);\n\n            gURLBar.setAttribute(\"switchingtabs\", \"true\");\n            window.addEventListener(\"MozAfterPaint\", function() {\n              gURLBar.removeAttribute(\"switchingtabs\");\n            }, {once: true});\n\n            this._appendStatusPanel();\n\n            if (updateBlockedPopups)\n              this.mCurrentBrowser.updateBlockedPopups();\n\n            // Update the URL bar.\n            var loc = this.mCurrentBrowser.currentURI;\n\n            var webProgress = this.mCurrentBrowser.webProgress;\n            var securityUI = this.mCurrentBrowser.securityUI;\n\n            this._callProgressListeners(null, \"onLocationChange\",\n                                        [webProgress, null, loc, 0], true,\n                                        false);\n\n            if (securityUI) {\n              // Include the true final argument to indicate that this event is\n              // simulated (instead of being observed by the webProgressListener).\n              this._callProgressListeners(null, \"onSecurityChange\",\n                                          [webProgress, null, securityUI.state, true],\n                                          true, false);\n            }\n\n            var listener = this._tabListeners.get(this.mCurrentTab);\n            if (listener && listener.mStateFlags) {\n              this._callProgressListeners(null, \"onUpdateCurrentBrowser\",\n                                          [listener.mStateFlags, listener.mStatus,\n                                           listener.mMessage, listener.mTotalProgress],\n                                          true, false);\n            }\n\n            if (!this._previewMode) {\n              this.mCurrentTab.updateLastAccessed();\n              this.mCurrentTab.removeAttribute(\"unread\");\n              oldTab.updateLastAccessed();\n\n              let oldFindBar = oldTab._findBar;\n              if (oldFindBar &&\n                  oldFindBar.findMode == oldFindBar.FIND_NORMAL &&\n                  !oldFindBar.hidden)\n                this._lastFindValue = oldFindBar._findField.value;\n\n              this.updateTitlebar();\n\n              this.mCurrentTab.removeAttribute(\"titlechanged\");\n              this.mCurrentTab.removeAttribute(\"attention\");\n\n              // The tab has been selected, it's not unselected anymore.\n              // (1) Call the current tab's finishUnselectedTabHoverTimer()\n              //     to save a telemetry record.\n              // (2) Call the current browser's unselectedTabHover() with false\n              //     to dispatch an event.\n              this.mCurrentTab.finishUnselectedTabHoverTimer();\n              this.mCurrentBrowser.unselectedTabHover(false);\n            }\n\n            // If the new tab is busy, and our current state is not busy, then\n            // we need to fire a start to all progress listeners.\n            const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;\n            if (this.mCurrentTab.hasAttribute(\"busy\") && !this.mIsBusy) {\n              this.mIsBusy = true;\n              this._callProgressListeners(null, \"onStateChange\",\n                                          [webProgress, null,\n                                           nsIWebProgressListener.STATE_START |\n                                           nsIWebProgressListener.STATE_IS_NETWORK, 0],\n                                          true, false);\n            }\n\n            // If the new tab is not busy, and our current state is busy, then\n            // we need to fire a stop to all progress listeners.\n            if (!this.mCurrentTab.hasAttribute(\"busy\") && this.mIsBusy) {\n              this.mIsBusy = false;\n              this._callProgressListeners(null, \"onStateChange\",\n                                          [webProgress, null,\n                                           nsIWebProgressListener.STATE_STOP |\n                                           nsIWebProgressListener.STATE_IS_NETWORK, 0],\n                                          true, false);\n            }\n\n            this._setCloseKeyState(!this.mCurrentTab.pinned);\n\n            // TabSelect events are suppressed during preview mode to avoid confusing extensions and other bits of code\n            // that might rely upon the other changes suppressed.\n            // Focus is suppressed in the event that the main browser window is minimized - focusing a tab would restore the window\n            if (!this._previewMode) {\n              // We've selected the new tab, so go ahead and notify listeners.\n              let event = new CustomEvent(\"TabSelect\", {\n                bubbles: true,\n                cancelable: false,\n                detail: {\n                  previousTab: oldTab\n                }\n              });\n              this.mCurrentTab.dispatchEvent(event);\n\n              this._tabAttrModified(oldTab, [\"selected\"]);\n              this._tabAttrModified(this.mCurrentTab, [\"selected\"]);\n\n              if (oldBrowser != newBrowser &&\n                  oldBrowser.getInPermitUnload) {\n                oldBrowser.getInPermitUnload(inPermitUnload => {\n                  if (!inPermitUnload) {\n                    return;\n                  }\n                  // Since the user is switching away from a tab that has\n                  // a beforeunload prompt active, we remove the prompt.\n                  // This prevents confusing user flows like the following:\n                  //   1. User attempts to close Firefox\n                  //   2. User switches tabs (ingoring a beforeunload prompt)\n                  //   3. User returns to tab, presses \"Leave page\"\n                  let promptBox = this.getTabModalPromptBox(oldBrowser);\n                  let prompts = promptBox.listPrompts();\n                  // There might not be any prompts here if the tab was closed\n                  // while in an onbeforeunload prompt, which will have\n                  // destroyed aforementioned prompt already, so check there's\n                  // something to remove, first:\n                  if (prompts.length) {\n                    // NB: This code assumes that the beforeunload prompt\n                    //     is the top-most prompt on the tab.\n                    prompts[prompts.length - 1].abortPrompt();\n                  }\n                });\n              }\n\n              if (!gMultiProcessBrowser) {\n                this._adjustFocusBeforeTabSwitch(oldTab, this.mCurrentTab);\n                this._adjustFocusAfterTabSwitch(this.mCurrentTab);\n              }\n            }\n\n            updateUserContextUIIndicator();\n            gIdentityHandler.updateSharingIndicator();\n\n            this.tabContainer._setPositionalAttributes();\n\n            if (!gMultiProcessBrowser) {\n              document.commandDispatcher.unlock();\n\n              let event = new CustomEvent(\"TabSwitchDone\", {\n                bubbles: true,\n                cancelable: true\n              });\n              this.dispatchEvent(event);\n            }\n\n            if (!aForceUpdate)\n              TelemetryStopwatch.finish(\"FX_TAB_SWITCH_UPDATE_MS\");\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_adjustFocusBeforeTabSwitch\">\n        <parameter name=\"oldTab\"/>\n        <parameter name=\"newTab\"/>\n        <body><![CDATA[\n          if (this._previewMode) {\n            return;\n          }\n\n          let oldBrowser = oldTab.linkedBrowser;\n          let newBrowser = newTab.linkedBrowser;\n\n          oldBrowser._urlbarFocused = (gURLBar && gURLBar.focused);\n\n          if (this.isFindBarInitialized(oldTab)) {\n            let findBar = this.getFindBar(oldTab);\n            oldTab._findBarFocused = (!findBar.hidden &&\n              findBar._findField.getAttribute(\"focused\") == \"true\");\n          }\n\n          let activeEl = document.activeElement;\n          // If focus is on the old tab, move it to the new tab.\n          if (activeEl == oldTab) {\n            newTab.focus();\n          } else if (gMultiProcessBrowser && activeEl != newBrowser && activeEl != newTab) {\n            // In e10s, if focus isn't already in the tabstrip or on the new browser,\n            // and the new browser's previous focus wasn't in the url bar but focus is\n            // there now, we need to adjust focus further.\n            let keepFocusOnUrlBar = newBrowser &&\n                                    newBrowser._urlbarFocused &&\n                                    gURLBar &&\n                                    gURLBar.focused;\n            if (!keepFocusOnUrlBar) {\n              // Clear focus so that _adjustFocusAfterTabSwitch can detect if\n              // some element has been focused and respect that.\n              document.activeElement.blur();\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_adjustFocusAfterTabSwitch\">\n        <parameter name=\"newTab\"/>\n        <body><![CDATA[\n        // Don't steal focus from the tab bar.\n        if (document.activeElement == newTab)\n          return;\n\n        let newBrowser = this.getBrowserForTab(newTab);\n\n        // If there's a tabmodal prompt showing, focus it.\n        if (newBrowser.hasAttribute(\"tabmodalPromptShowing\")) {\n          let XUL_NS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          let prompts = newBrowser.parentNode.getElementsByTagNameNS(XUL_NS, \"tabmodalprompt\");\n          let prompt = prompts[prompts.length - 1];\n          prompt.Dialog.setDefaultFocus();\n          return;\n        }\n\n        // Focus the location bar if it was previously focused for that tab.\n        // In full screen mode, only bother making the location bar visible\n        // if the tab is a blank one.\n        if (newBrowser._urlbarFocused && gURLBar) {\n          // Explicitly close the popup if the URL bar retains focus\n          gURLBar.closePopup();\n\n          // If the user happened to type into the URL bar for this browser\n          // by the time we got here, focusing will cause the text to be\n          // selected which could cause them to overwrite what they've\n          // already typed in.\n          if (gURLBar.focused && newBrowser.userTypedValue) {\n            return;\n          }\n\n          if (!window.fullScreen || isTabEmpty(newTab)) {\n            focusAndSelectUrlBar();\n            return;\n          }\n        }\n\n        // Focus the find bar if it was previously focused for that tab.\n        if (gFindBarInitialized && !gFindBar.hidden &&\n            this.selectedTab._findBarFocused) {\n          gFindBar._findField.focus();\n          return;\n        }\n\n        // Don't focus the content area if something has been focused after the\n        // tab switch was initiated.\n        if (gMultiProcessBrowser &&\n            document.activeElement != document.documentElement)\n          return;\n\n        // We're now committed to focusing the content area.\n        let fm = Services.focus;\n        let focusFlags = fm.FLAG_NOSCROLL;\n\n        if (!gMultiProcessBrowser) {\n          let newFocusedElement = fm.getFocusedElementForWindow(window.content, true, {});\n\n          // for anchors, use FLAG_SHOWRING so that it is clear what link was\n          // last clicked when switching back to that tab\n          if (newFocusedElement &&\n              (newFocusedElement instanceof HTMLAnchorElement ||\n               newFocusedElement.getAttributeNS(\"http://www.w3.org/1999/xlink\", \"type\") == \"simple\"))\n            focusFlags |= fm.FLAG_SHOWRING;\n        }\n\n        fm.setFocus(newBrowser, focusFlags);\n        ]]></body>\n      </method>\n\n      <method name=\"_tabAttrModified\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aChanged\"/>\n        <body><![CDATA[\n          if (aTab.closing)\n            return;\n\n          let event = new CustomEvent(\"TabAttrModified\", {\n            bubbles: true,\n            cancelable: false,\n            detail: {\n              changed: aChanged,\n            }\n          });\n          aTab.dispatchEvent(event);\n        ]]></body>\n      </method>\n\n      <method name=\"setBrowserSharing\">\n        <parameter name=\"aBrowser\"/>\n        <parameter name=\"aState\"/>\n        <body><![CDATA[\n          let tab = this.getTabForBrowser(aBrowser);\n          if (!tab)\n            return;\n\n          let sharing;\n          if (aState.screen) {\n            sharing = \"screen\";\n          } else if (aState.camera) {\n            sharing = \"camera\";\n          } else if (aState.microphone) {\n            sharing = \"microphone\";\n          }\n\n          if (sharing) {\n            tab.setAttribute(\"sharing\", sharing);\n            tab._sharingState = aState;\n          } else {\n            tab.removeAttribute(\"sharing\");\n            tab._sharingState = null;\n          }\n          this._tabAttrModified(tab, [\"sharing\"]);\n\n          if (aBrowser == this.mCurrentBrowser)\n            gIdentityHandler.updateSharingIndicator();\n        ]]></body>\n      </method>\n\n\n      <!-- TODO: remove after 57, once we know add-ons can no longer use it. -->\n      <method name=\"setTabTitleLoading\">\n        <parameter name=\"aTab\"/>\n        <body/>\n      </method>\n\n      <method name=\"setInitialTabTitle\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aTitle\"/>\n        <parameter name=\"aOptions\"/>\n        <body><![CDATA[\n          if (aTitle) {\n            if (!aTab.getAttribute(\"label\")) {\n              aTab._labelIsInitialTitle = true;\n            }\n\n            this._setTabLabel(aTab, aTitle, aOptions);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"setTabTitle\">\n        <parameter name=\"aTab\"/>\n        <body>\n          <![CDATA[\n            var browser = this.getBrowserForTab(aTab);\n            var title = browser.contentTitle;\n\n            // Don't replace an initially set label with the URL while the tab\n            // is loading.\n            if (aTab._labelIsInitialTitle) {\n              if (!title) {\n                return false;\n              }\n              delete aTab._labelIsInitialTitle;\n            }\n\n            let isContentTitle = false;\n            if (title) {\n              isContentTitle = true;\n            } else if (aTab.hasAttribute(\"customizemode\")) {\n              let brandBundle = document.getElementById(\"bundle_brand\");\n              let brandShortName = brandBundle.getString(\"brandShortName\");\n              title = gNavigatorBundle.getFormattedString(\"customizeMode.tabTitle\",\n                                                          [ brandShortName ]);\n              isContentTitle = true;\n            } else {\n              if (browser.currentURI.displaySpec) {\n                try {\n                  title = this.mURIFixup.createExposableURI(browser.currentURI).displaySpec;\n                } catch (ex) {\n                  title = browser.currentURI.displaySpec;\n                }\n              }\n\n              if (title && !isBlankPageURL(title)) {\n                // At this point, we now have a URI.\n                // Let's try to unescape it using a character set\n                // in case the URI is not ASCII.\n                try {\n                  var characterSet = browser.characterSet;\n                  const textToSubURI = Components.classes[\"@mozilla.org/intl/texttosuburi;1\"]\n                                                 .getService(Components.interfaces.nsITextToSubURI);\n                  title = textToSubURI.unEscapeNonAsciiURI(characterSet, title);\n                  // If it's a long data: URI that uses base64 encoding, truncate to\n                  // a reasonable length rather than trying to display the entire thing.\n                  // We can't shorten arbitrary URIs like this, as bidi etc might mean\n                  // we need the trailing characters for display. But a base64-encoded\n                  // data-URI is plain ASCII, so this is OK for tab-title display.\n                  // (See bug 1408854.)\n                  if (title.length > 500 && title.match(/^data:[^,]+;base64,/)) {\n                    title = title.substring(0, 500) + \"\\u2026\";\n                  }\n                } catch (ex) { /* Do nothing. */ }\n              } else {\n                // Still no title? Fall back to our untitled string.\n                title = gTabBrowserBundle.GetStringFromName(\"tabs.emptyTabTitle\");\n              }\n            }\n\n            return this._setTabLabel(aTab, title, { isContentTitle });\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_setTabLabel\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aLabel\"/>\n        <parameter name=\"aOptions\"/>\n        <body>\n          <![CDATA[\n            if (!aLabel) {\n              return false;\n            }\n\n            aTab._fullLabel = aLabel;\n\n            aOptions = aOptions || {};\n            if (!aOptions.isContentTitle) {\n              // Remove protocol and \"www.\"\n              if (!(\"_regex_shortenURLForTabLabel\" in this)) {\n                this._regex_shortenURLForTabLabel = /^[^:]+:\\/\\/(?:www\\.)?/;\n              }\n              aLabel = aLabel.replace(this._regex_shortenURLForTabLabel, \"\");\n            }\n\n            aTab._labelIsContentTitle = aOptions.isContentTitle;\n\n            if (aTab.getAttribute(\"label\") == aLabel) {\n              return false;\n            }\n\n            let dwu = window.QueryInterface(Ci.nsIInterfaceRequestor)\n                            .getInterface(Ci.nsIDOMWindowUtils);\n            let isRTL = dwu.getDirectionFromText(aLabel) == Ci.nsIDOMWindowUtils.DIRECTION_RTL;\n\n            aTab.setAttribute(\"label\", aLabel);\n            aTab.setAttribute(\"labeldirection\", isRTL ? \"rtl\" : \"ltr\");\n\n            // Dispatch TabAttrModified event unless we're setting the label\n            // before the TabOpen event was dispatched.\n            if (!aOptions.beforeTabOpen) {\n              this._tabAttrModified(aTab, [\"label\"]);\n            }\n\n            if (aTab.selected) {\n              this.updateTitlebar();\n            }\n\n            return true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"loadOneTab\">\n        <parameter name=\"aURI\"/>\n        <parameter name=\"aReferrerURI\"/>\n        <parameter name=\"aCharset\"/>\n        <parameter name=\"aPostData\"/>\n        <parameter name=\"aLoadInBackground\"/>\n        <parameter name=\"aAllowThirdPartyFixup\"/>\n        <body>\n          <![CDATA[\n            var aTriggeringPrincipal;\n            var aReferrerPolicy;\n            var aFromExternal;\n            var aRelatedToCurrent;\n            var aAllowMixedContent;\n            var aSkipAnimation;\n            var aForceNotRemote;\n            var aPreferredRemoteType;\n            var aNoReferrer;\n            var aUserContextId;\n            var aSameProcessAsFrameLoader;\n            var aOriginPrincipal;\n            var aOpener;\n            var aOpenerBrowser;\n            var aIsPrerendered;\n            var aCreateLazyBrowser;\n            var aNextTabParentId;\n            var aFocusUrlBar;\n            var aName;\n            if (arguments.length == 2 &&\n                typeof arguments[1] == \"object\" &&\n                !(arguments[1] instanceof Ci.nsIURI)) {\n              let params = arguments[1];\n              aTriggeringPrincipal      = params.triggeringPrincipal\n              aReferrerURI              = params.referrerURI;\n              aReferrerPolicy           = params.referrerPolicy;\n              aCharset                  = params.charset;\n              aPostData                 = params.postData;\n              aLoadInBackground         = params.inBackground;\n              aAllowThirdPartyFixup     = params.allowThirdPartyFixup;\n              aFromExternal             = params.fromExternal;\n              aRelatedToCurrent         = params.relatedToCurrent;\n              aAllowMixedContent        = params.allowMixedContent;\n              aSkipAnimation            = params.skipAnimation;\n              aForceNotRemote           = params.forceNotRemote;\n              aPreferredRemoteType      = params.preferredRemoteType;\n              aNoReferrer               = params.noReferrer;\n              aUserContextId            = params.userContextId;\n              aSameProcessAsFrameLoader = params.sameProcessAsFrameLoader;\n              aOriginPrincipal          = params.originPrincipal;\n              aOpener                   = params.opener;\n              aOpenerBrowser            = params.openerBrowser;\n              aIsPrerendered            = params.isPrerendered;\n              aCreateLazyBrowser        = params.createLazyBrowser;\n              aNextTabParentId          = params.nextTabParentId;\n              aFocusUrlBar              = params.focusUrlBar;\n              aName                     = params.name;\n            }\n\n            var bgLoad = (aLoadInBackground != null) ? aLoadInBackground :\n                         Services.prefs.getBoolPref(\"browser.tabs.loadInBackground\");\n            var owner = bgLoad ? null : this.selectedTab;\n\n            var tab = this.addTab(aURI, {\n                                  triggeringPrincipal: aTriggeringPrincipal,\n                                  referrerURI: aReferrerURI,\n                                  referrerPolicy: aReferrerPolicy,\n                                  charset: aCharset,\n                                  postData: aPostData,\n                                  ownerTab: owner,\n                                  allowThirdPartyFixup: aAllowThirdPartyFixup,\n                                  fromExternal: aFromExternal,\n                                  relatedToCurrent: aRelatedToCurrent,\n                                  skipAnimation: aSkipAnimation,\n                                  allowMixedContent: aAllowMixedContent,\n                                  forceNotRemote: aForceNotRemote,\n                                  createLazyBrowser: aCreateLazyBrowser,\n                                  preferredRemoteType: aPreferredRemoteType,\n                                  noReferrer: aNoReferrer,\n                                  userContextId: aUserContextId,\n                                  originPrincipal: aOriginPrincipal,\n                                  sameProcessAsFrameLoader: aSameProcessAsFrameLoader,\n                                  opener: aOpener,\n                                  openerBrowser: aOpenerBrowser,\n                                  isPrerendered: aIsPrerendered,\n                                  nextTabParentId: aNextTabParentId,\n                                  focusUrlBar: aFocusUrlBar,\n                                  name: aName });\n            if (!bgLoad)\n              this.selectedTab = tab;\n\n            return tab;\n         ]]>\n        </body>\n      </method>\n\n      <method name=\"loadTabs\">\n        <parameter name=\"aURIs\"/>\n        <parameter name=\"aLoadInBackground\"/>\n        <parameter name=\"aReplace\"/>\n        <body><![CDATA[\n          let aTriggeringPrincipal;\n          let aAllowThirdPartyFixup;\n          let aTargetTab;\n          let aNewIndex = -1;\n          let aPostDatas = [];\n          let aUserContextId;\n          if (arguments.length == 2 &&\n              typeof arguments[1] == \"object\") {\n            let params = arguments[1];\n            aLoadInBackground     = params.inBackground;\n            aReplace              = params.replace;\n            aAllowThirdPartyFixup = params.allowThirdPartyFixup;\n            aTargetTab            = params.targetTab;\n            aNewIndex             = typeof params.newIndex === \"number\" ?\n                                    params.newIndex : aNewIndex;\n            aPostDatas            = params.postDatas || aPostDatas;\n            aUserContextId        = params.userContextId;\n            aTriggeringPrincipal  = params.triggeringPrincipal;\n          }\n\n          if (!aURIs.length)\n            return;\n\n          // The tab selected after this new tab is closed (i.e. the new tab's\n          // \"owner\") is the next adjacent tab (i.e. not the previously viewed tab)\n          // when several urls are opened here (i.e. closing the first should select\n          // the next of many URLs opened) or if the pref to have UI links opened in\n          // the background is set (i.e. the link is not being opened modally)\n          //\n          // i.e.\n          //    Number of URLs    Load UI Links in BG       Focus Last Viewed?\n          //    == 1              false                     YES\n          //    == 1              true                      NO\n          //    > 1               false/true                NO\n          var multiple = aURIs.length > 1;\n          var owner = multiple || aLoadInBackground ? null : this.selectedTab;\n          var firstTabAdded = null;\n          var targetTabIndex = -1;\n\n          if (aReplace) {\n            let browser;\n            if (aTargetTab) {\n              browser = this.getBrowserForTab(aTargetTab);\n              targetTabIndex = aTargetTab._tPos;\n            } else {\n              browser = this.mCurrentBrowser;\n              targetTabIndex = this.tabContainer.selectedIndex;\n            }\n            let flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;\n            if (aAllowThirdPartyFixup) {\n              flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP |\n                       Ci.nsIWebNavigation.LOAD_FLAGS_FIXUP_SCHEME_TYPOS;\n            }\n            try {\n              browser.loadURIWithFlags(aURIs[0], {\n                flags, postData: aPostDatas[0],\n                triggeringPrincipal: aTriggeringPrincipal,\n              });\n            } catch (e) {\n              // Ignore failure in case a URI is wrong, so we can continue\n              // opening the next ones.\n            }\n          } else {\n            firstTabAdded = this.addTab(aURIs[0], {\n              ownerTab: owner,\n              skipAnimation: multiple,\n              allowThirdPartyFixup: aAllowThirdPartyFixup,\n              postData: aPostDatas[0],\n              userContextId: aUserContextId,\n              triggeringPrincipal: aTriggeringPrincipal,\n            });\n            if (aNewIndex !== -1) {\n              this.moveTabTo(firstTabAdded, aNewIndex);\n              targetTabIndex = firstTabAdded._tPos;\n            }\n          }\n\n          let tabNum = targetTabIndex;\n          for (let i = 1; i < aURIs.length; ++i) {\n            let tab = this.addTab(aURIs[i], {\n              skipAnimation: true,\n              allowThirdPartyFixup: aAllowThirdPartyFixup,\n              postData: aPostDatas[i],\n              userContextId: aUserContextId,\n              triggeringPrincipal: aTriggeringPrincipal,\n            });\n            if (targetTabIndex !== -1)\n              this.moveTabTo(tab, ++tabNum);\n          }\n\n          if (firstTabAdded && !aLoadInBackground) {\n            this.selectedTab = firstTabAdded;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"updateBrowserRemoteness\">\n        <parameter name=\"aBrowser\"/>\n        <parameter name=\"aShouldBeRemote\"/>\n        <parameter name=\"aOptions\"/>\n        <body>\n          <![CDATA[\n            aOptions = aOptions || {};\n            let isRemote = aBrowser.getAttribute(\"remote\") == \"true\";\n\n            if (!gMultiProcessBrowser && aShouldBeRemote) {\n              throw new Error(\"Cannot switch to remote browser in a window \" +\n                              \"without the remote tabs load context.\");\n            }\n\n            // Default values for remoteType\n            if (!aOptions.remoteType) {\n              aOptions.remoteType = aShouldBeRemote ? E10SUtils.DEFAULT_REMOTE_TYPE : E10SUtils.NOT_REMOTE;\n            }\n\n            // If we are passed an opener, we must be making the browser non-remote, and\n            // if the browser is _currently_ non-remote, we need the openers to match,\n            // because it is already too late to change it.\n            if (aOptions.opener) {\n              if (aShouldBeRemote) {\n                throw new Error(\"Cannot set an opener on a browser which should be remote!\");\n              }\n              if (!isRemote && aBrowser.contentWindow.opener != aOptions.opener) {\n                throw new Error(\"Cannot change opener on an already non-remote browser!\");\n              }\n            }\n\n            // Abort if we're not going to change anything\n            let currentRemoteType = aBrowser.getAttribute(\"remoteType\");\n            if (isRemote == aShouldBeRemote && !aOptions.newFrameloader &&\n                (!isRemote || currentRemoteType == aOptions.remoteType)) {\n              return false;\n            }\n\n            let tab = this.getTabForBrowser(aBrowser);\n            // aBrowser needs to be inserted now if it hasn't been already.\n            this._insertBrowser(tab);\n\n            let evt = document.createEvent(\"Events\");\n            evt.initEvent(\"BeforeTabRemotenessChange\", true, false);\n            tab.dispatchEvent(evt);\n\n            let wasActive = document.activeElement == aBrowser;\n\n            // Unmap the old outerWindowID.\n            this._outerWindowIDBrowserMap.delete(aBrowser.outerWindowID);\n\n            // Unhook our progress listener.\n            let filter = this._tabFilters.get(tab);\n            let listener = this._tabListeners.get(tab);\n            aBrowser.webProgress.removeProgressListener(filter);\n            filter.removeProgressListener(listener);\n\n            // We'll be creating a new listener, so destroy the old one.\n            listener.destroy();\n\n            let oldUserTypedValue = aBrowser.userTypedValue;\n            let hadStartedLoad = aBrowser.didStartLoadSinceLastUserTyping();\n\n            // Make sure the browser is destroyed so it unregisters from observer notifications\n            aBrowser.destroy();\n\n            // Make sure to restore the original droppedLinkHandler and\n            // sameProcessAsFrameLoader.\n            let droppedLinkHandler = aBrowser.droppedLinkHandler;\n            let sameProcessAsFrameLoader = aBrowser.sameProcessAsFrameLoader;\n\n            // Change the \"remote\" attribute.\n            let parent = aBrowser.parentNode;\n            parent.removeChild(aBrowser);\n            if (aShouldBeRemote) {\n              aBrowser.setAttribute(\"remote\", \"true\");\n              aBrowser.setAttribute(\"remoteType\", aOptions.remoteType);\n            } else {\n              aBrowser.setAttribute(\"remote\", \"false\");\n              aBrowser.removeAttribute(\"remoteType\");\n            }\n\n            // NB: This works with the hack in the browser constructor that\n            // turns this normal property into a field.\n            if (aOptions.sameProcessAsFrameLoader) {\n              // Always set sameProcessAsFrameLoader when passed in aOptions.\n              aBrowser.sameProcessAsFrameLoader = aOptions.sameProcessAsFrameLoader;\n            } else if (!aShouldBeRemote || currentRemoteType == aOptions.remoteType) {\n              // Only copy existing sameProcessAsFrameLoader when not switching\n              // remote type otherwise it would stop the switch.\n              aBrowser.sameProcessAsFrameLoader = sameProcessAsFrameLoader;\n            }\n\n            if (aOptions.opener) {\n              // Set the opener window on the browser, such that when the frame\n              // loader is created the opener is set correctly.\n              aBrowser.presetOpenerWindow(aOptions.opener);\n            }\n\n            parent.appendChild(aBrowser);\n\n            aBrowser.userTypedValue = oldUserTypedValue;\n            if (hadStartedLoad) {\n              aBrowser.urlbarChangeTracker.startedLoad();\n            }\n\n            aBrowser.droppedLinkHandler = droppedLinkHandler;\n\n            // Switching a browser's remoteness will create a new frameLoader.\n            // As frameLoaders start out with an active docShell we have to\n            // deactivate it if this is not the selected tab's browser or the\n            // browser window is minimized.\n            aBrowser.docShellIsActive = this.shouldActivateDocShell(aBrowser);\n\n            // Create a new tab progress listener for the new browser we just injected,\n            // since tab progress listeners have logic for handling the initial about:blank\n            // load\n            listener = this.mTabProgressListener(tab, aBrowser, true, false);\n            this._tabListeners.set(tab, listener);\n            filter.addProgressListener(listener, Ci.nsIWebProgress.NOTIFY_ALL);\n\n            // Restore the progress listener.\n            aBrowser.webProgress.addProgressListener(filter, Ci.nsIWebProgress.NOTIFY_ALL);\n\n            // Restore the securityUI state.\n            let securityUI = aBrowser.securityUI;\n            let state = securityUI ? securityUI.state\n                                   : Ci.nsIWebProgressListener.STATE_IS_INSECURE;\n            // Include the true final argument to indicate that this event is\n            // simulated (instead of being observed by the webProgressListener).\n            this._callProgressListeners(aBrowser, \"onSecurityChange\",\n                                        [aBrowser.webProgress, null, state, true],\n                                        true, false);\n\n            if (aShouldBeRemote) {\n              // Switching the browser to be remote will connect to a new child\n              // process so the browser can no longer be considered to be\n              // crashed.\n              tab.removeAttribute(\"crashed\");\n            } else {\n              aBrowser.messageManager.sendAsyncMessage(\"Browser:AppTab\", { isAppTab: tab.pinned })\n\n              // Register the new outerWindowID.\n              this._outerWindowIDBrowserMap.set(aBrowser.outerWindowID, aBrowser);\n            }\n\n            if (wasActive)\n              aBrowser.focus();\n\n            // If the findbar has been initialised, reset its browser reference.\n            if (this.isFindBarInitialized(tab)) {\n              this.getFindBar(tab).browser = aBrowser;\n            }\n\n            evt = document.createEvent(\"Events\");\n            evt.initEvent(\"TabRemotenessChange\", true, false);\n            tab.dispatchEvent(evt);\n\n            return true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"updateBrowserRemotenessByURL\">\n        <parameter name=\"aBrowser\"/>\n        <parameter name=\"aURL\"/>\n        <parameter name=\"aOptions\"/>\n        <body>\n          <![CDATA[\n            aOptions = aOptions || {};\n\n            if (!gMultiProcessBrowser)\n              return this.updateBrowserRemoteness(aBrowser, false);\n\n            let currentRemoteType = aBrowser.getAttribute(\"remoteType\") || null;\n\n            aOptions.remoteType =\n              E10SUtils.getRemoteTypeForURI(aURL,\n                                            gMultiProcessBrowser,\n                                            currentRemoteType,\n                                            aBrowser.currentURI);\n\n            // If this URL can't load in the current browser then flip it to the\n            // correct type.\n            if (currentRemoteType != aOptions.remoteType ||\n                aOptions.newFrameloader) {\n              let remote = aOptions.remoteType != E10SUtils.NOT_REMOTE;\n              return this.updateBrowserRemoteness(aBrowser, remote, aOptions);\n            }\n\n            return false;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removePreloadedBrowser\">\n        <body>\n          <![CDATA[\n            if (!this._isPreloadingEnabled()) {\n              return;\n            }\n\n            let browser = this._getPreloadedBrowser();\n\n            if (browser) {\n              browser.remove();\n            }\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"_preloadedBrowser\">null</field>\n      <method name=\"_getPreloadedBrowser\">\n        <body>\n          <![CDATA[\n            if (!this._isPreloadingEnabled()) {\n              return null;\n            }\n\n            // The preloaded browser might be null.\n            let browser = this._preloadedBrowser;\n\n            // Consume the browser.\n            this._preloadedBrowser = null;\n\n            // Attach the nsIFormFillController now that we know the browser\n            // will be used. If we do that before and the preloaded browser\n            // won't be consumed until shutdown then we leak a docShell.\n            // Also, we do not need to take care of attaching nsIFormFillControllers\n            // in the case that the browser is remote, as remote browsers take\n            // care of that themselves.\n            if (browser && this.hasAttribute(\"autocompletepopup\")) {\n              browser.setAttribute(\"autocompletepopup\", this.getAttribute(\"autocompletepopup\"));\n            }\n\n            return browser;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_isPreloadingEnabled\">\n        <body>\n          <![CDATA[\n            // Preloading for the newtab page is enabled when the pref is true\n            // and the URL is \"about:newtab\". We do not support preloading for\n            // custom newtab URLs.\n            return Services.prefs.getBoolPref(\"browser.newtab.preload\") &&\n                   !aboutNewTabService.overridden;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_createPreloadBrowser\">\n        <body>\n          <![CDATA[\n            // Do nothing if we have a preloaded browser already\n            // or preloading of newtab pages is disabled.\n            if (this._preloadedBrowser || !this._isPreloadingEnabled()) {\n              return;\n            }\n\n            let remoteType =\n              E10SUtils.getRemoteTypeForURI(BROWSER_NEW_TAB_URL,\n                                            gMultiProcessBrowser);\n            let browser = this._createBrowser({isPreloadBrowser: true, remoteType});\n            this._preloadedBrowser = browser;\n\n            let notificationbox = this.getNotificationBox(browser);\n            this.mPanelContainer.appendChild(notificationbox);\n\n            if (remoteType != E10SUtils.NOT_REMOTE) {\n              // For remote browsers, we need to make sure that the webProgress is\n              // instantiated, otherwise the parent won't get informed about the state\n              // of the preloaded browser until it gets attached to a tab.\n              browser.webProgress;\n            }\n\n            browser.loadURI(BROWSER_NEW_TAB_URL);\n            browser.docShellIsActive = false;\n\n            // Make sure the preloaded browser is loaded with desired zoom level\n            let tabURI = Services.io.newURI(BROWSER_NEW_TAB_URL);\n            FullZoom.onLocationChange(tabURI, false, browser);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_createBrowser\">\n        <parameter name=\"aParams\"/>\n        <body>\n          <![CDATA[\n            // Supported parameters:\n            // userContextId, remote, remoteType, isPreloadBrowser,\n            // uriIsAboutBlank, sameProcessAsFrameLoader, isPrerendered\n\n            const NS_XUL = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\n            let b = document.createElementNS(NS_XUL, \"browser\");\n            b.permanentKey = {};\n            b.setAttribute(\"type\", \"content\");\n            b.setAttribute(\"message\", \"true\");\n            b.setAttribute(\"messagemanagergroup\", \"browsers\");\n            b.setAttribute(\"contextmenu\", this.getAttribute(\"contentcontextmenu\"));\n            b.setAttribute(\"tooltip\", this.getAttribute(\"contenttooltip\"));\n\n            if (aParams.isPrerendered) {\n              b.setAttribute(\"prerendered\", \"true\");\n            }\n\n            if (aParams.userContextId) {\n              b.setAttribute(\"usercontextid\", aParams.userContextId);\n            }\n\n            // remote parameter used by some addons, use default in this case.\n            if (aParams.remote && !aParams.remoteType) {\n              aParams.remoteType = E10SUtils.DEFAULT_REMOTE_TYPE;\n            }\n\n            if (aParams.remoteType) {\n              b.setAttribute(\"remoteType\", aParams.remoteType);\n              b.setAttribute(\"remote\", \"true\");\n            }\n\n            if (aParams.openerWindow) {\n              if (aParams.remoteType) {\n                throw new Error(\"Cannot set opener window on a remote browser!\");\n              }\n              b.presetOpenerWindow(aParams.openerWindow);\n            }\n\n            if (!aParams.isPreloadBrowser && this.hasAttribute(\"autocompletepopup\")) {\n              b.setAttribute(\"autocompletepopup\", this.getAttribute(\"autocompletepopup\"));\n            }\n\n            if (aParams.isPreloadBrowser) {\n              b.setAttribute(\"isPreloadBrowser\", \"true\");\n            }\n\n            if (this.hasAttribute(\"selectmenulist\"))\n              b.setAttribute(\"selectmenulist\", this.getAttribute(\"selectmenulist\"));\n\n            if (this.hasAttribute(\"datetimepicker\")) {\n              b.setAttribute(\"datetimepicker\", this.getAttribute(\"datetimepicker\"));\n            }\n\n            b.setAttribute(\"autoscrollpopup\", this._autoScrollPopup.id);\n\n            if (aParams.nextTabParentId) {\n              if (!aParams.remoteType) {\n                throw new Error(\"Cannot have nextTabParentId without a remoteType\");\n              }\n              // Gecko is going to read this attribute and use it.\n              b.setAttribute(\"nextTabParentId\", aParams.nextTabParentId.toString());\n            }\n\n            if (aParams.sameProcessAsFrameLoader) {\n              b.sameProcessAsFrameLoader = aParams.sameProcessAsFrameLoader;\n            }\n\n            // This will be used by gecko to control the name of the opened\n            // window.\n            if (aParams.name) {\n              // XXX: The `name` property is special in HTML and XUL. Should\n              // we use a different attribute name for this?\n              b.setAttribute(\"name\", aParams.name);\n            }\n\n            // Create the browserStack container\n            var stack = document.createElementNS(NS_XUL, \"stack\");\n            stack.className = \"browserStack\";\n            stack.appendChild(b);\n            stack.setAttribute(\"flex\", \"1\");\n\n            // Create the browserContainer\n            var browserContainer = document.createElementNS(NS_XUL, \"vbox\");\n            browserContainer.className = \"browserContainer\";\n            browserContainer.appendChild(stack);\n            browserContainer.setAttribute(\"flex\", \"1\");\n\n            // Create the sidebar container\n            var browserSidebarContainer = document.createElementNS(NS_XUL,\n                                                                   \"hbox\");\n            browserSidebarContainer.className = \"browserSidebarContainer\";\n            browserSidebarContainer.appendChild(browserContainer);\n            browserSidebarContainer.setAttribute(\"flex\", \"1\");\n\n            // Add the Message and the Browser to the box\n            var notificationbox = document.createElementNS(NS_XUL,\n                                                           \"notificationbox\");\n            notificationbox.setAttribute(\"flex\", \"1\");\n            notificationbox.setAttribute(\"notificationside\", \"top\");\n            notificationbox.appendChild(browserSidebarContainer);\n\n            // Prevent the superfluous initial load of a blank document\n            // if we're going to load something other than about:blank.\n            if (!aParams.uriIsAboutBlank) {\n              b.setAttribute(\"nodefaultsrc\", \"true\");\n            }\n\n            return b;\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        `_createLazyBrowser` will define properties on the unbound lazy browser\n        which correspond to properties defined in XBL which will be bound to\n        the browser when it is inserted into the document.  If any of these\n        properties are accessed by consumers, `_insertBrowser` is called and\n        the browser is inserted to ensure that things don't break.  This list\n        provides the names of properties that may be called while the browser\n        is in its unbound (lazy) state.\n      -->\n      <field name=\"_browserBindingProperties\">[\n        \"canGoBack\", \"canGoForward\", \"goBack\", \"goForward\", \"permitUnload\",\n        \"reload\", \"reloadWithFlags\", \"stop\", \"loadURI\", \"loadURIWithFlags\",\n        \"goHome\", \"homePage\", \"gotoIndex\", \"currentURI\", \"documentURI\",\n        \"preferences\", \"imageDocument\", \"isRemoteBrowser\", \"messageManager\",\n        \"getTabBrowser\", \"finder\", \"fastFind\", \"sessionHistory\", \"contentTitle\",\n        \"characterSet\", \"fullZoom\", \"textZoom\", \"webProgress\",\n        \"addProgressListener\", \"removeProgressListener\", \"audioPlaybackStarted\",\n        \"audioPlaybackStopped\", \"pauseMedia\", \"stopMedia\",\n        \"resumeMedia\", \"mute\", \"unmute\", \"blockedPopups\", \"lastURI\",\n        \"purgeSessionHistory\", \"stopScroll\", \"startScroll\",\n        \"userTypedValue\", \"userTypedClear\", \"mediaBlocked\",\n        \"didStartLoadSinceLastUserTyping\"\n      ]</field>\n\n      <method name=\"_createLazyBrowser\">\n        <parameter name=\"aTab\"/>\n        <body>\n          <![CDATA[\n            let browser = aTab.linkedBrowser;\n\n            let names = this._browserBindingProperties;\n\n            for (let i = 0; i < names.length; i++) {\n              let name = names[i];\n              let getter;\n              let setter;\n              switch (name) {\n                case \"audioMuted\":\n                  getter = () => false;\n                  break;\n                case \"contentTitle\":\n                  getter = () => SessionStore.getLazyTabValue(aTab, \"title\");\n                  break;\n                case \"currentURI\":\n                  getter = () => {\n                    let url = SessionStore.getLazyTabValue(aTab, \"url\");\n                    return Services.io.newURI(url);\n                  };\n                  break;\n                case \"didStartLoadSinceLastUserTyping\":\n                  getter = () => () => false;\n                  break;\n                case \"fullZoom\":\n                case \"textZoom\":\n                  getter = () => 1;\n                  break;\n                case \"getTabBrowser\":\n                  getter = () => () => this;\n                  break;\n                case \"isRemoteBrowser\":\n                  getter = () => browser.getAttribute(\"remote\") == \"true\";\n                  break;\n                case \"permitUnload\":\n                  getter = () => () => ({ permitUnload: true, timedOut: false });\n                  break;\n                case \"reload\":\n                case \"reloadWithFlags\":\n                  getter = () =>\n                    params => {\n                      // Wait for load handler to be instantiated before\n                      // initializing the reload.\n                      aTab.addEventListener(\"SSTabRestoring\", () => {\n                        browser[name](params);\n                      }, { once: true });\n                      gBrowser._insertBrowser(aTab);\n                    };\n                  break;\n                case \"resumeMedia\":\n                  getter = () =>\n                    () => {\n                      // No need to insert a browser, so we just call the browser's\n                      // method.\n                      aTab.addEventListener(\"SSTabRestoring\", () => {\n                        browser[name]();\n                      }, { once: true });\n                    };\n                  break;\n                case \"userTypedValue\":\n                case \"userTypedClear\":\n                case \"mediaBlocked\":\n                  getter = () => SessionStore.getLazyTabValue(aTab, name);\n                  break;\n                default:\n                  getter = () => {\n                    if (AppConstants.NIGHTLY_BUILD) {\n                      let message =\n                        `[bug 1345098] Lazy browser prematurely inserted via '${name}' property access:\\n`\n                      console.log(message + new Error().stack);\n                    }\n                    this._insertBrowser(aTab);\n                    return browser[name];\n                  };\n                  setter = value => {\n                    if (AppConstants.NIGHTLY_BUILD) {\n                      let message =\n                        `[bug 1345098] Lazy browser prematurely inserted via '${name}' property access:\\n`\n                      console.log(message + new Error().stack);\n                    }\n                    this._insertBrowser(aTab);\n                    return browser[name] = value;\n                  };\n              }\n              Object.defineProperty(browser, name, {\n                get: getter,\n                set: setter,\n                configurable: true,\n                enumerable: true\n              });\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_insertBrowser\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aInsertedOnTabCreation\"/>\n        <body>\n          <![CDATA[\n            \"use strict\";\n\n            // If browser is already inserted or window is closed don't do anything.\n            if (aTab.linkedPanel || window.closed) {\n              return;\n            }\n\n            let browser = aTab.linkedBrowser;\n\n            // If browser is a lazy browser, delete the substitute properties.\n            if (this._browserBindingProperties[0] in browser) {\n              for (let name of this._browserBindingProperties) {\n                delete browser[name];\n              }\n            }\n\n            let { uriIsAboutBlank, remoteType, usingPreloadedContent } =\n                    aTab._browserParams;\n            delete aTab._browserParams;\n\n            let notificationbox = this.getNotificationBox(browser);\n            let uniqueId = this._generateUniquePanelID();\n            notificationbox.id = uniqueId;\n            aTab.linkedPanel = uniqueId;\n\n            // Inject the <browser> into the DOM if necessary.\n            if (!notificationbox.parentNode) {\n              // NB: this appendChild call causes us to run constructors for the\n              // browser element, which fires off a bunch of notifications. Some\n              // of those notifications can cause code to run that inspects our\n              // state, so it is important that the tab element is fully\n              // initialized by this point.\n              this.mPanelContainer.appendChild(notificationbox);\n            }\n\n            // wire up a progress listener for the new browser object.\n            let tabListener = this.mTabProgressListener(aTab, browser, uriIsAboutBlank, usingPreloadedContent);\n            const filter = Cc[\"@mozilla.org/appshell/component/browser-status-filter;1\"]\n                                     .createInstance(Ci.nsIWebProgress);\n            filter.addProgressListener(tabListener, Ci.nsIWebProgress.NOTIFY_ALL);\n            browser.webProgress.addProgressListener(filter, Ci.nsIWebProgress.NOTIFY_ALL);\n            this._tabListeners.set(aTab, tabListener);\n            this._tabFilters.set(aTab, filter);\n\n            browser.droppedLinkHandler = handleDroppedLink;\n\n            // We start our browsers out as inactive, and then maintain\n            // activeness in the tab switcher.\n            browser.docShellIsActive = false;\n\n            // When addTab() is called with an URL that is not \"about:blank\" we\n            // set the \"nodefaultsrc\" attribute that prevents a frameLoader\n            // from being created as soon as the linked <browser> is inserted\n            // into the DOM. We thus have to register the new outerWindowID\n            // for non-remote browsers after we have called browser.loadURI().\n            if (remoteType == E10SUtils.NOT_REMOTE) {\n              this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);\n            }\n\n            var evt = new CustomEvent(\"TabBrowserInserted\",\n              { bubbles: true, detail: { insertedOnTabCreation: aInsertedOnTabCreation } });\n            aTab.dispatchEvent(evt);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"discardBrowser\">\n        <parameter name=\"aBrowser\"/>\n        <body>\n          <![CDATA[\n            \"use strict\";\n\n            let tab = this.getTabForBrowser(aBrowser);\n\n            if (!tab ||\n                tab.selected ||\n                tab.closing ||\n                this._windowIsClosing ||\n                !aBrowser.isConnected ||\n                !aBrowser.isRemoteBrowser ||\n                aBrowser.frameLoader.tabParent.hasBeforeUnload) {\n              return;\n            }\n\n            // Set browser parameters for when browser is restored.  Also remove\n            // listeners and set up lazy restore data in SessionStore. This must\n            // be done before aBrowser is destroyed and removed from the document.\n            tab._browserParams = { uriIsAboutBlank: aBrowser.currentURI.spec == \"about:blank\",\n                                   remoteType: aBrowser.remoteType,\n                                   usingPreloadedContent: false };\n\n            SessionStore.resetBrowserToLazyState(tab);\n\n            this._outerWindowIDBrowserMap.delete(aBrowser.outerWindowID);\n\n            // Remove the tab's filter and progress listener.\n            let filter = this._tabFilters.get(tab);\n            let listener = this._tabListeners.get(tab);\n            aBrowser.webProgress.removeProgressListener(filter);\n            filter.removeProgressListener(listener);\n            listener.destroy();\n\n            this._tabListeners.delete(tab);\n            this._tabFilters.delete(tab);\n\n            aBrowser.destroy();\n\n            let notificationbox = this.getNotificationBox(aBrowser);\n            this.mPanelContainer.removeChild(notificationbox);\n            tab.removeAttribute(\"linkedpanel\");\n\n            this._createLazyBrowser(tab);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"addTab\">\n        <parameter name=\"aURI\"/>\n        <parameter name=\"aReferrerURI\"/>\n        <parameter name=\"aCharset\"/>\n        <parameter name=\"aPostData\"/>\n        <parameter name=\"aOwner\"/>\n        <parameter name=\"aAllowThirdPartyFixup\"/>\n        <body>\n          <![CDATA[\n            \"use strict\";\n\n            const NS_XUL = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n            var aTriggeringPrincipal;\n            var aReferrerPolicy;\n            var aFromExternal;\n            var aRelatedToCurrent;\n            var aSkipAnimation;\n            var aAllowMixedContent;\n            var aForceNotRemote;\n            var aPreferredRemoteType;\n            var aNoReferrer;\n            var aUserContextId;\n            var aEventDetail;\n            var aSameProcessAsFrameLoader;\n            var aOriginPrincipal;\n            var aDisallowInheritPrincipal;\n            var aOpener;\n            var aOpenerBrowser;\n            var aIsPrerendered;\n            var aCreateLazyBrowser;\n            var aSkipBackgroundNotify;\n            var aNextTabParentId;\n            var aNoInitialLabel;\n            var aFocusUrlBar;\n            var aName;\n            if (arguments.length == 2 &&\n                typeof arguments[1] == \"object\" &&\n                !(arguments[1] instanceof Ci.nsIURI)) {\n              let params = arguments[1];\n              aTriggeringPrincipal      = params.triggeringPrincipal;\n              aReferrerURI              = params.referrerURI;\n              aReferrerPolicy           = params.referrerPolicy;\n              aCharset                  = params.charset;\n              aPostData                 = params.postData;\n              aOwner                    = params.ownerTab;\n              aAllowThirdPartyFixup     = params.allowThirdPartyFixup;\n              aFromExternal             = params.fromExternal;\n              aRelatedToCurrent         = params.relatedToCurrent;\n              aSkipAnimation            = params.skipAnimation;\n              aAllowMixedContent        = params.allowMixedContent;\n              aForceNotRemote           = params.forceNotRemote;\n              aPreferredRemoteType      = params.preferredRemoteType;\n              aNoReferrer               = params.noReferrer;\n              aUserContextId            = params.userContextId;\n              aEventDetail              = params.eventDetail;\n              aSameProcessAsFrameLoader = params.sameProcessAsFrameLoader;\n              aOriginPrincipal          = params.originPrincipal;\n              aDisallowInheritPrincipal = params.disallowInheritPrincipal;\n              aOpener                   = params.opener;\n              aOpenerBrowser            = params.openerBrowser;\n              aIsPrerendered            = params.isPrerendered;\n              aCreateLazyBrowser        = params.createLazyBrowser;\n              aSkipBackgroundNotify     = params.skipBackgroundNotify;\n              aNextTabParentId          = params.nextTabParentId;\n              aNoInitialLabel           = params.noInitialLabel;\n              aFocusUrlBar              = params.focusUrlBar;\n              aName                     = params.name;\n            }\n\n            // if we're adding tabs, we're past interrupt mode, ditch the owner\n            if (this.mCurrentTab.owner)\n              this.mCurrentTab.owner = null;\n\n            // Find the tab that opened this one, if any. This is used for\n            // determining positioning, and inherited attributes such as the\n            // user context ID.\n            //\n            // If we have a browser opener (which is usually the browser\n            // element from a remote window.open() call), use that.\n            //\n            // Otherwise, if the tab is related to the current tab (e.g.,\n            // because it was opened by a link click), use the selected tab as\n            // the owner. If aReferrerURI is set, and we don't have an\n            // explicit relatedToCurrent arg, we assume that the tab is\n            // related to the current tab, since aReferrerURI is null or\n            // undefined if the tab is opened from an external application or\n            // bookmark (i.e. somewhere other than an existing tab).\n            let relatedToCurrent = aRelatedToCurrent == null ? !!aReferrerURI : aRelatedToCurrent;\n            let openerTab = ((aOpenerBrowser && this.getTabForBrowser(aOpenerBrowser)) ||\n                             (relatedToCurrent && this.selectedTab));\n\n            var t = document.createElementNS(NS_XUL, \"tab\");\n\n            t.openerTab = openerTab;\n\n            aURI = aURI || \"about:blank\";\n            let aURIObject = null;\n            try {\n              aURIObject = Services.io.newURI(aURI);\n            } catch (ex) { /* we'll try to fix up this URL later */ }\n\n            let lazyBrowserURI;\n            if (aCreateLazyBrowser && aURI != \"about:blank\") {\n              lazyBrowserURI = aURIObject;\n              aURI = \"about:blank\";\n            }\n\n            var uriIsAboutBlank = aURI == \"about:blank\";\n\n            if (!aNoInitialLabel) {\n              if (isBlankPageURL(aURI)) {\n                t.setAttribute(\"label\", gTabBrowserBundle.GetStringFromName(\"tabs.emptyTabTitle\"));\n              } else {\n                // Set URL as label so that the tab isn't empty initially.\n                this.setInitialTabTitle(t, aURI, { beforeTabOpen: true });\n              }\n            }\n\n            if (aIsPrerendered) {\n              t.setAttribute(\"hidden\", \"true\");\n            }\n\n            // Related tab inherits current tab's user context unless a different\n            // usercontextid is specified\n            if (aUserContextId == null && openerTab) {\n              aUserContextId = openerTab.getAttribute(\"usercontextid\") || 0;\n            }\n\n            if (aUserContextId) {\n              t.setAttribute(\"usercontextid\", aUserContextId);\n              ContextualIdentityService.setTabStyle(t);\n            }\n\n            t.setAttribute(\"onerror\", \"this.removeAttribute('image');\");\n\n            if (aSkipBackgroundNotify) {\n              t.setAttribute(\"skipbackgroundnotify\", true);\n            }\n\n            t.className = \"tabbrowser-tab\";\n\n            this.tabContainer._unlockTabSizing();\n\n            // When overflowing, new tabs are scrolled into view smoothly, which\n            // doesn't go well together with the width transition. So we skip the\n            // transition in that case.\n            let animate = !aSkipAnimation &&\n                          this.tabContainer.getAttribute(\"overflow\") != \"true\" &&\n                          this.animationsEnabled;\n            if (!animate) {\n              t.setAttribute(\"fadein\", \"true\");\n\n              // Call _handleNewTab asynchronously as it needs to know if the\n              // new tab is selected.\n              setTimeout(function(tabContainer) {\n                tabContainer._handleNewTab(t);\n              }, 0, this.tabContainer);\n            }\n\n            // invalidate cache\n            this._visibleTabs = null;\n\n            this.tabContainer.appendChild(t);\n\n            let usingPreloadedContent = false;\n            let b;\n\n            try {\n              // If this new tab is owned by another, assert that relationship\n              if (aOwner)\n                t.owner = aOwner;\n\n              var position = this.tabs.length - 1;\n              t._tPos = position;\n              this.tabContainer._setPositionalAttributes();\n\n              this.tabContainer.updateVisibility();\n\n              // If we don't have a preferred remote type, and we have a remote\n              // opener, use the opener's remote type.\n              if (!aPreferredRemoteType && aOpenerBrowser) {\n                aPreferredRemoteType = aOpenerBrowser.remoteType;\n              }\n\n              // If URI is about:blank and we don't have a preferred remote type,\n              // then we need to use the referrer, if we have one, to get the\n              // correct remote type for the new tab.\n              if (uriIsAboutBlank && !aPreferredRemoteType && aReferrerURI) {\n                aPreferredRemoteType =\n                  E10SUtils.getRemoteTypeForURI(aReferrerURI.spec,\n                                                gMultiProcessBrowser);\n              }\n\n              let remoteType =\n                aForceNotRemote ? E10SUtils.NOT_REMOTE\n                : E10SUtils.getRemoteTypeForURI(aURI, gMultiProcessBrowser,\n                                                aPreferredRemoteType);\n\n              // If we open a new tab with the newtab URL in the default\n              // userContext, check if there is a preloaded browser ready.\n              // Private windows are not included because both the label and the\n              // icon for the tab would be set incorrectly (see bug 1195981).\n              if (aURI == BROWSER_NEW_TAB_URL &&\n                  !aUserContextId &&\n                  !PrivateBrowsingUtils.isWindowPrivate(window)) {\n                b = this._getPreloadedBrowser();\n                if (b) {\n                  usingPreloadedContent = true;\n                }\n              }\n\n              if (!b) {\n                // No preloaded browser found, create one.\n                b = this._createBrowser({ remoteType,\n                                          uriIsAboutBlank,\n                                          userContextId: aUserContextId,\n                                          sameProcessAsFrameLoader: aSameProcessAsFrameLoader,\n                                          openerWindow: aOpener,\n                                          isPrerendered: aIsPrerendered,\n                                          nextTabParentId: aNextTabParentId,\n                                          name: aName });\n              }\n\n              t.linkedBrowser = b;\n\n              if (aFocusUrlBar) {\n                b._urlbarFocused = true;\n              }\n\n              this._tabForBrowser.set(b, t);\n              t.permanentKey = b.permanentKey;\n              t._browserParams = { uriIsAboutBlank,\n                                   remoteType,\n                                   usingPreloadedContent };\n\n              // If the caller opts in, create a lazy browser.\n              if (aCreateLazyBrowser) {\n                this._createLazyBrowser(t);\n\n                if (lazyBrowserURI) {\n                  // Lazy browser must be explicitly registered so tab will appear as\n                  // a switch-to-tab candidate in autocomplete.\n                  this._unifiedComplete.registerOpenPage(lazyBrowserURI, aUserContextId);\n                  b.registeredOpenURI = lazyBrowserURI;\n                }\n              } else {\n                this._insertBrowser(t, true);\n              }\n            } catch (e) {\n              Cu.reportError(\"Failed to create tab\");\n              Cu.reportError(e);\n              t.remove();\n              if (t.linkedBrowser) {\n                this._tabFilters.delete(t);\n                this._tabListeners.delete(t);\n                let notificationbox = this.getNotificationBox(t.linkedBrowser);\n                notificationbox.remove();\n              }\n              throw e;\n            }\n\n            // Dispatch a new tab notification.  We do this once we're\n            // entirely done, so that things are in a consistent state\n            // even if the event listener opens or closes tabs.\n            var detail = aEventDetail || {};\n            var evt = new CustomEvent(\"TabOpen\", { bubbles: true, detail });\n            t.dispatchEvent(evt);\n\n            if (!usingPreloadedContent && aOriginPrincipal && aURI) {\n              let {URI_INHERITS_SECURITY_CONTEXT} = Ci.nsIProtocolHandler;\n              // Unless we know for sure we're not inheriting principals,\n              // force the about:blank viewer to have the right principal:\n              if (!aURIObject ||\n                  (doGetProtocolFlags(aURIObject) & URI_INHERITS_SECURITY_CONTEXT)) {\n                b.createAboutBlankContentViewer(aOriginPrincipal);\n              }\n            }\n\n            // If we didn't swap docShells with a preloaded browser\n            // then let's just continue loading the page normally.\n            if (!usingPreloadedContent && (!uriIsAboutBlank || aDisallowInheritPrincipal)) {\n              // pretend the user typed this so it'll be available till\n              // the document successfully loads\n              if (aURI && gInitialPages.indexOf(aURI) == -1)\n                b.userTypedValue = aURI;\n\n              let flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;\n              if (aAllowThirdPartyFixup) {\n                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;\n                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_FIXUP_SCHEME_TYPOS;\n              }\n              if (aFromExternal)\n                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_FROM_EXTERNAL;\n              if (aAllowMixedContent)\n                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_MIXED_CONTENT;\n              if (aDisallowInheritPrincipal)\n                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL;\n              try {\n                b.loadURIWithFlags(aURI, {\n                  flags,\n                  triggeringPrincipal: aTriggeringPrincipal,\n                  referrerURI: aNoReferrer ? null : aReferrerURI,\n                  referrerPolicy: aReferrerPolicy,\n                  charset: aCharset,\n                  postData: aPostData,\n                });\n              } catch (ex) {\n                Cu.reportError(ex);\n              }\n            }\n\n            // If we're opening a tab related to the an existing tab, move it\n            // to a position after that tab.\n            if (openerTab &&\n                Services.prefs.getBoolPref(\"browser.tabs.insertRelatedAfterCurrent\")) {\n\n              let lastRelatedTab = this._lastRelatedTabMap.get(openerTab);\n              let newTabPos = (lastRelatedTab || openerTab)._tPos + 1;\n              if (lastRelatedTab)\n                lastRelatedTab.owner = null;\n              else\n                t.owner = openerTab;\n              this.moveTabTo(t, newTabPos, true);\n              this._lastRelatedTabMap.set(openerTab, t);\n            }\n\n            // This field is updated regardless if we actually animate\n            // since it's important that we keep this count correct in all cases.\n            this.tabAnimationsInProgress++;\n\n            if (animate) {\n              requestAnimationFrame(function() {\n                // kick the animation off\n                t.setAttribute(\"fadein\", \"true\");\n              });\n            }\n\n            return t;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"warnAboutClosingTabs\">\n      <parameter name=\"aCloseTabs\"/>\n      <parameter name=\"aTab\"/>\n      <body>\n        <![CDATA[\n          var tabsToClose;\n          switch (aCloseTabs) {\n            case this.closingTabsEnum.ALL:\n              tabsToClose = this.tabs.length - this._removingTabs.length -\n                            gBrowser._numPinnedTabs;\n              break;\n            case this.closingTabsEnum.OTHER:\n              tabsToClose = this.visibleTabs.length - 1 - gBrowser._numPinnedTabs;\n              break;\n            case this.closingTabsEnum.TO_END:\n              if (!aTab)\n                throw new Error(\"Required argument missing: aTab\");\n\n              tabsToClose = this.getTabsToTheEndFrom(aTab).length;\n              break;\n            default:\n              throw new Error(\"Invalid argument: \" + aCloseTabs);\n          }\n\n          if (tabsToClose <= 1)\n            return true;\n\n          const pref = aCloseTabs == this.closingTabsEnum.ALL ?\n                       \"browser.tabs.warnOnClose\" : \"browser.tabs.warnOnCloseOtherTabs\";\n          var shouldPrompt = Services.prefs.getBoolPref(pref);\n          if (!shouldPrompt)\n            return true;\n\n          var ps = Services.prompt;\n\n          // default to true: if it were false, we wouldn't get this far\n          var warnOnClose = { value: true };\n\n          // focus the window before prompting.\n          // this will raise any minimized window, which will\n          // make it obvious which window the prompt is for and will\n          // solve the problem of windows \"obscuring\" the prompt.\n          // see bug #350299 for more details\n          window.focus();\n          var warningMessage =\n            PluralForm.get(tabsToClose, gTabBrowserBundle.GetStringFromName(\"tabs.closeWarningMultiple\"))\n                      .replace(\"#1\", tabsToClose);\n          var buttonPressed =\n            ps.confirmEx(window,\n                         gTabBrowserBundle.GetStringFromName(\"tabs.closeWarningTitle\"),\n                         warningMessage,\n                         (ps.BUTTON_TITLE_IS_STRING * ps.BUTTON_POS_0)\n                         + (ps.BUTTON_TITLE_CANCEL * ps.BUTTON_POS_1),\n                         gTabBrowserBundle.GetStringFromName(\"tabs.closeButtonMultiple\"),\n                         null, null,\n                         aCloseTabs == this.closingTabsEnum.ALL ?\n                           gTabBrowserBundle.GetStringFromName(\"tabs.closeWarningPromptMe\") : null,\n                         warnOnClose);\n          var reallyClose = (buttonPressed == 0);\n\n          // don't set the pref unless they press OK and it's false\n          if (aCloseTabs == this.closingTabsEnum.ALL && reallyClose && !warnOnClose.value)\n            Services.prefs.setBoolPref(pref, false);\n\n          return reallyClose;\n        ]]>\n      </body>\n      </method>\n\n      <method name=\"getTabsToTheEndFrom\">\n        <parameter name=\"aTab\"/>\n        <body>\n          <![CDATA[\n            var tabsToEnd = [];\n            let tabs = this.visibleTabs;\n            for (let i = tabs.length - 1; tabs[i] != aTab && i >= 0; --i) {\n              tabsToEnd.push(tabs[i]);\n            }\n            return tabsToEnd;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeTabsToTheEndFrom\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aParams\"/>\n        <body>\n          <![CDATA[\n            if (!this.warnAboutClosingTabs(this.closingTabsEnum.TO_END, aTab))\n              return;\n\n            let removeTab = tab => {\n              // Avoid changing the selected browser several times.\n              if (tab.selected)\n                this.selectedTab = aTab;\n\n              this.removeTab(tab, aParams);\n            };\n\n            let tabs = this.getTabsToTheEndFrom(aTab);\n            let tabsWithBeforeUnload = [];\n            for (let i = tabs.length - 1; i >= 0; --i) {\n              let tab = tabs[i];\n              if (this._hasBeforeUnload(tab))\n                tabsWithBeforeUnload.push(tab);\n              else\n                removeTab(tab);\n            }\n            tabsWithBeforeUnload.forEach(removeTab);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeAllTabsBut\">\n        <parameter name=\"aTab\"/>\n        <body>\n          <![CDATA[\n            if (aTab.pinned ||\n                !this.warnAboutClosingTabs(this.closingTabsEnum.OTHER))\n              return;\n\n            let tabs = this.visibleTabs.reverse();\n            this.selectedTab = aTab;\n\n            let tabsWithBeforeUnload = [];\n            for (let i = tabs.length - 1; i >= 0; --i) {\n              let tab = tabs[i];\n              if (tab != aTab && !tab.pinned) {\n                if (this._hasBeforeUnload(tab))\n                  tabsWithBeforeUnload.push(tab)\n                else\n                  this.removeTab(tab, {animate: true});\n              }\n            }\n            for (let tab of tabsWithBeforeUnload) {\n              this.removeTab(tab, {animate: true});\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeCurrentTab\">\n        <parameter name=\"aParams\"/>\n        <body>\n          <![CDATA[\n            this.removeTab(this.mCurrentTab, aParams);\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"_removingTabs\">\n        []\n      </field>\n\n      <method name=\"removeTab\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aParams\"/>\n        <body>\n          <![CDATA[\n            if (aParams) {\n              var animate = aParams.animate;\n              var byMouse = aParams.byMouse;\n              var skipPermitUnload = aParams.skipPermitUnload;\n            }\n\n            // Telemetry stopwatches may already be running if removeTab gets\n            // called again for an already closing tab.\n            if (!TelemetryStopwatch.running(\"FX_TAB_CLOSE_TIME_ANIM_MS\", aTab) &&\n                !TelemetryStopwatch.running(\"FX_TAB_CLOSE_TIME_NO_ANIM_MS\", aTab)) {\n              // Speculatevely start both stopwatches now. We'll cancel one of\n              // the two later depending on whether we're animating.\n              TelemetryStopwatch.start(\"FX_TAB_CLOSE_TIME_ANIM_MS\", aTab);\n              TelemetryStopwatch.start(\"FX_TAB_CLOSE_TIME_NO_ANIM_MS\", aTab);\n            }\n            window.maybeRecordAbandonmentTelemetry(aTab, \"tabClosed\");\n\n            // Handle requests for synchronously removing an already\n            // asynchronously closing tab.\n            if (!animate &&\n                aTab.closing) {\n              this._endRemoveTab(aTab);\n              return;\n            }\n\n            var isLastTab = (this.tabs.length - this._removingTabs.length == 1);\n\n            if (!this._beginRemoveTab(aTab, null, null, true, skipPermitUnload)) {\n              TelemetryStopwatch.cancel(\"FX_TAB_CLOSE_TIME_ANIM_MS\", aTab);\n              TelemetryStopwatch.cancel(\"FX_TAB_CLOSE_TIME_NO_ANIM_MS\", aTab);\n              return;\n            }\n\n            if (!aTab.pinned && !aTab.hidden && aTab._fullyOpen && byMouse)\n              this.tabContainer._lockTabSizing(aTab);\n            else\n              this.tabContainer._unlockTabSizing();\n\n            if (!animate /* the caller didn't opt in */ ||\n                isLastTab ||\n                aTab.pinned ||\n                aTab.hidden ||\n                this._removingTabs.length > 3 /* don't want lots of concurrent animations */ ||\n                aTab.getAttribute(\"fadein\") != \"true\" /* fade-in transition hasn't been triggered yet */ ||\n                window.getComputedStyle(aTab).maxWidth == \"0.1px\" /* fade-in transition hasn't moved yet */ ||\n                !this.animationsEnabled) {\n              // We're not animating, so we can cancel the animation stopwatch.\n              TelemetryStopwatch.cancel(\"FX_TAB_CLOSE_TIME_ANIM_MS\", aTab);\n              this._endRemoveTab(aTab);\n              return;\n            }\n\n            // We're animating, so we can cancel the non-animation stopwatch.\n            TelemetryStopwatch.cancel(\"FX_TAB_CLOSE_TIME_NO_ANIM_MS\", aTab);\n\n            aTab.style.maxWidth = \"\"; // ensure that fade-out transition happens\n            aTab.removeAttribute(\"fadein\");\n            aTab.removeAttribute(\"bursting\");\n\n            setTimeout(function(tab, tabbrowser) {\n              if (tab.parentNode &&\n                  window.getComputedStyle(tab).maxWidth == \"0.1px\") {\n                NS_ASSERT(false, \"Giving up waiting for the tab closing animation to finish (bug 608589)\");\n                tabbrowser._endRemoveTab(tab);\n              }\n            }, 3000, aTab, this);\n          ]]>\n        </body>\n      </method>\n\n      <!-- Tab close requests are ignored if the window is closing anyway,\n           e.g. when holding Ctrl+W. -->\n      <field name=\"_windowIsClosing\">\n        false\n      </field>\n\n      <method name=\"_hasBeforeUnload\">\n        <parameter name=\"aTab\"/>\n        <body>\n          <![CDATA[\n            let browser = aTab.linkedBrowser;\n            return browser.isRemoteBrowser && browser.frameLoader &&\n                   browser.frameLoader.tabParent &&\n                   browser.frameLoader.tabParent.hasBeforeUnload;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_beginRemoveTab\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aAdoptedByTab\"/>\n        <parameter name=\"aCloseWindowWithLastTab\"/>\n        <parameter name=\"aCloseWindowFastpath\"/>\n        <parameter name=\"aSkipPermitUnload\"/>\n        <body>\n          <![CDATA[\n            if (aTab.closing ||\n                this._windowIsClosing)\n              return false;\n\n            var browser = this.getBrowserForTab(aTab);\n            if (!aSkipPermitUnload && !aAdoptedByTab &&\n                aTab.linkedPanel && !aTab._pendingPermitUnload &&\n                (!browser.isRemoteBrowser || this._hasBeforeUnload(aTab))) {\n              TelemetryStopwatch.start(\"FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS\", aTab);\n\n              // We need to block while calling permitUnload() because it\n              // processes the event queue and may lead to another removeTab()\n              // call before permitUnload() returns.\n              aTab._pendingPermitUnload = true;\n              let {permitUnload, timedOut} = browser.permitUnload();\n              delete aTab._pendingPermitUnload;\n\n              TelemetryStopwatch.finish(\"FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS\", aTab);\n\n              // If we were closed during onbeforeunload, we return false now\n              // so we don't (try to) close the same tab again. Of course, we\n              // also stop if the unload was cancelled by the user:\n              if (aTab.closing || (!timedOut && !permitUnload)) {\n                return false;\n              }\n            }\n\n            this._blurTab(aTab);\n\n            var closeWindow = false;\n            var newTab = false;\n            if (this.tabs.length - this._removingTabs.length == 1) {\n              closeWindow = aCloseWindowWithLastTab != null ? aCloseWindowWithLastTab :\n                            !window.toolbar.visible ||\n                              Services.prefs.getBoolPref(\"browser.tabs.closeWindowWithLastTab\");\n\n              if (closeWindow) {\n                // We've already called beforeunload on all the relevant tabs if we get here,\n                // so avoid calling it again:\n                window.skipNextCanClose = true;\n              }\n\n              // Closing the tab and replacing it with a blank one is notably slower\n              // than closing the window right away. If the caller opts in, take\n              // the fast path.\n              if (closeWindow &&\n                  aCloseWindowFastpath &&\n                  this._removingTabs.length == 0) {\n                // This call actually closes the window, unless the user\n                // cancels the operation.  We are finished here in both cases.\n                this._windowIsClosing = window.closeWindow(true, window.warnAboutClosingWindow);\n                return false;\n              }\n\n              newTab = true;\n            }\n            aTab._endRemoveArgs = [closeWindow, newTab];\n\n            // swapBrowsersAndCloseOther will take care of closing the window without animation.\n            if (closeWindow && aAdoptedByTab) {\n              // Remove the tab's filter to avoid leaking.\n              if (aTab.linkedPanel) {\n                this._tabFilters.delete(aTab);\n              }\n              return true;\n            }\n\n            if (!aTab._fullyOpen) {\n              // If the opening tab animation hasn't finished before we start closing the\n              // tab, decrement the animation count since _handleNewTab will not get called.\n              this.tabAnimationsInProgress--;\n            }\n\n            this.tabAnimationsInProgress++;\n\n            // Mute audio immediately to improve perceived speed of tab closure.\n            if (!aAdoptedByTab && aTab.hasAttribute(\"soundplaying\")) {\n              // Don't persist the muted state as this wasn't a user action.\n              // This lets undo-close-tab return it to an unmuted state.\n              aTab.linkedBrowser.mute(true);\n            }\n\n            aTab.closing = true;\n            this._removingTabs.push(aTab);\n            this._visibleTabs = null; // invalidate cache\n\n            // Invalidate hovered tab state tracking for this closing tab.\n            if (this.tabContainer._hoveredTab == aTab)\n              aTab._mouseleave();\n\n            if (newTab)\n              this.addTab(BROWSER_NEW_TAB_URL, {skipAnimation: true});\n            else\n              this.tabContainer.updateVisibility();\n\n            // We're committed to closing the tab now.\n            // Dispatch a notification.\n            // We dispatch it before any teardown so that event listeners can\n            // inspect the tab that's about to close.\n            var evt = new CustomEvent(\"TabClose\", { bubbles: true, detail: { adoptedBy: aAdoptedByTab } });\n            aTab.dispatchEvent(evt);\n\n            if (aTab.linkedPanel) {\n              if (!aAdoptedByTab && !gMultiProcessBrowser) {\n                // Prevent this tab from showing further dialogs, since we're closing it\n                var windowUtils = browser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor).\n                                  getInterface(Ci.nsIDOMWindowUtils);\n                windowUtils.disableDialogs();\n              }\n\n              // Remove the tab's filter and progress listener.\n              const filter = this._tabFilters.get(aTab);\n\n              browser.webProgress.removeProgressListener(filter);\n\n              const listener = this._tabListeners.get(aTab);\n              filter.removeProgressListener(listener);\n              listener.destroy();\n            }\n\n            if (browser.registeredOpenURI && !aAdoptedByTab) {\n              this._unifiedComplete.unregisterOpenPage(browser.registeredOpenURI,\n                                                       browser.getAttribute(\"usercontextid\") || 0);\n              delete browser.registeredOpenURI;\n            }\n\n            // We are no longer the primary content area.\n            browser.removeAttribute(\"primary\");\n\n            // Remove this tab as the owner of any other tabs, since it's going away.\n            for (let tab of this.tabs) {\n              if (\"owner\" in tab && tab.owner == aTab)\n                // |tab| is a child of the tab we're removing, make it an orphan\n                tab.owner = null;\n            }\n\n            return true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_endRemoveTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n          <![CDATA[\n            if (!aTab || !aTab._endRemoveArgs)\n              return;\n\n            var [aCloseWindow, aNewTab] = aTab._endRemoveArgs;\n            aTab._endRemoveArgs = null;\n\n            if (this._windowIsClosing) {\n              aCloseWindow = false;\n              aNewTab = false;\n            }\n\n            this.tabAnimationsInProgress--;\n\n            this._lastRelatedTabMap = new WeakMap();\n\n            // update the UI early for responsiveness\n            aTab.collapsed = true;\n            this._blurTab(aTab);\n\n            this._removingTabs.splice(this._removingTabs.indexOf(aTab), 1);\n\n            if (aCloseWindow) {\n              this._windowIsClosing = true;\n              while (this._removingTabs.length)\n                this._endRemoveTab(this._removingTabs[0]);\n            } else if (!this._windowIsClosing) {\n              if (aNewTab)\n                focusAndSelectUrlBar();\n\n              // workaround for bug 345399\n              this.tabContainer.mTabstrip._updateScrollButtonsDisabledState();\n            }\n\n            // We're going to remove the tab and the browser now.\n            this._tabFilters.delete(aTab);\n            this._tabListeners.delete(aTab);\n\n            var browser = this.getBrowserForTab(aTab);\n\n            if (aTab.linkedPanel) {\n              this._outerWindowIDBrowserMap.delete(browser.outerWindowID);\n\n              // Because of the way XBL works (fields just set JS\n              // properties on the element) and the code we have in place\n              // to preserve the JS objects for any elements that have\n              // JS properties set on them, the browser element won't be\n              // destroyed until the document goes away.  So we force a\n              // cleanup ourselves.\n              // This has to happen before we remove the child so that the\n              // XBL implementation of nsIObserver still works.\n              browser.destroy();\n            }\n\n            var wasPinned = aTab.pinned;\n\n            // Remove the tab ...\n            this.tabContainer.removeChild(aTab);\n\n            // ... and fix up the _tPos properties immediately.\n            for (let i = aTab._tPos; i < this.tabs.length; i++)\n              this.tabs[i]._tPos = i;\n\n            if (!this._windowIsClosing) {\n              if (wasPinned)\n                this.tabContainer._positionPinnedTabs();\n\n              // update tab close buttons state\n              this.tabContainer.adjustTabstrip();\n\n              setTimeout(function(tabs) {\n                tabs._lastTabClosedByMouse = false;\n              }, 0, this.tabContainer);\n            }\n\n            // update tab positional properties and attributes\n            this.selectedTab._selected = true;\n            this.tabContainer._setPositionalAttributes();\n\n            // Removing the panel requires fixing up selectedPanel immediately\n            // (see below), which would be hindered by the potentially expensive\n            // browser removal. So we remove the browser and the panel in two\n            // steps.\n\n            var panel = this.getNotificationBox(browser);\n\n            // In the multi-process case, it's possible an asynchronous tab switch\n            // is still underway. If so, then it's possible that the last visible\n            // browser is the one we're in the process of removing. There's the\n            // risk of displaying preloaded browsers that are at the end of the\n            // deck if we remove the browser before the switch is complete, so\n            // we alert the switcher in order to show a spinner instead.\n            if (this._switcher) {\n              this._switcher.onTabRemoved(aTab);\n            }\n\n            // This will unload the document. An unload handler could remove\n            // dependant tabs, so it's important that the tabbrowser is now in\n            // a consistent state (tab removed, tab positions updated, etc.).\n            browser.remove();\n\n            // Release the browser in case something is erroneously holding a\n            // reference to the tab after its removal.\n            this._tabForBrowser.delete(aTab.linkedBrowser);\n            aTab.linkedBrowser = null;\n\n            panel.remove();\n\n            // closeWindow might wait an arbitrary length of time if we're supposed\n            // to warn about closing the window, so we'll just stop the tab close\n            // stopwatches here instead.\n            TelemetryStopwatch.finish(\"FX_TAB_CLOSE_TIME_ANIM_MS\", aTab,\n                                      true /* aCanceledOkay */);\n            TelemetryStopwatch.finish(\"FX_TAB_CLOSE_TIME_NO_ANIM_MS\", aTab,\n                                      true /* aCanceledOkay */);\n\n            if (aCloseWindow)\n              this._windowIsClosing = closeWindow(true, window.warnAboutClosingWindow);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_blurTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n          <![CDATA[\n            if (!aTab.selected)\n              return;\n\n            if (aTab.owner &&\n                !aTab.owner.hidden &&\n                !aTab.owner.closing &&\n                Services.prefs.getBoolPref(\"browser.tabs.selectOwnerOnClose\")) {\n              this.selectedTab = aTab.owner;\n              return;\n            }\n\n            // Switch to a visible tab unless there aren't any others remaining\n            let remainingTabs = this.visibleTabs;\n            let numTabs = remainingTabs.length;\n            if (numTabs == 0 || numTabs == 1 && remainingTabs[0] == aTab) {\n              remainingTabs = Array.filter(this.tabs, function(tab) {\n                return !tab.closing;\n              }, this);\n            }\n\n            // Try to find a remaining tab that comes after the given tab\n            var tab = aTab;\n            do {\n              tab = tab.nextSibling;\n            } while (tab && remainingTabs.indexOf(tab) == -1);\n\n            if (!tab) {\n              tab = aTab;\n\n              do {\n                tab = tab.previousSibling;\n              } while (tab && remainingTabs.indexOf(tab) == -1);\n            }\n\n            this.selectedTab = tab;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"swapBrowsersAndCloseOther\">\n        <parameter name=\"aOurTab\"/>\n        <parameter name=\"aOtherTab\"/>\n        <body>\n          <![CDATA[\n            // Do not allow transfering a private tab to a non-private window\n            // and vice versa.\n            if (PrivateBrowsingUtils.isWindowPrivate(window) !=\n                PrivateBrowsingUtils.isWindowPrivate(aOtherTab.ownerGlobal))\n              return;\n\n            let ourBrowser = this.getBrowserForTab(aOurTab);\n            let otherBrowser = aOtherTab.linkedBrowser;\n\n            // Can't swap between chrome and content processes.\n            if (ourBrowser.isRemoteBrowser != otherBrowser.isRemoteBrowser)\n              return;\n\n            // Keep the userContextId if set on other browser\n            if (otherBrowser.hasAttribute(\"usercontextid\")) {\n              ourBrowser.setAttribute(\"usercontextid\", otherBrowser.getAttribute(\"usercontextid\"));\n            }\n\n            // That's gBrowser for the other window, not the tab's browser!\n            var remoteBrowser = aOtherTab.ownerGlobal.gBrowser;\n            var isPending = aOtherTab.hasAttribute(\"pending\");\n\n            let otherTabListener = remoteBrowser._tabListeners.get(aOtherTab);\n            let stateFlags = otherTabListener.mStateFlags;\n\n            // Expedite the removal of the icon if it was already scheduled.\n            if (aOtherTab._soundPlayingAttrRemovalTimer) {\n              clearTimeout(aOtherTab._soundPlayingAttrRemovalTimer);\n              aOtherTab._soundPlayingAttrRemovalTimer = 0;\n              aOtherTab.removeAttribute(\"soundplaying\");\n              remoteBrowser._tabAttrModified(aOtherTab, [\"soundplaying\"]);\n            }\n\n            // First, start teardown of the other browser.  Make sure to not\n            // fire the beforeunload event in the process.  Close the other\n            // window if this was its last tab.\n            if (!remoteBrowser._beginRemoveTab(aOtherTab, aOurTab, true))\n              return;\n\n            // If this is the last tab of the window, hide the window\n            // immediately without animation before the docshell swap, to avoid\n            // about:blank being painted.\n            let [closeWindow] = aOtherTab._endRemoveArgs;\n            if (closeWindow) {\n              let win = aOtherTab.ownerGlobal;\n              let dwu = win.QueryInterface(Ci.nsIInterfaceRequestor)\n                           .getInterface(Ci.nsIDOMWindowUtils);\n              dwu.suppressAnimation(true);\n              // Only suppressing window animations isn't enough to avoid\n              // an empty content area being painted.\n              let baseWin = win.QueryInterface(Ci.nsIInterfaceRequestor)\n                               .getInterface(Ci.nsIDocShell)\n                               .QueryInterface(Ci.nsIDocShellTreeItem)\n                               .treeOwner\n                               .QueryInterface(Ci.nsIBaseWindow);\n              baseWin.visibility = false;\n            }\n\n            let modifiedAttrs = [];\n            if (aOtherTab.hasAttribute(\"muted\")) {\n              aOurTab.setAttribute(\"muted\", \"true\");\n              aOurTab.muteReason = aOtherTab.muteReason;\n              ourBrowser.mute();\n              modifiedAttrs.push(\"muted\");\n            }\n            if (aOtherTab.hasAttribute(\"soundplaying\")) {\n              aOurTab.setAttribute(\"soundplaying\", \"true\");\n              modifiedAttrs.push(\"soundplaying\");\n            }\n            if (aOtherTab.hasAttribute(\"usercontextid\")) {\n              aOurTab.setUserContextId(aOtherTab.getAttribute(\"usercontextid\"));\n              modifiedAttrs.push(\"usercontextid\");\n            }\n            if (aOtherTab.hasAttribute(\"sharing\")) {\n              aOurTab.setAttribute(\"sharing\", aOtherTab.getAttribute(\"sharing\"));\n              modifiedAttrs.push(\"sharing\");\n              aOurTab._sharingState = aOtherTab._sharingState;\n              webrtcUI.swapBrowserForNotification(otherBrowser, ourBrowser);\n            }\n\n            SitePermissions.copyTemporaryPermissions(otherBrowser, ourBrowser);\n\n            // If the other tab is pending (i.e. has not been restored, yet)\n            // then do not switch docShells but retrieve the other tab's state\n            // and apply it to our tab.\n            if (isPending) {\n              SessionStore.setTabState(aOurTab, SessionStore.getTabState(aOtherTab));\n\n              // Make sure to unregister any open URIs.\n              this._swapRegisteredOpenURIs(ourBrowser, otherBrowser);\n            } else {\n              // Workarounds for bug 458697\n              // Icon might have been set on DOMLinkAdded, don't override that.\n              if (!ourBrowser.mIconURL && otherBrowser.mIconURL)\n                this.setIcon(aOurTab, otherBrowser.mIconURL, otherBrowser.contentPrincipal, otherBrowser.contentRequestContextID);\n              var isBusy = aOtherTab.hasAttribute(\"busy\");\n              if (isBusy) {\n                aOurTab.setAttribute(\"busy\", \"true\");\n                modifiedAttrs.push(\"busy\");\n                if (aOurTab.selected)\n                  this.mIsBusy = true;\n              }\n\n              this._swapBrowserDocShells(aOurTab, otherBrowser, Ci.nsIBrowser.SWAP_DEFAULT, stateFlags);\n            }\n\n            // Unregister the previously opened URI\n            if (otherBrowser.registeredOpenURI) {\n              this._unifiedComplete.unregisterOpenPage(otherBrowser.registeredOpenURI,\n                                                       otherBrowser.getAttribute(\"usercontextid\") || 0);\n              delete otherBrowser.registeredOpenURI;\n            }\n\n            // Handle findbar data (if any)\n            let otherFindBar = aOtherTab._findBar;\n            if (otherFindBar &&\n                otherFindBar.findMode == otherFindBar.FIND_NORMAL) {\n              let ourFindBar = this.getFindBar(aOurTab);\n              ourFindBar._findField.value = otherFindBar._findField.value;\n              if (!otherFindBar.hidden)\n                ourFindBar.onFindCommand();\n            }\n\n            // Finish tearing down the tab that's going away.\n            if (closeWindow) {\n              aOtherTab.ownerGlobal.close();\n            } else {\n              remoteBrowser._endRemoveTab(aOtherTab);\n            }\n\n            this.setTabTitle(aOurTab);\n\n            // If the tab was already selected (this happpens in the scenario\n            // of replaceTabWithWindow), notify onLocationChange, etc.\n            if (aOurTab.selected)\n              this.updateCurrentBrowser(true);\n\n            if (modifiedAttrs.length) {\n              this._tabAttrModified(aOurTab, modifiedAttrs);\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"swapBrowsers\">\n        <parameter name=\"aOurTab\"/>\n        <parameter name=\"aOtherTab\"/>\n        <parameter name=\"aFlags\"/>\n        <body>\n          <![CDATA[\n            let otherBrowser = aOtherTab.linkedBrowser;\n            let otherTabBrowser = otherBrowser.getTabBrowser();\n\n            // We aren't closing the other tab so, we also need to swap its tablisteners.\n            let filter = otherTabBrowser._tabFilters.get(aOtherTab);\n            let tabListener = otherTabBrowser._tabListeners.get(aOtherTab);\n            otherBrowser.webProgress.removeProgressListener(filter);\n            filter.removeProgressListener(tabListener);\n\n            // Perform the docshell swap through the common mechanism.\n            this._swapBrowserDocShells(aOurTab, otherBrowser, aFlags);\n\n            // Restore the listeners for the swapped in tab.\n            tabListener = otherTabBrowser.mTabProgressListener(aOtherTab, otherBrowser, false, false);\n            otherTabBrowser._tabListeners.set(aOtherTab, tabListener);\n\n            const notifyAll = Ci.nsIWebProgress.NOTIFY_ALL;\n            filter.addProgressListener(tabListener, notifyAll);\n            otherBrowser.webProgress.addProgressListener(filter, notifyAll);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_swapBrowserDocShells\">\n        <parameter name=\"aOurTab\"/>\n        <parameter name=\"aOtherBrowser\"/>\n        <parameter name=\"aFlags\"/>\n        <parameter name=\"aStateFlags\"/>\n        <body>\n          <![CDATA[\n            // aOurTab's browser needs to be inserted now if it hasn't already.\n            this._insertBrowser(aOurTab);\n\n            // Unhook our progress listener\n            const filter = this._tabFilters.get(aOurTab);\n            let tabListener = this._tabListeners.get(aOurTab);\n            let ourBrowser = this.getBrowserForTab(aOurTab);\n            ourBrowser.webProgress.removeProgressListener(filter);\n            filter.removeProgressListener(tabListener);\n\n            // Make sure to unregister any open URIs.\n            this._swapRegisteredOpenURIs(ourBrowser, aOtherBrowser);\n\n            // Unmap old outerWindowIDs.\n            this._outerWindowIDBrowserMap.delete(ourBrowser.outerWindowID);\n            let remoteBrowser = aOtherBrowser.ownerGlobal.gBrowser;\n            if (remoteBrowser) {\n              remoteBrowser._outerWindowIDBrowserMap.delete(aOtherBrowser.outerWindowID);\n            }\n\n            // If switcher is active, it will intercept swap events and\n            // react as needed.\n            if (!this._switcher) {\n              aOtherBrowser.docShellIsActive = this.shouldActivateDocShell(ourBrowser);\n            }\n\n            // Swap the docshells\n            ourBrowser.swapDocShells(aOtherBrowser);\n\n            if (ourBrowser.isRemoteBrowser) {\n              // Switch outerWindowIDs for remote browsers.\n              let ourOuterWindowID = ourBrowser._outerWindowID;\n              ourBrowser._outerWindowID = aOtherBrowser._outerWindowID;\n              aOtherBrowser._outerWindowID = ourOuterWindowID;\n            }\n\n            // Register new outerWindowIDs.\n            this._outerWindowIDBrowserMap.set(ourBrowser.outerWindowID, ourBrowser);\n            if (remoteBrowser) {\n              remoteBrowser._outerWindowIDBrowserMap.set(aOtherBrowser.outerWindowID, aOtherBrowser);\n            }\n\n            if (!(aFlags & Ci.nsIBrowser.SWAP_KEEP_PERMANENT_KEY)) {\n              // Swap permanentKey properties.\n              let ourPermanentKey = ourBrowser.permanentKey;\n              ourBrowser.permanentKey = aOtherBrowser.permanentKey;\n              aOtherBrowser.permanentKey = ourPermanentKey;\n              aOurTab.permanentKey = ourBrowser.permanentKey;\n              if (remoteBrowser) {\n                let otherTab = remoteBrowser.getTabForBrowser(aOtherBrowser);\n                if (otherTab) {\n                  otherTab.permanentKey = aOtherBrowser.permanentKey;\n                }\n              }\n            }\n\n            // Restore the progress listener\n            tabListener = this.mTabProgressListener(aOurTab, ourBrowser, false, false,\n                                                    aStateFlags);\n            this._tabListeners.set(aOurTab, tabListener);\n\n            const notifyAll = Ci.nsIWebProgress.NOTIFY_ALL;\n            filter.addProgressListener(tabListener, notifyAll);\n            ourBrowser.webProgress.addProgressListener(filter, notifyAll);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_swapRegisteredOpenURIs\">\n        <parameter name=\"aOurBrowser\"/>\n        <parameter name=\"aOtherBrowser\"/>\n        <body>\n          <![CDATA[\n            // Swap the registeredOpenURI properties of the two browsers\n            let tmp = aOurBrowser.registeredOpenURI;\n            delete aOurBrowser.registeredOpenURI;\n            if (aOtherBrowser.registeredOpenURI) {\n              aOurBrowser.registeredOpenURI = aOtherBrowser.registeredOpenURI;\n              delete aOtherBrowser.registeredOpenURI;\n            }\n            if (tmp) {\n              aOtherBrowser.registeredOpenURI = tmp;\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"reloadAllTabs\">\n        <body>\n          <![CDATA[\n            let tabs = this.visibleTabs;\n            let l = tabs.length;\n            for (var i = 0; i < l; i++) {\n              try {\n                this.getBrowserForTab(tabs[i]).reload();\n              } catch (e) {\n                // ignore failure to reload so others will be reloaded\n              }\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"reloadTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n          <![CDATA[\n            let browser = this.getBrowserForTab(aTab);\n            // Reset temporary permissions on the current tab. This is done here\n            // because we only want to reset permissions on user reload.\n            SitePermissions.clearTemporaryPermissions(browser);\n            browser.reload();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"addProgressListener\">\n        <parameter name=\"aListener\"/>\n        <body>\n          <![CDATA[\n            if (arguments.length != 1) {\n              Components.utils.reportError(\"gBrowser.addProgressListener was \" +\n                                           \"called with a second argument, \" +\n                                           \"which is not supported. See bug \" +\n                                           \"608628. Call stack: \" + new Error().stack);\n            }\n\n            this.mProgressListeners.push(aListener);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeProgressListener\">\n        <parameter name=\"aListener\"/>\n        <body>\n          <![CDATA[\n            this.mProgressListeners =\n              this.mProgressListeners.filter(l => l != aListener);\n         ]]>\n        </body>\n      </method>\n\n      <method name=\"addTabsProgressListener\">\n        <parameter name=\"aListener\"/>\n        <body>\n          this.mTabsProgressListeners.push(aListener);\n        </body>\n      </method>\n\n      <method name=\"removeTabsProgressListener\">\n        <parameter name=\"aListener\"/>\n        <body>\n        <![CDATA[\n          this.mTabsProgressListeners =\n            this.mTabsProgressListeners.filter(l => l != aListener);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getBrowserForTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          return aTab.linkedBrowser;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"showOnlyTheseTabs\">\n        <parameter name=\"aTabs\"/>\n        <body>\n        <![CDATA[\n          for (let tab of this.tabs) {\n            if (aTabs.indexOf(tab) == -1)\n              this.hideTab(tab);\n            else\n              this.showTab(tab);\n          }\n\n          this.tabContainer._handleTabSelect(true);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"showTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          if (aTab.hidden) {\n            aTab.removeAttribute(\"hidden\");\n            this._visibleTabs = null; // invalidate cache\n\n            this.tabContainer.adjustTabstrip();\n\n            this.tabContainer._setPositionalAttributes();\n\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"TabShow\", true, false);\n            aTab.dispatchEvent(event);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"hideTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          if (!aTab.hidden && !aTab.pinned && !aTab.selected &&\n              !aTab.closing) {\n            aTab.setAttribute(\"hidden\", \"true\");\n            this._visibleTabs = null; // invalidate cache\n\n            this.tabContainer.adjustTabstrip();\n\n            this.tabContainer._setPositionalAttributes();\n\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"TabHide\", true, false);\n            aTab.dispatchEvent(event);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"selectTabAtIndex\">\n        <parameter name=\"aIndex\"/>\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          let tabs = this.visibleTabs;\n\n          // count backwards for aIndex < 0\n          if (aIndex < 0) {\n            aIndex += tabs.length;\n            // clamp at index 0 if still negative.\n            if (aIndex < 0)\n              aIndex = 0;\n          } else if (aIndex >= tabs.length) {\n            // clamp at right-most tab if out of range.\n            aIndex = tabs.length - 1;\n          }\n\n          this.selectedTab = tabs[aIndex];\n\n          if (aEvent) {\n            aEvent.preventDefault();\n            aEvent.stopPropagation();\n          }\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"selectedTab\">\n        <getter>\n          return this.mCurrentTab;\n        </getter>\n        <setter>\n          <![CDATA[\n          if (gNavToolbox.collapsed && !this._allowTabChange) {\n            return this.mTabBox.selectedTab;\n          }\n          // Update the tab\n          this.mTabBox.selectedTab = val;\n          return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedBrowser\"\n                onget=\"return this.mCurrentBrowser;\"\n                readonly=\"true\"/>\n\n      <field name=\"browsers\" readonly=\"true\">\n        <![CDATA[\n          // This defines a proxy which allows us to access browsers by\n          // index without actually creating a full array of browsers.\n          new Proxy([], {\n            has: (target, name) => {\n              if (typeof name == \"string\" && Number.isInteger(parseInt(name))) {\n                return (name in this.tabs);\n              }\n              return false;\n            },\n            get: (target, name) => {\n              if (name == \"length\") {\n                return this.tabs.length;\n              }\n              if (typeof name == \"string\" && Number.isInteger(parseInt(name))) {\n                if (!(name in this.tabs)) {\n                  return undefined;\n                }\n                return this.tabs[name].linkedBrowser;\n              }\n              return target[name];\n            }\n          });\n        ]]>\n      </field>\n\n      <!-- Moves a tab to a new browser window, unless it's already the only tab\n           in the current window, in which case this will do nothing. -->\n      <method name=\"replaceTabWithWindow\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aOptions\"/>\n        <body>\n          <![CDATA[\n            if (this.tabs.length == 1)\n              return null;\n\n            var options = \"chrome,dialog=no,all\";\n            for (var name in aOptions)\n              options += \",\" + name + \"=\" + aOptions[name];\n\n            // Play the tab closing animation to give immediate feedback while\n            // waiting for the new window to appear.\n            // content area when the docshells are swapped.\n            if (this.animationsEnabled) {\n              aTab.style.maxWidth = \"\"; // ensure that fade-out transition happens\n              aTab.removeAttribute(\"fadein\");\n            }\n\n            // tell a new window to take the \"dropped\" tab\n            return window.openDialog(getBrowserURL(), \"_blank\", options, aTab);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"moveTabTo\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aIndex\"/>\n        <parameter name=\"aKeepRelatedTabs\"/>\n        <body>\n        <![CDATA[\n          var oldPosition = aTab._tPos;\n          if (oldPosition == aIndex)\n            return;\n\n          // Don't allow mixing pinned and unpinned tabs.\n          if (aTab.pinned)\n            aIndex = Math.min(aIndex, this._numPinnedTabs - 1);\n          else\n            aIndex = Math.max(aIndex, this._numPinnedTabs);\n          if (oldPosition == aIndex)\n            return;\n\n          if (!aKeepRelatedTabs) {\n            this._lastRelatedTabMap = new WeakMap();\n          }\n\n          let wasFocused = (document.activeElement == this.mCurrentTab);\n\n          aIndex = aIndex < aTab._tPos ? aIndex : aIndex + 1;\n\n          // invalidate cache\n          this._visibleTabs = null;\n\n          // use .item() instead of [] because dragging to the end of the strip goes out of\n          // bounds: .item() returns null (so it acts like appendChild), but [] throws\n          this.tabContainer.insertBefore(aTab, this.tabs.item(aIndex));\n\n          for (let i = 0; i < this.tabs.length; i++) {\n            this.tabs[i]._tPos = i;\n            this.tabs[i]._selected = false;\n          }\n\n          // If we're in the midst of an async tab switch while calling\n          // moveTabTo, we can get into a case where _visuallySelected\n          // is set to true on two different tabs.\n          //\n          // What we want to do in moveTabTo is to remove logical selection\n          // from all tabs, and then re-add logical selection to mCurrentTab\n          // (and visual selection as well if we're not running with e10s, which\n          // setting _selected will do automatically).\n          //\n          // If we're running with e10s, then the visual selection will not\n          // be changed, which is fine, since if we weren't in the midst of a\n          // tab switch, the previously visually selected tab should still be\n          // correct, and if we are in the midst of a tab switch, then the async\n          // tab switcher will set the visually selected tab once the tab switch\n          // has completed.\n          this.mCurrentTab._selected = true;\n\n          if (wasFocused)\n            this.mCurrentTab.focus();\n\n          this.tabContainer._handleTabSelect(true);\n\n          if (aTab.pinned)\n            this.tabContainer._positionPinnedTabs();\n\n          this.tabContainer._setPositionalAttributes();\n\n          var evt = document.createEvent(\"UIEvents\");\n          evt.initUIEvent(\"TabMove\", true, false, window, oldPosition);\n          aTab.dispatchEvent(evt);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"moveTabForward\">\n        <body>\n          <![CDATA[\n            let nextTab = this.mCurrentTab.nextSibling;\n            while (nextTab && nextTab.hidden)\n              nextTab = nextTab.nextSibling;\n\n            if (nextTab)\n              this.moveTabTo(this.mCurrentTab, nextTab._tPos);\n            else if (this.arrowKeysShouldWrap)\n              this.moveTabToStart();\n          ]]>\n        </body>\n      </method>\n\n      <!-- Adopts a tab from another browser window, and inserts it at aIndex -->\n      <method name=\"adoptTab\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aIndex\"/>\n        <parameter name=\"aSelectTab\"/>\n        <body>\n        <![CDATA[\n          // Swap the dropped tab with a new one we create and then close\n          // it in the other window (making it seem to have moved between\n          // windows). We also ensure that the tab we create to swap into has\n          // the same remote type and process as the one we're swapping in.\n          // This makes sure we don't get a short-lived process for the new tab.\n          let linkedBrowser = aTab.linkedBrowser;\n          let params = { eventDetail: { adoptedTab: aTab },\n                         preferredRemoteType: linkedBrowser.remoteType,\n                         sameProcessAsFrameLoader: linkedBrowser.frameLoader,\n                         skipAnimation: true };\n          if (aTab.hasAttribute(\"usercontextid\")) {\n            // new tab must have the same usercontextid as the old one\n            params.userContextId = aTab.getAttribute(\"usercontextid\");\n          }\n          let newTab = this.addTab(\"about:blank\", params);\n          let newBrowser = this.getBrowserForTab(newTab);\n\n          // Stop the about:blank load.\n          newBrowser.stop();\n          // Make sure it has a docshell.\n          newBrowser.docShell;\n\n          let numPinned = this._numPinnedTabs;\n          if (aIndex < numPinned || (aTab.pinned && aIndex == numPinned)) {\n            this.pinTab(newTab);\n          }\n\n          this.moveTabTo(newTab, aIndex);\n\n          // We need to select the tab before calling swapBrowsersAndCloseOther\n          // so that window.content in chrome windows points to the right tab\n          // when pagehide/show events are fired. This is no longer necessary\n          // for any exiting browser code, but it may be necessary for add-on\n          // compatibility.\n          if (aSelectTab) {\n            this.selectedTab = newTab;\n          }\n\n          aTab.parentNode._finishAnimateTabMove();\n          this.swapBrowsersAndCloseOther(newTab, aTab);\n\n          if (aSelectTab) {\n            // Call updateCurrentBrowser to make sure the URL bar is up to date\n            // for our new tab after we've done swapBrowsersAndCloseOther.\n            this.updateCurrentBrowser(true);\n          }\n\n          return newTab;\n        ]]>\n        </body>\n      </method>\n\n\n      <method name=\"moveTabBackward\">\n        <body>\n          <![CDATA[\n            let previousTab = this.mCurrentTab.previousSibling;\n            while (previousTab && previousTab.hidden)\n              previousTab = previousTab.previousSibling;\n\n            if (previousTab)\n              this.moveTabTo(this.mCurrentTab, previousTab._tPos);\n            else if (this.arrowKeysShouldWrap)\n              this.moveTabToEnd();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"moveTabToStart\">\n        <body>\n          <![CDATA[\n            var tabPos = this.mCurrentTab._tPos;\n            if (tabPos > 0)\n              this.moveTabTo(this.mCurrentTab, 0);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"moveTabToEnd\">\n        <body>\n          <![CDATA[\n            var tabPos = this.mCurrentTab._tPos;\n            if (tabPos < this.browsers.length - 1)\n              this.moveTabTo(this.mCurrentTab, this.browsers.length - 1);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"moveTabOver\">\n        <parameter name=\"aEvent\"/>\n        <body>\n          <![CDATA[\n            var direction = window.getComputedStyle(this.parentNode).direction;\n            if ((direction == \"ltr\" && aEvent.keyCode == KeyEvent.DOM_VK_RIGHT) ||\n                (direction == \"rtl\" && aEvent.keyCode == KeyEvent.DOM_VK_LEFT))\n              this.moveTabForward();\n            else\n              this.moveTabBackward();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"duplicateTab\">\n        <parameter name=\"aTab\"/><!-- can be from a different window as well -->\n        <parameter name=\"aRestoreTabImmediately\"/><!-- can defer loading of the tab contents -->\n        <body>\n          <![CDATA[\n            return SessionStore.duplicateTab(window, aTab, 0, aRestoreTabImmediately);\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        List of browsers whose docshells must be active in order for print preview\n        to work.\n      -->\n      <field name=\"_printPreviewBrowsers\">\n        new Set()\n      </field>\n\n      <method name=\"activateBrowserForPrintPreview\">\n        <parameter name=\"aBrowser\"/>\n        <body>\n          <![CDATA[\n            this._printPreviewBrowsers.add(aBrowser);\n            if (this._switcher) {\n              this._switcher.activateBrowserForPrintPreview(aBrowser);\n            }\n            aBrowser.docShellIsActive = true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"deactivatePrintPreviewBrowsers\">\n        <body>\n          <![CDATA[\n            let browsers = this._printPreviewBrowsers;\n            this._printPreviewBrowsers = new Set();\n            for (let browser of browsers) {\n              browser.docShellIsActive = this.shouldActivateDocShell(browser);\n            }\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        Returns true if a given browser's docshell should be active.\n      -->\n      <method name=\"shouldActivateDocShell\">\n        <parameter name=\"aBrowser\"/>\n        <body>\n          <![CDATA[\n            if (this._switcher) {\n              return this._switcher.shouldActivateDocShell(aBrowser);\n            }\n            return (aBrowser == this.selectedBrowser &&\n                    window.windowState != window.STATE_MINIMIZED &&\n                    !window.isFullyOccluded) ||\n                   this._printPreviewBrowsers.has(aBrowser);\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        The tab switcher is responsible for asynchronously switching\n        tabs in e10s. It waits until the new tab is ready (i.e., the\n        layer tree is available) before switching to it. Then it\n        unloads the layer tree for the old tab.\n\n        The tab switcher is a state machine. For each tab, it\n        maintains state about whether the layer tree for the tab is\n        available, being loaded, being unloaded, or unavailable. It\n        also keeps track of the tab currently being displayed, the tab\n        it's trying to load, and the tab the user has asked to switch\n        to. The switcher object is created upon tab switch. It is\n        released when there are no pending tabs to load or unload.\n\n        The following general principles have guided the design:\n\n        1. We only request one layer tree at a time. If the user\n        switches to a different tab while waiting, we don't request\n        the new layer tree until the old tab has loaded or timed out.\n\n        2. If loading the layers for a tab times out, we show the\n        spinner and possibly request the layer tree for another tab if\n        the user has requested one.\n\n        3. We discard layer trees on a delay. This way, if the user is\n        switching among the same tabs frequently, we don't continually\n        load the same tabs.\n\n        It's important that we always show either the spinner or a tab\n        whose layers are available. Otherwise the compositor will draw\n        an entirely black frame, which is very jarring. To ensure this\n        never happens when switching away from a tab, we assume the\n        old tab might still be drawn until a MozAfterPaint event\n        occurs. Because layout and compositing happen asynchronously,\n        we don't have any other way of knowing when the switch\n        actually takes place. Therefore, we don't unload the old tab\n        until the next MozAfterPaint event.\n      -->\n      <field name=\"_switcher\">null</field>\n      <method name=\"_getSwitcher\">\n        <body><![CDATA[\n          if (this._switcher) {\n            return this._switcher;\n          }\n\n          let switcher = {\n            // How long to wait for a tab's layers to load. After this\n            // time elapses, we're free to put up the spinner and start\n            // trying to load a different tab.\n            TAB_SWITCH_TIMEOUT: 400 /* ms */,\n\n            // When the user hasn't switched tabs for this long, we unload\n            // layers for all tabs that aren't in use.\n            UNLOAD_DELAY: 300 /* ms */,\n\n            // The next three tabs form the principal state variables.\n            // See the assertions in postActions for their invariants.\n\n            // Tab the user requested most recently.\n            requestedTab: this.selectedTab,\n\n            // Tab we're currently trying to load.\n            loadingTab: null,\n\n            // We show this tab in case the requestedTab hasn't loaded yet.\n            lastVisibleTab: this.selectedTab,\n\n            // Auxilliary state variables:\n\n            visibleTab: this.selectedTab,   // Tab that's on screen.\n            spinnerTab: null,               // Tab showing a spinner.\n            blankTab: null,                 // Tab showing blank.\n            originalTab: this.selectedTab,  // Tab that we started on.\n\n            tabbrowser: this,  // Reference to gBrowser.\n            loadTimer: null,   // TAB_SWITCH_TIMEOUT nsITimer instance.\n            unloadTimer: null, // UNLOAD_DELAY nsITimer instance.\n\n            // Map from tabs to STATE_* (below).\n            tabState: new Map(),\n\n            // True if we're in the midst of switching tabs.\n            switchInProgress: false,\n\n            // Keep an exact list of content processes (tabParent) in which\n            // we're actively suppressing the display port. This gives a robust\n            // way to make sure we don't forget to un-suppress.\n            activeSuppressDisplayport: new Set(),\n\n            // Set of tabs that might be visible right now. We maintain\n            // this set because we can't be sure when a tab is actually\n            // drawn. A tab is added to this set when we ask to make it\n            // visible. All tabs but the most recently shown tab are\n            // removed from the set upon MozAfterPaint.\n            maybeVisibleTabs: new Set([this.selectedTab]),\n\n            // This holds onto the set of tabs that we've been asked to warm up.\n            // This is used only for Telemetry and logging, and (in order to not\n            // over-complicate the async tab switcher any further) has nothing to do\n            // with how warmed tabs are loaded and unloaded.\n            warmingTabs: new WeakSet(),\n\n            STATE_UNLOADED: 0,\n            STATE_LOADING: 1,\n            STATE_LOADED: 2,\n            STATE_UNLOADING: 3,\n\n            // re-entrancy guard:\n            _processing: false,\n\n            // Wraps nsITimer. Must not use the vanilla setTimeout and\n            // clearTimeout, because they will be blocked by nsIPromptService\n            // dialogs.\n            setTimer(callback, timeout) {\n              let event = {\n                notify: callback\n              };\n\n              var timer = Cc[\"@mozilla.org/timer;1\"]\n                .createInstance(Components.interfaces.nsITimer);\n              timer.initWithCallback(event, timeout, Ci.nsITimer.TYPE_ONE_SHOT);\n              return timer;\n            },\n\n            clearTimer(timer) {\n              timer.cancel();\n            },\n\n            getTabState(tab) {\n              let state = this.tabState.get(tab);\n              if (state === undefined) {\n                return this.STATE_UNLOADED;\n              }\n              return state;\n            },\n\n            setTabStateNoAction(tab, state) {\n              if (state == this.STATE_UNLOADED) {\n                this.tabState.delete(tab);\n              } else {\n                this.tabState.set(tab, state);\n              }\n            },\n\n            setTabState(tab, state) {\n              this.setTabStateNoAction(tab, state);\n\n              let browser = tab.linkedBrowser;\n              let {tabParent} = browser.frameLoader;\n              if (state == this.STATE_LOADING) {\n                this.assert(!this.minimizedOrFullyOccluded);\n                browser.docShellIsActive = true;\n                if (!tabParent) {\n                  this.onLayersReady(browser);\n                }\n              } else if (state == this.STATE_UNLOADING) {\n                this.unwarmTab(tab);\n                browser.docShellIsActive = false;\n                if (!tabParent) {\n                  this.onLayersCleared(browser);\n                }\n              }\n\n              if (!tab.linkedBrowser.isRemoteBrowser) {\n                // setTabState is potentially re-entrant in the non-remote case,\n                // so we must re-get the state for this assertion.\n                let nonRemoteState = this.getTabState(tab);\n                // Non-remote tabs can never stay in the STATE_LOADING\n                // or STATE_UNLOADING states. By the time this function\n                // exits, a non-remote tab must be in STATE_LOADED or\n                // STATE_UNLOADED, since the painting and the layer\n                // upload happen synchronously.\n                this.assert(nonRemoteState == this.STATE_UNLOADED ||\n                            nonRemoteState == this.STATE_LOADED);\n              }\n            },\n\n            get minimizedOrFullyOccluded() {\n              return window.windowState == window.STATE_MINIMIZED ||\n                     window.isFullyOccluded;\n            },\n\n            init() {\n              this.log(\"START\");\n\n              // If we minimized the window before the switcher was activated,\n              // we might have set  the preserveLayers flag for the current\n              // browser. Let's clear it.\n              this.tabbrowser.mCurrentBrowser.preserveLayers(false);\n\n              window.addEventListener(\"MozAfterPaint\", this);\n              window.addEventListener(\"MozLayerTreeReady\", this);\n              window.addEventListener(\"MozLayerTreeCleared\", this);\n              window.addEventListener(\"TabRemotenessChange\", this);\n              window.addEventListener(\"sizemodechange\", this);\n              window.addEventListener(\"occlusionstatechange\", this);\n              window.addEventListener(\"SwapDocShells\", this, true);\n              window.addEventListener(\"EndSwapDocShells\", this, true);\n\n              let tab = this.requestedTab;\n              let browser = tab.linkedBrowser;\n              let tabIsLoaded = !browser.isRemoteBrowser ||\n                                browser.frameLoader.tabParent.hasPresented;\n\n              if (!this.minimizedOrFullyOccluded) {\n                this.log(\"Initial tab is loaded?: \" + tabIsLoaded);\n                this.setTabState(tab, tabIsLoaded ? this.STATE_LOADED\n                                                  : this.STATE_LOADING);\n              }\n            },\n\n            destroy() {\n              if (this.unloadTimer) {\n                this.clearTimer(this.unloadTimer);\n                this.unloadTimer = null;\n              }\n              if (this.loadTimer) {\n                this.clearTimer(this.loadTimer);\n                this.loadTimer = null;\n              }\n\n              window.removeEventListener(\"MozAfterPaint\", this);\n              window.removeEventListener(\"MozLayerTreeReady\", this);\n              window.removeEventListener(\"MozLayerTreeCleared\", this);\n              window.removeEventListener(\"TabRemotenessChange\", this);\n              window.removeEventListener(\"sizemodechange\", this);\n              window.removeEventListener(\"occlusionstatechange\", this);\n              window.removeEventListener(\"SwapDocShells\", this, true);\n              window.removeEventListener(\"EndSwapDocShells\", this, true);\n\n              this.tabbrowser._switcher = null;\n\n              this.activeSuppressDisplayport.forEach(function(tabParent) {\n                tabParent.suppressDisplayport(false);\n              });\n              this.activeSuppressDisplayport.clear();\n            },\n\n            finish() {\n              this.log(\"FINISH\");\n\n              this.assert(this.tabbrowser._switcher);\n              this.assert(this.tabbrowser._switcher === this);\n              this.assert(!this.spinnerTab);\n              this.assert(!this.blankTab);\n              this.assert(!this.loadTimer);\n              this.assert(!this.loadingTab);\n              this.assert(this.lastVisibleTab === this.requestedTab);\n              this.assert(this.minimizedOrFullyOccluded ||\n                          this.getTabState(this.requestedTab) == this.STATE_LOADED);\n\n              this.destroy();\n\n              let toBrowser = this.requestedTab.linkedBrowser;\n              toBrowser.setAttribute(\"primary\", \"true\");\n\n              let fromBrowser = this.originalTab.linkedBrowser;\n              // It's possible that the tab we're switching from closed\n              // before we were able to finalize, in which case, fromBrowser\n              // doesn't exist.\n              if (fromBrowser) {\n                fromBrowser.removeAttribute(\"primary\");\n              }\n\n              document.commandDispatcher.unlock();\n\n              let event = new CustomEvent(\"TabSwitchDone\", {\n                bubbles: true,\n                cancelable: true\n              });\n              this.tabbrowser.dispatchEvent(event);\n            },\n\n            // This function is called after all the main state changes to\n            // make sure we display the right tab.\n            updateDisplay() {\n              let requestedTabState = this.getTabState(this.requestedTab);\n              let requestedBrowser = this.requestedTab.linkedBrowser;\n\n              // It is often more desirable to show a blank tab when appropriate than\n              // the tab switch spinner - especially since the spinner is usually\n              // preceded by a perceived lag of TAB_SWITCH_TIMEOUT ms in the\n              // tab switch. We can hide this lag, and hide the time being spent\n              // constructing TabChild's, layer trees, etc, by showing a blank\n              // tab instead and focusing it immediately.\n              let shouldBeBlank = false;\n              if (requestedBrowser.isRemoteBrowser) {\n                // If a tab is remote and the window is not minimized, we can show a\n                // blank tab instead of a spinner in the following cases:\n                //\n                // 1. The tab has just crashed, and we haven't started showing the\n                //    tab crashed page yet (in this case, the TabParent is null)\n                // 2. The tab has never presented, and has not finished loading\n                //    a non-local-about: page.\n                //\n                // For (2), \"finished loading a non-local-about: page\" is\n                // determined by the busy state on the tab element and checking\n                // if the loaded URI is local.\n                let hasSufficientlyLoaded =\n                  !this.requestedTab.hasAttribute(\"busy\") &&\n                  !this.tabbrowser._isLocalAboutURI(requestedBrowser.currentURI);\n\n                let fl = requestedBrowser.frameLoader;\n                shouldBeBlank = !this.minimizedOrFullyOccluded &&\n                                (!fl.tabParent ||\n                                 (!hasSufficientlyLoaded && !fl.tabParent.hasPresented));\n              }\n\n              this.log(\"Tab should be blank: \" + shouldBeBlank);\n              this.log(\"Requested tab is remote?: \" + requestedBrowser.isRemoteBrowser);\n\n              // Figure out which tab we actually want visible right now.\n              let showTab = null;\n              if (requestedTabState != this.STATE_LOADED &&\n                  this.lastVisibleTab && this.loadTimer && !shouldBeBlank) {\n                // If we can't show the requestedTab, and lastVisibleTab is\n                // available, show it.\n                showTab = this.lastVisibleTab;\n              } else {\n                // Show the requested tab. If it's not available, we'll show the spinner or a blank tab.\n                showTab = this.requestedTab;\n              }\n\n              // First, let's deal with blank tabs, which we show instead\n              // of the spinner when the tab is not currently set up\n              // properly in the content process.\n              if (!shouldBeBlank && this.blankTab) {\n                this.blankTab.linkedBrowser.removeAttribute(\"blank\");\n                this.blankTab = null;\n              } else if (shouldBeBlank && this.blankTab !== showTab) {\n                if (this.blankTab) {\n                  this.blankTab.linkedBrowser.removeAttribute(\"blank\");\n                }\n                this.blankTab = showTab;\n                this.blankTab.linkedBrowser.setAttribute(\"blank\", \"true\");\n              }\n\n              // Show or hide the spinner as needed.\n              let needSpinner = this.getTabState(showTab) != this.STATE_LOADED &&\n                                !this.minimizedOrFullyOccluded &&\n                                !shouldBeBlank;\n\n              if (!needSpinner && this.spinnerTab) {\n                this.spinnerHidden();\n                this.tabbrowser.removeAttribute(\"pendingpaint\");\n                this.spinnerTab.linkedBrowser.removeAttribute(\"pendingpaint\");\n                this.spinnerTab = null;\n              } else if (needSpinner && this.spinnerTab !== showTab) {\n                if (this.spinnerTab) {\n                  this.spinnerTab.linkedBrowser.removeAttribute(\"pendingpaint\");\n                } else {\n                  this.spinnerDisplayed();\n                }\n                this.spinnerTab = showTab;\n                this.tabbrowser.setAttribute(\"pendingpaint\", \"true\");\n                this.spinnerTab.linkedBrowser.setAttribute(\"pendingpaint\", \"true\");\n              }\n\n              // Switch to the tab we've decided to make visible.\n              if (this.visibleTab !== showTab) {\n                this.tabbrowser._adjustFocusBeforeTabSwitch(this.visibleTab, showTab);\n                this.visibleTab = showTab;\n\n                this.maybeVisibleTabs.add(showTab);\n\n                let tabs = this.tabbrowser.mTabBox.tabs;\n                let tabPanel = this.tabbrowser.mPanelContainer;\n                let showPanel = tabs.getRelatedElement(showTab);\n                let index = Array.indexOf(tabPanel.childNodes, showPanel);\n                if (index != -1) {\n                  this.log(`Switch to tab ${index} - ${this.tinfo(showTab)}`);\n                  tabPanel.setAttribute(\"selectedIndex\", index);\n                  if (showTab === this.requestedTab) {\n                    if (this._requestingTab) {\n                      /*\n                       * If _requestingTab is set, that means that we're switching the\n                       * visibility of the tab synchronously, and we need to wait for\n                       * the \"select\" event before shifting focus so that\n                       * _adjustFocusAfterTabSwitch runs with the right information for\n                       * the tab switch.\n                       */\n                      this.tabbrowser.addEventListener(\"select\", () => {\n                        this.tabbrowser._adjustFocusAfterTabSwitch(showTab);\n                      }, {once: true});\n                    } else {\n                      this.tabbrowser._adjustFocusAfterTabSwitch(showTab);\n                    }\n                  }\n                }\n\n                // This doesn't necessarily exist if we're a new window and haven't switched tabs yet\n                if (this.lastVisibleTab)\n                  this.lastVisibleTab._visuallySelected = false;\n\n                this.visibleTab._visuallySelected = true;\n              }\n\n              this.lastVisibleTab = this.visibleTab;\n            },\n\n            assert(cond) {\n              if (!cond) {\n                dump(\"Assertion failure\\n\" + Error().stack);\n\n                // Don't break a user's browser if an assertion fails.\n                if (AppConstants.DEBUG) {\n                  throw new Error(\"Assertion failure\");\n                }\n              }\n            },\n\n            // We've decided to try to load requestedTab.\n            loadRequestedTab() {\n              this.assert(!this.loadTimer);\n              this.assert(!this.minimizedOrFullyOccluded);\n\n              // loadingTab can be non-null here if we timed out loading the current tab.\n              // In that case we just overwrite it with a different tab; it's had its chance.\n              this.loadingTab = this.requestedTab;\n              this.log(\"Loading tab \" + this.tinfo(this.loadingTab));\n\n              this.loadTimer = this.setTimer(() => this.onLoadTimeout(), this.TAB_SWITCH_TIMEOUT);\n              this.setTabState(this.requestedTab, this.STATE_LOADING);\n            },\n\n            // This function runs before every event. It fixes up the state\n            // to account for closed tabs.\n            preActions() {\n              this.assert(this.tabbrowser._switcher);\n              this.assert(this.tabbrowser._switcher === this);\n\n              for (let [tab, ] of this.tabState) {\n                if (!tab.linkedBrowser) {\n                  this.tabState.delete(tab);\n                  this.unwarmTab(tab);\n                }\n              }\n\n              if (this.lastVisibleTab && !this.lastVisibleTab.linkedBrowser) {\n                this.lastVisibleTab = null;\n              }\n              if (this.blankTab && !this.blankTab.linkedBrowser) {\n                this.blankTab = null;\n              }\n              if (this.spinnerTab && !this.spinnerTab.linkedBrowser) {\n                this.spinnerHidden();\n                this.spinnerTab = null;\n              }\n              if (this.loadingTab && !this.loadingTab.linkedBrowser) {\n                this.loadingTab = null;\n                this.clearTimer(this.loadTimer);\n                this.loadTimer = null;\n              }\n            },\n\n            // This code runs after we've responded to an event or requested a new\n            // tab. It's expected that we've already updated all the principal\n            // state variables. This function takes care of updating any auxilliary\n            // state.\n            postActions() {\n              // Once we finish loading loadingTab, we null it out. So the state should\n              // always be LOADING.\n              this.assert(!this.loadingTab ||\n                          this.getTabState(this.loadingTab) == this.STATE_LOADING);\n\n              // We guarantee that loadingTab is non-null iff loadTimer is non-null. So\n              // the timer is set only when we're loading something.\n              this.assert(!this.loadTimer || this.loadingTab);\n              this.assert(!this.loadingTab || this.loadTimer);\n\n              // If we're switching to a non-remote tab, there's no need to wait\n              // for it to send layers to the compositor, as this will happen\n              // synchronously. Clearing this here means that in the next step,\n              // we can load the non-remote browser immediately.\n              if (!this.requestedTab.linkedBrowser.isRemoteBrowser) {\n                this.loadingTab = null;\n                if (this.loadTimer) {\n                  this.clearTimer(this.loadTimer);\n                  this.loadTimer = null;\n                }\n              }\n\n              // If we're not loading anything, try loading the requested tab.\n              let requestedState = this.getTabState(this.requestedTab);\n              if (!this.loadTimer && !this.minimizedOrFullyOccluded &&\n                  (requestedState == this.STATE_UNLOADED ||\n                   requestedState == this.STATE_UNLOADING)) {\n                this.loadRequestedTab();\n              }\n\n              // See how many tabs still have work to do.\n              let numPending = 0;\n              let numWarming = 0;\n              for (let [tab, state] of this.tabState) {\n                // Skip print preview browsers since they shouldn't affect tab switching.\n                if (this.tabbrowser._printPreviewBrowsers.has(tab.linkedBrowser)) {\n                  continue;\n                }\n\n                if (state == this.STATE_LOADED && tab !== this.requestedTab) {\n                  numPending++;\n\n                  if (tab !== this.visibleTab) {\n                    numWarming++;\n                  }\n                }\n                if (state == this.STATE_LOADING || state == this.STATE_UNLOADING) {\n                  numPending++;\n                }\n              }\n\n              this.updateDisplay();\n\n              // It's possible for updateDisplay to trigger one of our own event\n              // handlers, which might cause finish() to already have been called.\n              // Check for that before calling finish() again.\n              if (!this.tabbrowser._switcher) {\n                return;\n              }\n\n              this.maybeFinishTabSwitch();\n\n              if (numWarming > this.tabbrowser.tabWarmingMax) {\n                this.logState(\"Hit tabWarmingMax\");\n                if (this.unloadTimer) {\n                  this.clearTimer(this.unloadTimer);\n                }\n                this.unloadNonRequiredTabs();\n              }\n\n              if (numPending == 0) {\n                this.finish();\n              }\n\n              this.logState(\"done\");\n            },\n\n            // Fires when we're ready to unload unused tabs.\n            onUnloadTimeout() {\n              this.logState(\"onUnloadTimeout\");\n              this.preActions();\n              this.unloadTimer = null;\n\n              this.unloadNonRequiredTabs();\n\n              this.postActions();\n            },\n\n            // If there are any non-visible and non-requested tabs in\n            // STATE_LOADED, sets them to STATE_UNLOADING. Also queues\n            // up the unloadTimer to run onUnloadTimeout if there are still\n            // tabs in the process of unloading.\n            unloadNonRequiredTabs() {\n              this.warmingTabs = new WeakSet();\n              let numPending = 0;\n\n              // Unload any tabs that can be unloaded.\n              for (let [tab, state] of this.tabState) {\n                if (this.tabbrowser._printPreviewBrowsers.has(tab.linkedBrowser)) {\n                  continue;\n                }\n\n                if (state == this.STATE_LOADED &&\n                    !this.maybeVisibleTabs.has(tab) &&\n                    tab !== this.lastVisibleTab &&\n                    tab !== this.loadingTab &&\n                    tab !== this.requestedTab) {\n                  this.setTabState(tab, this.STATE_UNLOADING);\n                }\n\n                if (state != this.STATE_UNLOADED && tab !== this.requestedTab) {\n                  numPending++;\n                }\n              }\n\n              if (numPending) {\n                // Keep the timer going since there may be more tabs to unload.\n                this.unloadTimer = this.setTimer(() => this.onUnloadTimeout(), this.UNLOAD_DELAY);\n              }\n            },\n\n            // Fires when an ongoing load has taken too long.\n            onLoadTimeout() {\n              this.logState(\"onLoadTimeout\");\n              this.preActions();\n              this.loadTimer = null;\n              this.loadingTab = null;\n              this.postActions();\n            },\n\n            // Fires when the layers become available for a tab.\n            onLayersReady(browser) {\n              let tab = this.tabbrowser.getTabForBrowser(browser);\n              this.logState(`onLayersReady(${tab._tPos}, ${browser.isRemoteBrowser})`);\n\n              this.assert(this.getTabState(tab) == this.STATE_LOADING ||\n                          this.getTabState(tab) == this.STATE_LOADED);\n              this.setTabState(tab, this.STATE_LOADED);\n\n              if (this.loadingTab === tab) {\n                this.clearTimer(this.loadTimer);\n                this.loadTimer = null;\n                this.loadingTab = null;\n              }\n            },\n\n            // Fires when we paint the screen. Any tab switches we initiated\n            // previously are done, so there's no need to keep the old layers\n            // around.\n            onPaint() {\n              this.maybeVisibleTabs.clear();\n            },\n\n            // Called when we're done clearing the layers for a tab.\n            onLayersCleared(browser) {\n              let tab = this.tabbrowser.getTabForBrowser(browser);\n              if (tab) {\n                this.logState(`onLayersCleared(${tab._tPos})`);\n                this.assert(this.getTabState(tab) == this.STATE_UNLOADING ||\n                            this.getTabState(tab) == this.STATE_UNLOADED);\n                this.setTabState(tab, this.STATE_UNLOADED);\n              }\n            },\n\n            // Called when a tab switches from remote to non-remote. In this case\n            // a MozLayerTreeReady notification that we requested may never fire,\n            // so we need to simulate it.\n            onRemotenessChange(tab) {\n              this.logState(`onRemotenessChange(${tab._tPos}, ${tab.linkedBrowser.isRemoteBrowser})`);\n              if (!tab.linkedBrowser.isRemoteBrowser) {\n                if (this.getTabState(tab) == this.STATE_LOADING) {\n                  this.onLayersReady(tab.linkedBrowser);\n                } else if (this.getTabState(tab) == this.STATE_UNLOADING) {\n                  this.onLayersCleared(tab.linkedBrowser);\n                }\n              } else if (this.getTabState(tab) == this.STATE_LOADED) {\n                // A tab just changed from non-remote to remote, which means\n                // that it's gone back into the STATE_LOADING state until\n                // it sends up a layer tree.\n                this.setTabState(tab, this.STATE_LOADING);\n              }\n            },\n\n            // Called when a tab has been removed, and the browser node is\n            // about to be removed from the DOM.\n            onTabRemoved(tab) {\n              if (this.lastVisibleTab == tab) {\n                // The browser that was being presented to the user is\n                // going to be removed during this tick of the event loop.\n                // This will cause us to show a tab spinner instead.\n                this.preActions();\n                this.lastVisibleTab = null;\n                this.postActions();\n              }\n            },\n\n            onSizeModeOrOcclusionStateChange() {\n              if (this.minimizedOrFullyOccluded) {\n                for (let [tab, state] of this.tabState) {\n                  // Skip print preview browsers since they shouldn't affect tab switching.\n                  if (this.tabbrowser._printPreviewBrowsers.has(tab.linkedBrowser)) {\n                    continue;\n                  }\n\n                  if (state == this.STATE_LOADING || state == this.STATE_LOADED) {\n                    this.setTabState(tab, this.STATE_UNLOADING);\n                  }\n                }\n                if (this.loadTimer) {\n                  this.clearTimer(this.loadTimer);\n                  this.loadTimer = null;\n                }\n                this.loadingTab = null;\n              } else {\n                // Do nothing. We'll automatically start loading the requested tab in\n                // postActions.\n              }\n            },\n\n            onSwapDocShells(ourBrowser, otherBrowser) {\n              // This event fires before the swap. ourBrowser is from\n              // our window. We save the state of otherBrowser since ourBrowser\n              // needs to take on that state at the end of the swap.\n\n              let otherTabbrowser = otherBrowser.ownerGlobal.gBrowser;\n              let otherState;\n              if (otherTabbrowser && otherTabbrowser._switcher) {\n                let otherTab = otherTabbrowser.getTabForBrowser(otherBrowser);\n                let otherSwitcher = otherTabbrowser._switcher;\n                otherState = otherSwitcher.getTabState(otherTab);\n              } else {\n                otherState = (otherBrowser.docShellIsActive\n                              ? this.STATE_LOADED\n                              : this.STATE_UNLOADED);\n              }\n\n              if (!this.swapMap) {\n                this.swapMap = new WeakMap();\n              }\n              this.swapMap.set(otherBrowser, {\n                state: otherState,\n              });\n            },\n\n            onEndSwapDocShells(ourBrowser, otherBrowser) {\n              // The swap has happened. We reset the loadingTab in\n              // case it has been swapped. We also set ourBrowser's state\n              // to whatever otherBrowser's state was before the swap.\n\n              if (this.loadTimer) {\n                // Clearing the load timer means that we will\n                // immediately display a spinner if ourBrowser isn't\n                // ready yet. Typically it will already be ready\n                // though. If it's not, we're probably in a new window,\n                // in which case we have no other tabs to display anyway.\n                this.clearTimer(this.loadTimer);\n                this.loadTimer = null;\n              }\n              this.loadingTab = null;\n\n              let { state: otherState } = this.swapMap.get(otherBrowser);\n\n              this.swapMap.delete(otherBrowser);\n\n              let ourTab = this.tabbrowser.getTabForBrowser(ourBrowser);\n              if (ourTab) {\n                this.setTabStateNoAction(ourTab, otherState);\n              }\n            },\n\n            shouldActivateDocShell(browser) {\n              let tab = this.tabbrowser.getTabForBrowser(browser);\n              let state = this.getTabState(tab);\n              return state == this.STATE_LOADING || state == this.STATE_LOADED;\n            },\n\n            activateBrowserForPrintPreview(browser) {\n              let tab = this.tabbrowser.getTabForBrowser(browser);\n              this.setTabState(tab, this.STATE_LOADING);\n            },\n\n            canWarmTab(tab) {\n              if (!this.tabbrowser.tabWarmingEnabled) {\n                return false;\n              }\n\n              // If the tab is not yet inserted, closing, not remote,\n              // crashed, already visible, or already requested, warming\n              // up the tab makes no sense.\n              if (this.minimizedOrFullyOccluded ||\n                  !tab.linkedPanel ||\n                  tab.closing ||\n                  !tab.linkedBrowser.isRemoteBrowser ||\n                  !tab.linkedBrowser.frameLoader.tabParent) {\n                return false;\n              }\n\n              // Similarly, if the tab is already in STATE_LOADING or\n              // STATE_LOADED somehow, there's no point in trying to\n              // warm it up.\n              let state = this.getTabState(tab);\n              if (state === this.STATE_LOADING ||\n                  state === this.STATE_LOADED) {\n                return false;\n              }\n\n              return true;\n            },\n\n            unwarmTab(tab) {\n              this.warmingTabs.delete(tab);\n            },\n\n            warmupTab(tab) {\n              if (!this.canWarmTab(tab)) {\n                return;\n              }\n\n              this.logState(\"warmupTab \" + this.tinfo(tab));\n\n              this.warmingTabs.add(tab);\n              this.setTabState(tab, this.STATE_LOADING);\n              this.suppressDisplayPortAndQueueUnload(tab,\n                this.tabbrowser.tabWarmingUnloadDelay);\n            },\n\n            // Called when the user asks to switch to a given tab.\n            requestTab(tab) {\n              if (tab === this.requestedTab) {\n                return;\n              }\n\n              if (this.tabbrowser.tabWarmingEnabled) {\n                let warmingState = \"disqualified\";\n\n                if (this.warmingTabs.has(tab)) {\n                  let tabState = this.getTabState(tab);\n                  if (tabState == this.STATE_LOADING) {\n                    warmingState = \"stillLoading\";\n                  } else if (tabState == this.STATE_LOADED) {\n                    warmingState = \"loaded\";\n                  }\n                } else if (this.canWarmTab(tab)) {\n                  warmingState = \"notWarmed\";\n                }\n\n                Services.telemetry\n                        .getHistogramById(\"FX_TAB_SWITCH_REQUEST_TAB_WARMING_STATE\")\n                        .add(warmingState);\n\n                this.unwarmTab(tab);\n              }\n\n              this._requestingTab = true;\n              this.logState(\"requestTab \" + this.tinfo(tab));\n              this.startTabSwitch();\n\n              this.requestedTab = tab;\n\n              this.suppressDisplayPortAndQueueUnload(this.requestedTab, this.UNLOAD_DELAY);\n              this._requestingTab = false;\n            },\n\n            suppressDisplayPortAndQueueUnload(tab, unloadTimeout) {\n              let browser = tab.linkedBrowser;\n              let fl = browser.frameLoader;\n\n              if (fl && fl.tabParent && !this.activeSuppressDisplayport.has(fl.tabParent)) {\n                fl.tabParent.suppressDisplayport(true);\n                this.activeSuppressDisplayport.add(fl.tabParent);\n              }\n\n              this.preActions();\n\n              if (this.unloadTimer) {\n                this.clearTimer(this.unloadTimer);\n              }\n              this.unloadTimer = this.setTimer(() => this.onUnloadTimeout(), unloadTimeout);\n\n              this.postActions();\n            },\n\n            handleEvent(event, delayed = false) {\n              if (this._processing) {\n                this.setTimer(() => this.handleEvent(event, true), 0);\n                return;\n              }\n              if (delayed && this.tabbrowser._switcher != this) {\n                // if we delayed processing this event, we might be out of date, in which\n                // case we drop the delayed events\n                return;\n              }\n              this._processing = true;\n              this.preActions();\n\n              if (event.type == \"MozLayerTreeReady\") {\n                this.onLayersReady(event.originalTarget);\n              } if (event.type == \"MozAfterPaint\") {\n                this.onPaint();\n              } else if (event.type == \"MozLayerTreeCleared\") {\n                this.onLayersCleared(event.originalTarget);\n              } else if (event.type == \"TabRemotenessChange\") {\n                this.onRemotenessChange(event.target);\n              } else if (event.type == \"sizemodechange\" ||\n                         event.type == \"occlusionstatechange\") {\n                this.onSizeModeOrOcclusionStateChange();\n              } else if (event.type == \"SwapDocShells\") {\n                this.onSwapDocShells(event.originalTarget, event.detail);\n              } else if (event.type == \"EndSwapDocShells\") {\n                this.onEndSwapDocShells(event.originalTarget, event.detail);\n              }\n\n              this.postActions();\n              this._processing = false;\n            },\n\n            /*\n             * Telemetry and Profiler related helpers for recording tab switch\n             * timing.\n             */\n\n            startTabSwitch() {\n              TelemetryStopwatch.cancel(\"FX_TAB_SWITCH_TOTAL_E10S_MS\", window);\n              TelemetryStopwatch.start(\"FX_TAB_SWITCH_TOTAL_E10S_MS\", window);\n              this.addMarker(\"AsyncTabSwitch:Start\");\n              this.switchInProgress = true;\n            },\n\n            /**\n             * Something has occurred that might mean that we've completed\n             * the tab switch (layers are ready, paints are done, spinners\n             * are hidden). This checks to make sure all conditions are\n             * satisfied, and then records the tab switch as finished.\n             */\n            maybeFinishTabSwitch() {\n              if (this.switchInProgress && this.requestedTab &&\n                  (this.getTabState(this.requestedTab) == this.STATE_LOADED ||\n                   this.requestedTab === this.blankTab)) {\n                // After this point the tab has switched from the content thread's point of view.\n                // The changes will be visible after the next refresh driver tick + composite.\n                let time = TelemetryStopwatch.timeElapsed(\"FX_TAB_SWITCH_TOTAL_E10S_MS\", window);\n                if (time != -1) {\n                  TelemetryStopwatch.finish(\"FX_TAB_SWITCH_TOTAL_E10S_MS\", window);\n                  this.log(\"DEBUG: tab switch time = \" + time);\n                  this.addMarker(\"AsyncTabSwitch:Finish\");\n                }\n                this.switchInProgress = false;\n              }\n            },\n\n            spinnerDisplayed() {\n              this.assert(!this.spinnerTab);\n              let browser = this.requestedTab.linkedBrowser;\n              this.assert(browser.isRemoteBrowser);\n              TelemetryStopwatch.start(\"FX_TAB_SWITCH_SPINNER_VISIBLE_MS\", window);\n              // We have a second, similar probe for capturing recordings of\n              // when the spinner is displayed for very long periods.\n              TelemetryStopwatch.start(\"FX_TAB_SWITCH_SPINNER_VISIBLE_LONG_MS\", window);\n              this.addMarker(\"AsyncTabSwitch:SpinnerShown\");\n            },\n\n            spinnerHidden() {\n              this.assert(this.spinnerTab);\n              this.log(\"DEBUG: spinner time = \" +\n                       TelemetryStopwatch.timeElapsed(\"FX_TAB_SWITCH_SPINNER_VISIBLE_MS\", window));\n              TelemetryStopwatch.finish(\"FX_TAB_SWITCH_SPINNER_VISIBLE_MS\", window);\n              TelemetryStopwatch.finish(\"FX_TAB_SWITCH_SPINNER_VISIBLE_LONG_MS\", window);\n              this.addMarker(\"AsyncTabSwitch:SpinnerHidden\");\n              // we do not get a onPaint after displaying the spinner\n            },\n\n            addMarker(marker) {\n              if (Services.profiler) {\n                Services.profiler.AddMarker(marker);\n              }\n            },\n\n            /*\n             * Debug related logging for switcher.\n             */\n\n            _useDumpForLogging: false,\n            _logInit: false,\n\n            logging() {\n              if (this._useDumpForLogging)\n                return true;\n              if (this._logInit)\n                return this._shouldLog;\n              let result = Services.prefs.getBoolPref(\"browser.tabs.remote.logSwitchTiming\", false);\n              this._shouldLog = result;\n              this._logInit = true;\n              return this._shouldLog;\n            },\n\n            tinfo(tab) {\n              if (tab) {\n                return tab._tPos + \"(\" + tab.linkedBrowser.currentURI.spec + \")\";\n              }\n              return \"null\";\n            },\n\n            log(s) {\n              if (!this.logging())\n                return;\n              if (this._useDumpForLogging) {\n                dump(s + \"\\n\");\n              } else {\n                Services.console.logStringMessage(s);\n              }\n            },\n\n            logState(prefix) {\n              if (!this.logging())\n                return;\n\n              let accum = prefix + \" \";\n              for (let i = 0; i < this.tabbrowser.tabs.length; i++) {\n                let tab = this.tabbrowser.tabs[i];\n                let state = this.getTabState(tab);\n                let isWarming = this.warmingTabs.has(tab);\n\n                accum += i + \":\";\n                if (tab === this.lastVisibleTab) accum += \"V\";\n                if (tab === this.loadingTab) accum += \"L\";\n                if (tab === this.requestedTab) accum += \"R\";\n                if (tab === this.blankTab) accum += \"B\";\n                if (isWarming) accum += \"(W)\";\n                if (state == this.STATE_LOADED) accum += \"(+)\";\n                if (state == this.STATE_LOADING) accum += \"(+?)\";\n                if (state == this.STATE_UNLOADED) accum += \"(-)\";\n                if (state == this.STATE_UNLOADING) accum += \"(-?)\";\n                accum += \" \";\n              }\n              if (this._useDumpForLogging) {\n                dump(accum + \"\\n\");\n              } else {\n                Services.console.logStringMessage(accum);\n              }\n            },\n          };\n          this._switcher = switcher;\n          switcher.init();\n          return switcher;\n        ]]></body>\n      </method>\n\n      <method name=\"warmupTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n          <![CDATA[\n            if (gMultiProcessBrowser) {\n              this._getSwitcher().warmupTab(aTab);\n            }\n          ]]>\n        </body>\n      </method>\n\n      <!-- BEGIN FORWARDED BROWSER PROPERTIES.  IF YOU ADD A PROPERTY TO THE BROWSER ELEMENT\n           MAKE SURE TO ADD IT HERE AS WELL. -->\n      <property name=\"canGoBack\"\n                onget=\"return this.mCurrentBrowser.canGoBack;\"\n                readonly=\"true\"/>\n\n      <property name=\"canGoForward\"\n                onget=\"return this.mCurrentBrowser.canGoForward;\"\n                readonly=\"true\"/>\n\n      <method name=\"goBack\">\n        <body>\n          <![CDATA[\n            return this.mCurrentBrowser.goBack();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"goForward\">\n        <body>\n          <![CDATA[\n            return this.mCurrentBrowser.goForward();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"reload\">\n        <body>\n          <![CDATA[\n            return this.mCurrentBrowser.reload();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"reloadWithFlags\">\n        <parameter name=\"aFlags\"/>\n        <body>\n          <![CDATA[\n            return this.mCurrentBrowser.reloadWithFlags(aFlags);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"stop\">\n        <body>\n          <![CDATA[\n            return this.mCurrentBrowser.stop();\n          ]]>\n        </body>\n      </method>\n\n      <!-- throws exception for unknown schemes -->\n      <method name=\"loadURI\">\n        <parameter name=\"aURI\"/>\n        <parameter name=\"aReferrerURI\"/>\n        <parameter name=\"aCharset\"/>\n        <body>\n          <![CDATA[\n            return this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);\n          ]]>\n        </body>\n      </method>\n\n      <!-- throws exception for unknown schemes -->\n      <method name=\"loadURIWithFlags\">\n        <parameter name=\"aURI\"/>\n        <parameter name=\"aFlags\"/>\n        <parameter name=\"aReferrerURI\"/>\n        <parameter name=\"aCharset\"/>\n        <parameter name=\"aPostData\"/>\n        <body>\n          <![CDATA[\n            // Note - the callee understands both:\n            // (a) loadURIWithFlags(aURI, aFlags, ...)\n            // (b) loadURIWithFlags(aURI, { flags: aFlags, ... })\n            // Forwarding it as (a) here actually supports both (a) and (b),\n            // so you can call us either way too.\n            return this.mCurrentBrowser.loadURIWithFlags(aURI, aFlags, aReferrerURI, aCharset, aPostData);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"goHome\">\n        <body>\n          <![CDATA[\n            return this.mCurrentBrowser.goHome();\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"homePage\">\n        <getter>\n          <![CDATA[\n            return this.mCurrentBrowser.homePage;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            this.mCurrentBrowser.homePage = val;\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"gotoIndex\">\n        <parameter name=\"aIndex\"/>\n        <body>\n          <![CDATA[\n            return this.mCurrentBrowser.gotoIndex(aIndex);\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"currentURI\"\n                onget=\"return this.mCurrentBrowser.currentURI;\"\n                readonly=\"true\"/>\n\n      <property name=\"finder\"\n                onget=\"return this.mCurrentBrowser.finder\"\n                readonly=\"true\"/>\n\n      <property name=\"docShell\"\n                onget=\"return this.mCurrentBrowser.docShell\"\n                readonly=\"true\"/>\n\n      <property name=\"webNavigation\"\n                onget=\"return this.mCurrentBrowser.webNavigation\"\n                readonly=\"true\"/>\n\n      <property name=\"webBrowserFind\"\n                readonly=\"true\"\n                onget=\"return this.mCurrentBrowser.webBrowserFind\"/>\n\n      <property name=\"webProgress\"\n                readonly=\"true\"\n                onget=\"return this.mCurrentBrowser.webProgress\"/>\n\n      <property name=\"contentWindow\"\n                readonly=\"true\"\n                onget=\"return this.mCurrentBrowser.contentWindow\"/>\n\n      <property name=\"contentWindowAsCPOW\"\n                readonly=\"true\"\n                onget=\"return this.mCurrentBrowser.contentWindowAsCPOW\"/>\n\n      <property name=\"sessionHistory\"\n                onget=\"return this.mCurrentBrowser.sessionHistory;\"\n                readonly=\"true\"/>\n\n      <property name=\"markupDocumentViewer\"\n                onget=\"return this.mCurrentBrowser.markupDocumentViewer;\"\n                readonly=\"true\"/>\n\n      <property name=\"contentViewerEdit\"\n                onget=\"return this.mCurrentBrowser.contentViewerEdit;\"\n                readonly=\"true\"/>\n\n      <property name=\"contentDocument\"\n                onget=\"return this.mCurrentBrowser.contentDocument;\"\n                readonly=\"true\"/>\n\n      <property name=\"contentDocumentAsCPOW\"\n                onget=\"return this.mCurrentBrowser.contentDocumentAsCPOW;\"\n                readonly=\"true\"/>\n\n      <property name=\"contentTitle\"\n                onget=\"return this.mCurrentBrowser.contentTitle;\"\n                readonly=\"true\"/>\n\n      <property name=\"contentPrincipal\"\n                onget=\"return this.mCurrentBrowser.contentPrincipal;\"\n                readonly=\"true\"/>\n\n      <property name=\"securityUI\"\n                onget=\"return this.mCurrentBrowser.securityUI;\"\n                readonly=\"true\"/>\n\n      <property name=\"fullZoom\"\n                onget=\"return this.mCurrentBrowser.fullZoom;\"\n                onset=\"this.mCurrentBrowser.fullZoom = val;\"/>\n\n      <property name=\"textZoom\"\n                onget=\"return this.mCurrentBrowser.textZoom;\"\n                onset=\"this.mCurrentBrowser.textZoom = val;\"/>\n\n      <property name=\"isSyntheticDocument\"\n                onget=\"return this.mCurrentBrowser.isSyntheticDocument;\"\n                readonly=\"true\"/>\n\n      <method name=\"_handleKeyDownEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!aEvent.isTrusted) {\n            // Don't let untrusted events mess with tabs.\n            return;\n          }\n\n          if (aEvent.altKey)\n            return;\n\n          // Don't check if the event was already consumed because tab\n          // navigation should always work for better user experience.\n\n          if (aEvent.ctrlKey && aEvent.shiftKey && !aEvent.metaKey) {\n            switch (aEvent.keyCode) {\n              case aEvent.DOM_VK_PAGE_UP:\n                this.moveTabBackward();\n                aEvent.preventDefault();\n                return;\n              case aEvent.DOM_VK_PAGE_DOWN:\n                this.moveTabForward();\n                aEvent.preventDefault();\n                return;\n            }\n          }\n\n          if (AppConstants.platform != \"macosx\") {\n            if (aEvent.ctrlKey && !aEvent.shiftKey && !aEvent.metaKey &&\n                aEvent.keyCode == KeyEvent.DOM_VK_F4 &&\n                !this.mCurrentTab.pinned) {\n              this.removeCurrentTab({animate: true});\n              aEvent.preventDefault();\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_handleKeyPressEventMac\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!aEvent.isTrusted) {\n            // Don't let untrusted events mess with tabs.\n            return;\n          }\n\n          if (aEvent.altKey)\n            return;\n\n          if (AppConstants.platform == \"macosx\") {\n            if (!aEvent.metaKey)\n              return;\n\n            var offset = 1;\n            switch (aEvent.charCode) {\n              case \"}\".charCodeAt(0):\n                offset = -1;\n              case \"{\".charCodeAt(0):\n                if (window.getComputedStyle(this).direction == \"ltr\")\n                  offset *= -1;\n                this.tabContainer.advanceSelectedTab(offset, true);\n                aEvent.preventDefault();\n            }\n          }\n        ]]></body>\n      </method>\n\n      <property name=\"userTypedValue\"\n                onget=\"return this.mCurrentBrowser.userTypedValue;\"\n                onset=\"return this.mCurrentBrowser.userTypedValue = val;\"/>\n\n      <method name=\"createTooltip\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          event.stopPropagation();\n          var tab = document.tooltipNode;\n          if (tab.localName != \"tab\") {\n            event.preventDefault();\n            return;\n          }\n\n          let stringWithShortcut = (stringId, keyElemId) => {\n            let keyElem = document.getElementById(keyElemId);\n            let shortcut = ShortcutUtils.prettifyShortcut(keyElem);\n            return gTabBrowserBundle.formatStringFromName(stringId, [shortcut], 1);\n          };\n\n          var label;\n          if (tab.mOverCloseButton) {\n            label = tab.selected ?\n                    stringWithShortcut(\"tabs.closeSelectedTab.tooltip\", \"key_close\") :\n                    gTabBrowserBundle.GetStringFromName(\"tabs.closeTab.tooltip\");\n          } else if (tab._overPlayingIcon) {\n            let stringID;\n            if (tab.selected) {\n              stringID = tab.linkedBrowser.audioMuted ?\n                \"tabs.unmuteAudio.tooltip\" :\n                \"tabs.muteAudio.tooltip\";\n              label = stringWithShortcut(stringID, \"key_toggleMute\");\n            } else {\n              if (tab.hasAttribute(\"activemedia-blocked\")) {\n                stringID = \"tabs.unblockAudio.tooltip\";\n              } else {\n                stringID = tab.linkedBrowser.audioMuted ?\n                  \"tabs.unmuteAudio.background.tooltip\" :\n                  \"tabs.muteAudio.background.tooltip\";\n              }\n\n              label = gTabBrowserBundle.GetStringFromName(stringID);\n            }\n          } else {\n            label = tab._fullLabel || tab.getAttribute(\"label\");\n            if (AppConstants.NIGHTLY_BUILD &&\n                tab.linkedBrowser &&\n                tab.linkedBrowser.isRemoteBrowser &&\n                tab.linkedBrowser.frameLoader) {\n              label += \" (pid \" + tab.linkedBrowser.frameLoader.tabParent.osPid + \")\";\n            }\n            if (tab.userContextId) {\n              label = gTabBrowserBundle.formatStringFromName(\"tabs.containers.tooltip\", [label, ContextualIdentityService.getUserContextLabel(tab.userContextId)], 2);\n            }\n          }\n\n          event.target.setAttribute(\"label\", label);\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.type) {\n            case \"keydown\":\n              this._handleKeyDownEvent(aEvent);\n              break;\n            case \"keypress\":\n              this._handleKeyPressEventMac(aEvent);\n              break;\n            case \"sizemodechange\":\n            case \"occlusionstatechange\":\n              if (aEvent.target == window && !this._switcher) {\n                this.mCurrentBrowser.preserveLayers(\n                  window.windowState == window.STATE_MINIMIZED || window.isFullyOccluded);\n                this.mCurrentBrowser.docShellIsActive = this.shouldActivateDocShell(this.mCurrentBrowser);\n              }\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"receiveMessage\">\n        <parameter name=\"aMessage\"/>\n        <body><![CDATA[\n          let data = aMessage.data;\n          let browser = aMessage.target;\n\n          switch (aMessage.name) {\n            case \"DOMTitleChanged\": {\n              let tab = this.getTabForBrowser(browser);\n              if (!tab || tab.hasAttribute(\"pending\"))\n                return undefined;\n              let titleChanged = this.setTabTitle(tab);\n              if (titleChanged && !tab.selected && !tab.hasAttribute(\"busy\"))\n                tab.setAttribute(\"titlechanged\", \"true\");\n              break;\n            }\n            case \"DOMWindowClose\": {\n              if (this.tabs.length == 1) {\n                // We already did PermitUnload in the content process\n                // for this tab (the only one in the window). So we don't\n                // need to do it again for any tabs.\n                window.skipNextCanClose = true;\n                window.close();\n                return undefined;\n              }\n\n              let tab = this.getTabForBrowser(browser);\n              if (tab) {\n                // Skip running PermitUnload since it already happened in\n                // the content process.\n                this.removeTab(tab, {skipPermitUnload: true});\n              }\n              break;\n            }\n            case \"contextmenu\": {\n              openContextMenu(aMessage);\n              break;\n            }\n            case \"DOMWindowFocus\": {\n              let tab = this.getTabForBrowser(browser);\n              if (!tab)\n                return undefined;\n              this.selectedTab = tab;\n              window.focus();\n              break;\n            }\n            case \"Browser:Init\": {\n              let tab = this.getTabForBrowser(browser);\n              if (!tab)\n                return undefined;\n\n              this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);\n              browser.messageManager.sendAsyncMessage(\"Browser:AppTab\", { isAppTab: tab.pinned })\n              break;\n            }\n            case \"Browser:WindowCreated\": {\n              let tab = this.getTabForBrowser(browser);\n              if (tab && data.userContextId) {\n                ContextualIdentityService.telemetry(data.userContextId);\n                tab.setUserContextId(data.userContextId);\n              }\n\n              // We don't want to update the container icon and identifier if\n              // this is not the selected browser.\n              if (browser == gBrowser.selectedBrowser) {\n                updateUserContextUIIndicator();\n              }\n\n              break;\n            }\n            case \"Findbar:Keypress\": {\n              let tab = this.getTabForBrowser(browser);\n              // If the find bar for this tab is not yet alive, only initialize\n              // it if there's a possibility FindAsYouType will be used.\n              // There's no point in doing it for most random keypresses.\n              if (!this.isFindBarInitialized(tab) &&\n                data.shouldFastFind) {\n                let shouldFastFind = this._findAsYouType;\n                if (!shouldFastFind) {\n                  // Please keep in sync with toolkit/content/widgets/findbar.xml\n                  const FAYT_LINKS_KEY = \"'\";\n                  const FAYT_TEXT_KEY = \"/\";\n                  let charCode = data.fakeEvent.charCode;\n                  let key = charCode ? String.fromCharCode(charCode) : null;\n                  shouldFastFind = key == FAYT_LINKS_KEY || key == FAYT_TEXT_KEY;\n                }\n                if (shouldFastFind) {\n                  // Make sure we return the result.\n                  return this.getFindBar(tab).receiveMessage(aMessage);\n                }\n              }\n              break;\n            }\n            case \"RefreshBlocker:Blocked\": {\n              // The data object is expected to contain the following properties:\n              //  - URI (string)\n              //     The URI that a page is attempting to refresh or redirect to.\n              //  - delay (int)\n              //     The delay (in milliseconds) before the page was going to\n              //     reload or redirect.\n              //  - sameURI (bool)\n              //     true if we're refreshing the page. false if we're redirecting.\n              //  - outerWindowID (int)\n              //     The outerWindowID of the frame that requested the refresh or\n              //     redirect.\n\n              let brandBundle = document.getElementById(\"bundle_brand\");\n              let brandShortName = brandBundle.getString(\"brandShortName\");\n              let message =\n                gNavigatorBundle.getFormattedString(\"refreshBlocked.\" +\n                                                    (data.sameURI ? \"refreshLabel\"\n                                                                  : \"redirectLabel\"),\n                                                    [brandShortName]);\n\n              let notificationBox = this.getNotificationBox(browser);\n              let notification = notificationBox.getNotificationWithValue(\"refresh-blocked\");\n\n              if (notification) {\n                notification.label = message;\n              } else {\n                let refreshButtonText =\n                  gNavigatorBundle.getString(\"refreshBlocked.goButton\");\n                let refreshButtonAccesskey =\n                  gNavigatorBundle.getString(\"refreshBlocked.goButton.accesskey\");\n\n                let buttons = [{\n                  label: refreshButtonText,\n                  accessKey: refreshButtonAccesskey,\n                  callback() {\n                    if (browser.messageManager) {\n                      browser.messageManager.sendAsyncMessage(\"RefreshBlocker:Refresh\", data);\n                    }\n                  }\n                }];\n\n                notificationBox.appendNotification(message, \"refresh-blocked\",\n                                                   \"chrome://browser/skin/notification-icons/popup.svg\",\n                                                   notificationBox.PRIORITY_INFO_MEDIUM,\n                                                   buttons);\n              }\n              break;\n            }\n\n            case \"Prerender:Request\": {\n              let sendCancelPrerendering = () => {\n                browser.frameloader.messageManager.\n                  sendAsyncMessage(\"Prerender:Canceled\", { id: data.id });\n              };\n\n              let tab = this.getTabForBrowser(browser);\n              if (!tab) {\n                // No tab?\n                sendCancelPrerendering();\n                break;\n              }\n\n              if (tab.hidden) {\n                // Skip prerender on hidden tab.\n                sendCancelPrerendering();\n                break;\n              }\n\n              if (browser.canGoForward) {\n                // Skip prerender on history navigation as we don't support it\n                // yet. Remove this check once bug 1323650 is implemented.\n                sendCancelPrerendering();\n                break;\n              }\n\n              if (!data.href) {\n                // If we don't have data.href, loadOneTab will load about:blank\n                // which is meaningless for prerendering.\n                sendCancelPrerendering();\n                break;\n              }\n\n              let groupedSHistory = browser.frameLoader.ensureGroupedSHistory();\n\n              let newTab = this.loadOneTab(data.href, {\n                referrerURI: (data.referrer ? makeURI(data.referrer) : null),\n                referrerPolicy: Ci.nsIHttpChannel.REFERRER_POLICY_UNSET,\n                postData: null,\n                allowThirdPartyFixup: true,\n                relatedToCurrent: true,\n                isPrerendered: true,\n                triggeringPrincipal: Utils.deserializePrincipal(data.triggeringPrincipal),\n              });\n              let partialSHistory = newTab.linkedBrowser.frameLoader.partialSHistory;\n              groupedSHistory.addPrerenderingPartialSHistory(partialSHistory, data.id);\n              break;\n            }\n\n            case \"Prerender:Cancel\": {\n              let groupedSHistory = browser.frameLoader.groupedSHistory;\n              if (groupedSHistory) {\n                groupedSHistory.cancelPrerendering(data.id);\n              }\n              break;\n            }\n\n            case \"Prerender:Swap\": {\n              let frameloader = browser.frameLoader;\n              let groupedSHistory = browser.frameLoader.groupedSHistory;\n              if (groupedSHistory) {\n                groupedSHistory.activatePrerendering(data.id).then(\n                  () => frameloader.messageManager.sendAsyncMessage(\"Prerender:Swapped\", data),\n                  () => frameloader.messageManager.sendAsyncMessage(\"Prerender:Canceled\", data),\n                );\n              }\n              break;\n            }\n\n          }\n          return undefined;\n        ]]></body>\n      </method>\n\n      <method name=\"observe\">\n        <parameter name=\"aSubject\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aData\"/>\n        <body><![CDATA[\n          switch (aTopic) {\n            case \"contextual-identity-updated\": {\n              for (let tab of this.tabs) {\n                if (tab.getAttribute(\"usercontextid\") == aData) {\n                  ContextualIdentityService.setTabStyle(tab);\n                }\n              }\n              break;\n            }\n            case \"nsPref:changed\": {\n              // This is the only pref observed.\n              this._findAsYouType = Services.prefs.getBoolPref(\"accessibility.typeaheadfind\");\n              break;\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_updateNewTabVisibility\">\n        <body><![CDATA[\n          let sib = this.tabContainer.nextElementSibling;\n          while (sib && sib.hidden) {\n            sib = sib.nextElementSibling;\n          }\n          const kAttr = \"hasadjacentnewtabbutton\";\n          if (sib && sib.id == \"new-tab-button\") {\n            this.tabContainer.setAttribute(kAttr, \"true\");\n          } else {\n            this.tabContainer.removeAttribute(kAttr);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onWidgetAfterDOMChange\">\n        <parameter name=\"aNode\"/>\n        <parameter name=\"aNextNode\"/>\n        <parameter name=\"aContainer\"/>\n        <body><![CDATA[\n          if (aContainer.ownerDocument == document &&\n              aContainer.id == \"TabsToolbar\") {\n            this._updateNewTabVisibility();\n          }\n        ]]></body>\n      </method>\n      <method name=\"onAreaNodeRegistered\">\n        <parameter name=\"aArea\"/>\n        <parameter name=\"aContainer\"/>\n        <body><![CDATA[\n          if (aContainer.ownerDocument == document &&\n              aArea == \"TabsToolbar\") {\n            this._updateNewTabVisibility();\n          }\n        ]]></body>\n      </method>\n      <method name=\"onAreaReset\">\n        <parameter name=\"aArea\"/>\n        <parameter name=\"aContainer\"/>\n        <body><![CDATA[\n          this.onAreaNodeRegistered(aArea, aContainer);\n        ]]></body>\n      </method>\n\n      <field name=\"_tabMinWidthLimit\">50</field>\n      <property name=\"tabMinWidth\">\n        <setter><![CDATA[\n          let root = document.documentElement;\n          root.style.setProperty(\"--tab-min-width\", val + \"px\");\n          return val;\n        ]]></setter>\n      </property>\n\n      <constructor>\n        <![CDATA[\n          this.mCurrentBrowser = document.getAnonymousElementByAttribute(this, \"anonid\", \"initialBrowser\");\n          this.mCurrentBrowser.permanentKey = {};\n\n          CustomizableUI.addListener(this);\n          this._updateNewTabVisibility();\n\n          Services.obs.addObserver(this, \"contextual-identity-updated\");\n\n          this.mCurrentTab = this.tabContainer.firstChild;\n          const nsIEventListenerService =\n            Components.interfaces.nsIEventListenerService;\n          let els = Components.classes[\"@mozilla.org/eventlistenerservice;1\"]\n                              .getService(nsIEventListenerService);\n          els.addSystemEventListener(document, \"keydown\", this, false);\n          if (AppConstants.platform == \"macosx\") {\n            els.addSystemEventListener(document, \"keypress\", this, false);\n          }\n          window.addEventListener(\"sizemodechange\", this);\n          window.addEventListener(\"occlusionstatechange\", this);\n\n          var uniqueId = this._generateUniquePanelID();\n          this.mPanelContainer.childNodes[0].id = uniqueId;\n          this.mCurrentTab.linkedPanel = uniqueId;\n          this.mCurrentTab.permanentKey = this.mCurrentBrowser.permanentKey;\n          this.mCurrentTab._tPos = 0;\n          this.mCurrentTab._fullyOpen = true;\n          this.mCurrentTab.linkedBrowser = this.mCurrentBrowser;\n          this._tabForBrowser.set(this.mCurrentBrowser, this.mCurrentTab);\n\n          // set up the shared autoscroll popup\n          this._autoScrollPopup = this.mCurrentBrowser._createAutoScrollPopup();\n          this._autoScrollPopup.id = \"autoscroller\";\n          this.appendChild(this._autoScrollPopup);\n          this.mCurrentBrowser.setAttribute(\"autoscrollpopup\", this._autoScrollPopup.id);\n          this.mCurrentBrowser.droppedLinkHandler = handleDroppedLink;\n\n          // Hook up the event listeners to the first browser\n          var tabListener = this.mTabProgressListener(this.mCurrentTab, this.mCurrentBrowser, true, false);\n          const nsIWebProgress = Components.interfaces.nsIWebProgress;\n          const filter = Components.classes[\"@mozilla.org/appshell/component/browser-status-filter;1\"]\n                                   .createInstance(nsIWebProgress);\n          filter.addProgressListener(tabListener, nsIWebProgress.NOTIFY_ALL);\n          this._tabListeners.set(this.mCurrentTab, tabListener);\n          this._tabFilters.set(this.mCurrentTab, filter);\n          this.webProgress.addProgressListener(filter, nsIWebProgress.NOTIFY_ALL);\n\n          if (Services.prefs.getBoolPref(\"browser.display.use_system_colors\"))\n            this.style.backgroundColor = \"-moz-default-background-color\";\n\n          let messageManager = window.getGroupMessageManager(\"browsers\");\n\n          let remote = window.QueryInterface(Ci.nsIInterfaceRequestor)\n            .getInterface(Ci.nsIWebNavigation)\n            .QueryInterface(Ci.nsILoadContext)\n            .useRemoteTabs;\n          if (remote) {\n            messageManager.addMessageListener(\"DOMTitleChanged\", this);\n            messageManager.addMessageListener(\"DOMWindowClose\", this);\n            window.messageManager.addMessageListener(\"contextmenu\", this);\n            messageManager.addMessageListener(\"Browser:Init\", this);\n\n            // If this window has remote tabs, switch to our tabpanels fork\n            // which does asynchronous tab switching.\n            this.mPanelContainer.classList.add(\"tabbrowser-tabpanels\");\n          } else {\n            this._outerWindowIDBrowserMap.set(this.mCurrentBrowser.outerWindowID,\n                                              this.mCurrentBrowser);\n          }\n          messageManager.addMessageListener(\"DOMWindowFocus\", this);\n          messageManager.addMessageListener(\"RefreshBlocker:Blocked\", this);\n          messageManager.addMessageListener(\"Browser:WindowCreated\", this);\n\n          // To correctly handle keypresses for potential FindAsYouType, while\n          // the tab's find bar is not yet initialized.\n          this._findAsYouType = Services.prefs.getBoolPref(\"accessibility.typeaheadfind\");\n          Services.prefs.addObserver(\"accessibility.typeaheadfind\", this);\n          messageManager.addMessageListener(\"Findbar:Keypress\", this);\n\n          // Add listeners for prerender messages\n          messageManager.addMessageListener(\"Prerender:Request\", this);\n          messageManager.addMessageListener(\"Prerender:Cancel\", this);\n          messageManager.addMessageListener(\"Prerender:Swap\", this);\n\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"animationsEnabled\",\n                                                \"toolkit.cosmeticAnimations.enabled\", true);\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"tabWarmingEnabled\",\n                                                \"browser.tabs.remote.warmup.enabled\", false);\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"tabWarmingMax\",\n                                                \"browser.tabs.remote.warmup.maxTabs\", 3);\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"tabWarmingUnloadDelay\" /* ms */,\n                                                \"browser.tabs.remote.warmup.unloadDelayMs\", 2000);\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"tabMinWidthPref\",\n                                                \"browser.tabs.tabMinWidth\", this._tabMinWidthLimit,\n            (pref, prevValue, newValue) => this.tabMinWidth = newValue,\n            newValue => Math.max(newValue, this._tabMinWidthLimit),\n          );\n\n          this.tabMinWidth = this.tabMinWidthPref;\n        ]]>\n      </constructor>\n\n      <method name=\"_generateUniquePanelID\">\n        <body><![CDATA[\n          if (!this._uniquePanelIDCounter) {\n            this._uniquePanelIDCounter = 0;\n          }\n\n          let outerID = window.QueryInterface(Ci.nsIInterfaceRequestor)\n                              .getInterface(Ci.nsIDOMWindowUtils)\n                              .outerWindowID;\n\n          // We want panel IDs to be globally unique, that's why we include the\n          // window ID. We switched to a monotonic counter as Date.now() lead\n          // to random failures because of colliding IDs.\n          return \"panel-\" + outerID + \"-\" + (++this._uniquePanelIDCounter);\n        ]]></body>\n      </method>\n\n      <destructor>\n        <![CDATA[\n          Services.obs.removeObserver(this, \"contextual-identity-updated\");\n\n          CustomizableUI.removeListener(this);\n\n          for (let tab of this.tabs) {\n            let browser = tab.linkedBrowser;\n            if (browser.registeredOpenURI) {\n              this._unifiedComplete.unregisterOpenPage(browser.registeredOpenURI,\n                                                       browser.getAttribute(\"usercontextid\") || 0);\n              delete browser.registeredOpenURI;\n            }\n\n            let filter = this._tabFilters.get(tab);\n            if (filter) {\n              browser.webProgress.removeProgressListener(filter);\n\n              let listener = this._tabListeners.get(tab);\n              if (listener) {\n                filter.removeProgressListener(listener);\n                listener.destroy();\n              }\n\n              this._tabFilters.delete(tab);\n              this._tabListeners.delete(tab);\n            }\n          }\n          const nsIEventListenerService =\n            Components.interfaces.nsIEventListenerService;\n          let els = Components.classes[\"@mozilla.org/eventlistenerservice;1\"]\n                              .getService(nsIEventListenerService);\n          els.removeSystemEventListener(document, \"keydown\", this, false);\n          if (AppConstants.platform == \"macosx\") {\n            els.removeSystemEventListener(document, \"keypress\", this, false);\n          }\n          window.removeEventListener(\"sizemodechange\", this);\n          window.removeEventListener(\"occlusionstatechange\", this);\n\n          if (gMultiProcessBrowser) {\n            let messageManager = window.getGroupMessageManager(\"browsers\");\n            messageManager.removeMessageListener(\"DOMTitleChanged\", this);\n            window.messageManager.removeMessageListener(\"contextmenu\", this);\n\n            if (this._switcher) {\n              this._switcher.destroy();\n            }\n          }\n\n          Services.prefs.removeObserver(\"accessibility.typeaheadfind\", this);\n        ]]>\n      </destructor>\n\n      <field name=\"_soundPlayingAttrRemovalTimer\">0</field>\n      <field name=\"_hoverTabTimer\">null</field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"DOMWindowClose\" phase=\"capturing\">\n        <![CDATA[\n          if (!event.isTrusted)\n            return;\n\n          if (this.tabs.length == 1) {\n            // We already did PermitUnload in nsGlobalWindow::Close\n            // for this tab. There are no other tabs we need to do\n            // PermitUnload for.\n            window.skipNextCanClose = true;\n            return;\n          }\n\n          var tab = this._getTabForContentWindow(event.target);\n          if (tab) {\n            // Skip running PermitUnload since it already happened.\n            this.removeTab(tab, {skipPermitUnload: true});\n            event.preventDefault();\n          }\n        ]]>\n      </handler>\n      <handler event=\"DOMWillOpenModalDialog\" phase=\"capturing\">\n        <![CDATA[\n          if (!event.isTrusted)\n            return;\n\n          let targetIsWindow = event.target instanceof Window;\n\n          // We're about to open a modal dialog, so figure out for which tab:\n          // If this is a same-process modal dialog, then we're given its DOM\n          // window as the event's target. For remote dialogs, we're given the\n          // browser, but that's in the originalTarget and not the target,\n          // because it's across the tabbrowser's XBL boundary.\n          let tabForEvent = targetIsWindow ?\n                            this._getTabForContentWindow(event.target.top) :\n                            this.getTabForBrowser(event.originalTarget);\n\n          // Focus window for beforeunload dialog so it is seen but don't\n          // steal focus from other applications.\n          if (event.detail &&\n              event.detail.tabPrompt &&\n              event.detail.inPermitUnload &&\n              Services.focus.activeWindow)\n            window.focus();\n\n          // Don't need to act if the tab is already selected or if there isn't\n          // a tab for the event (e.g. for the webextensions options_ui remote\n          // browsers embedded in the \"about:addons\" page):\n          if (!tabForEvent || tabForEvent.selected)\n            return;\n\n          // We always switch tabs for beforeunload tab-modal prompts.\n          if (event.detail &&\n              event.detail.tabPrompt &&\n              !event.detail.inPermitUnload) {\n            let docPrincipal = targetIsWindow ? event.target.document.nodePrincipal : null;\n            // At least one of these should/will be non-null:\n            let promptPrincipal = event.detail.promptPrincipal || docPrincipal ||\n                                  tabForEvent.linkedBrowser.contentPrincipal;\n            // For null principals, we bail immediately and don't show the checkbox:\n            if (!promptPrincipal || promptPrincipal.isNullPrincipal) {\n              tabForEvent.setAttribute(\"attention\", \"true\");\n              return;\n            }\n\n            // For non-system/expanded principals, we bail and show the checkbox\n            if (promptPrincipal.URI &&\n                !Services.scriptSecurityManager.isSystemPrincipal(promptPrincipal)) {\n              let permission = Services.perms.testPermissionFromPrincipal(promptPrincipal,\n                                                                          \"focus-tab-by-prompt\");\n              if (permission != Services.perms.ALLOW_ACTION) {\n                // Tell the prompt box we want to show the user a checkbox:\n                let tabPrompt = this.getTabModalPromptBox(tabForEvent.linkedBrowser);\n                tabPrompt.onNextPromptShowAllowFocusCheckboxFor(promptPrincipal);\n                tabForEvent.setAttribute(\"attention\", \"true\");\n                return;\n              }\n            }\n            // ... so system and expanded principals, as well as permitted \"normal\"\n            // URI-based principals, always get to steal focus for the tab when prompting.\n          }\n\n          // If permissions/origins dictate so, bring tab to the front.\n          this.selectedTab = tabForEvent;\n        ]]>\n      </handler>\n      <handler event=\"DOMTitleChanged\">\n        <![CDATA[\n          if (!event.isTrusted)\n            return;\n\n          var contentWin = event.target.defaultView;\n          if (contentWin != contentWin.top)\n            return;\n\n          var tab = this._getTabForContentWindow(contentWin);\n          if (!tab || tab.hasAttribute(\"pending\"))\n            return;\n\n          var titleChanged = this.setTabTitle(tab);\n          if (titleChanged && !tab.selected && !tab.hasAttribute(\"busy\"))\n            tab.setAttribute(\"titlechanged\", \"true\");\n        ]]>\n      </handler>\n      <handler event=\"oop-browser-crashed\">\n        <![CDATA[\n          if (!event.isTrusted)\n            return;\n\n          let browser = event.originalTarget;\n\n          // Preloaded browsers do not actually have any tabs. If one crashes,\n          // it should be released and removed.\n          if (browser === this._preloadedBrowser) {\n            this.removePreloadedBrowser();\n            return;\n          }\n\n          let icon = browser.mIconURL;\n          let tab = this.getTabForBrowser(browser);\n\n          if (this.selectedBrowser == browser) {\n            TabCrashHandler.onSelectedBrowserCrash(browser);\n          } else {\n            this.updateBrowserRemoteness(browser, false);\n            SessionStore.reviveCrashedTab(tab);\n          }\n\n          tab.removeAttribute(\"soundplaying\");\n          this.setIcon(tab, icon, browser.contentPrincipal, browser.contentRequestContextID);\n        ]]>\n      </handler>\n      <handler event=\"DOMAudioPlaybackStarted\">\n        <![CDATA[\n          var tab = this.getTabFromAudioEvent(event)\n          if (!tab) {\n            return;\n          }\n\n          clearTimeout(tab._soundPlayingAttrRemovalTimer);\n          tab._soundPlayingAttrRemovalTimer = 0;\n\n          let modifiedAttrs = [];\n          if (tab.hasAttribute(\"soundplaying-scheduledremoval\")) {\n            tab.removeAttribute(\"soundplaying-scheduledremoval\");\n            modifiedAttrs.push(\"soundplaying-scheduledremoval\");\n          }\n\n          if (!tab.hasAttribute(\"soundplaying\")) {\n            tab.setAttribute(\"soundplaying\", true);\n            modifiedAttrs.push(\"soundplaying\");\n          }\n\n          if (modifiedAttrs.length) {\n            // Flush style so that the opacity takes effect immediately, in\n            // case the media is stopped before the style flushes naturally.\n            getComputedStyle(tab).opacity;\n          }\n\n          this._tabAttrModified(tab, modifiedAttrs);\n        ]]>\n      </handler>\n      <handler event=\"DOMAudioPlaybackStopped\">\n        <![CDATA[\n          var tab = this.getTabFromAudioEvent(event)\n          if (!tab) {\n            return;\n          }\n\n          if (tab.hasAttribute(\"soundplaying\")) {\n            let removalDelay = Services.prefs.getIntPref(\"browser.tabs.delayHidingAudioPlayingIconMS\");\n\n            tab.style.setProperty(\"--soundplaying-removal-delay\", `${removalDelay - 300}ms`);\n            tab.setAttribute(\"soundplaying-scheduledremoval\", \"true\");\n            this._tabAttrModified(tab, [\"soundplaying-scheduledremoval\"]);\n\n            tab._soundPlayingAttrRemovalTimer = setTimeout(() => {\n              tab.removeAttribute(\"soundplaying-scheduledremoval\");\n              tab.removeAttribute(\"soundplaying\");\n              this._tabAttrModified(tab, [\"soundplaying\", \"soundplaying-scheduledremoval\"]);\n            }, removalDelay);\n          }\n        ]]>\n      </handler>\n      <handler event=\"DOMAudioPlaybackBlockStarted\">\n        <![CDATA[\n          var tab = this.getTabFromAudioEvent(event)\n          if (!tab) {\n            return;\n          }\n\n          if (!tab.hasAttribute(\"activemedia-blocked\")) {\n            tab.setAttribute(\"activemedia-blocked\", true);\n            this._tabAttrModified(tab, [\"activemedia-blocked\"]);\n            tab.startMediaBlockTimer();\n          }\n        ]]>\n      </handler>\n      <handler event=\"DOMAudioPlaybackBlockStopped\">\n        <![CDATA[\n          var tab = this.getTabFromAudioEvent(event)\n          if (!tab) {\n            return;\n          }\n\n          if (tab.hasAttribute(\"activemedia-blocked\")) {\n            tab.removeAttribute(\"activemedia-blocked\");\n            this._tabAttrModified(tab, [\"activemedia-blocked\"]);\n            let hist = Services.telemetry.getHistogramById(\"TAB_AUDIO_INDICATOR_USED\");\n            hist.add(2 /* unblockByVisitingTab */);\n            tab.finishMediaBlockTimer();\n          }\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"tabbrowser-arrowscrollbox\" extends=\"chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll\">\n    <implementation>\n      <!-- Override scrollbox.xml method, since our scrollbox's children are\n           inherited from the binding parent -->\n      <method name=\"_getScrollableElements\">\n        <body><![CDATA[\n          return Array.filter(document.getBindingParent(this).childNodes,\n                              this._canScrollToElement, this);\n        ]]></body>\n      </method>\n      <method name=\"_canScrollToElement\">\n        <parameter name=\"tab\"/>\n        <body><![CDATA[\n          return !tab.pinned && !tab.hidden;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"underflow\" phase=\"capturing\"><![CDATA[\n        if (event.originalTarget != this._scrollbox)\n          return;\n\n        // Ignore vertical events\n        if (event.detail == 0)\n          return;\n\n        var tabs = document.getBindingParent(this);\n        tabs.removeAttribute(\"overflow\");\n\n        if (tabs._lastTabClosedByMouse)\n          tabs._expandSpacerBy(this._scrollButtonDown.clientWidth);\n\n        for (let tab of Array.from(tabs.tabbrowser._removingTabs))\n          tabs.tabbrowser.removeTab(tab);\n\n        tabs._positionPinnedTabs();\n      ]]></handler>\n      <handler event=\"overflow\"><![CDATA[\n        if (event.originalTarget != this._scrollbox)\n          return;\n\n        // Ignore vertical events\n        if (event.detail == 0)\n          return;\n\n        var tabs = document.getBindingParent(this);\n        tabs.setAttribute(\"overflow\", \"true\");\n        tabs._positionPinnedTabs();\n        tabs._handleTabSelect(true);\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"tabbrowser-tabs\"\n           extends=\"chrome://global/content/bindings/tabbox.xml#tabs\">\n    <resources>\n      <stylesheet src=\"chrome://browser/content/tabbrowser.css\"/>\n    </resources>\n\n    <content>\n      <xul:hbox class=\"tab-drop-indicator-box\">\n        <xul:image class=\"tab-drop-indicator\" anonid=\"tab-drop-indicator\" collapsed=\"true\"/>\n      </xul:hbox>\n      <xul:arrowscrollbox anonid=\"arrowscrollbox\" orient=\"horizontal\" flex=\"1\"\n                          style=\"min-width: 1px;\"\n                          class=\"tabbrowser-arrowscrollbox\">\n<!--\n This is a hack to circumvent bug 472020, otherwise the tabs show up on the\n right of the newtab button.\n-->\n        <children includes=\"tab\"/>\n<!--\n  This is to ensure anything extensions put here will go before the newtab\n  button, necessary due to the previous hack.\n-->\n        <children/>\n        <xul:toolbarbutton class=\"tabs-newtab-button toolbarbutton-1\"\n                           anonid=\"tabs-newtab-button\"\n                           command=\"cmd_newNavigatorTab\"\n                           onclick=\"checkForMiddleClick(this, event);\"\n                           tooltip=\"dynamic-shortcut-tooltip\"/>\n        <xul:hbox class=\"restore-tabs-button-wrapper\"\n                  anonid=\"restore-tabs-button-wrapper\">\n          <xul:toolbarbutton anonid=\"restore-tabs-button\"\n                             class=\"restore-tabs-button\"\n                             onclick=\"SessionStore.restoreLastSession();\"/>\n        </xul:hbox>\n\n        <xul:spacer class=\"closing-tabs-spacer\" anonid=\"closing-tabs-spacer\"\n                    style=\"width: 0;\"/>\n      </xul:arrowscrollbox>\n    </content>\n\n    <implementation implements=\"nsIDOMEventListener, nsIObserver\">\n      <constructor>\n        <![CDATA[\n          this.mTabClipWidth = Services.prefs.getIntPref(\"browser.tabs.tabClipWidth\");\n\n          let { restoreTabsButton } = this;\n          restoreTabsButton.setAttribute(\"label\", gTabBrowserBundle.GetStringFromName(\"tabs.restoreLastTabs\"));\n\n          var tab = this.firstChild;\n          tab.label = gTabBrowserBundle.GetStringFromName(\"tabs.emptyTabTitle\");\n          tab.setAttribute(\"onerror\", \"this.removeAttribute('image');\");\n\n          window.addEventListener(\"resize\", this);\n          window.addEventListener(\"load\", this);\n\n          Services.prefs.addObserver(\"privacy.userContext\", this);\n          this.observe(null, \"nsPref:changed\", \"privacy.userContext.enabled\");\n\n          this._setPositionalAttributes();\n        ]]>\n      </constructor>\n\n      <destructor>\n        <![CDATA[\n          Services.prefs.removeObserver(\"privacy.userContext\", this);\n        ]]>\n      </destructor>\n\n      <field name=\"tabbrowser\" readonly=\"true\">\n        document.getElementById(this.getAttribute(\"tabbrowser\"));\n      </field>\n\n      <field name=\"tabbox\" readonly=\"true\">\n        this.tabbrowser.mTabBox;\n      </field>\n\n      <field name=\"contextMenu\" readonly=\"true\">\n        document.getElementById(\"tabContextMenu\");\n      </field>\n\n      <field name=\"mTabstripWidth\">0</field>\n\n      <field name=\"mTabstrip\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowscrollbox\");\n      </field>\n\n      <field name=\"_firstTab\">null</field>\n      <field name=\"_lastTab\">null</field>\n      <field name=\"_beforeSelectedTab\">null</field>\n      <field name=\"_beforeHoveredTab\">null</field>\n      <field name=\"_afterHoveredTab\">null</field>\n      <field name=\"_hoveredTab\">null</field>\n      <field name=\"restoreTabsButton\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"restore-tabs-button\");\n      </field>\n      <field name=\"_restoreTabsButtonWrapperWidth\">0</field>\n      <field name=\"windowUtils\">\n        window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);\n      </field>\n\n      <property name=\"restoreTabsButtonWrapperWidth\" readonly=\"true\">\n        <getter>\n          if (!this._restoreTabsButtonWrapperWidth) {\n            this._restoreTabsButtonWrapperWidth = this.windowUtils\n              .getBoundsWithoutFlushing(this.restoreTabsButton.parentNode)\n              .width;\n          }\n          return this._restoreTabsButtonWrapperWidth;\n        </getter>\n      </property>\n\n      <method name=\"updateSessionRestoreVisibility\">\n        <body><![CDATA[\n          let {restoreTabsButton, restoreTabsButtonWrapperWidth, windowUtils, mTabstripWidth} = this;\n          let restoreTabsButtonWrapper = restoreTabsButton.parentNode;\n\n          if (!restoreTabsButtonWrapper.getAttribute(\"session-exists\")) {\n            restoreTabsButtonWrapper.removeAttribute(\"shown\");\n            return;\n          }\n\n          let newTabButton = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"tabs-newtab-button\");\n\n          // If there are no pinned tabs it will multiply by 0 and result in 0\n          let pinnedTabsWidth = windowUtils.getBoundsWithoutFlushing(this.firstChild).width * this._lastNumPinned;\n\n          let numUnpinnedTabs = this.childNodes.length - this._lastNumPinned;\n          let unpinnedTabsWidth = windowUtils.getBoundsWithoutFlushing(this.lastChild).width * numUnpinnedTabs;\n\n          let tabbarUsedSpace = pinnedTabsWidth + unpinnedTabsWidth\n            + windowUtils.getBoundsWithoutFlushing(newTabButton).width;\n\n          // Subtract the elements' widths from the available space to ensure\n          // that showing the restoreTabsButton won't cause any overflow.\n          if ((mTabstripWidth - tabbarUsedSpace) > restoreTabsButtonWrapperWidth) {\n            restoreTabsButtonWrapper.setAttribute(\"shown\", \"true\");\n          } else {\n            restoreTabsButtonWrapper.removeAttribute(\"shown\");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"observe\">\n        <parameter name=\"aSubject\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aData\"/>\n        <body><![CDATA[\n          switch (aTopic) {\n            case \"nsPref:changed\":\n              // This is has to deal with changes in\n              // privacy.userContext.enabled and\n              // privacy.userContext.longPressBehavior.\n              let containersEnabled = Services.prefs.getBoolPref(\"privacy.userContext.enabled\")\n                                        && !PrivateBrowsingUtils.isWindowPrivate(window);\n\n              // This pref won't change so often, so just recreate the menu.\n              let longPressBehavior = Services.prefs.getIntPref(\"privacy.userContext.longPressBehavior\");\n\n              // If longPressBehavior pref is set to 0 (or any invalid value)\n              // long press menu is disabled.\n              if (containersEnabled && (longPressBehavior <= 0 || longPressBehavior > 2)) {\n                containersEnabled = false;\n              }\n\n              const newTab = document.getElementById(\"new-tab-button\");\n              const newTab2 = document.getAnonymousElementByAttribute(this, \"anonid\", \"tabs-newtab-button\")\n\n              for (let parent of [newTab, newTab2]) {\n                if (!parent)\n                  continue;\n\n                gClickAndHoldListenersOnElement.remove(parent);\n                parent.removeAttribute(\"type\");\n                if (parent.firstChild) {\n                  parent.firstChild.remove();\n                }\n\n                if (containersEnabled) {\n                  let popup = document.createElementNS(\n                                \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\",\n                                \"menupopup\");\n                  if (parent.id) {\n                    popup.id = \"newtab-popup\";\n                  } else {\n                    popup.setAttribute(\"anonid\", \"newtab-popup\");\n                  }\n                  popup.className = \"new-tab-popup\";\n                  popup.setAttribute(\"position\", \"after_end\");\n                  parent.appendChild(popup);\n\n                  // longPressBehavior == 2 means that the menu is shown after X\n                  // millisecs. Otherwise, with 1, the menu is open immediatelly.\n                  if (longPressBehavior == 2) {\n                    gClickAndHoldListenersOnElement.add(parent);\n                  }\n\n                  parent.setAttribute(\"type\", \"menu\");\n                }\n              }\n\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <property name=\"_isCustomizing\" readonly=\"true\">\n        <getter><![CDATA[\n          return document.documentElement.getAttribute(\"customizing\") == \"true\";\n        ]]></getter>\n      </property>\n\n      <method name=\"_setPositionalAttributes\">\n        <body><![CDATA[\n          let visibleTabs = this.tabbrowser.visibleTabs;\n\n          if (!visibleTabs.length)\n            return;\n\n          let selectedIndex = visibleTabs.indexOf(this.selectedItem);\n\n          if (this._beforeSelectedTab) {\n            this._beforeSelectedTab.removeAttribute(\"beforeselected-visible\");\n          }\n\n          if (this.selectedItem.closing || selectedIndex == 0) {\n            this._beforeSelectedTab = null;\n          } else {\n            this._beforeSelectedTab = visibleTabs[selectedIndex - 1];\n            this._beforeSelectedTab.setAttribute(\"beforeselected-visible\",\n                                                 \"true\");\n          }\n\n          if (this._firstTab)\n            this._firstTab.removeAttribute(\"first-visible-tab\");\n          this._firstTab = visibleTabs[0];\n          this._firstTab.setAttribute(\"first-visible-tab\", \"true\");\n          if (this._lastTab)\n            this._lastTab.removeAttribute(\"last-visible-tab\");\n          this._lastTab = visibleTabs[visibleTabs.length - 1];\n          this._lastTab.setAttribute(\"last-visible-tab\", \"true\");\n\n          let hoveredTab = this._hoveredTab;\n          if (hoveredTab) {\n            hoveredTab._mouseleave();\n          }\n          hoveredTab = this.querySelector(\"tab:hover\");\n          if (hoveredTab) {\n            hoveredTab._mouseenter();\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_blockDblClick\">false</field>\n\n      <field name=\"_tabDropIndicator\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"tab-drop-indicator\");\n      </field>\n\n      <field name=\"_dragOverDelay\">350</field>\n      <field name=\"_dragTime\">0</field>\n\n      <field name=\"_container\" readonly=\"true\"><![CDATA[\n        this.parentNode && this.parentNode.localName == \"toolbar\" ? this.parentNode : this;\n      ]]></field>\n\n      <field name=\"_propagatedVisibilityOnce\">false</field>\n\n      <property name=\"visible\"\n                onget=\"return !this._container.collapsed;\">\n        <setter><![CDATA[\n          if (val == this.visible &&\n              this._propagatedVisibilityOnce)\n            return val;\n\n          this._container.collapsed = !val;\n\n          this._propagateVisibility();\n          this._propagatedVisibilityOnce = true;\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <method name=\"_propagateVisibility\">\n        <body><![CDATA[\n          let visible = this.visible;\n\n          document.getElementById(\"menu_closeWindow\").hidden = !visible;\n          document.getElementById(\"menu_close\").setAttribute(\"label\",\n            gTabBrowserBundle.GetStringFromName(visible ? \"tabs.closeTab\" : \"tabs.close\"));\n\n          TabsInTitlebar.allowedBy(\"tabs-visible\", visible);\n        ]]></body>\n      </method>\n\n      <method name=\"updateVisibility\">\n        <body><![CDATA[\n          if (this.childNodes.length - this.tabbrowser._removingTabs.length == 1)\n            this.visible = window.toolbar.visible;\n          else\n            this.visible = true;\n        ]]></body>\n      </method>\n\n      <field name=\"_closeButtonsUpdatePending\">false</field>\n      <method name=\"adjustTabstrip\">\n        <body><![CDATA[\n          // If we're overflowing, tabs are at their minimum widths.\n          if (this.getAttribute(\"overflow\") == \"true\") {\n            this.setAttribute(\"closebuttons\", \"activetab\");\n            return;\n          }\n\n          if (this._closeButtonsUpdatePending) {\n            return;\n          }\n          this._closeButtonsUpdatePending = true;\n\n          // Wait until after the next paint to get current layout data from\n          // getBoundsWithoutFlushing.\n          window.requestAnimationFrame(() => {\n            window.requestAnimationFrame(() => {\n              this._closeButtonsUpdatePending = false;\n\n              // The scrollbox may have started overflowing since we checked\n              // overflow earlier, so check again.\n              if (this.getAttribute(\"overflow\") == \"true\") {\n                this.setAttribute(\"closebuttons\", \"activetab\");\n                return;\n              }\n\n              // Check if tab widths are below the threshold where we want to\n              // remove close buttons from background tabs so that people don't\n              // accidentally close tabs by selecting them.\n              let rect = ele => {\n                return window.QueryInterface(Ci.nsIInterfaceRequestor)\n                             .getInterface(Ci.nsIDOMWindowUtils)\n                             .getBoundsWithoutFlushing(ele);\n              };\n              let tab = this.tabbrowser.visibleTabs[this.tabbrowser._numPinnedTabs];\n              if (tab && rect(tab).width <= this.mTabClipWidth) {\n                this.setAttribute(\"closebuttons\", \"activetab\");\n              } else {\n                this.removeAttribute(\"closebuttons\");\n              }\n            });\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"_handleTabSelect\">\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (this.getAttribute(\"overflow\") == \"true\")\n            this.mTabstrip.ensureElementIsVisible(this.selectedItem, aInstant);\n\n          this.selectedItem._notselectedsinceload = false;\n        ]]></body>\n      </method>\n\n      <field name=\"_closingTabsSpacer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"closing-tabs-spacer\");\n      </field>\n\n      <field name=\"_tabDefaultMaxWidth\">NaN</field>\n      <field name=\"_lastTabClosedByMouse\">false</field>\n      <field name=\"_hasTabTempMaxWidth\">false</field>\n\n      <!-- Try to keep the active tab's close button under the mouse cursor -->\n      <method name=\"_lockTabSizing\">\n        <parameter name=\"aTab\"/>\n        <body><![CDATA[\n          var tabs = this.tabbrowser.visibleTabs;\n          if (!tabs.length)\n            return;\n\n          var isEndTab = (aTab._tPos > tabs[tabs.length - 1]._tPos);\n          var tabWidth = aTab.getBoundingClientRect().width;\n\n          if (!this._tabDefaultMaxWidth)\n            this._tabDefaultMaxWidth =\n              parseFloat(window.getComputedStyle(aTab).maxWidth);\n          this._lastTabClosedByMouse = true;\n\n          if (this.getAttribute(\"overflow\") == \"true\") {\n            // Don't need to do anything if we're in overflow mode and aren't scrolled\n            // all the way to the right, or if we're closing the last tab.\n            if (isEndTab || !this.mTabstrip._scrollButtonDown.disabled)\n              return;\n\n            // If the tab has an owner that will become the active tab, the owner will\n            // be to the left of it, so we actually want the left tab to slide over.\n            // This can't be done as easily in non-overflow mode, so we don't bother.\n            if (aTab.owner)\n              return;\n\n            this._expandSpacerBy(tabWidth);\n          } else { // non-overflow mode\n            // Locking is neither in effect nor needed, so let tabs expand normally.\n            if (isEndTab && !this._hasTabTempMaxWidth)\n              return;\n\n            let numPinned = this.tabbrowser._numPinnedTabs;\n            // Force tabs to stay the same width, unless we're closing the last tab,\n            // which case we need to let them expand just enough so that the overall\n            // tabbar width is the same.\n            if (isEndTab) {\n              let numNormalTabs = tabs.length - numPinned;\n              tabWidth = tabWidth * (numNormalTabs + 1) / numNormalTabs;\n              if (tabWidth > this._tabDefaultMaxWidth)\n                tabWidth = this._tabDefaultMaxWidth;\n            }\n            tabWidth += \"px\";\n            for (let i = numPinned; i < tabs.length; i++) {\n              let tab = tabs[i];\n              tab.style.setProperty(\"max-width\", tabWidth, \"important\");\n              if (!isEndTab) { // keep tabs the same width\n                tab.style.transition = \"none\";\n                tab.clientTop; // flush styles to skip animation; see bug 649247\n                tab.style.transition = \"\";\n              }\n            }\n            this._hasTabTempMaxWidth = true;\n            this.tabbrowser.addEventListener(\"mousemove\", this);\n            window.addEventListener(\"mouseout\", this);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_expandSpacerBy\">\n        <parameter name=\"pixels\"/>\n        <body><![CDATA[\n          let spacer = this._closingTabsSpacer;\n          spacer.style.width = parseFloat(spacer.style.width) + pixels + \"px\";\n          this.setAttribute(\"using-closing-tabs-spacer\", \"true\");\n          this.tabbrowser.addEventListener(\"mousemove\", this);\n          window.addEventListener(\"mouseout\", this);\n        ]]></body>\n      </method>\n\n      <method name=\"_unlockTabSizing\">\n        <body><![CDATA[\n          this.tabbrowser.removeEventListener(\"mousemove\", this);\n          window.removeEventListener(\"mouseout\", this);\n\n          if (this._hasTabTempMaxWidth) {\n            this._hasTabTempMaxWidth = false;\n            let tabs = this.tabbrowser.visibleTabs;\n            for (let i = 0; i < tabs.length; i++)\n              tabs[i].style.maxWidth = \"\";\n          }\n\n          if (this.hasAttribute(\"using-closing-tabs-spacer\")) {\n            this.removeAttribute(\"using-closing-tabs-spacer\");\n            this._closingTabsSpacer.style.width = 0;\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_lastNumPinned\">0</field>\n      <field name=\"_pinnedTabsLayoutCache\">null</field>\n      <method name=\"_positionPinnedTabs\">\n        <body><![CDATA[\n          var numPinned = this.tabbrowser._numPinnedTabs;\n          var doPosition = this.getAttribute(\"overflow\") == \"true\" &&\n                           numPinned > 0;\n\n          if (doPosition) {\n            this.setAttribute(\"positionpinnedtabs\", \"true\");\n\n            let layoutData = this._pinnedTabsLayoutCache;\n            if (!layoutData) {\n              let tabstrip = this.mTabstrip;\n              layoutData = this._pinnedTabsLayoutCache = {\n                pinnedTabWidth: this.childNodes[0].getBoundingClientRect().width,\n                scrollButtonWidth: tabstrip._scrollButtonDown.getBoundingClientRect().width\n              };\n            }\n\n            let width = 0;\n            for (let i = numPinned - 1; i >= 0; i--) {\n              let tab = this.childNodes[i];\n              width += layoutData.pinnedTabWidth;\n              tab.style.marginInlineStart = -(width + layoutData.scrollButtonWidth) + \"px\";\n            }\n            this.style.paddingInlineStart = width + \"px\";\n          } else {\n            this.removeAttribute(\"positionpinnedtabs\");\n\n            for (let i = 0; i < numPinned; i++) {\n              let tab = this.childNodes[i];\n              tab.style.marginInlineStart = \"\";\n            }\n\n            this.style.paddingInlineStart = \"\";\n          }\n\n          if (this._lastNumPinned != numPinned) {\n            this._lastNumPinned = numPinned;\n            this._handleTabSelect(true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_animateTabMove\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);\n\n          if (this.getAttribute(\"movingtab\") != \"true\") {\n            this.setAttribute(\"movingtab\", \"true\");\n            this.parentNode.setAttribute(\"movingtab\", \"true\");\n            this.selectedItem = draggedTab;\n          }\n\n          if (!(\"animLastScreenX\" in draggedTab._dragData))\n            draggedTab._dragData.animLastScreenX = draggedTab._dragData.screenX;\n\n          let screenX = event.screenX;\n          if (screenX == draggedTab._dragData.animLastScreenX)\n            return;\n\n          draggedTab._dragData.animLastScreenX = screenX;\n\n          let rtl = (window.getComputedStyle(this).direction == \"rtl\");\n          let pinned = draggedTab.pinned;\n          let numPinned = this.tabbrowser._numPinnedTabs;\n          let tabs = this.tabbrowser.visibleTabs\n                                    .slice(pinned ? 0 : numPinned,\n                                           pinned ? numPinned : undefined);\n          if (rtl)\n            tabs.reverse();\n          let tabWidth = draggedTab.getBoundingClientRect().width;\n          draggedTab._dragData.tabWidth = tabWidth;\n\n          // Move the dragged tab based on the mouse position.\n\n          let leftTab = tabs[0];\n          let rightTab = tabs[tabs.length - 1];\n          let tabScreenX = draggedTab.boxObject.screenX;\n          let translateX = screenX - draggedTab._dragData.screenX;\n          if (!pinned)\n            translateX += this.mTabstrip._scrollbox.scrollLeft - draggedTab._dragData.scrollX;\n          let leftBound = leftTab.boxObject.screenX - tabScreenX;\n          let rightBound = (rightTab.boxObject.screenX + rightTab.boxObject.width) -\n                           (tabScreenX + tabWidth);\n          translateX = Math.max(translateX, leftBound);\n          translateX = Math.min(translateX, rightBound);\n          draggedTab.style.transform = \"translateX(\" + translateX + \"px)\";\n          draggedTab._dragData.translateX = translateX;\n\n          // Determine what tab we're dragging over.\n          // * Point of reference is the center of the dragged tab. If that\n          //   point touches a background tab, the dragged tab would take that\n          //   tab's position when dropped.\n          // * We're doing a binary search in order to reduce the amount of\n          //   tabs we need to check.\n\n          let tabCenter = tabScreenX + translateX + tabWidth / 2;\n          let newIndex = -1;\n          let oldIndex = \"animDropIndex\" in draggedTab._dragData ?\n                         draggedTab._dragData.animDropIndex : draggedTab._tPos;\n          let low = 0;\n          let high = tabs.length - 1;\n          while (low <= high) {\n            let mid = Math.floor((low + high) / 2);\n            if (tabs[mid] == draggedTab &&\n                ++mid > high)\n              break;\n            let boxObject = tabs[mid].boxObject;\n            screenX = boxObject.screenX + getTabShift(tabs[mid], oldIndex);\n            if (screenX > tabCenter) {\n              high = mid - 1;\n            } else if (screenX + boxObject.width < tabCenter) {\n              low = mid + 1;\n            } else {\n              newIndex = tabs[mid]._tPos;\n              break;\n            }\n          }\n          if (newIndex >= oldIndex)\n            newIndex++;\n          if (newIndex < 0 || newIndex == oldIndex)\n            return;\n          draggedTab._dragData.animDropIndex = newIndex;\n\n          // Shift background tabs to leave a gap where the dragged tab\n          // would currently be dropped.\n\n          for (let tab of tabs) {\n            if (tab != draggedTab) {\n              let shift = getTabShift(tab, newIndex);\n              tab.style.transform = shift ? \"translateX(\" + shift + \"px)\" : \"\";\n            }\n          }\n\n          function getTabShift(tab, dropIndex) {\n            if (tab._tPos < draggedTab._tPos && tab._tPos >= dropIndex)\n              return rtl ? -tabWidth : tabWidth;\n            if (tab._tPos > draggedTab._tPos && tab._tPos < dropIndex)\n              return rtl ? tabWidth : -tabWidth;\n            return 0;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_finishAnimateTabMove\">\n        <body><![CDATA[\n          if (this.getAttribute(\"movingtab\") != \"true\")\n            return;\n\n          for (let tab of this.tabbrowser.visibleTabs)\n            tab.style.transform = \"\";\n\n          this.removeAttribute(\"movingtab\");\n          this.parentNode.removeAttribute(\"movingtab\");\n\n          this._handleTabSelect();\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.type) {\n            case \"load\":\n              this.updateVisibility();\n              TabsInTitlebar.init();\n              break;\n            case \"resize\":\n              if (aEvent.target != window)\n                break;\n\n              TabsInTitlebar.updateAppearance();\n\n              var width = this.mTabstrip.boxObject.width;\n              if (width != this.mTabstripWidth) {\n                this.adjustTabstrip();\n                this._handleTabSelect(true);\n                this.mTabstripWidth = width;\n                this.updateSessionRestoreVisibility();\n              }\n              break;\n            case \"mouseout\":\n              // If the \"related target\" (the node to which the pointer went) is not\n              // a child of the current document, the mouse just left the window.\n              let relatedTarget = aEvent.relatedTarget;\n              if (relatedTarget && relatedTarget.ownerDocument == document)\n                break;\n            case \"mousemove\":\n              if (document.getElementById(\"tabContextMenu\").state != \"open\")\n                this._unlockTabSizing();\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_animateElement\">\n        this.mTabstrip._scrollButtonDown;\n      </field>\n\n      <method name=\"_notifyBackgroundTab\">\n        <parameter name=\"aTab\"/>\n        <body><![CDATA[\n          if (aTab.pinned || aTab.hidden)\n            return;\n\n          var scrollRect = this.mTabstrip.scrollClientRect;\n          var tab = aTab.getBoundingClientRect();\n\n          // DOMRect left/right properties are immutable.\n          tab = {left: tab.left, right: tab.right};\n\n          // Is the new tab already completely visible?\n          if (scrollRect.left <= tab.left && tab.right <= scrollRect.right)\n            return;\n\n          if (this.mTabstrip.smoothScroll) {\n            let selected = !this.selectedItem.pinned &&\n                           this.selectedItem.getBoundingClientRect();\n\n            // Can we make both the new tab and the selected tab completely visible?\n            if (!selected ||\n                Math.max(tab.right - selected.left, selected.right - tab.left) <=\n                  scrollRect.width) {\n              this.mTabstrip.ensureElementIsVisible(aTab);\n              return;\n            }\n\n            this.mTabstrip.scrollByPixels(this.mTabstrip._isRTLScrollbox ?\n                                          selected.right - scrollRect.right :\n                                          selected.left - scrollRect.left);\n          }\n\n          if (!this._animateElement.hasAttribute(\"highlight\")) {\n            this._animateElement.setAttribute(\"highlight\", \"true\");\n            setTimeout(function(ele) {\n              ele.removeAttribute(\"highlight\");\n            }, 150, this._animateElement);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_getDragTargetTab\">\n        <parameter name=\"event\"/>\n        <parameter name=\"isLink\"/>\n        <body><![CDATA[\n          let tab = event.target.localName == \"tab\" ? event.target : null;\n          if (tab && isLink) {\n            let boxObject = tab.boxObject;\n            if (event.screenX < boxObject.screenX + boxObject.width * .25 ||\n                event.screenX > boxObject.screenX + boxObject.width * .75)\n              return null;\n          }\n          return tab;\n        ]]></body>\n      </method>\n\n      <method name=\"_getDropIndex\">\n        <parameter name=\"event\"/>\n        <parameter name=\"isLink\"/>\n        <body><![CDATA[\n          var tabs = this.childNodes;\n          var tab = this._getDragTargetTab(event, isLink);\n          if (window.getComputedStyle(this).direction == \"ltr\") {\n            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)\n              if (event.screenX < tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)\n                return i;\n          } else {\n            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)\n              if (event.screenX > tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)\n                return i;\n          }\n          return tabs.length;\n        ]]></body>\n      </method>\n\n      <method name=\"_getDropEffectForTabDrag\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          var dt = event.dataTransfer;\n          if (dt.mozItemCount == 1) {\n            var types = dt.mozTypesAt(0);\n            // tabs are always added as the first type\n            if (types[0] == TAB_DROP_TYPE) {\n              let sourceNode = dt.mozGetDataAt(TAB_DROP_TYPE, 0);\n              if (sourceNode instanceof XULElement &&\n                  sourceNode.localName == \"tab\" &&\n                  sourceNode.ownerGlobal.isChromeWindow &&\n                  sourceNode.ownerDocument.documentElement.getAttribute(\"windowtype\") == \"navigator:browser\" &&\n                  sourceNode.ownerGlobal.gBrowser.tabContainer == sourceNode.parentNode) {\n                // Do not allow transfering a private tab to a non-private window\n                // and vice versa.\n                if (PrivateBrowsingUtils.isWindowPrivate(window) !=\n                    PrivateBrowsingUtils.isWindowPrivate(sourceNode.ownerGlobal))\n                  return \"none\";\n\n                if (window.gMultiProcessBrowser !=\n                    sourceNode.ownerGlobal.gMultiProcessBrowser)\n                  return \"none\";\n\n                return dt.dropEffect == \"copy\" ? \"copy\" : \"move\";\n              }\n            }\n          }\n\n          if (browserDragAndDrop.canDropLink(event)) {\n            return \"link\";\n          }\n          return \"none\";\n        ]]></body>\n      </method>\n\n      <method name=\"_handleNewTab\">\n        <parameter name=\"tab\"/>\n        <body><![CDATA[\n          if (tab.parentNode != this)\n            return;\n          tab._fullyOpen = true;\n          this.tabbrowser.tabAnimationsInProgress--;\n\n          this.adjustTabstrip();\n\n          if (tab.getAttribute(\"selected\") == \"true\") {\n            this._handleTabSelect();\n          } else if (!tab.hasAttribute(\"skipbackgroundnotify\")) {\n            this._notifyBackgroundTab(tab);\n          }\n\n          // XXXmano: this is a temporary workaround for bug 345399\n          // We need to manually update the scroll buttons disabled state\n          // if a tab was inserted to the overflow area or removed from it\n          // without any scrolling and when the tabbar has already\n          // overflowed.\n          this.mTabstrip._updateScrollButtonsDisabledState();\n\n          // Preload the next about:newtab if there isn't one already.\n          this.tabbrowser._createPreloadBrowser();\n        ]]></body>\n      </method>\n\n      <method name=\"_canAdvanceToTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          return !aTab.closing;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getRelatedElement\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          if (!aTab)\n            return null;\n          // If the tab's browser is lazy, we need to `_insertBrowser` in order\n          // to have a linkedPanel.  This will also serve to bind the browser\n          // and make it ready to use when the tab is selected.\n          this.tabbrowser._insertBrowser(aTab);\n          return document.getElementById(aTab.linkedPanel);\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"TabSelect\" action=\"this._handleTabSelect();\"/>\n\n      <handler event=\"transitionend\"><![CDATA[\n        if (event.propertyName != \"max-width\")\n          return;\n\n        var tab = event.target;\n\n        if (tab.getAttribute(\"fadein\") == \"true\") {\n          if (tab._fullyOpen)\n            this.adjustTabstrip();\n          else\n            this._handleNewTab(tab);\n        } else if (tab.closing) {\n          this.tabbrowser._endRemoveTab(tab);\n        }\n      ]]></handler>\n\n      <handler event=\"dblclick\"><![CDATA[\n        // When the tabbar has an unified appearance with the titlebar\n        // and menubar, a double-click in it should have the same behavior\n        // as double-clicking the titlebar\n        if (TabsInTitlebar.enabled || this.parentNode._dragBindingAlive)\n          return;\n\n        if (event.button != 0 ||\n            event.originalTarget.localName != \"box\")\n          return;\n\n        // See hack note in the tabbrowser-close-tab-button binding\n        if (!this._blockDblClick)\n          BrowserOpenTab();\n\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"click\" button=\"0\" phase=\"capturing\"><![CDATA[\n        /* Catches extra clicks meant for the in-tab close button.\n         * Placed here to avoid leaking (a temporary handler added from the\n         * in-tab close button binding would close over the tab and leak it\n         * until the handler itself was removed). (bug 897751)\n         *\n         * The only sequence in which a second click event (i.e. dblclik)\n         * can be dispatched on an in-tab close button is when it is shown\n         * after the first click (i.e. the first click event was dispatched\n         * on the tab). This happens when we show the close button only on\n         * the active tab. (bug 352021)\n         * The only sequence in which a third click event can be dispatched\n         * on an in-tab close button is when the tab was opened with a\n         * double click on the tabbar. (bug 378344)\n         * In both cases, it is most likely that the close button area has\n         * been accidentally clicked, therefore we do not close the tab.\n         *\n         * We don't want to ignore processing of more than one click event,\n         * though, since the user might actually be repeatedly clicking to\n         * close many tabs at once.\n         */\n        let target = event.originalTarget;\n        if (target.classList.contains(\"tab-close-button\")) {\n          // We preemptively set this to allow the closing-multiple-tabs-\n          // in-a-row case.\n          if (this._blockDblClick) {\n            target._ignoredCloseButtonClicks = true;\n          } else if (event.detail > 1 && !target._ignoredCloseButtonClicks) {\n            target._ignoredCloseButtonClicks = true;\n            event.stopPropagation();\n            return;\n          } else {\n            // Reset the \"ignored click\" flag\n            target._ignoredCloseButtonClicks = false;\n          }\n        }\n\n        /* Protects from close-tab-button errant doubleclick:\n         * Since we're removing the event target, if the user\n         * double-clicks the button, the dblclick event will be dispatched\n         * with the tabbar as its event target (and explicit/originalTarget),\n         * which treats that as a mouse gesture for opening a new tab.\n         * In this context, we're manually blocking the dblclick event\n         * (see tabbrowser-close-tab-button dblclick handler).\n         */\n        if (this._blockDblClick) {\n          if (!(\"_clickedTabBarOnce\" in this)) {\n            this._clickedTabBarOnce = true;\n            return;\n          }\n          delete this._clickedTabBarOnce;\n          this._blockDblClick = false;\n        }\n      ]]></handler>\n\n      <handler event=\"click\"><![CDATA[\n        if (event.button != 1)\n          return;\n\n        if (event.target.localName == \"tab\") {\n          this.tabbrowser.removeTab(event.target, {animate: true,\n                byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE});\n        } else if (event.originalTarget.localName == \"box\") {\n          // The user middleclicked an open space on the tabstrip. This could\n          // be because they intend to open a new tab, but it could also be\n          // because they just removed a tab and they now middleclicked on the\n          // resulting space while that tab is closing. In that case, we don't\n          // want to open a tab. So if we're removing one or more tabs, and\n          // the tab click is before the end of the last visible tab, we do\n          // nothing.\n          if (this.tabbrowser._removingTabs.length) {\n            let visibleTabs = this.tabbrowser.visibleTabs;\n            let ltr = (window.getComputedStyle(this).direction == \"ltr\");\n            let lastTab = visibleTabs[visibleTabs.length - 1];\n            let endOfTab = lastTab.getBoundingClientRect()[ltr ? \"right\" : \"left\"];\n            if ((ltr && event.clientX > endOfTab) ||\n                (!ltr && event.clientX < endOfTab)) {\n              BrowserOpenTab();\n            }\n          } else {\n            BrowserOpenTab();\n          }\n        } else {\n          return;\n        }\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"keydown\" group=\"system\"><![CDATA[\n        if (event.altKey || event.shiftKey)\n          return;\n\n        let wrongModifiers;\n        if (AppConstants.platform == \"macosx\") {\n          wrongModifiers = !event.metaKey;\n        } else {\n          wrongModifiers = !event.ctrlKey || event.metaKey;\n        }\n\n        if (wrongModifiers)\n          return;\n\n        // Don't check if the event was already consumed because tab navigation\n        // should work always for better user experience.\n\n        switch (event.keyCode) {\n          case KeyEvent.DOM_VK_UP:\n            this.tabbrowser.moveTabBackward();\n            break;\n          case KeyEvent.DOM_VK_DOWN:\n            this.tabbrowser.moveTabForward();\n            break;\n          case KeyEvent.DOM_VK_RIGHT:\n          case KeyEvent.DOM_VK_LEFT:\n            this.tabbrowser.moveTabOver(event);\n            break;\n          case KeyEvent.DOM_VK_HOME:\n            this.tabbrowser.moveTabToStart();\n            break;\n          case KeyEvent.DOM_VK_END:\n            this.tabbrowser.moveTabToEnd();\n            break;\n          default:\n            // Consume the keydown event for the above keyboard\n            // shortcuts only.\n            return;\n        }\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        var tab = this._getDragTargetTab(event, false);\n        if (!tab || this._isCustomizing)\n          return;\n\n        let dt = event.dataTransfer;\n        dt.mozSetDataAt(TAB_DROP_TYPE, tab, 0);\n        let browser = tab.linkedBrowser;\n\n        // We must not set text/x-moz-url or text/plain data here,\n        // otherwise trying to deatch the tab by dropping it on the desktop\n        // may result in an \"internet shortcut\"\n        dt.mozSetDataAt(\"text/x-moz-text-internal\", browser.currentURI.spec, 0);\n\n        // Set the cursor to an arrow during tab drags.\n        dt.mozCursor = \"default\";\n\n        // Set the tab as the source of the drag, which ensures we have a stable\n        // node to deliver the `dragend` event.  See bug 1345473.\n        dt.addElement(tab);\n\n        // Create a canvas to which we capture the current tab.\n        // Until canvas is HiDPI-aware (bug 780362), we need to scale the desired\n        // canvas size (in CSS pixels) to the window's backing resolution in order\n        // to get a full-resolution drag image for use on HiDPI displays.\n        let windowUtils = window.getInterface(Ci.nsIDOMWindowUtils);\n        let scale = windowUtils.screenPixelsPerCSSPixel / windowUtils.fullZoom;\n        let canvas = this._dndCanvas;\n        if (!canvas) {\n          this._dndCanvas = canvas =\n            document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n          canvas.style.width = \"100%\";\n          canvas.style.height = \"100%\";\n          canvas.mozOpaque = true;\n        }\n\n        canvas.width = 160 * scale;\n        canvas.height = 90 * scale;\n        let toDrag = canvas;\n        let dragImageOffset = -16;\n        if (gMultiProcessBrowser) {\n          var context = canvas.getContext(\"2d\");\n          context.fillStyle = \"white\";\n          context.fillRect(0, 0, canvas.width, canvas.height);\n\n          let captureListener;\n          let platform = AppConstants.platform;\n          // On Windows and Mac we can update the drag image during a drag\n          // using updateDragImage. On Linux, we can use a panel.\n          if (platform == \"win\" || platform == \"macosx\") {\n            captureListener = function() {\n              dt.updateDragImage(canvas, dragImageOffset, dragImageOffset);\n            }\n          } else {\n            // Create a panel to use it in setDragImage\n            // which will tell xul to render a panel that follows\n            // the pointer while a dnd session is on.\n            if (!this._dndPanel) {\n              this._dndCanvas = canvas;\n              this._dndPanel = document.createElement(\"panel\");\n              this._dndPanel.className = \"dragfeedback-tab\";\n              this._dndPanel.setAttribute(\"type\", \"drag\");\n              let wrapper = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"div\");\n              wrapper.style.width = \"160px\";\n              wrapper.style.height = \"90px\";\n              wrapper.appendChild(canvas);\n              this._dndPanel.appendChild(wrapper);\n              document.documentElement.appendChild(this._dndPanel);\n            }\n            toDrag = this._dndPanel;\n          }\n          // PageThumb is async with e10s but that's fine\n          // since we can update the image during the dnd.\n          PageThumbs.captureToCanvas(browser, canvas, captureListener);\n        } else {\n          // For the non e10s case we can just use PageThumbs\n          // sync, so let's use the canvas for setDragImage.\n          PageThumbs.captureToCanvas(browser, canvas);\n          dragImageOffset = dragImageOffset * scale;\n        }\n        dt.setDragImage(toDrag, dragImageOffset, dragImageOffset);\n\n        // _dragData.offsetX/Y give the coordinates that the mouse should be\n        // positioned relative to the corner of the new window created upon\n        // dragend such that the mouse appears to have the same position\n        // relative to the corner of the dragged tab.\n        function clientX(ele) {\n          return ele.getBoundingClientRect().left;\n        }\n        let tabOffsetX = clientX(tab) - clientX(this);\n        tab._dragData = {\n          offsetX: event.screenX - window.screenX - tabOffsetX,\n          offsetY: event.screenY - window.screenY,\n          scrollX: this.mTabstrip._scrollbox.scrollLeft,\n          screenX: event.screenX\n        };\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        var effects = this._getDropEffectForTabDrag(event);\n\n        var ind = this._tabDropIndicator;\n        if (effects == \"\" || effects == \"none\") {\n          ind.collapsed = true;\n          return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n\n        var tabStrip = this.mTabstrip;\n        var ltr = (window.getComputedStyle(this).direction == \"ltr\");\n\n        // autoscroll the tab strip if we drag over the scroll\n        // buttons, even if we aren't dragging a tab, but then\n        // return to avoid drawing the drop indicator\n        var pixelsToScroll = 0;\n        if (this.getAttribute(\"overflow\") == \"true\") {\n          var targetAnonid = event.originalTarget.getAttribute(\"anonid\");\n          switch (targetAnonid) {\n            case \"scrollbutton-up\":\n              pixelsToScroll = tabStrip.scrollIncrement * -1;\n              break;\n            case \"scrollbutton-down\":\n              pixelsToScroll = tabStrip.scrollIncrement;\n              break;\n          }\n          if (pixelsToScroll)\n            tabStrip.scrollByPixels((ltr ? 1 : -1) * pixelsToScroll, true);\n        }\n\n        if (effects == \"move\" &&\n            this == event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0).parentNode) {\n          ind.collapsed = true;\n          this._animateTabMove(event);\n          return;\n        }\n\n        this._finishAnimateTabMove();\n\n        if (effects == \"link\") {\n          let tab = this._getDragTargetTab(event, true);\n          if (tab) {\n            if (!this._dragTime)\n              this._dragTime = Date.now();\n            if (Date.now() >= this._dragTime + this._dragOverDelay)\n              this.selectedItem = tab;\n            ind.collapsed = true;\n            return;\n          }\n        }\n\n        var rect = tabStrip.getBoundingClientRect();\n        var newMargin;\n        if (pixelsToScroll) {\n          // if we are scrolling, put the drop indicator at the edge\n          // so that it doesn't jump while scrolling\n          let scrollRect = tabStrip.scrollClientRect;\n          let minMargin = scrollRect.left - rect.left;\n          let maxMargin = Math.min(minMargin + scrollRect.width,\n                                   scrollRect.right);\n          if (!ltr)\n            [minMargin, maxMargin] = [this.clientWidth - maxMargin,\n                                      this.clientWidth - minMargin];\n          newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;\n        } else {\n          let newIndex = this._getDropIndex(event, effects == \"link\");\n          if (newIndex == this.childNodes.length) {\n            let tabRect = this.childNodes[newIndex - 1].getBoundingClientRect();\n            if (ltr)\n              newMargin = tabRect.right - rect.left;\n            else\n              newMargin = rect.right - tabRect.left;\n          } else {\n            let tabRect = this.childNodes[newIndex].getBoundingClientRect();\n            if (ltr)\n              newMargin = tabRect.left - rect.left;\n            else\n              newMargin = rect.right - tabRect.right;\n          }\n        }\n\n        ind.collapsed = false;\n\n        newMargin += ind.clientWidth / 2;\n        if (!ltr)\n          newMargin *= -1;\n\n        ind.style.transform = \"translate(\" + Math.round(newMargin) + \"px)\";\n        ind.style.marginInlineStart = (-ind.clientWidth) + \"px\";\n      ]]></handler>\n\n      <handler event=\"drop\"><![CDATA[\n        var dt = event.dataTransfer;\n        var dropEffect = dt.dropEffect;\n        var draggedTab;\n        if (dt.mozTypesAt(0)[0] == TAB_DROP_TYPE) { // tab copy or move\n          draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);\n          // not our drop then\n          if (!draggedTab)\n            return;\n        }\n\n        this._tabDropIndicator.collapsed = true;\n        event.stopPropagation();\n        if (draggedTab && dropEffect == \"copy\") {\n          // copy the dropped tab (wherever it's from)\n          let newIndex = this._getDropIndex(event, false);\n          let newTab = this.tabbrowser.duplicateTab(draggedTab);\n          this.tabbrowser.moveTabTo(newTab, newIndex);\n          if (draggedTab.parentNode != this || event.shiftKey)\n            this.selectedItem = newTab;\n        } else if (draggedTab && draggedTab.parentNode == this) {\n          let oldTranslateX = draggedTab._dragData.translateX;\n          let tabWidth = draggedTab._dragData.tabWidth;\n          let translateOffset = oldTranslateX % tabWidth;\n          let newTranslateX = oldTranslateX - translateOffset;\n          if (oldTranslateX > 0 && translateOffset > tabWidth / 2) {\n            newTranslateX += tabWidth;\n          } else if (oldTranslateX < 0 && -translateOffset > tabWidth / 2) {\n            newTranslateX -= tabWidth;\n          }\n\n          let dropIndex = \"animDropIndex\" in draggedTab._dragData &&\n                          draggedTab._dragData.animDropIndex;\n          if (dropIndex && dropIndex > draggedTab._tPos)\n            dropIndex--;\n\n          let animate = this.tabbrowser.animationsEnabled;\n          if (oldTranslateX && oldTranslateX != newTranslateX && animate) {\n            draggedTab.setAttribute(\"tabdrop-samewindow\", \"true\");\n            draggedTab.style.transform = \"translateX(\" + newTranslateX + \"px)\";\n            let onTransitionEnd = transitionendEvent => {\n              if (transitionendEvent.propertyName != \"transform\" ||\n                  transitionendEvent.originalTarget != draggedTab) {\n                return;\n              }\n              draggedTab.removeEventListener(\"transitionend\", onTransitionEnd);\n\n              draggedTab.removeAttribute(\"tabdrop-samewindow\");\n\n              this._finishAnimateTabMove();\n              if (dropIndex !== false)\n                this.tabbrowser.moveTabTo(draggedTab, dropIndex);\n            }\n            draggedTab.addEventListener(\"transitionend\", onTransitionEnd);\n          } else {\n            this._finishAnimateTabMove();\n            if (dropIndex !== false)\n              this.tabbrowser.moveTabTo(draggedTab, dropIndex);\n          }\n        } else if (draggedTab) {\n          let newIndex = this._getDropIndex(event, false);\n          this.tabbrowser.adoptTab(draggedTab, newIndex, true);\n        } else {\n          // Pass true to disallow dropping javascript: or data: urls\n          let links;\n          try {\n            links = browserDragAndDrop.dropLinks(event, true);\n          } catch (ex) {}\n\n          if (!links || links.length === 0)\n            return;\n\n          let inBackground = Services.prefs.getBoolPref(\"browser.tabs.loadInBackground\");\n\n          if (event.shiftKey)\n            inBackground = !inBackground;\n\n          let targetTab = this._getDragTargetTab(event, true);\n          let userContextId = this.selectedItem.getAttribute(\"usercontextid\");\n          let replace = !!targetTab;\n          let newIndex = this._getDropIndex(event, true);\n          let urls = links.map(link => link.url);\n\n          let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(event);\n          this.tabbrowser.loadTabs(urls, {\n            inBackground,\n            replace,\n            allowThirdPartyFixup: true,\n            targetTab,\n            newIndex,\n            userContextId,\n            triggeringPrincipal,\n          });\n        }\n\n        if (draggedTab) {\n          delete draggedTab._dragData;\n        }\n      ]]></handler>\n\n      <handler event=\"dragend\"><![CDATA[\n        var dt = event.dataTransfer;\n        var draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);\n\n        // Prevent this code from running if a tabdrop animation is\n        // running since calling _finishAnimateTabMove would clear\n        // any CSS transition that is running.\n        if (draggedTab.hasAttribute(\"tabdrop-samewindow\"))\n          return;\n\n        this._finishAnimateTabMove();\n\n        if (dt.mozUserCancelled || dt.dropEffect != \"none\" || this._isCustomizing) {\n          delete draggedTab._dragData;\n          return;\n        }\n\n        // Disable detach within the browser toolbox\n        var eX = event.screenX;\n        var eY = event.screenY;\n        var wX = window.screenX;\n        // check if the drop point is horizontally within the window\n        if (eX > wX && eX < (wX + window.outerWidth)) {\n          let bo = this.mTabstrip.boxObject;\n          // also avoid detaching if the the tab was dropped too close to\n          // the tabbar (half a tab)\n          let endScreenY = bo.screenY + 1.5 * bo.height;\n          if (eY < endScreenY && eY > window.screenY)\n            return;\n        }\n\n        // screen.availLeft et. al. only check the screen that this window is on,\n        // but we want to look at the screen the tab is being dropped onto.\n        var screen = Cc[\"@mozilla.org/gfx/screenmanager;1\"]\n                       .getService(Ci.nsIScreenManager)\n                       .screenForRect(eX, eY, 1, 1);\n        var fullX = {}, fullY = {}, fullWidth = {}, fullHeight = {};\n        var availX = {}, availY = {}, availWidth = {}, availHeight = {};\n        // get full screen rect and available rect, both in desktop pix\n        screen.GetRectDisplayPix(fullX, fullY, fullWidth, fullHeight);\n        screen.GetAvailRectDisplayPix(availX, availY, availWidth, availHeight);\n\n        // scale factor to convert desktop pixels to CSS px\n        var scaleFactor =\n          screen.contentsScaleFactor / screen.defaultCSSScaleFactor;\n        // synchronize CSS-px top-left coordinates with the screen's desktop-px\n        // coordinates, to ensure uniqueness across multiple screens\n        // (compare the equivalent adjustments in nsGlobalWindow::GetScreenXY()\n        // and related methods)\n        availX.value = (availX.value - fullX.value) * scaleFactor + fullX.value;\n        availY.value = (availY.value - fullY.value) * scaleFactor + fullY.value;\n        availWidth.value *= scaleFactor;\n        availHeight.value *= scaleFactor;\n\n        // ensure new window entirely within screen\n        var winWidth = Math.min(window.outerWidth, availWidth.value);\n        var winHeight = Math.min(window.outerHeight, availHeight.value);\n        var left = Math.min(Math.max(eX - draggedTab._dragData.offsetX, availX.value),\n                            availX.value + availWidth.value - winWidth);\n        var top = Math.min(Math.max(eY - draggedTab._dragData.offsetY, availY.value),\n                           availY.value + availHeight.value - winHeight);\n\n        delete draggedTab._dragData;\n\n        if (this.tabbrowser.tabs.length == 1) {\n          // resize _before_ move to ensure the window fits the new screen.  if\n          // the window is too large for its screen, the window manager may do\n          // automatic repositioning.\n          window.resizeTo(winWidth, winHeight);\n          window.moveTo(left, top);\n          window.focus();\n        } else {\n          let props = { screenX: left, screenY: top, suppressanimation: 1 };\n          if (AppConstants.platform != \"win\") {\n            props.outerWidth = winWidth;\n            props.outerHeight = winHeight;\n          }\n          this.tabbrowser.replaceTabWithWindow(draggedTab, props);\n        }\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragexit\"><![CDATA[\n        this._dragTime = 0;\n\n        // This does not work at all (see bug 458613)\n        var target = event.relatedTarget;\n        while (target && target != this)\n          target = target.parentNode;\n        if (target)\n          return;\n\n        this._tabDropIndicator.collapsed = true;\n        event.stopPropagation();\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <!-- close-tab-button binding\n       This binding relies on the structure of the tabbrowser binding.\n       Therefore it should only be used as a child of the tab or the tabs\n       element (in both cases, when they are anonymous nodes of <tabbrowser>).\n  -->\n  <binding id=\"tabbrowser-close-tab-button\"\n           extends=\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton-image\">\n    <handlers>\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        var bindingParent = document.getBindingParent(this);\n        var tabContainer = bindingParent.parentNode;\n        tabContainer.tabbrowser.removeTab(bindingParent, {animate: true,\n                byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE});\n        // This enables double-click protection for the tab container\n        // (see tabbrowser-tabs 'click' handler).\n        tabContainer._blockDblClick = true;\n      ]]></handler>\n\n      <handler event=\"dblclick\" button=\"0\" phase=\"capturing\">\n        // for the one-close-button case\n        event.stopPropagation();\n      </handler>\n\n      <handler event=\"dragstart\">\n        event.stopPropagation();\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"tabbrowser-tab\" display=\"xul:hbox\"\n           extends=\"chrome://global/content/bindings/tabbox.xml#tab\">\n    <resources>\n      <stylesheet src=\"chrome://browser/content/tabbrowser.css\"/>\n    </resources>\n\n    <content context=\"tabContextMenu\">\n      <xul:stack class=\"tab-stack\" flex=\"1\">\n        <xul:vbox xbl:inherits=\"selected=visuallyselected,fadein\"\n                  class=\"tab-background\">\n          <xul:hbox xbl:inherits=\"selected=visuallyselected\"\n                    class=\"tab-line\"/>\n          <xul:spacer flex=\"1\"/>\n          <xul:hbox class=\"tab-bottom-line\"/>\n        </xul:vbox>\n        <xul:hbox xbl:inherits=\"pinned,bursting,notselectedsinceload\"\n                  anonid=\"tab-loading-burst\"\n                  class=\"tab-loading-burst\"/>\n        <xul:hbox xbl:inherits=\"pinned,selected=visuallyselected,titlechanged,attention\"\n                  class=\"tab-content\" align=\"center\">\n          <xul:hbox xbl:inherits=\"fadein,pinned,busy,progress,selected=visuallyselected\"\n                    anonid=\"tab-throbber\"\n                    class=\"tab-throbber\"\n                    layer=\"true\"/>\n          <xul:image xbl:inherits=\"src=image,triggeringprincipal=iconloadingprincipal,requestcontextid,fadein,pinned,selected=visuallyselected,busy,crashed,sharing\"\n                     anonid=\"tab-icon-image\"\n                     class=\"tab-icon-image\"\n                     validate=\"never\"\n                     role=\"presentation\"/>\n          <xul:image xbl:inherits=\"sharing,selected=visuallyselected,pinned\"\n                     anonid=\"sharing-icon\"\n                     class=\"tab-sharing-icon-overlay\"\n                     role=\"presentation\"/>\n          <xul:image xbl:inherits=\"crashed,busy,soundplaying,soundplaying-scheduledremoval,pinned,muted,blocked,selected=visuallyselected,activemedia-blocked\"\n                     anonid=\"overlay-icon\"\n                     class=\"tab-icon-overlay\"\n                     role=\"presentation\"/>\n          <xul:hbox class=\"tab-label-container\"\n                    xbl:inherits=\"pinned,selected=visuallyselected,labeldirection\"\n                    onoverflow=\"this.setAttribute('textoverflow', 'true');\"\n                    onunderflow=\"this.removeAttribute('textoverflow');\"\n                    flex=\"1\">\n            <xul:label class=\"tab-text tab-label\"\n                       xbl:inherits=\"xbl:text=label,accesskey,fadein,pinned,selected=visuallyselected,attention\"\n                       role=\"presentation\"/>\n          </xul:hbox>\n          <xul:image xbl:inherits=\"soundplaying,soundplaying-scheduledremoval,pinned,muted,blocked,selected=visuallyselected,activemedia-blocked\"\n                     anonid=\"soundplaying-icon\"\n                     class=\"tab-icon-sound\"\n                     role=\"presentation\"/>\n          <xul:toolbarbutton anonid=\"close-button\"\n                             xbl:inherits=\"fadein,pinned,selected=visuallyselected\"\n                             class=\"tab-close-button close-icon\"/>\n        </xul:hbox>\n      </xul:stack>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (!(\"_lastAccessed\" in this)) {\n          this.updateLastAccessed();\n        }\n      ]]></constructor>\n\n      <property name=\"_visuallySelected\">\n        <setter>\n          <![CDATA[\n          if (val)\n            this.setAttribute(\"visuallyselected\", \"true\");\n          else\n            this.removeAttribute(\"visuallyselected\");\n          this.parentNode.tabbrowser._tabAttrModified(this, [\"visuallyselected\"]);\n\n          this._setPositionAttributes(val);\n\n          return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"_selected\">\n        <setter>\n          <![CDATA[\n          // in e10s we want to only pseudo-select a tab before its rendering is done, so that\n          // the rest of the system knows that the tab is selected, but we don't want to update its\n          // visual status to selected until after we receive confirmation that its content has painted.\n          if (val)\n            this.setAttribute(\"selected\", \"true\");\n          else\n            this.removeAttribute(\"selected\");\n\n          // If we're non-e10s we should update the visual selection as well at the same time,\n          // *or* if we're e10s and the visually selected tab isn't changing, in which case the\n          // tab switcher code won't run and update anything else (like the before- and after-\n          // selected attributes).\n          if (!gMultiProcessBrowser || (val && this.hasAttribute(\"visuallyselected\"))) {\n            this._visuallySelected = val;\n          }\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"pinned\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"pinned\") == \"true\";\n        </getter>\n      </property>\n      <property name=\"hidden\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"hidden\") == \"true\";\n        </getter>\n      </property>\n      <property name=\"muted\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"muted\") == \"true\";\n        </getter>\n      </property>\n      <!--\n      Describes how the tab ended up in this mute state. May be any of:\n\n       - undefined: The tabs mute state has never changed.\n       - null: The mute state was last changed through the UI.\n       - Any string: The ID was changed through an extension API. The string\n                     must be the ID of the extension which changed it.\n      -->\n      <field name=\"muteReason\">undefined</field>\n\n      <property name=\"userContextId\" readonly=\"true\">\n        <getter>\n          return this.hasAttribute(\"usercontextid\")\n                   ? parseInt(this.getAttribute(\"usercontextid\"))\n                   : 0;\n        </getter>\n      </property>\n\n      <property name=\"soundPlaying\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"soundplaying\") == \"true\";\n        </getter>\n      </property>\n\n      <property name=\"activeMediaBlocked\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"activemedia-blocked\") == \"true\";\n        </getter>\n      </property>\n\n      <property name=\"lastAccessed\">\n        <getter>\n          return this._lastAccessed == Infinity ? Date.now() : this._lastAccessed;\n        </getter>\n      </property>\n      <method name=\"updateLastAccessed\">\n        <parameter name=\"aDate\"/>\n        <body><![CDATA[\n          this._lastAccessed = this.selected ? Infinity : (aDate || Date.now());\n        ]]></body>\n      </method>\n\n      <field name=\"mOverCloseButton\">false</field>\n      <property name=\"_overPlayingIcon\" readonly=\"true\">\n        <getter><![CDATA[\n          let iconVisible = this.hasAttribute(\"soundplaying\") ||\n                            this.hasAttribute(\"muted\") ||\n                            this.hasAttribute(\"activemedia-blocked\");\n          let soundPlayingIcon =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"soundplaying-icon\");\n          let overlayIcon =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"overlay-icon\");\n\n          return soundPlayingIcon && soundPlayingIcon.matches(\":hover\") ||\n                 (overlayIcon && overlayIcon.matches(\":hover\") && iconVisible);\n        ]]></getter>\n      </property>\n      <field name=\"mCorrespondingMenuitem\">null</field>\n\n      <!--\n      While it would make sense to track this in a field, the field will get nuked\n      once the node is gone from the DOM, which causes us to think the tab is not\n      closed, which causes us to make wrong decisions. So we use an expando instead.\n      <field name=\"closing\">false</field>\n      -->\n\n      <method name=\"_mouseenter\">\n        <body><![CDATA[\n          if (this.hidden || this.closing)\n            return;\n\n          let tabContainer = this.parentNode;\n          let visibleTabs = tabContainer.tabbrowser.visibleTabs;\n          let tabIndex = visibleTabs.indexOf(this);\n\n          if (this.selected)\n            tabContainer._handleTabSelect();\n\n          if (tabIndex == 0) {\n            tabContainer._beforeHoveredTab = null;\n          } else {\n            let candidate = visibleTabs[tabIndex - 1];\n            if (!candidate.selected) {\n              tabContainer._beforeHoveredTab = candidate;\n              candidate.setAttribute(\"beforehovered\", \"true\");\n            }\n          }\n\n          if (tabIndex == visibleTabs.length - 1) {\n            tabContainer._afterHoveredTab = null;\n          } else {\n            let candidate = visibleTabs[tabIndex + 1];\n            if (!candidate.selected) {\n              tabContainer._afterHoveredTab = candidate;\n              candidate.setAttribute(\"afterhovered\", \"true\");\n            }\n          }\n\n          tabContainer._hoveredTab = this;\n          if (this.linkedPanel && !this.selected) {\n            this.linkedBrowser.unselectedTabHover(true);\n            this.startUnselectedTabHoverTimer();\n          }\n\n          // Prepare connection to host beforehand.\n          SessionStore.speculativeConnectOnTabHover(this);\n          tabContainer.tabbrowser.warmupTab(this);\n        ]]></body>\n      </method>\n\n      <method name=\"_mouseleave\">\n        <body><![CDATA[\n          let tabContainer = this.parentNode;\n          if (tabContainer._beforeHoveredTab) {\n            tabContainer._beforeHoveredTab.removeAttribute(\"beforehovered\");\n            tabContainer._beforeHoveredTab = null;\n          }\n          if (tabContainer._afterHoveredTab) {\n            tabContainer._afterHoveredTab.removeAttribute(\"afterhovered\");\n            tabContainer._afterHoveredTab = null;\n          }\n\n          tabContainer._hoveredTab = null;\n          if (this.linkedPanel && !this.selected) {\n            this.linkedBrowser.unselectedTabHover(false);\n            this.cancelUnselectedTabHoverTimer();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"startUnselectedTabHoverTimer\">\n        <body><![CDATA[\n          // Only record data when we need to.\n          if (!this.linkedBrowser.shouldHandleUnselectedTabHover) {\n            return;\n          }\n\n          if (!TelemetryStopwatch.running(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this)) {\n            TelemetryStopwatch.start(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this);\n          }\n\n          if (this._hoverTabTimer) {\n            clearTimeout(this._hoverTabTimer);\n            this._hoverTabTimer = null;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"cancelUnselectedTabHoverTimer\">\n        <body><![CDATA[\n          // Since we're listening \"mouseout\" event, instead of \"mouseleave\".\n          // Every time the cursor is moving from the tab to its child node (icon),\n          // it would dispatch \"mouseout\"(for tab) first and then dispatch\n          // \"mouseover\" (for icon, eg: close button, speaker icon) soon.\n          // It causes we would cancel present TelemetryStopwatch immediately\n          // when cursor is moving on the icon, and then start a new one.\n          // In order to avoid this situation, we could delay cancellation and\n          // remove it if we get \"mouseover\" within very short period.\n          this._hoverTabTimer = setTimeout(() => {\n            if (TelemetryStopwatch.running(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this)) {\n              TelemetryStopwatch.cancel(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this);\n            }\n          }, 100);\n        ]]></body>\n      </method>\n\n      <method name=\"finishUnselectedTabHoverTimer\">\n        <body><![CDATA[\n          // Stop timer when the tab is opened.\n          if (TelemetryStopwatch.running(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this)) {\n            TelemetryStopwatch.finish(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"startMediaBlockTimer\">\n        <body><![CDATA[\n          TelemetryStopwatch.start(\"TAB_MEDIA_BLOCKING_TIME_MS\", this);\n        ]]></body>\n      </method>\n\n       <method name=\"finishMediaBlockTimer\">\n        <body><![CDATA[\n          TelemetryStopwatch.finish(\"TAB_MEDIA_BLOCKING_TIME_MS\", this);\n        ]]></body>\n      </method>\n\n      <method name=\"toggleMuteAudio\">\n        <parameter name=\"aMuteReason\"/>\n        <body>\n        <![CDATA[\n          // Do not attempt to toggle mute state if browser is lazy.\n          if (!this.linkedPanel) {\n            return;\n          }\n\n          let tabContainer = this.parentNode;\n          let browser = this.linkedBrowser;\n          let modifiedAttrs = [];\n          let hist = Services.telemetry.getHistogramById(\"TAB_AUDIO_INDICATOR_USED\");\n\n          if (this.hasAttribute(\"activemedia-blocked\")) {\n            this.removeAttribute(\"activemedia-blocked\");\n            modifiedAttrs.push(\"activemedia-blocked\");\n\n            browser.resumeMedia();\n            hist.add(3 /* unblockByClickingIcon */);\n            this.finishMediaBlockTimer();\n          } else {\n            if (browser.audioMuted) {\n              browser.unmute();\n              this.removeAttribute(\"muted\");\n              BrowserUITelemetry.countTabMutingEvent(\"unmute\", aMuteReason);\n              hist.add(1 /* unmute */);\n            } else {\n              browser.mute();\n              this.setAttribute(\"muted\", \"true\");\n              BrowserUITelemetry.countTabMutingEvent(\"mute\", aMuteReason);\n              hist.add(0 /* mute */);\n            }\n            this.muteReason = aMuteReason || null;\n            modifiedAttrs.push(\"muted\");\n          }\n          tabContainer.tabbrowser._tabAttrModified(this, modifiedAttrs);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setUserContextId\">\n        <parameter name=\"aUserContextId\"/>\n        <body>\n        <![CDATA[\n          if (aUserContextId) {\n            if (this.linkedBrowser) {\n              this.linkedBrowser.setAttribute(\"usercontextid\", aUserContextId);\n            }\n            this.setAttribute(\"usercontextid\", aUserContextId);\n          } else {\n            if (this.linkedBrowser) {\n              this.linkedBrowser.removeAttribute(\"usercontextid\");\n            }\n            this.removeAttribute(\"usercontextid\");\n          }\n\n          ContextualIdentityService.setTabStyle(this);\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"mouseover\"><![CDATA[\n        let anonid = event.originalTarget.getAttribute(\"anonid\");\n        if (anonid == \"close-button\")\n          this.mOverCloseButton = true;\n\n        this._mouseenter();\n      ]]></handler>\n      <handler event=\"mouseout\"><![CDATA[\n        let anonid = event.originalTarget.getAttribute(\"anonid\");\n        if (anonid == \"close-button\")\n          this.mOverCloseButton = false;\n\n        this._mouseleave();\n      ]]></handler>\n      <handler event=\"dragstart\" phase=\"capturing\">\n        this.style.MozUserFocus = \"\";\n      </handler>\n      <handler event=\"mousedown\" phase=\"capturing\">\n      <![CDATA[\n        if (this.selected) {\n          this.style.MozUserFocus = \"ignore\";\n        } else if (this.mOverCloseButton ||\n                   this._overPlayingIcon) {\n          // Prevent tabbox.xml from selecting the tab.\n          event.stopPropagation();\n        }\n      ]]>\n      </handler>\n      <handler event=\"mouseup\">\n        this.style.MozUserFocus = \"\";\n      </handler>\n      <handler event=\"click\">\n      <![CDATA[\n        if (event.button != 0) {\n          return;\n        }\n\n        if (this._overPlayingIcon) {\n          this.toggleMuteAudio();\n        }\n      ]]>\n      </handler>\n      <handler event=\"animationend\">\n      <![CDATA[\n        let anonid = event.originalTarget.getAttribute(\"anonid\");\n        if (anonid == \"tab-loading-burst\") {\n          this.removeAttribute(\"bursting\");\n        }\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"tabbrowser-alltabs-popup\"\n           extends=\"chrome://global/content/bindings/popup.xml#popup\">\n    <implementation implements=\"nsIDOMEventListener\">\n      <method name=\"_tabOnAttrModified\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          var tab = aEvent.target;\n          if (tab.mCorrespondingMenuitem)\n            this._setMenuitemAttributes(tab.mCorrespondingMenuitem, tab);\n        ]]></body>\n      </method>\n\n      <method name=\"_tabOnTabClose\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          var tab = aEvent.target;\n          if (tab.mCorrespondingMenuitem)\n            this.removeChild(tab.mCorrespondingMenuitem);\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.type) {\n            case \"TabAttrModified\":\n              this._tabOnAttrModified(aEvent);\n              break;\n            case \"TabClose\":\n              this._tabOnTabClose(aEvent);\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_updateTabsVisibilityStatus\">\n        <body><![CDATA[\n          var tabContainer = gBrowser.tabContainer;\n          // We don't want menu item decoration unless there is overflow.\n          if (tabContainer.getAttribute(\"overflow\") != \"true\") {\n            return;\n          }\n\n          let windowUtils = window.QueryInterface(Ci.nsIInterfaceRequestor)\n                                  .getInterface(Ci.nsIDOMWindowUtils);\n          let tabstripRect = windowUtils.getBoundsWithoutFlushing(tabContainer.mTabstrip);\n          for (let menuitem of this.childNodes) {\n            let curTab = menuitem.tab;\n            if (!curTab) {\n              // \"Undo close tab\", menuseparator, or entries put here by addons.\n              continue;\n            }\n            let curTabRect = windowUtils.getBoundsWithoutFlushing(curTab);\n            if (curTabRect.left >= tabstripRect.left &&\n                curTabRect.right <= tabstripRect.right) {\n              menuitem.setAttribute(\"tabIsVisible\", \"true\");\n            } else {\n              menuitem.removeAttribute(\"tabIsVisible\");\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_createTabMenuItem\">\n        <parameter name=\"aTab\"/>\n        <body><![CDATA[\n          var menuItem = document.createElementNS(\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\",\n            \"menuitem\");\n\n          menuItem.setAttribute(\"class\", \"menuitem-iconic alltabs-item menuitem-with-favicon\");\n\n          this._setMenuitemAttributes(menuItem, aTab);\n\n          aTab.mCorrespondingMenuitem = menuItem;\n          menuItem.tab = aTab;\n\n          this.appendChild(menuItem);\n        ]]></body>\n      </method>\n\n      <method name=\"_setMenuitemAttributes\">\n        <parameter name=\"aMenuitem\"/>\n        <parameter name=\"aTab\"/>\n        <body><![CDATA[\n          aMenuitem.setAttribute(\"label\", aTab.label);\n          aMenuitem.setAttribute(\"crop\", \"end\");\n\n          if (aTab.hasAttribute(\"busy\")) {\n            aMenuitem.setAttribute(\"busy\", aTab.getAttribute(\"busy\"));\n            aMenuitem.removeAttribute(\"iconloadingprincipal\");\n            aMenuitem.removeAttribute(\"image\");\n          } else {\n            aMenuitem.setAttribute(\"iconloadingprincipal\", aTab.getAttribute(\"iconloadingprincipal\"));\n            aMenuitem.setAttribute(\"image\", aTab.getAttribute(\"image\"));\n            aMenuitem.removeAttribute(\"busy\");\n          }\n\n          if (aTab.hasAttribute(\"pending\"))\n            aMenuitem.setAttribute(\"pending\", aTab.getAttribute(\"pending\"));\n          else\n            aMenuitem.removeAttribute(\"pending\");\n\n          if (aTab.selected)\n            aMenuitem.setAttribute(\"selected\", \"true\");\n          else\n            aMenuitem.removeAttribute(\"selected\");\n\n          function addEndImage() {\n            let endImage = document.createElement(\"image\");\n            endImage.setAttribute(\"class\", \"alltabs-endimage\");\n            let endImageContainer = document.createElement(\"hbox\");\n            endImageContainer.setAttribute(\"align\", \"center\");\n            endImageContainer.setAttribute(\"pack\", \"center\");\n            endImageContainer.appendChild(endImage);\n            aMenuitem.appendChild(endImageContainer);\n            return endImage;\n          }\n\n          if (aMenuitem.firstChild)\n            aMenuitem.firstChild.remove();\n          if (aTab.hasAttribute(\"muted\"))\n            addEndImage().setAttribute(\"muted\", \"true\");\n          else if (aTab.hasAttribute(\"soundplaying\"))\n            addEndImage().setAttribute(\"soundplaying\", \"true\");\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\">\n      <![CDATA[\n        if (event.target.getAttribute(\"id\") == \"alltabs_containersMenuTab\") {\n          createUserContextMenu(event, {useAccessKeys: false});\n          return;\n        }\n\n        let containersEnabled = Services.prefs.getBoolPref(\"privacy.userContext.enabled\");\n\n        if (event.target.getAttribute(\"anonid\") == \"newtab-popup\" ||\n            event.target.id == \"newtab-popup\") {\n          createUserContextMenu(event, {\n            useAccessKeys: false,\n            showDefaultTab: Services.prefs.getIntPref(\"privacy.userContext.longPressBehavior\") == 1\n          });\n        } else {\n          document.getElementById(\"alltabs-popup-separator-1\").hidden = !containersEnabled;\n          let containersTab = document.getElementById(\"alltabs_containersTab\");\n\n          containersTab.hidden = !containersEnabled;\n          if (PrivateBrowsingUtils.isWindowPrivate(window)) {\n            containersTab.setAttribute(\"disabled\", \"true\");\n          }\n\n          document.getElementById(\"alltabs_undoCloseTab\").disabled =\n            SessionStore.getClosedTabCount(window) == 0;\n\n          var tabcontainer = gBrowser.tabContainer;\n\n          // Listen for changes in the tab bar.\n          tabcontainer.addEventListener(\"TabAttrModified\", this);\n          tabcontainer.addEventListener(\"TabClose\", this);\n\n          let tabs = gBrowser.visibleTabs;\n          for (var i = 0; i < tabs.length; i++) {\n            if (!tabs[i].pinned)\n              this._createTabMenuItem(tabs[i]);\n          }\n          this._updateTabsVisibilityStatus();\n        }\n      ]]></handler>\n\n      <handler event=\"popuphidden\">\n      <![CDATA[\n        if (event.target.getAttribute(\"id\") == \"alltabs_containersMenuTab\") {\n          return;\n        }\n\n        // clear out the menu popup and remove the listeners\n        for (let i = this.childNodes.length - 1; i > 0; i--) {\n          let menuItem = this.childNodes[i];\n          if (menuItem.tab) {\n            menuItem.tab.mCorrespondingMenuitem = null;\n            this.removeChild(menuItem);\n          }\n          if (menuItem.hasAttribute(\"usercontextid\")) {\n            this.removeChild(menuItem);\n          }\n        }\n        var tabcontainer = gBrowser.tabContainer;\n        tabcontainer.removeEventListener(\"TabAttrModified\", this);\n        tabcontainer.removeEventListener(\"TabClose\", this);\n      ]]></handler>\n\n      <handler event=\"DOMMenuItemActive\">\n      <![CDATA[\n        var tab = event.target.tab;\n        if (tab) {\n          let overLink = tab.linkedBrowser.currentURI.displaySpec;\n          if (overLink == \"about:blank\")\n            overLink = \"\";\n          XULBrowserWindow.setOverLink(overLink, null);\n        }\n      ]]></handler>\n\n      <handler event=\"DOMMenuItemInactive\">\n      <![CDATA[\n        XULBrowserWindow.setOverLink(\"\", null);\n      ]]></handler>\n\n      <handler event=\"command\"><![CDATA[\n        if (event.target.tab) {\n          if (gBrowser.selectedTab != event.target.tab) {\n            gBrowser.selectedTab = event.target.tab;\n          } else {\n            gBrowser.tabContainer._handleTabSelect();\n          }\n        }\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n  <binding id=\"statuspanel\" display=\"xul:hbox\">\n    <content>\n      <xul:hbox class=\"statuspanel-inner\">\n        <xul:label class=\"statuspanel-label\"\n                   role=\"status\"\n                   aria-live=\"off\"\n                   xbl:inherits=\"value=label,crop,mirror\"\n                   flex=\"1\"\n                   crop=\"end\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMEventListener\">\n      <constructor><![CDATA[\n        window.addEventListener(\"resize\", this);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        window.removeEventListener(\"resize\", this);\n        MousePosTracker.removeListener(this);\n      ]]></destructor>\n\n      <property name=\"label\">\n        <setter><![CDATA[\n          if (!this.label) {\n            this.removeAttribute(\"mirror\");\n            this.removeAttribute(\"sizelimit\");\n          }\n\n          if (this.getAttribute(\"type\") == \"status\" &&\n              this.getAttribute(\"previoustype\") == \"status\") {\n            // Before updating the label, set the panel's current width as its\n            // min-width to let the panel grow but not shrink and prevent\n            // unnecessary flicker while loading pages. We only care about the\n            // panel's width once it has been painted, so we can do this\n            // without flushing layout.\n            this.style.minWidth =\n              window.QueryInterface(Ci.nsIInterfaceRequestor)\n                    .getInterface(Ci.nsIDOMWindowUtils)\n                    .getBoundsWithoutFlushing(this).width + \"px\";\n          } else {\n            this.style.minWidth = \"\";\n          }\n\n          if (val) {\n            this.setAttribute(\"label\", val);\n            this.removeAttribute(\"inactive\");\n            this._mouseTargetRect = null;\n            MousePosTracker.addListener(this);\n          } else {\n            this.setAttribute(\"inactive\", \"true\");\n            MousePosTracker.removeListener(this);\n          }\n\n          return val;\n        ]]></setter>\n        <getter>\n          return this.hasAttribute(\"inactive\") ? \"\" : this.getAttribute(\"label\");\n        </getter>\n      </property>\n\n      <method name=\"getMouseTargetRect\">\n        <body><![CDATA[\n          if (!this._mouseTargetRect) {\n            this._calcMouseTargetRect();\n          }\n          return this._mouseTargetRect;\n        ]]></body>\n      </method>\n\n      <method name=\"onMouseEnter\">\n        <body>\n          this._mirror();\n        </body>\n      </method>\n\n      <method name=\"onMouseLeave\">\n        <body>\n          this._mirror();\n        </body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (!this.label)\n            return;\n\n          switch (event.type) {\n            case \"resize\":\n              this._mouseTargetRect = null;\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_calcMouseTargetRect\">\n        <body><![CDATA[\n          let container = this.parentNode;\n          let alignRight = (getComputedStyle(container).direction == \"rtl\");\n          let panelRect = this.getBoundingClientRect();\n          let containerRect = container.getBoundingClientRect();\n\n          this._mouseTargetRect = {\n            top:    panelRect.top,\n            bottom: panelRect.bottom,\n            left:   alignRight ? containerRect.right - panelRect.width : containerRect.left,\n            right:  alignRight ? containerRect.right : containerRect.left + panelRect.width\n          };\n        ]]></body>\n      </method>\n\n      <method name=\"_mirror\">\n        <body>\n          if (this.hasAttribute(\"mirror\"))\n            this.removeAttribute(\"mirror\");\n          else\n            this.setAttribute(\"mirror\", \"true\");\n\n          if (!this.hasAttribute(\"sizelimit\")) {\n            this.setAttribute(\"sizelimit\", \"true\");\n            this._mouseTargetRect = null;\n          }\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"tabbrowser-tabpanels\"\n           extends=\"chrome://global/content/bindings/tabbox.xml#tabpanels\">\n    <implementation>\n      <field name=\"_selectedIndex\">0</field>\n\n      <property name=\"selectedIndex\">\n        <getter>\n        <![CDATA[\n          return this._selectedIndex;\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          if (val < 0 || val >= this.childNodes.length)\n            return val;\n\n          let toTab = this.getRelatedElement(this.childNodes[val]);\n\n          gBrowser._getSwitcher().requestTab(toTab);\n\n          var panel = this._selectedPanel;\n          var newPanel = this.childNodes[val];\n          this._selectedPanel = newPanel;\n          if (this._selectedPanel != panel) {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"select\", true, true);\n            this.dispatchEvent(event);\n\n            this._selectedIndex = val;\n          }\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n    </implementation>\n  </binding>\n\n  <binding id=\"tabbrowser-browser\"\n           extends=\"chrome://global/content/bindings/browser.xml#browser\">\n    <implementation>\n      <field name=\"tabModalPromptBox\">null</field>\n\n      <!-- throws exception for unknown schemes -->\n      <method name=\"loadURIWithFlags\">\n        <parameter name=\"aURI\"/>\n        <parameter name=\"aFlags\"/>\n        <parameter name=\"aReferrerURI\"/>\n        <parameter name=\"aCharset\"/>\n        <parameter name=\"aPostData\"/>\n        <body>\n          <![CDATA[\n            var params = arguments[1];\n            if (typeof(params) == \"number\") {\n              params = {\n                flags: aFlags,\n                referrerURI: aReferrerURI,\n                charset: aCharset,\n                postData: aPostData,\n              };\n            }\n            _loadURIWithFlags(this, aURI, params);\n          ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"tabbrowser-remote-browser\"\n           extends=\"chrome://global/content/bindings/remote-browser.xml#remote-browser\">\n    <implementation>\n      <field name=\"tabModalPromptBox\">null</field>\n\n      <!-- throws exception for unknown schemes -->\n      <method name=\"loadURIWithFlags\">\n        <parameter name=\"aURI\"/>\n        <parameter name=\"aFlags\"/>\n        <parameter name=\"aReferrerURI\"/>\n        <parameter name=\"aCharset\"/>\n        <parameter name=\"aPostData\"/>\n        <body>\n          <![CDATA[\n            var params = arguments[1];\n            if (typeof(params) == \"number\") {\n              params = {\n                flags: aFlags,\n                referrerURI: aReferrerURI,\n                charset: aCharset,\n                postData: aPostData,\n              };\n            }\n            _loadURIWithFlags(this, aURI, params);\n          ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"urlbarBindings.xml","body":"<?xml version=\"1.0\"?>\n\n<!--\n-*- Mode: HTML -*-\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n-->\n\n<!-- eslint-env mozilla/browser-window -->\n\n<!DOCTYPE bindings [\n<!ENTITY % notificationDTD SYSTEM \"chrome://global/locale/notification.dtd\">\n%notificationDTD;\n<!ENTITY % browserDTD SYSTEM \"chrome://browser/locale/browser.dtd\">\n%browserDTD;\n<!ENTITY % brandDTD SYSTEM \"chrome://branding/locale/brand.dtd\">\n%brandDTD;\n]>\n\n<bindings id=\"urlbarBindings\" xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"urlbar\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete\">\n\n    <content sizetopopup=\"pref\">\n      <xul:hbox anonid=\"textbox-container\"\n                class=\"autocomplete-textbox-container urlbar-textbox-container\"\n                flex=\"1\" xbl:inherits=\"focused\">\n        <children includes=\"image|deck|stack|box\"/>\n        <xul:hbox anonid=\"textbox-input-box\"\n                  class=\"textbox-input-box urlbar-input-box\"\n                  flex=\"1\" xbl:inherits=\"tooltiptext=inputtooltiptext\">\n          <children/>\n          <html:input anonid=\"input\"\n                      class=\"autocomplete-textbox urlbar-input textbox-input\"\n                      allowevents=\"true\"\n                      inputmode=\"mozAwesomebar\"\n                      xbl:inherits=\"tooltiptext=inputtooltiptext,value,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,focused,textoverflow\"/>\n        </xul:hbox>\n        <xul:image anonid=\"urlbar-go-button\"\n                   class=\"urlbar-go-button urlbar-icon\"\n                   onclick=\"gURLBar.handleCommand(event);\"\n                   tooltiptext=\"FROM-DTD-goEndCap-tooltip\"\n                   xbl:inherits=\"pageproxystate,parentfocused=focused,usertyping\"/>\n        <xul:dropmarker anonid=\"historydropmarker\"\n                        class=\"urlbar-history-dropmarker urlbar-icon chromeclass-toolbar-additional\"\n                        tooltiptext=\"FROM-DTD-urlbar-openHistoryPopup-tooltip\"\n                        allowevents=\"true\"\n                        xbl:inherits=\"open,parentfocused=focused,usertyping\"/>\n        <children includes=\"hbox\"/>\n      </xul:hbox>\n      <xul:popupset anonid=\"popupset\"\n                    class=\"autocomplete-result-popupset\"/>\n      <children includes=\"toolbarbutton\"/>\n    </content>\n\n    <implementation implements=\"nsIObserver, nsIDOMEventListener\">\n      <field name=\"ExtensionSearchHandler\" readonly=\"true\">\n        (Components.utils.import(\"resource://gre/modules/ExtensionSearchHandler.jsm\", {})).ExtensionSearchHandler;\n      </field>\n\n      <constructor><![CDATA[\n        this._prefs = Components.classes[\"@mozilla.org/preferences-service;1\"]\n                                .getService(Components.interfaces.nsIPrefService)\n                                .getBranch(\"browser.urlbar.\");\n        this._prefs.addObserver(\"\", this);\n\n        this._defaultPrefs = Components.classes[\"@mozilla.org/preferences-service;1\"]\n                                       .getService(Components.interfaces.nsIPrefService)\n                                       .getDefaultBranch(\"browser.urlbar.\");\n\n        Services.prefs.addObserver(\"browser.search.suggest.enabled\", this);\n        this.browserSearchSuggestEnabled = Services.prefs.getBoolPref(\"browser.search.suggest.enabled\");\n\n        this.clickSelectsAll = this._prefs.getBoolPref(\"clickSelectsAll\");\n        this.doubleClickSelectsAll = this._prefs.getBoolPref(\"doubleClickSelectsAll\");\n        this.completeDefaultIndex = this._prefs.getBoolPref(\"autoFill\");\n        this.speculativeConnectEnabled = this._prefs.getBoolPref(\"speculativeConnect.enabled\");\n        this.urlbarSearchSuggestEnabled = this._prefs.getBoolPref(\"suggest.searches\");\n        this.timeout = this._prefs.getIntPref(\"delay\");\n        this._formattingEnabled = this._prefs.getBoolPref(\"formatting.enabled\");\n        this._mayTrimURLs = this._prefs.getBoolPref(\"trimURLs\");\n        this._adoptIntoActiveWindow = this._prefs.getBoolPref(\"switchTabs.adoptIntoActiveWindow\");\n        this.inputField.controllers.insertControllerAt(0, this._copyCutController);\n        this.inputField.addEventListener(\"paste\", this);\n        this.inputField.addEventListener(\"mousedown\", this);\n        this.inputField.addEventListener(\"mousemove\", this);\n        this.inputField.addEventListener(\"mouseout\", this);\n        this.inputField.addEventListener(\"overflow\", this);\n        this.inputField.addEventListener(\"underflow\", this);\n\n        var textBox = document.getAnonymousElementByAttribute(this,\n                                                \"anonid\", \"textbox-input-box\");\n        var cxmenu = document.getAnonymousElementByAttribute(textBox,\n                                            \"anonid\", \"input-box-contextmenu\");\n        var pasteAndGo;\n        cxmenu.addEventListener(\"popupshowing\", function() {\n          if (!pasteAndGo)\n            return;\n          var controller = document.commandDispatcher.getControllerForCommand(\"cmd_paste\");\n          var enabled = controller.isCommandEnabled(\"cmd_paste\");\n          if (enabled)\n            pasteAndGo.removeAttribute(\"disabled\");\n          else\n            pasteAndGo.setAttribute(\"disabled\", \"true\");\n        });\n\n        var insertLocation = cxmenu.firstChild;\n        while (insertLocation.nextSibling &&\n               insertLocation.getAttribute(\"cmd\") != \"cmd_paste\")\n          insertLocation = insertLocation.nextSibling;\n        if (insertLocation) {\n          pasteAndGo = document.createElement(\"menuitem\");\n          let label = Services.strings.createBundle(\"chrome://browser/locale/browser.properties\").\n                                   GetStringFromName(\"pasteAndGo.label\");\n          pasteAndGo.setAttribute(\"label\", label);\n          pasteAndGo.setAttribute(\"anonid\", \"paste-and-go\");\n          pasteAndGo.setAttribute(\"oncommand\",\n              \"gURLBar.select(); goDoCommand('cmd_paste'); gURLBar.handleCommand();\");\n          cxmenu.insertBefore(pasteAndGo, insertLocation.nextSibling);\n        }\n\n        this.popup.addEventListener(\"popupshowing\", () => {\n          this._enableOrDisableOneOffSearches();\n        }, {capturing: true, once: true});\n\n        // history dropmarker open state\n        this.popup.addEventListener(\"popupshowing\", () => {\n          this.setAttribute(\"open\", \"true\");\n        });\n        this.popup.addEventListener(\"popuphidden\", () => {\n          requestAnimationFrame(() => {\n            this.removeAttribute(\"open\");\n          });\n        });\n\n        // The autocomplete controller uses heuristic on some internal caches\n        // to handle cases like backspace, autofill or repeated searches.\n        // Ensure to clear those internal caches when switching tabs.\n        gBrowser.tabContainer.addEventListener(\"TabSelect\", this);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        this._prefs.removeObserver(\"\", this);\n        this._prefs = null;\n        Services.prefs.removeObserver(\"browser.search.suggest.enabled\", this);\n        this.inputField.controllers.removeController(this._copyCutController);\n        this.inputField.removeEventListener(\"paste\", this);\n        this.inputField.removeEventListener(\"mousedown\", this);\n        this.inputField.removeEventListener(\"mousemove\", this);\n        this.inputField.removeEventListener(\"mouseout\", this);\n        this.inputField.removeEventListener(\"overflow\", this);\n        this.inputField.removeEventListener(\"underflow\", this);\n\n        if (this._deferredKeyEventTimeout) {\n          clearTimeout(this._deferredKeyEventTimeout);\n          this._deferredKeyEventTimeout = null;\n        }\n\n        // Null out the one-offs' popup and textbox so that it cleans up its\n        // internal state for both.  Most importantly, it removes the event\n        // listeners that it added to both.\n        this.popup.oneOffSearchButtons.popup = null;\n        this.popup.oneOffSearchButtons.textbox = null;\n      ]]></destructor>\n\n      <field name=\"goButton\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"urlbar-go-button\");\n      </field>\n\n      <field name=\"_value\">\"\"</field>\n      <field name=\"gotResultForCurrentQuery\">false</field>\n\n      <!--\n        This is set around HandleHenter so it can be used in handleCommand.\n        It is also used to track whether we must handle a delayed handleEnter,\n        by checking if it has been cleared.\n      -->\n      <field name=\"handleEnterInstance\">null</field>\n\n      <!--\n        For performance reasons we want to limit the size of the text runs we\n        build and show to the user.\n      -->\n      <field name=\"textRunsMaxLen\">255</field>\n\n      <!--\n        Since we never want scrollbars, we always use the maxResults value.\n      -->\n      <property name=\"maxRows\"\n                onget=\"return this.popup.maxResults;\"/>\n\n      <!--\n        Set by focusAndSelectUrlBar to indicate whether the next focus event was\n        initiated by an explicit user action. See the \"focus\" handler below.\n      -->\n      <field name=\"userInitiatedFocus\">false</field>\n\n      <!--\n        onBeforeValueGet is called by the base-binding's .value getter.\n        It can return an object with a \"value\" property, to override the\n        return value of the getter.\n      -->\n      <method name=\"onBeforeValueGet\">\n        <body><![CDATA[\n          return { value: this._value };\n        ]]></body>\n      </method>\n\n      <!--\n        onBeforeValueSet is called by the base-binding's .value setter.\n        It should return the value that the setter should use.\n      -->\n      <method name=\"onBeforeValueSet\">\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          this._value = aValue;\n          var returnValue = aValue;\n          var action = this._parseActionUrl(aValue);\n\n          if (action) {\n            switch (action.type) {\n              case \"switchtab\": // Fall through.\n              case \"remotetab\": // Fall through.\n              case \"visiturl\": {\n                returnValue = action.params.displayUrl;\n                break;\n              }\n              case \"keyword\": // Fall through.\n              case \"searchengine\": {\n                returnValue = action.params.input;\n                break;\n              }\n              case \"extension\": {\n                returnValue = action.params.content;\n                break;\n              }\n            }\n          } else {\n            let originalUrl = ReaderMode.getOriginalUrlObjectForDisplay(aValue);\n            if (originalUrl) {\n              returnValue = originalUrl.displaySpec;\n            }\n          }\n\n          // Set the actiontype only if the user is not overriding actions.\n          if (action && this._pressedNoActionKeys.size == 0) {\n            this.setAttribute(\"actiontype\", action.type);\n          } else {\n            this.removeAttribute(\"actiontype\");\n          }\n          return returnValue;\n        ]]></body>\n      </method>\n\n      <method name=\"onKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.keyCode) {\n            case KeyEvent.DOM_VK_LEFT:\n            case KeyEvent.DOM_VK_RIGHT:\n            case KeyEvent.DOM_VK_HOME:\n              // Reset the selected index so that nsAutoCompleteController\n              // simply closes the popup without trying to fill anything.\n              this.popup.selectedIndex = -1;\n              break;\n          }\n          if (!this.popup.disableKeyNavigation) {\n            if (this._keyCodesToDefer.has(aEvent.keyCode) &&\n                this._shouldDeferKeyEvent(aEvent)) {\n              this._deferKeyEvent(aEvent, \"onKeyPress\");\n              return false;\n            }\n            if (this.popup.popupOpen && this.popup.handleKeyPress(aEvent)) {\n              return true;\n            }\n          }\n          return this.handleKeyPress(aEvent);\n        ]]></body>\n      </method>\n\n      <!--\n        Search results arrive asynchronously, which means that keypresses may\n        arrive before results do and therefore not have the effect the user\n        intends.  That's especially likely to happen with the down arrow and\n        enter keys due to the one-off search buttons: if the user very quickly\n        pastes something in the input, presses the down arrow key, and then hits\n        enter, they are probably expecting to visit the first result.  But if\n        there are no results, then pressing down and enter will trigger the\n        first one-off button.  To prevent that undesirable behavior, certain\n        keys are buffered and deferred until more results arrive, at which time\n        they're replayed.\n\n        @param event\n               The key event that should maybe be deferred.  You can pass null\n               or undefined if you don't have one to see whether the next key\n               event in general should be deferred.\n        @return True if the event should be deferred, false if not.\n       -->\n      <method name=\"_shouldDeferKeyEvent\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let waitedLongEnough =\n            this._searchStartDate + this._deferredKeyEventTimeoutMs < Date.now();\n          if (waitedLongEnough && !this._deferredKeyEventTimeout) {\n            return false;\n          }\n          if (event && event.keyCode == KeyEvent.DOM_VK_TAB && !this.popupOpen) {\n            // In this case, the popup is closed and the user pressed the Tab\n            // key.  The focus should move out of the urlbar immediately.\n            return false;\n          }\n          if (!this.gotResultForCurrentQuery || !this.popupOpen) {\n            return true;\n          }\n          let maxResultsRemaining =\n            this.popup.maxResults - this.popup._matchCount;\n          let lastResultSelected =\n            this.popup.selectedIndex + 1 == this.popup._matchCount;\n          return maxResultsRemaining > 0 && lastResultSelected;\n        ]]></body>\n      </method>\n\n      <!--\n        Adds a key event to the deferred event queue.\n\n        @param event\n               The key event to defer.\n        @param methodName\n               The name of the method on `this` to call.  It's expected to take\n               a single argument, the event.\n      -->\n      <method name=\"_deferKeyEvent\">\n        <parameter name=\"event\"/>\n        <parameter name=\"methodName\"/>\n        <body><![CDATA[\n          // Somehow event.defaultPrevented ends up true for deferred events.\n          // autocomplete ignores defaultPrevented events, which means it would\n          // ignore replayed deferred events if we didn't tell it to bypass\n          // defaultPrevented.  That's the purpose of this expando.  If we could\n          // figure out what's setting defaultPrevented and prevent it, then we\n          // could get rid of this.\n          event.urlbarDeferred = true;\n\n          this._deferredKeyEventQueue.push({\n            methodName,\n            event,\n            searchString: this.mController.searchString,\n          });\n\n          if (!this._deferredKeyEventTimeout) {\n            this._deferredKeyEventTimeout = setTimeout(() => {\n              this._deferredKeyEventTimeout = null;\n              this.maybeReplayDeferredKeyEvents();\n            }, this._deferredKeyEventTimeoutMs);\n          }\n        ]]></body>\n      </method>\n\n      <!-- The enter key is always deferred, so it's not included here. -->\n      <field name=\"_keyCodesToDefer\">new Set([\n        Ci.nsIDOMKeyEvent.DOM_VK_DOWN,\n        Ci.nsIDOMKeyEvent.DOM_VK_TAB,\n      ])</field>\n      <field name=\"_deferredKeyEventQueue\">[]</field>\n      <field name=\"_deferredKeyEventTimeout\">null</field>\n      <field name=\"_deferredKeyEventTimeoutMs\">200</field>\n      <field name=\"_searchStartDate\">0</field>\n\n      <method name=\"maybeReplayDeferredKeyEvents\">\n        <body><![CDATA[\n          if (!this._deferredKeyEventQueue.length ||\n              this._shouldDeferKeyEvent()) {\n            return;\n          }\n          if (this._deferredKeyEventTimeout) {\n            clearTimeout(this._deferredKeyEventTimeout);\n            this._deferredKeyEventTimeout = null;\n          }\n          let instance = this._deferredKeyEventQueue.shift();\n          // Safety check: handle only if the search string didn't change.\n          if (this.mController.searchString == instance.searchString) {\n            this[instance.methodName](instance.event);\n          }\n          setTimeout(() => {\n            this.maybeReplayDeferredKeyEvents();\n          });\n        ]]></body>\n      </method>\n\n      <field name=\"_mayTrimURLs\">true</field>\n      <method name=\"trimValue\">\n        <parameter name=\"aURL\"/>\n        <body><![CDATA[\n          // This method must not modify the given URL such that calling\n          // nsIURIFixup::createFixupURI with the result will produce a different URI.\n          return this._mayTrimURLs ? trimURL(aURL) : aURL;\n        ]]></body>\n      </method>\n\n      <field name=\"_formattingEnabled\">true</field>\n      <method name=\"formatValue\">\n        <body><![CDATA[\n          if (!this._formattingEnabled || !this.editor)\n            return;\n\n          let controller = this.editor.selectionController;\n          let strikeOut = controller.getSelection(controller.SELECTION_URLSTRIKEOUT);\n          strikeOut.removeAllRanges();\n\n          let selection = controller.getSelection(controller.SELECTION_URLSECONDARY);\n          selection.removeAllRanges();\n\n          if (this.focused)\n            return;\n\n          let textNode = this.editor.rootElement.firstChild;\n          let value = textNode.textContent;\n          if (!value)\n            return;\n\n          // Get the URL from the fixup service:\n          let flags = Services.uriFixup.FIXUP_FLAG_FIX_SCHEME_TYPOS |\n                      Services.uriFixup.FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP;\n          let uriInfo;\n          try {\n            uriInfo = Services.uriFixup.getFixupURIInfo(value, flags);\n          } catch (ex) {}\n          // Ignore if we couldn't make a URI out of this, the URI resulted in a search,\n          // or the URI has a non-http(s)/ftp protocol.\n          if (!uriInfo ||\n              !uriInfo.fixedURI ||\n              uriInfo.keywordProviderName ||\n              [\"http\", \"https\", \"ftp\"].indexOf(uriInfo.fixedURI.scheme) == -1) {\n            return;\n          }\n\n          // If we trimmed off the http scheme, ensure we stick it back on before\n          // trying to figure out what domain we're accessing, so we don't get\n          // confused by user:pass@host http URLs. We later use\n          // trimmedLength to ensure we don't count the length of a trimmed protocol\n          // when determining which parts of the URL to highlight as \"preDomain\".\n          let trimmedLength = 0;\n          if (uriInfo.fixedURI.scheme == \"http\" && !value.startsWith(\"http://\")) {\n            value = \"http://\" + value;\n            trimmedLength = \"http://\".length;\n          }\n\n          let matchedURL = value.match(/^((?:[a-z]+:\\/\\/)(?:[^\\/#?]+@)?)(\\S+?)(?::\\d+)?\\s*(?:[\\/#?]|$)/);\n          if (!matchedURL)\n            return;\n\n          // Strike out the \"https\" part if mixed active content is loaded.\n          if (this.getAttribute(\"pageproxystate\") == \"valid\" &&\n              value.startsWith(\"https:\") &&\n              gBrowser.securityUI.state &\n                Ci.nsIWebProgressListener.STATE_LOADED_MIXED_ACTIVE_CONTENT) {\n            let range = document.createRange();\n            range.setStart(textNode, 0);\n            range.setEnd(textNode, 5);\n            strikeOut.addRange(range);\n          }\n\n          let [, preDomain, domain] = matchedURL;\n          let baseDomain = domain;\n          let subDomain = \"\";\n          try {\n            baseDomain = Services.eTLD.getBaseDomainFromHost(uriInfo.fixedURI.host);\n            if (!domain.endsWith(baseDomain)) {\n              // getBaseDomainFromHost converts its resultant to ACE.\n              let IDNService = Cc[\"@mozilla.org/network/idn-service;1\"]\n                               .getService(Ci.nsIIDNService);\n              baseDomain = IDNService.convertACEtoUTF8(baseDomain);\n            }\n          } catch (e) {}\n          if (baseDomain != domain) {\n            subDomain = domain.slice(0, -baseDomain.length);\n          }\n\n          let rangeLength = preDomain.length + subDomain.length - trimmedLength;\n          if (rangeLength) {\n            let range = document.createRange();\n            range.setStart(textNode, 0);\n            range.setEnd(textNode, rangeLength);\n            selection.addRange(range);\n          }\n\n          let startRest = preDomain.length + domain.length - trimmedLength;\n          if (startRest < value.length - trimmedLength) {\n            let range = document.createRange();\n            range.setStart(textNode, startRest);\n            range.setEnd(textNode, value.length - trimmedLength);\n            selection.addRange(range);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"handleRevert\">\n        <body><![CDATA[\n          var isScrolling = this.popupOpen;\n\n          gBrowser.userTypedValue = null;\n\n          // don't revert to last valid url unless page is NOT loading\n          // and user is NOT key-scrolling through autocomplete list\n          if (!XULBrowserWindow.isBusy && !isScrolling) {\n            URLBarSetURI();\n\n            // If the value isn't empty and the urlbar has focus, select the value.\n            if (this.value && this.hasAttribute(\"focused\"))\n              this.select();\n          }\n\n          // tell widget to revert to last typed text only if the user\n          // was scrolling when they hit escape\n          return !isScrolling;\n        ]]></body>\n      </method>\n\n      <!--\n        This is ultimately called by the autocomplete controller as the result\n        of handleEnter when the Return key is pressed in the textbox.  Since\n        onPopupClick also calls handleEnter, this is also called as a result in\n        that case.\n\n        @param event\n               The event that triggered the command.\n        @param openUILinkWhere\n               Optional.  The \"where\" to pass to openUILinkIn.  This method\n               computes the appropriate \"where\" given the event, but you can\n               use this to override it.\n        @param openUILinkParams\n               Optional.  The parameters to pass to openUILinkIn.  As with\n               \"where\", this method computes the appropriate parameters, but\n               any parameters you supply here will override those.\n      -->\n      <method name=\"handleCommand\">\n        <parameter name=\"event\"/>\n        <parameter name=\"openUILinkWhere\"/>\n        <parameter name=\"openUILinkParams\"/>\n        <body><![CDATA[\n          let isMouseEvent = event instanceof MouseEvent;\n          if (isMouseEvent && event.button == 2) {\n            // Do nothing for right clicks.\n            return;\n          }\n\n          BrowserUsageTelemetry.recordUrlbarSelectedResultMethod(event);\n\n          // Determine whether to use the selected one-off search button.  In\n          // one-off search buttons parlance, \"selected\" means that the button\n          // has been navigated to via the keyboard.  So we want to use it if\n          // the triggering event is not a mouse click -- i.e., it's a Return\n          // key -- or if the one-off was mouse-clicked.\n          let selectedOneOff = this.popup.oneOffSearchButtons.selectedButton;\n          if (selectedOneOff &&\n              isMouseEvent &&\n              event.originalTarget != selectedOneOff) {\n            selectedOneOff = null;\n          }\n\n          // Do the command of the selected one-off if it's not an engine.\n          if (selectedOneOff && !selectedOneOff.engine) {\n            selectedOneOff.doCommand();\n            return;\n          }\n\n          let where = openUILinkWhere;\n          if (!where) {\n            if (isMouseEvent) {\n              where = whereToOpenLink(event, false, false);\n            } else {\n              // If the current tab is empty, ignore Alt+Enter (reuse this tab)\n              let altEnter = !isMouseEvent &&\n                             event &&\n                             event.altKey &&\n                             !isTabEmpty(gBrowser.selectedTab);\n              where = altEnter ? \"tab\" : \"current\";\n            }\n          }\n\n          let url = this.value;\n          if (!url) {\n            return;\n          }\n\n          let mayInheritPrincipal = false;\n          let postData = null;\n          let browser = gBrowser.selectedBrowser;\n          let action = this._parseActionUrl(url);\n\n          if (selectedOneOff && selectedOneOff.engine) {\n            // If there's a selected one-off button then load a search using\n            // the one-off's engine.\n            [url, postData] =\n              this._parseAndRecordSearchEngineLoad(selectedOneOff.engine,\n                                                   this.oneOffSearchQuery,\n                                                   event, where,\n                                                   openUILinkParams);\n          } else if (action) {\n            switch (action.type) {\n              case \"visiturl\":\n                // Unifiedcomplete uses fixupURI to tell if something is a visit\n                // or a search, and passes out the fixedURI as the url param.\n                // By using that uri we would end up passing a different string\n                // to the docshell that may run a different not-found heuristic.\n                // For example, \"mozilla/run\" would be fixed by unifiedcomplete\n                // to \"http://mozilla/run\". The docshell, once it can't resolve\n                // mozilla, would note the string has a scheme, and try to load\n                // http://mozilla.com/run instead of searching \"mozilla/run\".\n                // So, if we have the original input at hand, we pass it through\n                // and let the docshell handle it.\n                if (action.params.input) {\n                  url = action.params.input;\n                  break;\n                }\n                url = action.params.url;\n                break;\n              case \"remotetab\":\n                url = action.params.url;\n                break;\n              case \"keyword\":\n                if (action.params.postData) {\n                  postData = getPostDataStream(action.params.postData);\n                }\n                mayInheritPrincipal = true;\n                url = action.params.url;\n                break;\n              case \"switchtab\":\n                url = action.params.url;\n                if (this.hasAttribute(\"actiontype\")) {\n                  this.handleRevert();\n                  let prevTab = gBrowser.selectedTab;\n                  let loadOpts = {\n                    adoptIntoActiveWindow: this._adoptIntoActiveWindow,\n                  };\n\n                  if (switchToTabHavingURI(url, false, loadOpts) &&\n                      isTabEmpty(prevTab)) {\n                    gBrowser.removeTab(prevTab);\n                  }\n                  return;\n                }\n                break;\n              case \"searchengine\":\n                if (selectedOneOff && selectedOneOff.engine) {\n                  // Replace the engine with the selected one-off engine.\n                  action.params.engineName = selectedOneOff.engine.name;\n                }\n                const actionDetails = {\n                  isSuggestion: !!action.params.searchSuggestion,\n                  isAlias: !!action.params.alias\n                };\n                [url, postData] = this._parseAndRecordSearchEngineLoad(\n                  action.params.engineName,\n                  action.params.searchSuggestion || action.params.searchQuery,\n                  event,\n                  where,\n                  openUILinkParams,\n                  actionDetails\n                );\n                break;\n              case \"extension\":\n                this.handleRevert();\n                // Give the extension control of handling the command.\n                let searchString = action.params.content;\n                let keyword = action.params.keyword;\n                this.ExtensionSearchHandler.handleInputEntered(keyword, searchString, where);\n                return;\n            }\n          } else {\n            // This is a fallback for add-ons and old testing code that directly\n            // set value and try to confirm it. UnifiedComplete should always\n            // resolve to a valid url.\n            try {\n              new URL(url);\n            } catch (ex) {\n              let lastLocationChange = browser.lastLocationChange;\n              getShortcutOrURIAndPostData(url).then(data => {\n                if (where != \"current\" ||\n                    browser.lastLocationChange == lastLocationChange) {\n                  this._loadURL(data.url, browser, data.postData, where,\n                                openUILinkParams, data.mayInheritPrincipal);\n                }\n              });\n              return;\n            }\n          }\n\n          this._loadURL(url, browser, postData, where, openUILinkParams,\n                        mayInheritPrincipal);\n        ]]></body>\n      </method>\n\n      <property name=\"oneOffSearchQuery\">\n        <getter><![CDATA[\n          // If the user has selected a search suggestion, chances are they\n          // want to use the one off search engine to search for that suggestion,\n          // not the string that they manually entered into the location bar.\n          let action = this._parseActionUrl(this.value);\n          if (action && action.type == \"searchengine\") {\n            return action.params.input;\n          }\n          // this.textValue may be an autofilled string.  Search only with the\n          // portion that the user typed, if any, by preferring the autocomplete\n          // controller's searchString (including handleEnterInstance.searchString).\n          return this.handleEnterSearchString ||\n                 this.mController.searchString ||\n                 this.textValue;\n        ]]></getter>\n      </property>\n\n      <method name=\"_loadURL\">\n        <parameter name=\"url\"/>\n        <parameter name=\"browser\"/>\n        <parameter name=\"postData\"/>\n        <parameter name=\"openUILinkWhere\"/>\n        <parameter name=\"openUILinkParams\"/>\n        <parameter name=\"mayInheritPrincipal\"/>\n        <body><![CDATA[\n          this.value = url;\n          browser.userTypedValue = url;\n          if (gInitialPages.includes(url)) {\n            browser.initialPageLoadedFromURLBar = url;\n          }\n          try {\n            addToUrlbarHistory(url);\n          } catch (ex) {\n            // Things may go wrong when adding url to session history,\n            // but don't let that interfere with the loading of the url.\n            Cu.reportError(ex);\n          }\n\n          let params = {\n            postData,\n            allowThirdPartyFixup: true,\n          };\n          if (openUILinkWhere == \"current\") {\n            params.targetBrowser = browser;\n            params.indicateErrorPageLoad = true;\n            params.allowPinnedTabHostChange = true;\n            params.disallowInheritPrincipal = !mayInheritPrincipal;\n            params.allowPopups = url.startsWith(\"javascript:\");\n          } else {\n            params.initiatingDoc = document;\n          }\n\n          if (openUILinkParams) {\n            for (let key in openUILinkParams) {\n              params[key] = openUILinkParams[key];\n            }\n          }\n\n          // Focus the content area before triggering loads, since if the load\n          // occurs in a new tab, we want focus to be restored to the content\n          // area when the current tab is re-selected.\n          browser.focus();\n\n          if (openUILinkWhere != \"current\") {\n            this.handleRevert();\n          }\n\n          try {\n            openUILinkIn(url, openUILinkWhere, params);\n          } catch (ex) {\n            // This load can throw an exception in certain cases, which means\n            // we'll want to replace the URL with the loaded URL:\n            if (ex.result != Cr.NS_ERROR_LOAD_SHOWED_ERRORPAGE) {\n              this.handleRevert();\n            }\n          }\n\n          if (openUILinkWhere == \"current\") {\n            // Ensure the start of the URL is visible for usability reasons.\n            this.selectionStart = this.selectionEnd = 0;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_parseAndRecordSearchEngineLoad\">\n        <parameter name=\"engineOrEngineName\"/>\n        <parameter name=\"query\"/>\n        <parameter name=\"event\"/>\n        <parameter name=\"openUILinkWhere\"/>\n        <parameter name=\"openUILinkParams\"/>\n        <parameter name=\"searchActionDetails\"/>\n        <body><![CDATA[\n          let engine =\n            typeof(engineOrEngineName) == \"string\" ?\n              Services.search.getEngineByName(engineOrEngineName) :\n              engineOrEngineName;\n          let isOneOff = this.popup.oneOffSearchButtons\n              .maybeRecordTelemetry(event, openUILinkWhere, openUILinkParams);\n          // Infer the type of the event which triggered the search.\n          let eventType = \"unknown\";\n          if (event instanceof KeyboardEvent) {\n            eventType = \"key\";\n          } else if (event instanceof MouseEvent) {\n            eventType = \"mouse\";\n          }\n          // Augment the search action details object.\n          let details = searchActionDetails || {};\n          details.isOneOff = isOneOff;\n          details.type = eventType;\n\n          BrowserSearch.recordSearchInTelemetry(engine, \"urlbar\", details);\n          let submission = engine.getSubmission(query, null, \"keyword\");\n          return [submission.uri.spec, submission.postData];\n        ]]></body>\n      </method>\n\n      <method name=\"maybeCanonizeURL\">\n        <parameter name=\"aTriggeringEvent\"/>\n        <parameter name=\"aUrl\"/>\n        <body><![CDATA[\n          // Only add the suffix when the URL bar value isn't already \"URL-like\",\n          // and only if we get a keyboard event, to match user expectations.\n          if (!/^\\s*[^.:\\/\\s]+(?:\\/.*|\\s*)$/i.test(aUrl) ||\n              !(aTriggeringEvent instanceof KeyboardEvent)) {\n            return;\n          }\n\n          let url = aUrl;\n          let accel = AppConstants.platform == \"macosx\" ?\n                      aTriggeringEvent.metaKey :\n                      aTriggeringEvent.ctrlKey;\n          let shift = aTriggeringEvent.shiftKey;\n          let suffix = \"\";\n\n          switch (true) {\n            case (accel && shift):\n              suffix = \".org/\";\n              break;\n            case (shift):\n              suffix = \".net/\";\n              break;\n            case (accel):\n              try {\n                suffix = gPrefService.getCharPref(\"browser.fixup.alternate.suffix\");\n                if (suffix.charAt(suffix.length - 1) != \"/\")\n                  suffix += \"/\";\n              } catch (e) {\n                suffix = \".com/\";\n              }\n              break;\n          }\n\n          if (!suffix)\n            return;\n\n          // trim leading/trailing spaces (bug 233205)\n          url = url.trim();\n\n          // Tack www. and suffix on.  If user has appended directories, insert\n          // suffix before them (bug 279035).  Be careful not to get two slashes.\n          let firstSlash = url.indexOf(\"/\");\n          if (firstSlash >= 0) {\n            url = url.substring(0, firstSlash) + suffix +\n                  url.substring(firstSlash + 1);\n          } else {\n            url = url + suffix;\n          }\n\n          this.popup.overrideValue = \"http://www.\" + url;\n        ]]></body>\n      </method>\n\n      <method name=\"_initURLTooltip\">\n        <body><![CDATA[\n          if (this.focused || !this.hasAttribute(\"textoverflow\"))\n            return;\n          this.inputField.setAttribute(\"tooltiptext\", this.value);\n        ]]></body>\n      </method>\n\n      <method name=\"_hideURLTooltip\">\n        <body><![CDATA[\n          this.inputField.removeAttribute(\"tooltiptext\");\n        ]]></body>\n      </method>\n\n      <!-- Returns:\n           null if there's a security issue and we should do nothing.\n           a URL object if there is one that we're OK with loading,\n           a text value otherwise.\n           -->\n      <method name=\"_getDroppableItem\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let links;\n          try {\n            links = browserDragAndDrop.dropLinks(aEvent);\n          } catch (ex) {\n            // this is possibly a security exception, in which case we should return\n            // null. Always return null because we can't *know* what exception is\n            // being returned.\n            return null;\n          }\n          // The URL bar automatically handles inputs with newline characters,\n          // so we can get away with treating text/x-moz-url flavours as text/plain.\n          if (links.length > 0 && links[0].url) {\n            aEvent.preventDefault();\n            let url = links[0].url;\n            let strippedURL = stripUnsafeProtocolOnPaste(url);\n            if (strippedURL != url) {\n              aEvent.stopImmediatePropagation();\n              return null;\n            }\n            let urlObj;\n            try {\n              // If this throws, urlSecurityCheck would also throw, as that's what it\n              // does with things that don't pass the IO service's newURI constructor\n              // without fixup. It's conceivable we may want to relax this check in\n              // the future (so e.g. www.foo.com gets fixed up), but not right now.\n              urlObj = new URL(url);\n              // If we succeed, try to pass security checks. If this works, return the\n              // URL object. If the *security checks* fail, return null.\n              try {\n                urlSecurityCheck(url,\n                                 gBrowser.contentPrincipal,\n                                 Ci.nsIScriptSecurityManager.DISALLOW_INHERIT_PRINCIPAL);\n                return urlObj;\n              } catch (ex) {\n                return null;\n              }\n            } catch (ex) {\n              // We couldn't make a URL out of this. Continue on, and return text below.\n            }\n          }\n          return aEvent.dataTransfer.getData(\"text/unicode\");\n        ]]></body>\n      </method>\n\n      <method name=\"onDragOver\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this._getDroppableItem(aEvent)) {\n            aEvent.dataTransfer.dropEffect = \"none\";\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onDrop\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let droppedItem = this._getDroppableItem(aEvent);\n          if (droppedItem) {\n            this.value = droppedItem instanceof URL ? droppedItem.href : droppedItem;\n            SetPageProxyState(\"invalid\");\n            this.focus();\n            if (droppedItem instanceof URL) {\n              this.handleCommand();\n              // Force not showing the dropped URI immediately.\n              gBrowser.userTypedValue = null;\n              URLBarSetURI();\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"makeURIReadable\">\n        <parameter name=\"aURI\"/>\n        <body>\n          <![CDATA[\n            // Avoid copying 'about:reader?url=', and always provide the original URI:\n            // Reader mode ensures we call createExposableURI itself.\n            let readerStrippedURI = ReaderMode.getOriginalUrlObjectForDisplay(aURI.displaySpec);\n            if (readerStrippedURI) {\n              aURI = readerStrippedURI;\n            } else {\n              // Only copy exposable URIs\n              try {\n                aURI = Services.uriFixup.createExposableURI(aURI);\n              } catch (ex) {}\n            }\n            return aURI;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_getSelectedValueForClipboard\">\n        <body><![CDATA[\n          // Grab the actual input field's value, not our value, which could include moz-action:\n          var inputVal = this.inputField.value;\n          let selection = this.editor.selection;\n          const flags = Ci.nsIDocumentEncoder.OutputPreformatted |\n                        Ci.nsIDocumentEncoder.OutputRaw;\n          let selectedVal = selection.QueryInterface(Ci.nsISelectionPrivate)\n                                     .toStringWithFormat(\"text/plain\", flags, 0);\n\n          // Handle multiple-range selection as a string for simplicity.\n          if (selection.rangeCount > 1) {\n             return selectedVal;\n          }\n\n          // If the selection doesn't start at the beginning or doesn't span the full domain or\n          // the URL bar is modified or there is no text at all, nothing else to do here.\n          if (this.selectionStart > 0 || this.valueIsTyped || selectedVal == \"\")\n            return selectedVal;\n          // The selection doesn't span the full domain if it doesn't contain a slash and is\n          // followed by some character other than a slash.\n          if (!selectedVal.includes(\"/\")) {\n            let remainder = inputVal.replace(selectedVal, \"\");\n            if (remainder != \"\" && remainder[0] != \"/\")\n              return selectedVal;\n          }\n\n          let uriFixup = Cc[\"@mozilla.org/docshell/urifixup;1\"].getService(Ci.nsIURIFixup);\n\n          let uri;\n          if (this.getAttribute(\"pageproxystate\") == \"valid\") {\n            uri = gBrowser.currentURI;\n          } else {\n            // We're dealing with an autocompleted value, create a new URI from that.\n            try {\n              uri = uriFixup.createFixupURI(inputVal, Ci.nsIURIFixup.FIXUP_FLAG_NONE);\n            } catch (e) {}\n            if (!uri)\n              return selectedVal;\n          }\n\n          uri = this.makeURIReadable(uri);\n\n          // If the entire URL is selected, just use the actual loaded URI,\n          // unless we want a decoded URI, or it's a data: or javascript: URI,\n          // since those are hard to read when encoded.\n          if (inputVal == selectedVal &&\n              !uri.schemeIs(\"javascript\") && !uri.schemeIs(\"data\") &&\n              !Services.prefs.getBoolPref(\"browser.urlbar.decodeURLsOnCopy\")) {\n            return uri.displaySpec;\n          }\n\n          // Just the beginning of the URL is selected, or we want a decoded\n          // url. First check for a trimmed value.\n          let spec = uri.displaySpec;\n          let trimmedSpec = this.trimValue(spec);\n          if (spec != trimmedSpec) {\n            // Prepend the portion that trimValue removed from the beginning.\n            // This assumes trimValue will only truncate the URL at\n            // the beginning or end (or both).\n            let trimmedSegments = spec.split(trimmedSpec);\n            selectedVal = trimmedSegments[0] + selectedVal;\n          }\n\n          return selectedVal;\n        ]]></body>\n      </method>\n\n      <field name=\"_copyCutController\"><![CDATA[\n        ({\n          urlbar: this,\n          doCommand(aCommand) {\n            var urlbar = this.urlbar;\n            var val = urlbar._getSelectedValueForClipboard();\n            if (!val)\n              return;\n\n            if (aCommand == \"cmd_cut\" && this.isCommandEnabled(aCommand)) {\n              let start = urlbar.selectionStart;\n              let end = urlbar.selectionEnd;\n              urlbar.inputField.value = urlbar.inputField.value.substring(0, start) +\n                                        urlbar.inputField.value.substring(end);\n              urlbar.selectionStart = urlbar.selectionEnd = start;\n\n              let event = document.createEvent(\"UIEvents\");\n              event.initUIEvent(\"input\", true, false, window, 0);\n              urlbar.dispatchEvent(event);\n\n              SetPageProxyState(\"invalid\");\n            }\n\n            Cc[\"@mozilla.org/widget/clipboardhelper;1\"]\n              .getService(Ci.nsIClipboardHelper)\n              .copyString(val);\n          },\n          supportsCommand(aCommand) {\n            switch (aCommand) {\n              case \"cmd_copy\":\n              case \"cmd_cut\":\n                return true;\n            }\n            return false;\n          },\n          isCommandEnabled(aCommand) {\n            return this.supportsCommand(aCommand) &&\n                   (aCommand != \"cmd_cut\" || !this.urlbar.readOnly) &&\n                   this.urlbar.selectionStart < this.urlbar.selectionEnd;\n          },\n          onEvent(aEventName) {}\n        })\n      ]]></field>\n\n      <method name=\"observe\">\n        <parameter name=\"aSubject\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aData\"/>\n        <body><![CDATA[\n          if (aTopic == \"nsPref:changed\") {\n            switch (aData) {\n              case \"clickSelectsAll\":\n              case \"doubleClickSelectsAll\":\n                this[aData] = this._prefs.getBoolPref(aData);\n                break;\n              case \"autoFill\":\n                this.completeDefaultIndex = this._prefs.getBoolPref(aData);\n                break;\n              case \"delay\":\n                this.timeout = this._prefs.getIntPref(aData);\n                break;\n              case \"formatting.enabled\":\n                this._formattingEnabled = this._prefs.getBoolPref(aData);\n                break;\n              case \"speculativeConnect.enabled\":\n                this.speculativeConnectEnabled = this._prefs.getBoolPref(aData);\n                break;\n              case \"browser.search.suggest.enabled\":\n                this.browserSearchSuggestEnabled = Services.prefs.getBoolPref(aData);\n                break;\n              case \"suggest.searches\":\n                this.urlbarSearchSuggestEnabled = this._prefs.getBoolPref(aData);\n              case \"userMadeSearchSuggestionsChoice\":\n                // Mirror the value for future use, see the comment in the\n                // binding's constructor.\n                this._prefs.setBoolPref(\"searchSuggestionsChoice\",\n                  this.urlbarSearchSuggestEnabled);\n                // Clear the cached value to allow changing conditions in tests.\n                delete this._whichSearchSuggestionsNotification;\n                break;\n              case \"trimURLs\":\n                this._mayTrimURLs = this._prefs.getBoolPref(aData);\n                break;\n              case \"oneOffSearches\":\n                this._enableOrDisableOneOffSearches();\n                break;\n              case \"maxRichResults\":\n                this.popup.maxResults = this._prefs.getIntPref(aData);\n                break;\n              case \"switchTabs.adoptIntoActiveWindow\":\n                this._adoptIntoActiveWindow =\n                  this._prefs.getBoolPref(\"switchTabs.adoptIntoActiveWindow\");\n                break;\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_enableOrDisableOneOffSearches\">\n        <body><![CDATA[\n          let enable = this._prefs.getBoolPref(\"oneOffSearches\");\n          this.popup.enableOneOffSearches(enable);\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.type) {\n            case \"paste\":\n              let originalPasteData = aEvent.clipboardData.getData(\"text/plain\");\n              if (!originalPasteData) {\n                return;\n              }\n\n              let oldValue = this.inputField.value;\n              let oldStart = oldValue.substring(0, this.inputField.selectionStart);\n              // If there is already non-whitespace content in the URL bar\n              // preceding the pasted content, it's not necessary to check\n              // protocols used by the pasted content:\n              if (oldStart.trim()) {\n                return;\n              }\n              let oldEnd = oldValue.substring(this.inputField.selectionEnd);\n\n              let pasteData = stripUnsafeProtocolOnPaste(originalPasteData);\n              if (originalPasteData != pasteData) {\n                // Unfortunately we're not allowed to set the bits being pasted\n                // so cancel this event:\n                aEvent.preventDefault();\n                aEvent.stopImmediatePropagation();\n\n                this.inputField.value = oldStart + pasteData + oldEnd;\n                // Fix up cursor/selection:\n                let newCursorPos = oldStart.length + pasteData.length;\n                this.inputField.selectionStart = newCursorPos;\n                this.inputField.selectionEnd = newCursorPos;\n              }\n              break;\n            case \"mousedown\":\n              if (this.doubleClickSelectsAll &&\n                  aEvent.button == 0 && aEvent.detail == 2) {\n                this.editor.selectAll();\n                aEvent.preventDefault();\n              }\n              break;\n            case \"mousemove\":\n              this._initURLTooltip();\n              break;\n            case \"mouseout\":\n              this._hideURLTooltip();\n              break;\n            case \"overflow\":\n              if (!this.value) {\n                // We initially get a spurious overflow event from the\n                // anonymous div containing the placeholder text; bail out.\n                break;\n              }\n              this.setAttribute(\"textoverflow\", \"true\");\n              break;\n            case \"underflow\":\n              this.removeAttribute(\"textoverflow\");\n              this._hideURLTooltip();\n              break;\n            case \"TabSelect\":\n              this.controller.resetInternalState();\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <!--\n        onBeforeTextValueSet is called by the base-binding's .textValue getter.\n        It should return the value that the getter should use.\n      -->\n      <method name=\"onBeforeTextValueGet\">\n        <body><![CDATA[\n          return { value: this.inputField.value };\n        ]]></body>\n      </method>\n\n      <!--\n        onBeforeTextValueSet is called by the base-binding's .textValue setter.\n        It should return the value that the setter should use.\n      -->\n      <method name=\"onBeforeTextValueSet\">\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          let val = aValue;\n          let uri;\n          try {\n            uri = makeURI(val);\n          } catch (ex) {}\n\n          if (uri) {\n            // Do not touch moz-action URIs at all.  They depend on being\n            // properly encoded and decoded and will break if decoded\n            // unexpectedly.\n            if (!this._parseActionUrl(val)) {\n              val = losslessDecodeURI(uri);\n            }\n          }\n\n          return val;\n        ]]></body>\n      </method>\n\n      <method name=\"_parseActionUrl\">\n        <parameter name=\"aUrl\"/>\n        <body><![CDATA[\n          const MOZ_ACTION_REGEX = /^moz-action:([^,]+),(.*)$/;\n          if (!MOZ_ACTION_REGEX.test(aUrl))\n            return null;\n\n          // URL is in the format moz-action:ACTION,PARAMS\n          // Where PARAMS is a JSON encoded object.\n          let [, type, params] = aUrl.match(MOZ_ACTION_REGEX);\n\n          let action = {\n            type,\n          };\n\n          action.params = JSON.parse(params);\n          for (let key in action.params) {\n            action.params[key] = decodeURIComponent(action.params[key]);\n          }\n\n          if (\"url\" in action.params) {\n            let uri;\n            try {\n              uri = makeURI(action.params.url);\n              action.params.displayUrl = losslessDecodeURI(uri);\n            } catch (e) {\n              action.params.displayUrl = action.params.url;\n            }\n          }\n\n          return action;\n        ]]></body>\n      </method>\n\n      <property name=\"_noActionKeys\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.__noActionKeys) {\n            this.__noActionKeys = new Set([\n              KeyEvent.DOM_VK_ALT,\n              KeyEvent.DOM_VK_SHIFT,\n            ]);\n            let modifier = AppConstants.platform == \"macosx\" ?\n                           KeyEvent.DOM_VK_META :\n                           KeyEvent.DOM_VK_CONTROL;\n            this.__noActionKeys.add(modifier);\n          }\n          return this.__noActionKeys;\n        ]]></getter>\n      </property>\n\n      <field name=\"_pressedNoActionKeys\"><![CDATA[\n        new Set()\n      ]]></field>\n\n      <method name=\"_clearNoActions\">\n        <parameter name=\"aURL\"/>\n        <body><![CDATA[\n          this._pressedNoActionKeys.clear();\n          this.popup.removeAttribute(\"noactions\");\n          let action = this._parseActionUrl(this._value);\n          if (action)\n            this.setAttribute(\"actiontype\", action.type);\n        ]]></body>\n      </method>\n\n      <method name=\"onInput\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this.mIgnoreInput && this.mController.input == this) {\n            this._value = this.inputField.value;\n            gBrowser.userTypedValue = this.value;\n            this.valueIsTyped = true;\n            if (this.inputField.value) {\n              this.setAttribute(\"usertyping\", \"true\");\n            } else {\n              this.removeAttribute(\"usertyping\");\n            }\n            // Only wait for a result when we are sure to get one.  In some\n            // cases, like when pasting the same exact text, we may not fire\n            // a new search and we won't get a result.\n            if (this.mController.handleText()) {\n              this.gotResultForCurrentQuery = false;\n              this._searchStartDate = Date.now();\n              this._deferredKeyEventQueue = [];\n              if (this._deferredKeyEventTimeout) {\n                clearTimeout(this._deferredKeyEventTimeout);\n                this._deferredKeyEventTimeout = null;\n              }\n            }\n          }\n          this.resetActionType();\n        ]]></body>\n      </method>\n\n      <method name=\"handleEnter\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          // We need to ensure we're using a selected autocomplete result.\n          // A result should automatically be selected by default,\n          // however autocomplete is async and therefore we may not\n          // have a result set relating to the current input yet. If that\n          // happens, we need to mark that when the first result does get added,\n          // it needs to be handled as if enter was pressed with that first\n          // result selected.\n          // If anything other than the default (first) result is selected, then\n          // it must have been manually selected by the human. We let this\n          // explicit choice be used, even if it may be related to a previous\n          // input.\n          // However, if the default result is automatically selected, we\n          // ensure that it corresponds to the current input.\n\n          // Store the current search string so it can be used in handleCommand,\n          // which will be called as a result of mController.handleEnter().\n          this.handleEnterSearchString = this.mController.searchString;\n\n          if (!this._deferredKeyEventQueue.length &&\n              (this.popup.selectedIndex != 0 || this.gotResultForCurrentQuery)) {\n            let canonizeValue = this.value;\n            if (event.shiftKey || (AppConstants.platform === \"macosx\" ?\n                                   event.metaKey :\n                                   event.ctrlKey)) {\n              let action = this._parseActionUrl(canonizeValue);\n              if (action && \"searchSuggestion\" in action.params) {\n                canonizeValue = action.params.searchSuggestion;\n              } else if (this.popup.selectedIndex === 0 &&\n                         this.mController.getStyleAt(0).includes(\"autofill\")) {\n                canonizeValue = this.handleEnterSearchString;\n              }\n            }\n            this.maybeCanonizeURL(event, canonizeValue);\n            let handled = this.mController.handleEnter(false, event);\n            this.handleEnterSearchString = null;\n            this.popup.overrideValue = null;\n            return handled;\n          }\n\n          // Defer the event until the first non-heuristic result comes in.\n          this._deferKeyEvent(event, \"handleEnter\");\n          return false;\n        ]]></body>\n      </method>\n\n      <method name=\"handleDelete\">\n        <body><![CDATA[\n          // If the heuristic result is selected, then the autocomplete\n          // controller's handleDelete implementation will remove it, which is\n          // not what we want.  So in that case, call handleText so it acts as\n          // a backspace on the text value instead of removing the result.\n          if (this.popup.selectedIndex == 0 &&\n              this.popup._isFirstResultHeuristic) {\n            this.mController.handleText();\n            return false;\n          }\n          return this.mController.handleDelete();\n        ]]></body>\n      </method>\n\n      <property name=\"_userMadeSearchSuggestionsChoice\" readonly=\"true\">\n        <getter><![CDATA[\n          return this._prefs.getBoolPref(\"userMadeSearchSuggestionsChoice\") ||\n                 this._defaultPrefs.getBoolPref(\"suggest.searches\") != this._prefs.getBoolPref(\"suggest.searches\");\n        ]]></getter>\n      </property>\n\n      <property name=\"whichSearchSuggestionsNotification\" readonly=\"true\">\n        <getter><![CDATA[\n          // Once we return \"none\" once, we'll always return \"none\".\n          // If available, use the cached value, rather than running all of the\n          // checks again at every locationbar focus.\n          if (this._whichSearchSuggestionsNotification) {\n            return this._whichSearchSuggestionsNotification;\n          }\n\n          if (this.browserSearchSuggestEnabled && !this.inPrivateContext &&\n              // In any case, if the user made a choice we should not nag him.\n              !this._userMadeSearchSuggestionsChoice) {\n            if (this._defaultPrefs.getBoolPref(\"suggest.searches\") &&\n                this.urlbarSearchSuggestEnabled && // Has not been switched off.\n                this._prefs.getIntPref(\"timesBeforeHidingSuggestionsHint\")) {\n              return \"opt-out\";\n            }\n          }\n          return this._whichSearchSuggestionsNotification = \"none\";\n        ]]></getter>\n      </property>\n\n      <method name=\"updateSearchSuggestionsNotificationImpressions\">\n        <parameter name=\"whichNotification\"/>\n        <body><![CDATA[\n          if (whichNotification == \"none\") {\n            throw new Error(\"Unexpected notification type\");\n          }\n\n          let remaining = this._prefs.getIntPref(\"timesBeforeHidingSuggestionsHint\");\n          if (remaining > 0) {\n            this._prefs.setIntPref(\"timesBeforeHidingSuggestionsHint\", remaining - 1);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"maybeShowSearchSuggestionsNotificationOnFocus\">\n        <parameter name=\"mouseFocused\"/>\n        <body><![CDATA[\n          let whichNotification = this.whichSearchSuggestionsNotification;\n          if (this._showSearchSuggestionNotificationOnMouseFocus &&\n              mouseFocused) {\n            // Force showing the opt-out notification.\n            this._whichSearchSuggestionsNotification = whichNotification = \"opt-out\";\n          }\n          if (whichNotification == \"opt-out\") {\n            try {\n              this.popup.openAutocompletePopup(this, this);\n            } finally {\n              if (mouseFocused) {\n                delete this._whichSearchSuggestionsNotification;\n                this._showSearchSuggestionNotificationOnMouseFocus = false;\n              }\n            }\n          }\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"keydown\"><![CDATA[\n        if (this._noActionKeys.has(event.keyCode) &&\n            this.popup.selectedIndex >= 0 &&\n            !this._pressedNoActionKeys.has(event.keyCode)) {\n          if (this._pressedNoActionKeys.size == 0) {\n            this.popup.setAttribute(\"noactions\", \"true\");\n            this.removeAttribute(\"actiontype\");\n          }\n          this._pressedNoActionKeys.add(event.keyCode);\n        }\n      ]]></handler>\n\n      <handler event=\"keyup\"><![CDATA[\n        if (this._noActionKeys.has(event.keyCode) &&\n            this._pressedNoActionKeys.has(event.keyCode)) {\n          this._pressedNoActionKeys.delete(event.keyCode);\n          if (this._pressedNoActionKeys.size == 0)\n            this._clearNoActions();\n        }\n      ]]></handler>\n\n      <handler event=\"mousedown\"><![CDATA[\n        if (event.button == 0) {\n          if (event.originalTarget.getAttribute(\"anonid\") == \"historydropmarker\") {\n            this.toggleHistoryPopup();\n          }\n\n          // Eventually show the opt-out notification even if the location bar is\n          // empty, focused, and the user clicks on it.\n          if (this.focused && this.textValue == \"\") {\n            this.maybeShowSearchSuggestionsNotificationOnFocus(true);\n          }\n        }\n      ]]></handler>\n\n      <handler event=\"focus\"><![CDATA[\n        if (event.originalTarget == this.inputField) {\n          this._hideURLTooltip();\n          this.formatValue();\n          if (this.getAttribute(\"pageproxystate\") != \"valid\") {\n            UpdatePopupNotificationsVisibility();\n          }\n\n          // We show the opt-out notification when the mouse/keyboard focus the\n          // urlbar, but in any case we want to enforce at least one\n          // notification when the user focuses it with the mouse.\n          let whichNotification = this.whichSearchSuggestionsNotification;\n          if (whichNotification == \"opt-out\" &&\n              this._showSearchSuggestionNotificationOnMouseFocus === undefined) {\n            this._showSearchSuggestionNotificationOnMouseFocus = true;\n          }\n\n          // Check whether the focus change came from a keyboard/mouse action.\n          let focusMethod = Services.focus.getLastFocusMethod(window);\n          // If it's a focus started by code and the primary user intention was\n          // not to go to the location bar, don't show a notification.\n          if (!focusMethod && !this.userInitiatedFocus) {\n            return;\n          }\n\n          let mouseFocused = !!(focusMethod & Services.focus.FLAG_BYMOUSE);\n          this.maybeShowSearchSuggestionsNotificationOnFocus(mouseFocused);\n        }\n      ]]></handler>\n\n      <handler event=\"blur\"><![CDATA[\n        if (event.originalTarget == this.inputField) {\n          this._clearNoActions();\n          this.formatValue();\n          if (this.getAttribute(\"pageproxystate\") != \"valid\") {\n            UpdatePopupNotificationsVisibility();\n          }\n        }\n        if (this.ExtensionSearchHandler.hasActiveInputSession()) {\n          this.ExtensionSearchHandler.handleInputCancelled();\n        }\n        if (this._deferredKeyEventTimeout) {\n          clearTimeout(this._deferredKeyEventTimeout);\n          this._deferredKeyEventTimeout = null;\n        }\n        this._deferredKeyEventQueue = [];\n      ]]></handler>\n\n      <handler event=\"dragstart\" phase=\"capturing\"><![CDATA[\n        // Drag only if the gesture starts from the input field.\n        if (this.inputField != event.originalTarget &&\n            !(this.inputField.compareDocumentPosition(event.originalTarget) &\n              Node.DOCUMENT_POSITION_CONTAINED_BY))\n          return;\n\n        // Drag only if the entire value is selected and it's a valid URI.\n        var isFullSelection = this.selectionStart == 0 &&\n                              this.selectionEnd == this.textLength;\n        if (!isFullSelection ||\n            this.getAttribute(\"pageproxystate\") != \"valid\")\n          return;\n\n        var urlString = gBrowser.selectedBrowser.currentURI.displaySpec;\n        var title = gBrowser.selectedBrowser.contentTitle || urlString;\n        var htmlString = \"<a href=\\\"\" + urlString + \"\\\">\" + urlString + \"</a>\";\n\n        var dt = event.dataTransfer;\n        dt.setData(\"text/x-moz-url\", urlString + \"\\n\" + title);\n        dt.setData(\"text/unicode\", urlString);\n        dt.setData(\"text/html\", htmlString);\n\n        dt.effectAllowed = \"copyLink\";\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\" phase=\"capturing\" action=\"this.onDragOver(event, this);\"/>\n      <handler event=\"drop\" phase=\"capturing\" action=\"this.onDrop(event, this);\"/>\n      <handler event=\"select\"><![CDATA[\n        if (!Cc[\"@mozilla.org/widget/clipboard;1\"]\n               .getService(Ci.nsIClipboard)\n               .supportsSelectionClipboard())\n          return;\n\n        if (!window.QueryInterface(Ci.nsIInterfaceRequestor)\n                   .getInterface(Ci.nsIDOMWindowUtils)\n                   .isHandlingUserInput)\n          return;\n\n        var val = this._getSelectedValueForClipboard();\n        if (!val)\n          return;\n\n        Cc[\"@mozilla.org/widget/clipboardhelper;1\"]\n          .getService(Ci.nsIClipboardHelper)\n          .copyStringToClipboard(val, Ci.nsIClipboard.kSelectionClipboard);\n      ]]></handler>\n    </handlers>\n\n  </binding>\n\n  <binding id=\"urlbar-rich-result-popup\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup\">\n\n    <resources>\n      <stylesheet src=\"chrome://browser/content/search/searchbarBindings.css\"/>\n      <stylesheet src=\"chrome://browser/skin/searchbar.css\"/>\n    </resources>\n\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\"\n             aria-owns=\"richlistbox\">\n      <xul:deck anonid=\"search-suggestions-notification\"\n                align=\"center\"\n                role=\"alert\"\n                selectedIndex=\"0\">\n        <!-- OPT-OUT -->\n        <xul:hbox flex=\"1\" align=\"center\" anonid=\"search-suggestions-opt-out\">\n          <xul:image class=\"ac-site-icon\" type=\"searchengine\"/>\n          <xul:hbox anonid=\"search-suggestions-hint-typing\">\n            <xul:description class=\"ac-title-text\">FROM-DTD-brandShortName</xul:description>\n          </xul:hbox>\n          <xul:hbox anonid=\"search-suggestions-hint-box\" flex=\"1\">\n            <xul:description id=\"search-suggestions-hint\">\n              <html:span class=\"prefix\">&#x1f4a1; FROM-DTD-urlbar-searchSuggestionsNotification-hintPrefix</html:span>\n              <html:span>FROM-DTD-urlbar-searchSuggestionsNotification-hint</html:span>\n            </xul:description>\n          </xul:hbox>\n          <xul:label id=\"search-suggestions-change-settings\"\n                     class=\"text-link\"\n                     role=\"link\"\n\n                     value=\"FROM-DTD-urlbar-searchSuggestionsNotification-changeSettingsWin\"\n                     accesskey=\"FROM-DTD-urlbar-searchSuggestionsNotification-changeSettingsWin-accesskey\"\n\n                     onclick=\"openPreferences('paneSearch');\"\n                     control=\"search-suggestions-change-settings\"/>\n        </xul:hbox>\n      </xul:deck>\n      <xul:richlistbox anonid=\"richlistbox\" class=\"autocomplete-richlistbox\"\n                       flex=\"1\"/>\n      <xul:hbox anonid=\"footer\">\n        <children/>\n        <xul:vbox anonid=\"one-off-search-buttons\"\n                  class=\"search-one-offs\"\n                  compact=\"true\"\n                  includecurrentengine=\"true\"\n                  disabletab=\"true\"\n                  flex=\"1\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <field name=\"DOMWindowUtils\">\n        window.QueryInterface(Ci.nsIInterfaceRequestor)\n              .getInterface(Ci.nsIDOMWindowUtils);\n      </field>\n\n      <field name=\"_maxResults\">0</field>\n\n      <field name=\"_bundle\" readonly=\"true\">\n        Cc[\"@mozilla.org/intl/stringbundle;1\"].\n          getService(Ci.nsIStringBundleService).\n          createBundle(\"chrome://browser/locale/places/places.properties\");\n      </field>\n\n      <field name=\"searchSuggestionsNotification\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(\n          this, \"anonid\", \"search-suggestions-notification\"\n        );\n      </field>\n\n      <field name=\"footer\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"footer\");\n      </field>\n\n      <field name=\"oneOffSearchButtons\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"one-off-search-buttons\");\n      </field>\n\n      <field name=\"_oneOffSearchesEnabled\">false</field>\n\n      <field name=\"_overrideValue\">null</field>\n      <property name=\"overrideValue\"\n                onget=\"return this._overrideValue;\"\n                onset=\"this._overrideValue = val; return val;\"/>\n\n      <method name=\"onPopupClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.button == 2) {\n            // Ignore right-clicks.\n            return;\n          }\n          // Otherwise \"call super\" -- do what autocomplete-base-popup does.\n          let controller = this.view.QueryInterface(Components.interfaces.nsIAutoCompleteController);\n          controller.handleEnter(true, aEvent);\n        ]]></body>\n      </method>\n\n      <method name=\"enableOneOffSearches\">\n        <parameter name=\"enable\"/>\n        <body><![CDATA[\n          this._oneOffSearchesEnabled = enable;\n          if (enable) {\n            this.oneOffSearchButtons.telemetryOrigin = \"urlbar\";\n            this.oneOffSearchButtons.style.display = \"-moz-box\";\n            // Set .textbox first, since the popup setter will cause\n            // a _rebuild call that uses it.\n            this.oneOffSearchButtons.textbox = this.input;\n            this.oneOffSearchButtons.popup = this;\n          } else {\n            this.oneOffSearchButtons.telemetryOrigin = null;\n            this.oneOffSearchButtons.style.display = \"none\";\n            this.oneOffSearchButtons.textbox = null;\n            this.oneOffSearchButtons.popup = null;\n          }\n        ]]></body>\n      </method>\n\n      <!-- Override this so that navigating between items results in an item\n           always being selected. -->\n      <method name=\"getNextIndex\">\n        <parameter name=\"reverse\"/>\n        <parameter name=\"amount\"/>\n        <parameter name=\"index\"/>\n        <parameter name=\"maxRow\"/>\n        <body><![CDATA[\n          if (maxRow < 0)\n            return -1;\n\n          let newIndex = index + (reverse ? -1 : 1) * amount;\n\n          // We only want to wrap if navigation is in any direction by one item,\n          // otherwise we clamp to one end of the list.\n          // ie, hitting page-down will only cause is to wrap if we're already\n          // at one end of the list.\n\n          // Allow the selection to be removed if the first result is not a\n          // heuristic result.\n          if (!this._isFirstResultHeuristic) {\n            if (reverse && index == -1 || newIndex > maxRow && index != maxRow)\n              newIndex = maxRow;\n            else if (!reverse && index == -1 || newIndex < 0 && index != 0)\n              newIndex = 0;\n\n            if (newIndex < 0 && index == 0 || newIndex > maxRow && index == maxRow)\n              newIndex = -1;\n\n            return newIndex;\n          }\n\n          // Otherwise do not allow the selection to be removed.\n          if (newIndex < 0) {\n            newIndex = index > 0 ? 0 : maxRow;\n          } else if (newIndex > maxRow) {\n            newIndex = index < maxRow ? maxRow : 0;\n          }\n          return newIndex;\n        ]]></body>\n      </method>\n\n      <property name=\"_isFirstResultHeuristic\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            // The popup usually has a special \"heuristic\" first result (added\n            // by UnifiedComplete.js) that is automatically selected when the\n            // popup opens.\n            return this.input.mController.matchCount > 0 &&\n                   this.input.mController\n                             .getStyleAt(0)\n                             .split(/\\s+/).indexOf(\"heuristic\") > 0;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"maxResults\">\n        <getter>\n          <![CDATA[\n            if (!this._maxResults) {\n              this._maxResults = Services.prefs.getIntPref(\"browser.urlbar.maxRichResults\");\n            }\n            return this._maxResults;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            return this._maxResults = parseInt(val);\n          ]]>\n        </setter>\n      </property>\n\n      <!-- This is set either to undefined or to a new object containing\n           { start, end } margin values in pixels. These are used to align the\n           results to the input field. -->\n      <property name=\"margins\"\n                onget=\"return this._margins;\">\n        <setter>\n          <![CDATA[\n          if (val == this._margins) {\n            return val;\n          }\n\n          if (val && this._margins && val.start == this._margins.start &&\n                                      val.end == this._margins.end) {\n            return val;\n          }\n\n          this._margins = val;\n\n          if (val) {\n            let paddingInCSS =\n                3   // .autocomplete-richlistbox padding-left/right\n              + 6   // .ac-site-icon margin-inline-start\n              + 16  // .ac-site-icon width\n              + 6;  // .ac-site-icon margin-inline-end\n            let actualVal = Math.round(val.start) - paddingInCSS;\n            let actualValEnd = Math.round(val.end);\n            this.style.setProperty(\"--item-padding-start\", actualVal + \"px\");\n            this.style.setProperty(\"--item-padding-end\", actualValEnd + \"px\");\n          } else {\n            this.style.removeProperty(\"--item-padding-start\");\n            this.style.removeProperty(\"--item-padding-end\");\n          }\n          for (let item of this.richlistbox.childNodes) {\n            item.handleOverUnderflow();\n          }\n          return val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          // initially the panel is hidden\n          // to avoid impacting startup / new window performance\n          aInput.popup.hidden = false;\n\n          this._openAutocompletePopup(aInput, aElement);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body><![CDATA[\n          if (this.mPopupOpen) {\n            return;\n          }\n\n          // Set the direction of the popup based on the textbox (bug 649840).\n          // getComputedStyle causes a layout flush, so avoid calling it if a\n          // direction has already been set.\n          if (!this.style.direction) {\n            this.style.direction =\n              aElement.ownerGlobal.getComputedStyle(aElement).direction;\n          }\n          let popupDirection = this.style.direction;\n\n          // Make the popup span the width of the window.  First, set its width.\n          let documentRect =\n            this.DOMWindowUtils\n                .getBoundsWithoutFlushing(window.document.documentElement);\n          let width = documentRect.right - documentRect.left;\n          this.setAttribute(\"width\", width);\n\n          // Now make its starting margin negative so that its leading edge\n          // aligns with the window border.\n          let elementRect =\n            this.DOMWindowUtils.getBoundsWithoutFlushing(aElement);\n          if (popupDirection == \"rtl\") {\n            let offset = elementRect.right - documentRect.right\n            this.style.marginRight = offset + \"px\";\n          } else {\n            let offset = documentRect.left - elementRect.left;\n            this.style.marginLeft = offset + \"px\";\n          }\n\n          // Keep the popup items' site icons aligned with the urlbar's identity\n          // icon if it's not too far from the edge of the window.  We define\n          // \"too far\" as \"more than 30% of the window's width AND more than\n          // 250px\".  Do this *before* adding any items because when the new\n          // value of the margins are different from the previous value, over-\n          // and underflow must be handled for each item already in the popup.\n          let boundToCheck = popupDirection == \"rtl\" ? \"right\" : \"left\";\n          let inputRect = this.DOMWindowUtils.getBoundsWithoutFlushing(aInput);\n          let startOffset = Math.abs(inputRect[boundToCheck] - documentRect[boundToCheck]);\n          let alignSiteIcons = startOffset / width <= 0.3 || startOffset <= 250;\n          if (alignSiteIcons) {\n            // Calculate the end margin if we have a start margin.\n            let boundToCheckEnd = popupDirection == \"rtl\" ? \"left\" : \"right\";\n            let endOffset = Math.abs(inputRect[boundToCheckEnd] -\n                                     documentRect[boundToCheckEnd]);\n            if (endOffset > startOffset * 2) {\n              // Provide more space when aligning would result in an unbalanced\n              // margin. This allows the location bar to be moved to the start\n              // of the navigation toolbar to reclaim space for results.\n              endOffset = startOffset;\n            }\n            let identityIcon = document.getElementById(\"identity-icon\");\n            let identityRect =\n              this.DOMWindowUtils.getBoundsWithoutFlushing(identityIcon);\n            if (popupDirection == \"rtl\") {\n              this.margins = { start: documentRect.right - identityRect.right,\n                               end: endOffset };\n            } else {\n              this.margins = { start: identityRect.left,\n                               end: endOffset };\n            }\n          } else {\n            // Reset the alignment so that the site icons are positioned\n            // according to whatever's in the CSS.\n            this.margins = undefined;\n          }\n\n          // Now that the margins have been set, start adding items (via\n          // _invalidate).\n          this.mInput = aInput;\n          aInput.controller.setInitiallySelectedIndex(this._isFirstResultHeuristic ? 0 : -1);\n          this.view = aInput.controller.QueryInterface(Components.interfaces.nsITreeView);\n          this._invalidate();\n\n          try {\n            let whichNotification = aInput.whichSearchSuggestionsNotification;\n            if (whichNotification != \"none\") {\n              // Update the impressions count on real popupshown, since there's\n              // no guarantee openPopup will be respected by the platform.\n              // Though, we must ensure the handled event is the expected one.\n              let impressionId = this._searchSuggestionsImpressionId = {};\n              this.addEventListener(\"popupshown\", () => {\n                if (this._searchSuggestionsImpressionId == impressionId)\n                  aInput.updateSearchSuggestionsNotificationImpressions(whichNotification);\n              }, {once: true});\n              this._showSearchSuggestionsNotification(whichNotification, popupDirection);\n            } else if (this.classList.contains(\"showSearchSuggestionsNotification\")) {\n              this._hideSearchSuggestionsNotification();\n            }\n          } catch (ex) {\n            // Not critical for the urlbar functionality, just report the error.\n            Components.utils.reportError(ex);\n          }\n\n          // Position the popup below the navbar.  To get the y-coordinate,\n          // which is an offset from the bottom of the input, subtract the\n          // bottom of the navbar from the buttom of the input.\n          let yOffset = Math.round(\n            this.DOMWindowUtils.getBoundsWithoutFlushing(document.getElementById(\"nav-bar\")).bottom -\n            this.DOMWindowUtils.getBoundsWithoutFlushing(aInput).bottom);\n\n          this.openPopup(aElement, \"after_start\", 0, yOffset, false, false);\n        ]]></body>\n      </method>\n\n      <method name=\"_showSearchSuggestionsNotification\">\n        <parameter name=\"whichNotification\"/>\n        <parameter name=\"popupDirection\"/>\n        <body>\n          <![CDATA[\n          if (whichNotification == \"opt-out\") {\n            if (this.margins) {\n              this.searchSuggestionsNotification.style.paddingInlineStart =\n                this.margins.start + \"px\";\n            } else {\n              this.searchSuggestionsNotification.style.removeProperty(\"padding-inline-start\");\n            }\n\n            // We want to animate the opt-out hint only once.\n            if (!this._firstSearchSuggestionsNotification) {\n              this._firstSearchSuggestionsNotification = true;\n              this.searchSuggestionsNotification.setAttribute(\"animate\", \"true\");\n            }\n          }\n\n          this.searchSuggestionsNotification.setAttribute(\"aria-describedby\",\n                                                          \"search-suggestions-hint\");\n\n          // With the notification shown, the listbox's height can sometimes be\n          // too small when it's flexed, as it normally is.  Also, it can start\n          // out slightly scrolled down.  Both problems appear together, most\n          // often when the popup is very narrow and the notification's text\n          // must wrap.  Work around them by removing the flex.\n          //\n          // But without flexing the listbox, the listbox's height animation\n          // sometimes fails to complete, leaving the popup too tall.  Work\n          // around that problem by disabling the listbox animation.\n          this.richlistbox.flex = 0;\n          this.setAttribute(\"dontanimate\", \"true\");\n\n          this.classList.add(\"showSearchSuggestionsNotification\");\n          // Don't show the one-off buttons if we are showing onboarding and\n          // there's no result, since it would be ugly and pointless.\n          this.footer.collapsed = this._matchCount == 0;\n          this.input.tabScrolling = this._matchCount != 0;\n\n          // This event allows accessibility APIs to see the notification.\n          if (!this.popupOpen) {\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"AlertActive\", true, true);\n            this.searchSuggestionsNotification.dispatchEvent(event);\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_hideSearchSuggestionsNotification\">\n        <body>\n          <![CDATA[\n          this.classList.remove(\"showSearchSuggestionsNotification\");\n          this.richlistbox.flex = 1;\n          this.removeAttribute(\"dontanimate\");\n          this.searchSuggestionsNotification.removeAttribute(\"animate\");\n          if (this._matchCount) {\n            // Update popup height.\n            this._invalidate();\n          } else {\n            this.closePopup();\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_selectedOneOffChanged\">\n        <body><![CDATA[\n          // Update all searchengine result items to use the newly selected\n          // engine.\n          for (let item of this.richlistbox.childNodes) {\n            if (item.collapsed) {\n              break;\n            }\n            let url = item.getAttribute(\"url\");\n            if (url) {\n              let action = item._parseActionUrl(url);\n              if (action && action.type == \"searchengine\") {\n                item._adjustAcItem();\n              }\n            }\n          }\n        ]]></body>\n      </method>\n\n      <!-- This handles keypress changes to the selection among the one-off\n           search buttons and between the one-offs and the listbox.  It returns\n           true if the keypress was consumed and false if not. -->\n      <method name=\"handleKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          this.oneOffSearchButtons.handleKeyPress(aEvent, this._matchCount,\n                                                  !this._isFirstResultHeuristic,\n                                                  gBrowser.userTypedValue);\n          return aEvent.defaultPrevented && !aEvent.urlbarDeferred;\n        ]]></body>\n      </method>\n\n      <!-- This is called when a one-off is clicked and when \"search in new tab\"\n           is selected from a one-off context menu. -->\n      <method name=\"handleOneOffSearch\">\n        <parameter name=\"event\"/>\n        <parameter name=\"engine\"/>\n        <parameter name=\"where\"/>\n        <parameter name=\"params\"/>\n        <body><![CDATA[\n          this.input.handleCommand(event, where, params);\n        ]]></body>\n      </method>\n\n      <!-- Result listitems call this to determine which search engine they\n           should show in their labels and include in their url attributes. -->\n      <property name=\"overrideSearchEngineName\" readonly=\"true\">\n        <getter><![CDATA[\n          let button = this.oneOffSearchButtons.selectedButton;\n          return button && button.engine && button.engine.name;\n        ]]></getter>\n      </property>\n\n      <method name=\"createResultLabel\">\n        <parameter name=\"item\"/>\n        <parameter name=\"proposedLabel\"/>\n        <body>\n          <![CDATA[\n            let parts = [proposedLabel];\n\n            let action = this.mInput._parseActionUrl(item.getAttribute(\"url\"));\n            if (action) {\n              switch (action.type) {\n              case \"searchengine\":\n                parts = [\n                  action.params.searchSuggestion || action.params.searchQuery,\n                  action.params.engineName,\n                ];\n                break;\n              case \"switchtab\":\n              case \"remotetab\":\n                parts = [\n                  item.getAttribute(\"title\"),\n                  item.getAttribute(\"displayurl\"),\n                ];\n                break;\n              }\n            }\n\n            let types = item.getAttribute(\"type\").split(/\\s+/);\n            let type = types.find(t => t != \"action\" && t != \"heuristic\");\n            try {\n              // Some types intentionally do not map to strings, which is not\n              // an error.\n              parts.push(this._bundle.GetStringFromName(type + \"ResultLabel\"));\n            } catch (e) {}\n\n            return parts.filter(str => str).join(\" \");\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"maybeSetupSpeculativeConnect\">\n        <parameter name=\"aUriString\"/>\n        <body><![CDATA[\n          try {\n            let uri = makeURI(aUriString);\n            Services.io.speculativeConnect2(uri, gBrowser.contentPrincipal, null);\n          } catch (ex) {\n            // Can't setup speculative connection for this uri string for some\n            // reason, just ignore it.\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onResultsAdded\">\n        <body>\n          <![CDATA[\n            // If nothing is selected yet, select the first result if it is a\n            // pre-selected \"heuristic\" result.  (See UnifiedComplete.js.)\n            if (this.selectedIndex == -1 && this._isFirstResultHeuristic) {\n              // Don't fire DOMMenuItemActive so that screen readers still see\n              // the input as being focused.\n              this.richlistbox.suppressMenuItemEvent = true;\n              this.input.controller.setInitiallySelectedIndex(0);\n              this.richlistbox.suppressMenuItemEvent = false;\n            }\n            // If this is the first time we get the result from the current\n            // search and we are not in the private context, we can speculatively\n            // connect to the intended site as a performance optimization.\n            if (!this.input.gotResultForCurrentQuery &&\n                this.input.speculativeConnectEnabled &&\n                !this.input.inPrivateContext &&\n                this.input.mController.matchCount > 0) {\n              let firstStyle = this.input.mController.getStyleAt(0);\n              if (firstStyle.includes(\"autofill\")) {\n                let uri = this.input.mController.getFinalCompleteValueAt(0);\n                // \"http\" will be stripped out, but other scheme won't.\n                if (!uri.includes(\"://\")) {\n                  uri = \"http://\" + uri;\n                }\n                this.maybeSetupSpeculativeConnect(uri);\n              } else if (firstStyle.includes(\"searchengine\") &&\n                         this.input.browserSearchSuggestEnabled &&\n                         this.input.urlbarSearchSuggestEnabled) {\n                // Preconnect to the current search engine only if the search\n                // suggestions are enabled.\n                let engine = Services.search.currentEngine;\n                engine.speculativeConnect({window,\n                                           originAttributes: gBrowser.contentPrincipal.originAttributes});\n              }\n            }\n\n            // When a result is present the footer should always be visible.\n            this.footer.collapsed = false;\n            this.input.tabScrolling = true;\n\n            this.input.gotResultForCurrentQuery = true;\n            this.input.maybeReplayDeferredKeyEvents();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_onSearchBegin\">\n        <body><![CDATA[\n          // Set the selected index to 0 (heuristic) until a result comes back\n          // and we can evaluate it better.\n          //\n          // This is required to properly manage delayed handleEnter:\n          // 1. if a search starts we set selectedIndex to 0 here, and it will\n          //    be updated by onResultsAdded. Since selectedIndex is 0,\n          //    handleEnter will delay the action if a result didn't arrive yet.\n          // 2. if a search doesn't start (for example if autocomplete is\n          //    disabled), this won't be called, and the selectedIndex will be\n          //    the default -1 value. Then handleEnter will know it should not\n          //    delay the action, cause a result wont't ever arrive.\n          this.input.controller.setInitiallySelectedIndex(0);\n\n          // Since we are starting a new search, reset the currently selected\n          // one-off button, to cover those cases where the oneoff buttons\n          // binding won't receive an actual DOM event. For example, a search\n          // could be started without an actual input event, and the popup may\n          // not have been closed from the previous search.\n          this.oneOffSearchButtons.selectedButton = null;\n        ]]></body>\n      </method>\n\n      <field name=\"_addonIframe\">null</field>\n      <field name=\"_addonIframeOwner\">null</field>\n      <field name=\"_addonIframeOverriddenFunctionsByName\">{}</field>\n\n      <!-- These methods must be overridden and properly handled by the API\n           runtime so that it doesn't break the popup.  If any of these methods\n           is not overridden, then initAddonIframe should throw. -->\n      <field name=\"_addonIframeOverrideFunctionNames\">[\n        \"_invalidate\",\n      ]</field>\n\n      <field name=\"_addonIframeHiddenAnonids\">[\n        \"search-suggestions-notification\",\n        \"richlistbox\",\n        \"one-off-search-buttons\",\n      ]</field>\n      <field name=\"_addonIframeHiddenDisplaysByAnonid\">{}</field>\n\n      <method name=\"initAddonIframe\">\n        <parameter name=\"owner\"/>\n        <parameter name=\"overrides\"/>\n        <body><![CDATA[\n          if (this._addonIframeOwner) {\n            // Another add-on has already requested the iframe.  Return null to\n            // signal to the calling add-on that it should not take over the\n            // popup.  First add-on wins for now.\n            return null;\n          }\n          // Make sure all overrides are provided before doing anything.\n          for (let name of this._addonIframeOverrideFunctionNames) {\n            if (typeof(overrides[name]) != \"function\") {\n              throw new Error(\n                \"Override for method '\" + name + \"' must be given\"\n              );\n            }\n          }\n          // OK, insert the iframe.\n          this._addonIframeOwner = owner;\n          this._addonIframe = this._makeAddonIframe();\n          this._addonIframeOverriddenFunctionsByName = {};\n          for (let name of this._addonIframeOverrideFunctionNames) {\n            this._addonIframeOverriddenFunctionsByName[name] = this[name];\n            this[name] = overrides[name];\n          }\n          return this._addonIframe;\n        ]]></body>\n      </method>\n\n      <method name=\"destroyAddonIframe\">\n        <parameter name=\"owner\"/>\n        <body><![CDATA[\n          if (this._addonIframeOwner != owner) {\n            throw new Error(\"You're not the iframe owner\");\n          }\n          this._addonIframeOwner = null;\n          this._addonIframe.remove();\n          this._addonIframe = null;\n          for (let anonid of this._addonIframeHiddenAnonids) {\n            let child = document.getAnonymousElementByAttribute(\n              this, \"anonid\", anonid\n            );\n            child.style.display =\n              this._addonIframeHiddenDisplaysByAnonid[anonid];\n          }\n          for (let name in this._addonIframeOverriddenFunctionsByName) {\n            this[name] = this._addonIframeOverriddenFunctionsByName[name];\n          }\n          this._addonIframeOverriddenFunctionsByName = {};\n        ]]></body>\n      </method>\n\n      <method name=\"_makeAddonIframe\">\n        <body><![CDATA[\n          this._addonIframeHiddenDisplaysByAnonid = {};\n          for (let anonid of this._addonIframeHiddenAnonids) {\n            let child = document.getAnonymousElementByAttribute(\n              this, \"anonid\", anonid\n            );\n            this._addonIframeHiddenDisplaysByAnonid[anonid] =\n              child.style.display;\n            child.style.display = \"none\";\n          }\n          let XUL_NS =\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          let iframe = document.createElementNS(XUL_NS, \"iframe\");\n          iframe.setAttribute(\"type\", \"content\");\n          iframe.setAttribute(\"flex\", \"1\");\n          iframe.style.transition = \"height 100ms\";\n          this.appendChild(iframe);\n          return iframe;\n        ]]></body>\n      </method>\n\n    </implementation>\n    <handlers>\n\n      <handler event=\"SelectedOneOffButtonChanged\"><![CDATA[\n        this._selectedOneOffChanged();\n      ]]></handler>\n\n      <handler event=\"mousedown\"><![CDATA[\n        // Required to make the xul:label.text-link elements in the search\n        // suggestions notification work correctly when clicked on Linux.\n        // This is copied from the mousedown handler in\n        // browser-search-autocomplete-result-popup, which apparently had a\n        // similar problem.\n        event.preventDefault();\n\n        if (!this.input.speculativeConnectEnabled) {\n          return;\n        }\n        if (event.button == 2) {\n          // Ignore right-clicks.\n          return;\n        }\n        // Ensure the user is clicking on an url instead of other buttons\n        // on the popup.\n        let elt = event.originalTarget;\n        while (elt && elt.localName != \"richlistitem\" && elt != this) {\n          elt = elt.parentNode;\n        }\n        if (!elt || elt.localName != \"richlistitem\") {\n          return;\n        }\n        // The user might click on a ghost entry which was removed because of\n        // the coming new results.\n        if (this.input.controller.matchCount <= this.selectedIndex) {\n          return;\n        }\n\n        let url = this.input.controller.getFinalCompleteValueAt(this.selectedIndex);\n\n        // Whitelist the cases that we want to speculative connect, and ignore\n        // other moz-action uris or fancy protocols.\n        // Note that it's likely we've speculatively connected to the first\n        // url because it is a heuristic \"autofill\" result (see bug 1348275).\n        // \"moz-action:searchengine\" is also the same case. (see bug 1355443)\n        // So we won't duplicate the effort here.\n        if (url.startsWith(\"http\") && this.selectedIndex > 0) {\n          this.maybeSetupSpeculativeConnect(url);\n        } else if (url.startsWith(\"moz-action:remotetab\")) {\n          // URL is in the format moz-action:ACTION,PARAMS\n          // Where PARAMS is a JSON encoded object.\n          const MOZ_ACTION_REGEX = /^moz-action:([^,]+),(.*)$/;\n          if (!MOZ_ACTION_REGEX.test(url))\n            return;\n\n          let params = JSON.parse(url.match(MOZ_ACTION_REGEX)[2]);\n          if (params.url) {\n            this.maybeSetupSpeculativeConnect(decodeURIComponent(params.url));\n          }\n        }\n\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n  <binding id=\"addon-progress-notification\" extends=\"chrome://global/content/bindings/notification.xml#popup-notification\">\n    <implementation>\n      <constructor><![CDATA[\n        if (!this.notification)\n          return;\n\n        this.notification.options.installs.forEach(function(aInstall) {\n          aInstall.addListener(this);\n        }, this);\n\n        // Calling updateProgress can sometimes cause this notification to be\n        // removed in the middle of refreshing the notification panel which\n        // makes the panel get refreshed again. Just initialise to the\n        // undetermined state and then schedule a proper check at the next\n        // opportunity\n        this.setProgress(0, -1);\n        this._updateProgressTimeout = setTimeout(this.updateProgress.bind(this), 0);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        this.destroy();\n      ]]></destructor>\n\n      <field name=\"progressmeter\" readonly=\"true\">\n        document.getElementById(\"addon-progress-notification-progressmeter\");\n      </field>\n      <field name=\"progresstext\" readonly=\"true\">\n        document.getElementById(\"addon-progress-notification-progresstext\");\n      </field>\n      <property name=\"DownloadUtils\" readonly=\"true\">\n        <getter><![CDATA[\n          let module = {};\n          Components.utils.import(\"resource://gre/modules/DownloadUtils.jsm\", module);\n          Object.defineProperty(this, \"DownloadUtils\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: module.DownloadUtils\n          });\n          return module.DownloadUtils;\n        ]]></getter>\n      </property>\n\n      <method name=\"destroy\">\n        <body><![CDATA[\n          if (!this.notification)\n            return;\n\n          this.notification.options.installs.forEach(function(aInstall) {\n            aInstall.removeListener(this);\n          }, this);\n          clearTimeout(this._updateProgressTimeout);\n        ]]></body>\n      </method>\n\n      <method name=\"setProgress\">\n        <parameter name=\"aProgress\"/>\n        <parameter name=\"aMaxProgress\"/>\n        <body><![CDATA[\n          if (aMaxProgress == -1) {\n            this.progressmeter.setAttribute(\"mode\", \"undetermined\");\n          } else {\n            this.progressmeter.setAttribute(\"mode\", \"determined\");\n            this.progressmeter.setAttribute(\"value\", (aProgress * 100) / aMaxProgress);\n          }\n\n          let now = Date.now();\n\n          if (!this.notification.lastUpdate) {\n            this.notification.lastUpdate = now;\n            this.notification.lastProgress = aProgress;\n            return;\n          }\n\n          let delta = now - this.notification.lastUpdate;\n          if ((delta < 400) && (aProgress < aMaxProgress))\n            return;\n\n          delta /= 1000;\n\n          // This algorithm is the same used by the downloads code.\n          let speed = (aProgress - this.notification.lastProgress) / delta;\n          if (this.notification.speed)\n            speed = speed * 0.9 + this.notification.speed * 0.1;\n\n          this.notification.lastUpdate = now;\n          this.notification.lastProgress = aProgress;\n          this.notification.speed = speed;\n\n          let status = null;\n          [status, this.notification.last] = this.DownloadUtils.getDownloadStatus(aProgress, aMaxProgress, speed, this.notification.last);\n          this.progresstext.setAttribute(\"value\", status);\n          this.progresstext.setAttribute(\"tooltiptext\", status);\n        ]]></body>\n      </method>\n\n      <method name=\"cancel\">\n        <body><![CDATA[\n          let installs = this.notification.options.installs;\n          installs.forEach(function(aInstall) {\n            try {\n              aInstall.cancel();\n            } catch (e) {\n              // Cancel will throw if the download has already failed\n            }\n          }, this);\n\n          PopupNotifications.remove(this.notification);\n        ]]></body>\n      </method>\n\n      <method name=\"updateProgress\">\n        <body><![CDATA[\n          if (!this.notification)\n            return;\n\n          let downloadingCount = 0;\n          let progress = 0;\n          let maxProgress = 0;\n\n          this.notification.options.installs.forEach(function(aInstall) {\n            if (aInstall.maxProgress == -1)\n              maxProgress = -1;\n            progress += aInstall.progress;\n            if (maxProgress >= 0)\n              maxProgress += aInstall.maxProgress;\n            if (aInstall.state < AddonManager.STATE_DOWNLOADED)\n              downloadingCount++;\n          });\n\n          if (downloadingCount == 0) {\n            this.destroy();\n            if (Services.prefs.getBoolPref(\"xpinstall.customConfirmationUI\", false)) {\n              this.progressmeter.setAttribute(\"mode\", \"undetermined\");\n              let status = gNavigatorBundle.getString(\"addonDownloadVerifying\");\n              this.progresstext.setAttribute(\"value\", status);\n              this.progresstext.setAttribute(\"tooltiptext\", status);\n            } else {\n              PopupNotifications.remove(this.notification);\n            }\n          } else {\n            this.setProgress(progress, maxProgress);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadProgress\">\n        <body><![CDATA[\n          this.updateProgress();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadFailed\">\n        <body><![CDATA[\n          this.updateProgress();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadCancelled\">\n        <body><![CDATA[\n          this.updateProgress();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadEnded\">\n        <body><![CDATA[\n          this.updateProgress();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"plugin-popupnotification-center-item\">\n    <content align=\"center\">\n      <xul:vbox pack=\"center\" anonid=\"itemBox\" class=\"itemBox\">\n        <xul:description anonid=\"center-item-label\" class=\"center-item-label\" />\n        <xul:hbox flex=\"1\" pack=\"start\" align=\"center\" anonid=\"center-item-warning\">\n          <xul:image anonid=\"center-item-warning-icon\" class=\"center-item-warning-icon\"/>\n          <xul:label anonid=\"center-item-warning-label\"/>\n          <xul:label anonid=\"center-item-link\" value=\"FROM-DTD-checkForUpdates\" class=\"text-link\"/>\n        </xul:hbox>\n      </xul:vbox>\n      <xul:vbox pack=\"center\">\n        <xul:menulist class=\"center-item-menulist\"\n                      anonid=\"center-item-menulist\">\n          <xul:menupopup>\n            <xul:menuitem anonid=\"allownow\" value=\"allownow\"\n                          label=\"FROM-DTD-pluginActivateNow-label\" />\n            <xul:menuitem anonid=\"allowalways\" value=\"allowalways\"\n                          label=\"FROM-DTD-pluginActivateAlways-label\" />\n            <xul:menuitem anonid=\"block\" value=\"block\"\n                          label=\"FROM-DTD-pluginBlockNow-label\" />\n          </xul:menupopup>\n        </xul:menulist>\n      </xul:vbox>\n    </content>\n    <resources>\n      <stylesheet src=\"chrome://global/skin/notification.css\"/>\n    </resources>\n    <implementation>\n      <constructor><![CDATA[\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"center-item-label\").value = this.action.pluginName;\n\n        let curState = \"block\";\n        if (this.action.fallbackType == Ci.nsIObjectLoadingContent.PLUGIN_ACTIVE) {\n          if (this.action.pluginPermissionType == Ci.nsIPermissionManager.EXPIRE_SESSION) {\n            curState = \"allownow\";\n          } else {\n            curState = \"allowalways\";\n          }\n        }\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"center-item-menulist\").value = curState;\n\n        let warningString = \"\";\n        let linkString = \"\";\n\n        let link = document.getAnonymousElementByAttribute(this, \"anonid\", \"center-item-link\");\n\n        let url;\n        let linkHandler;\n\n        if (this.action.pluginTag.enabledState == Ci.nsIPluginTag.STATE_DISABLED) {\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"center-item-menulist\").hidden = true;\n          warningString = gNavigatorBundle.getString(\"pluginActivateDisabled.label\");\n          linkString = gNavigatorBundle.getString(\"pluginActivateDisabled.manage\");\n          linkHandler = function(event) {\n            event.preventDefault();\n            gPluginHandler.managePlugins();\n          };\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"center-item-warning-icon\").hidden = true;\n        } else {\n          url = this.action.detailsLink;\n\n          switch (this.action.blocklistState) {\n          case Ci.nsIBlocklistService.STATE_NOT_BLOCKED:\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"center-item-warning\").hidden = true;\n            break;\n          case Ci.nsIBlocklistService.STATE_BLOCKED:\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"center-item-menulist\").hidden = true;\n            warningString = gNavigatorBundle.getString(\"pluginActivateBlocked.label\");\n            linkString = gNavigatorBundle.getString(\"pluginActivate.learnMore\");\n            break;\n          case Ci.nsIBlocklistService.STATE_VULNERABLE_UPDATE_AVAILABLE:\n            warningString = gNavigatorBundle.getString(\"pluginActivateOutdated.label\");\n            linkString = gNavigatorBundle.getString(\"pluginActivate.updateLabel\");\n            break;\n          case Ci.nsIBlocklistService.STATE_VULNERABLE_NO_UPDATE:\n            warningString = gNavigatorBundle.getString(\"pluginActivateVulnerable.label\");\n            linkString = gNavigatorBundle.getString(\"pluginActivate.riskLabel\");\n            break;\n          }\n        }\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"center-item-warning-label\").value = warningString;\n\n        let chromeWin = window.QueryInterface(Ci.nsIDOMChromeWindow);\n        let isWindowPrivate = PrivateBrowsingUtils.isWindowPrivate(chromeWin);\n\n        if (isWindowPrivate) {\n          // TODO: temporary compromise of hiding some privacy leaks, remove once bug 892487 is fixed\n          let allowalways = document.getAnonymousElementByAttribute(this, \"anonid\", \"allowalways\");\n          let block = document.getAnonymousElementByAttribute(this, \"anonid\", \"block\");\n          let allownow = document.getAnonymousElementByAttribute(this, \"anonid\", \"allownow\");\n\n          allowalways.hidden = curState !== \"allowalways\";\n          block.hidden       = curState !== \"block\";\n          allownow.hidden    = curState === \"allowalways\";\n        }\n\n        if (url || linkHandler) {\n          link.value = linkString;\n          if (url) {\n            link.href = url;\n          }\n          if (linkHandler) {\n            link.addEventListener(\"click\", linkHandler);\n          }\n        } else {\n          link.hidden = true;\n        }\n      ]]></constructor>\n      <property name=\"value\">\n        <getter>\n          return document.getAnonymousElementByAttribute(this, \"anonid\",\n                   \"center-item-menulist\").value;\n        </getter>\n        <setter><!-- This should be used only in automated tests -->\n          document.getAnonymousElementByAttribute(this, \"anonid\",\n                    \"center-item-menulist\").value = val;\n        </setter>\n      </property>\n    </implementation>\n  </binding>\n\n  <binding id=\"click-to-play-plugins-notification\" extends=\"chrome://global/content/bindings/notification.xml#popup-notification\">\n    <content align=\"start\" style=\"width: FROM-DTD-pluginNotification-width;\">\n      <xul:vbox flex=\"1\" align=\"stretch\" class=\"click-to-play-plugins-notification-main-box\"\n                xbl:inherits=\"popupid\">\n        <xul:hbox class=\"click-to-play-plugins-notification-description-box\" flex=\"1\" align=\"start\">\n          <xul:description class=\"click-to-play-plugins-outer-description\" flex=\"1\">\n            <html:span anonid=\"click-to-play-plugins-notification-description\" />\n            <html:br/>\n            <xul:label class=\"text-link click-to-play-plugins-notification-link popup-notification-learnmore-link\"\n                       anonid=\"click-to-play-plugins-notification-link\" />\n          </xul:description>\n        </xul:hbox>\n        <xul:grid anonid=\"click-to-play-plugins-notification-center-box\"\n                  class=\"click-to-play-plugins-notification-center-box\">\n          <xul:columns>\n            <xul:column flex=\"1\"/>\n            <xul:column/>\n          </xul:columns>\n          <xul:rows>\n            <children includes=\"row\"/>\n            <xul:hbox pack=\"start\" anonid=\"plugin-notification-showbox\">\n              <xul:button label=\"FROM-DTD-pluginNotification-showAll-label\"\n                          accesskey=\"FROM-DTD-pluginNotification-showAll-accesskey\"\n                          class=\"plugin-notification-showbutton\"\n                          oncommand=\"document.getBindingParent(this)._setState(2)\"/>\n            </xul:hbox>\n          </xul:rows>\n        </xul:grid>\n        <xul:hbox anonid=\"button-container\"\n                  class=\"click-to-play-plugins-notification-button-container\"\n                  pack=\"center\" align=\"center\">\n          <xul:button anonid=\"primarybutton\"\n                      class=\"click-to-play-popup-button popup-notification-button\"\n                      oncommand=\"document.getBindingParent(this)._onButton(this)\"\n                      flex=\"1\"/>\n          <xul:button anonid=\"secondarybutton\"\n                      default=\"true\"\n                      highlight=\"true\"\n                      class=\"click-to-play-popup-button popup-notification-button\"\n                      oncommand=\"document.getBindingParent(this)._onButton(this);\"\n                      flex=\"1\"/>\n        </xul:hbox>\n        <xul:box hidden=\"true\">\n          <children/>\n        </xul:box>\n      </xul:vbox>\n    </content>\n    <resources>\n      <stylesheet src=\"chrome://global/skin/notification.css\"/>\n    </resources>\n    <implementation>\n      <field name=\"_states\">\n        ({SINGLE: 0, MULTI_COLLAPSED: 1, MULTI_EXPANDED: 2})\n      </field>\n      <field name=\"_primaryButton\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"primarybutton\");\n      </field>\n      <field name=\"_secondaryButton\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"secondarybutton\")\n      </field>\n      <field name=\"_buttonContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"button-container\")\n      </field>\n      <field name=\"_brandShortName\">\n        document.getElementById(\"bundle_brand\").getString(\"brandShortName\")\n      </field>\n      <field name=\"_items\">[]</field>\n      <constructor><![CDATA[\n        const XUL_NS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n        let sortedActions = [];\n        for (let action of this.notification.options.pluginData.values()) {\n          sortedActions.push(action);\n        }\n        sortedActions.sort((a, b) => a.pluginName.localeCompare(b.pluginName));\n\n        for (let action of sortedActions) {\n          let item = document.createElementNS(XUL_NS, \"row\");\n          item.setAttribute(\"class\", \"plugin-popupnotification-centeritem\");\n          item.action = action;\n          this.appendChild(item);\n          this._items.push(item);\n        }\n        switch (this._items.length) {\n          case 0:\n            PopupNotifications._dismiss();\n            break;\n          case 1:\n            this._setState(this._states.SINGLE);\n            break;\n          default:\n            if (this.notification.options.primaryPlugin) {\n              this._setState(this._states.MULTI_COLLAPSED);\n            } else {\n              this._setState(this._states.MULTI_EXPANDED);\n            }\n        }\n      ]]></constructor>\n      <method name=\"_setState\">\n        <parameter name=\"state\" />\n        <body><![CDATA[\n          var grid = document.getAnonymousElementByAttribute(this, \"anonid\", \"click-to-play-plugins-notification-center-box\");\n\n          if (this._states.SINGLE == state) {\n            grid.hidden = true;\n            this._setupSingleState();\n            return;\n          }\n\n          let prePath = this.notification.options.principal.URI.prePath;\n          this._setupDescription(\"pluginActivateMultiple.message\", null, prePath);\n\n          var showBox = document.getAnonymousElementByAttribute(this, \"anonid\", \"plugin-notification-showbox\");\n\n          var dialogStrings = Services.strings.createBundle(\"chrome://global/locale/dialog.properties\");\n          this._primaryButton.label = dialogStrings.GetStringFromName(\"button-accept\");\n          this._primaryButton.setAttribute(\"default\", \"true\");\n\n          this._secondaryButton.label = dialogStrings.GetStringFromName(\"button-cancel\");\n          this._primaryButton.setAttribute(\"action\", \"_multiAccept\");\n          this._secondaryButton.setAttribute(\"action\", \"_cancel\");\n\n          grid.hidden = false;\n\n          if (this._states.MULTI_COLLAPSED == state) {\n            for (let child of this.childNodes) {\n              if (child.tagName != \"row\") {\n                continue;\n              }\n              child.hidden = this.notification.options.primaryPlugin !=\n                             child.action.permissionString;\n            }\n            showBox.hidden = false;\n          } else {\n            for (let child of this.childNodes) {\n              if (child.tagName != \"row\") {\n                continue;\n              }\n              child.hidden = false;\n            }\n            showBox.hidden = true;\n          }\n          this._setupLink(null);\n        ]]></body>\n      </method>\n      <method name=\"_setupSingleState\">\n        <body><![CDATA[\n          var action = this._items[0].action;\n          var prePath = action.pluginPermissionPrePath;\n          let chromeWin = window.QueryInterface(Ci.nsIDOMChromeWindow);\n          let isWindowPrivate = PrivateBrowsingUtils.isWindowPrivate(chromeWin);\n\n          let label, linkLabel, button1, button2;\n\n          if (action.fallbackType == Ci.nsIObjectLoadingContent.PLUGIN_ACTIVE) {\n            button1 = {\n              label: \"pluginBlockNow.label\",\n              accesskey: \"pluginBlockNow.accesskey\",\n              action: \"_singleBlock\"\n            };\n            button2 = {\n              label: \"pluginContinue.label\",\n              accesskey: \"pluginContinue.accesskey\",\n              action: \"_singleContinue\",\n              default: true\n            };\n            switch (action.blocklistState) {\n            case Ci.nsIBlocklistService.STATE_NOT_BLOCKED:\n              label = \"pluginEnabled.message\";\n              linkLabel = \"pluginActivate.learnMore\";\n              break;\n\n            case Ci.nsIBlocklistService.STATE_BLOCKED:\n              Cu.reportError(Error(\"Cannot happen!\"));\n              break;\n\n            case Ci.nsIBlocklistService.STATE_VULNERABLE_UPDATE_AVAILABLE:\n              label = \"pluginEnabledOutdated.message\";\n              linkLabel = \"pluginActivate.updateLabel\";\n              break;\n\n            case Ci.nsIBlocklistService.STATE_VULNERABLE_NO_UPDATE:\n              label = \"pluginEnabledVulnerable.message\";\n              linkLabel = \"pluginActivate.riskLabel\"\n              break;\n\n            default:\n              Cu.reportError(Error(\"Unexpected blocklist state\"));\n            }\n\n            // TODO: temporary compromise, remove this once bug 892487 is fixed\n            if (isWindowPrivate) {\n              this._buttonContainer.hidden = true;\n            }\n          } else if (action.pluginTag.enabledState == Ci.nsIPluginTag.STATE_DISABLED) {\n            let linkElement =\n              document.getAnonymousElementByAttribute(\n                         this, \"anonid\", \"click-to-play-plugins-notification-link\");\n            linkElement.textContent = gNavigatorBundle.getString(\"pluginActivateDisabled.manage\");\n            linkElement.setAttribute(\"onclick\", \"gPluginHandler.managePlugins()\");\n\n            let descElement = document.getAnonymousElementByAttribute(this, \"anonid\", \"click-to-play-plugins-notification-description\");\n            descElement.textContent = gNavigatorBundle.getFormattedString(\n              \"pluginActivateDisabled.message\", [action.pluginName, this._brandShortName]) + \" \";\n            this._buttonContainer.hidden = true;\n            return;\n          } else if (action.blocklistState == Ci.nsIBlocklistService.STATE_BLOCKED) {\n            let descElement = document.getAnonymousElementByAttribute(this, \"anonid\", \"click-to-play-plugins-notification-description\");\n            descElement.textContent = gNavigatorBundle.getFormattedString(\n              \"pluginActivateBlocked.message\", [action.pluginName, this._brandShortName]) + \" \";\n            this._setupLink(\"pluginActivate.learnMore\", action.detailsLink);\n            this._buttonContainer.hidden = true;\n            return;\n          } else {\n            button1 = {\n              label: \"pluginActivateNow.label\",\n              accesskey: \"pluginActivateNow.accesskey\",\n              action: \"_singleActivateNow\"\n            };\n            button2 = {\n              label: \"pluginActivateAlways.label\",\n              accesskey: \"pluginActivateAlways.accesskey\",\n              action: \"_singleActivateAlways\"\n            };\n            switch (action.blocklistState) {\n            case Ci.nsIBlocklistService.STATE_NOT_BLOCKED:\n              label = \"pluginActivate2.message\";\n              linkLabel = \"pluginActivate.learnMore\";\n              button2.default = true;\n              break;\n\n            case Ci.nsIBlocklistService.STATE_VULNERABLE_UPDATE_AVAILABLE:\n              label = \"pluginActivateOutdated.message\";\n              linkLabel = \"pluginActivate.updateLabel\";\n              button1.default = true;\n              break;\n\n            case Ci.nsIBlocklistService.STATE_VULNERABLE_NO_UPDATE:\n              label = \"pluginActivateVulnerable.message\";\n              linkLabel = \"pluginActivate.riskLabel\"\n              button1.default = true;\n              break;\n\n            default:\n              Cu.reportError(Error(\"Unexpected blocklist state\"));\n            }\n\n            // TODO: temporary compromise, remove this once bug 892487 is fixed\n            if (isWindowPrivate) {\n              button1.default = true;\n              this._secondaryButton.hidden = true;\n            }\n          }\n          this._setupDescription(label, action.pluginName, prePath);\n          this._setupLink(linkLabel, action.detailsLink);\n\n          this._primaryButton.label = gNavigatorBundle.getString(button1.label);\n          this._primaryButton.accessKey = gNavigatorBundle.getString(button1.accesskey);\n          this._primaryButton.setAttribute(\"action\", button1.action);\n\n          this._secondaryButton.label = gNavigatorBundle.getString(button2.label);\n          this._secondaryButton.accessKey = gNavigatorBundle.getString(button2.accesskey);\n          this._secondaryButton.setAttribute(\"action\", button2.action);\n          if (button1.default) {\n            this._primaryButton.setAttribute(\"default\", \"true\");\n          } else if (button2.default) {\n            this._secondaryButton.setAttribute(\"default\", \"true\");\n          }\n\n          if (this._primaryButton.hidden) {\n            this._secondaryButton.setAttribute(\"alone\", \"true\");\n          } else if (this._secondaryButton.hidden) {\n            this._primaryButton.setAttribute(\"alone\", \"true\");\n          }\n        ]]></body>\n      </method>\n      <method name=\"_setupDescription\">\n        <parameter name=\"baseString\" />\n        <parameter name=\"pluginName\" /> <!-- null for the multiple-plugin case -->\n        <parameter name=\"prePath\" />\n        <body><![CDATA[\n          var span = document.getAnonymousElementByAttribute(this, \"anonid\", \"click-to-play-plugins-notification-description\");\n          while (span.lastChild) {\n            span.removeChild(span.lastChild);\n          }\n\n          var args = [\"__prepath__\", this._brandShortName];\n          if (pluginName) {\n            args.unshift(pluginName);\n          }\n          var bases = gNavigatorBundle.getFormattedString(baseString, args).\n            split(\"__prepath__\", 2);\n\n          span.appendChild(document.createTextNode(bases[0]));\n          var prePathSpan = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"em\");\n          prePathSpan.appendChild(document.createTextNode(prePath));\n          span.appendChild(prePathSpan);\n          span.appendChild(document.createTextNode(bases[1] + \" \"));\n        ]]></body>\n      </method>\n      <method name=\"_setupLink\">\n        <parameter name=\"linkString\"/>\n        <parameter name=\"linkUrl\" />\n        <body><![CDATA[\n          var link = document.getAnonymousElementByAttribute(this, \"anonid\", \"click-to-play-plugins-notification-link\");\n          if (!linkString || !linkUrl) {\n            link.hidden = true;\n            return;\n          }\n\n          link.hidden = false;\n          link.textContent = gNavigatorBundle.getString(linkString);\n          link.href = linkUrl;\n        ]]></body>\n      </method>\n      <method name=\"_onButton\">\n        <parameter name=\"aButton\" />\n        <body><![CDATA[\n          let methodName = aButton.getAttribute(\"action\");\n          this[methodName]();\n        ]]></body>\n      </method>\n      <method name=\"_singleActivateNow\">\n        <body><![CDATA[\n          gPluginHandler._updatePluginPermission(this.notification,\n            this._items[0].action,\n            \"allownow\");\n          this._cancel();\n        ]]></body>\n      </method>\n      <method name=\"_singleBlock\">\n        <body><![CDATA[\n          gPluginHandler._updatePluginPermission(this.notification,\n            this._items[0].action,\n            \"block\");\n            this._cancel();\n        ]]></body>\n      </method>\n      <method name=\"_singleActivateAlways\">\n        <body><![CDATA[\n          gPluginHandler._updatePluginPermission(this.notification,\n            this._items[0].action,\n            \"allowalways\");\n          this._cancel();\n        ]]></body>\n      </method>\n      <method name=\"_singleContinue\">\n        <body><![CDATA[\n          gPluginHandler._updatePluginPermission(this.notification,\n            this._items[0].action,\n            \"continue\");\n          this._cancel();\n        ]]></body>\n      </method>\n      <method name=\"_multiAccept\">\n        <body><![CDATA[\n          for (let item of this._items) {\n            let action = item.action;\n            if (action.pluginTag.enabledState == Ci.nsIPluginTag.STATE_DISABLED ||\n                action.blocklistState == Ci.nsIBlocklistService.STATE_BLOCKED) {\n              continue;\n            }\n            gPluginHandler._updatePluginPermission(this.notification,\n              item.action, item.value);\n          }\n          this._cancel();\n        ]]></body>\n      </method>\n      <method name=\"_cancel\">\n        <body><![CDATA[\n          PopupNotifications._dismiss();\n        ]]></body>\n      </method>\n      <method name=\"_accept\">\n        <parameter name=\"aEvent\" />\n        <body><![CDATA[\n          if (aEvent.defaultPrevented)\n            return;\n          aEvent.preventDefault();\n          if (this._primaryButton.getAttribute(\"default\") == \"true\") {\n            this._primaryButton.click();\n          } else if (this._secondaryButton.getAttribute(\"default\") == \"true\") {\n            this._secondaryButton.click();\n          }\n        ]]></body>\n      </method>\n    </implementation>\n    <handlers>\n      <!-- The _accept method checks for .defaultPrevented so that if focus is in a button,\n           enter activates the button and not this default action -->\n      <handler event=\"keypress\" keycode=\"VK_RETURN\" group=\"system\" action=\"this._accept(event);\"/>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"panelUI.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings [\n  <!ENTITY % browserDTD SYSTEM \"chrome://browser/locale/browser.dtd\">\n  %browserDTD;\n]>\n\n<bindings id=\"browserPanelUIBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"panelmultiview\">\n    <resources>\n      <stylesheet src=\"chrome://browser/content/customizableui/panelUI.css\"/>\n    </resources>\n    <content>\n      <xul:vbox anonid=\"viewContainer\" class=\"panel-viewcontainer\" xbl:inherits=\"panelopen,viewtype,transitioning\">\n        <xul:stack anonid=\"viewStack\" xbl:inherits=\"viewtype,transitioning\" class=\"panel-viewstack\">\n          <xul:vbox anonid=\"mainViewContainer\" class=\"panel-mainview\" xbl:inherits=\"viewtype\"/>\n\n          <!-- Used to capture click events over the PanelUI-mainView if we're in\n               subview mode. That way, any click on the PanelUI-mainView causes us\n               to revert to the mainView mode, whereupon PanelUI-click-capture then\n               allows click events to go through it. -->\n          <xul:vbox anonid=\"clickCapturer\" class=\"panel-clickcapturer\"/>\n\n          <!-- We manually set display: none (via a CSS attribute selector) on the\n               subviews that are not being displayed. We're using this over a deck\n               because a deck assumes the size of its largest child, regardless of\n               whether or not it is shown. That's not good for our case, since we\n               want to allow each subview to be uniquely sized. -->\n          <xul:vbox anonid=\"subViews\" class=\"panel-subviews\" xbl:inherits=\"panelopen\">\n            <children includes=\"panelview\"/>\n          </xul:vbox>\n        </xul:stack>\n      </xul:vbox>\n    </content>\n    <implementation>\n      <constructor><![CDATA[\n        const {PanelMultiView} = Components.utils.import(\"resource:///modules/PanelMultiView.jsm\", {});\n        this.instance = new PanelMultiView(this);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        this.instance.destructor();\n      ]]></destructor>\n    </implementation>\n  </binding>\n\n  <binding id=\"photonpanelmultiview\" extends=\"chrome://browser/content/customizableui/panelUI.xml#panelmultiview\">\n    <content>\n      <xul:box anonid=\"viewContainer\" class=\"panel-viewcontainer\" xbl:inherits=\"panelopen,transitioning\">\n        <xul:box anonid=\"viewStack\" xbl:inherits=\"transitioning\" class=\"panel-viewstack\">\n          <children includes=\"panelview\"/>\n        </xul:box>\n      </xul:box>\n      <xul:box class=\"panel-viewcontainer offscreen\">\n        <xul:box anonid=\"offscreenViewStack\" class=\"panel-viewstack\"/>\n      </xul:box>\n    </content>\n  </binding>\n\n  <binding id=\"panelview\">\n    <content>\n      <xul:box class=\"panel-header\" anonid=\"header\">\n        <xul:toolbarbutton anonid=\"back\"\n                           class=\"subviewbutton subviewbutton-iconic subviewbutton-back\"\n                           closemenu=\"none\"\n                           tabindex=\"0\"\n                           tooltip=\"FROM-DTD-backCmd-label\"\n                           onclick=\"document.getBindingParent(this).panelMultiView.goBack(); this.blur()\"/>\n        <xul:label xbl:inherits=\"value=title\"/>\n      </xul:box>\n      <children/>\n    </content>\n    <implementation>\n      <property name=\"header\"\n                readonly=\"true\"\n                onget=\"return document.getAnonymousElementByAttribute(this, 'anonid', 'header');\"/>\n      <property name=\"backButton\"\n                readonly=\"true\"\n                onget=\"return document.getAnonymousElementByAttribute(this, 'anonid', 'back');\"/>\n      <property name=\"panelMultiView\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.parentNode.localName.endsWith(\"panelmultiview\")) {\n            return document.getBindingParent(this.parentNode);\n          }\n\n          return this.parentNode;\n        ]]></getter>\n      </property>\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"toolbar.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"browserToolbarBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"toolbar\" role=\"xul:toolbar\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/toolbar.css\"/>\n    </resources>\n    <implementation>\n      <field name=\"overflowedDuringConstruction\">null</field>\n\n      <constructor><![CDATA[\n          let scope = {};\n          Cu.import(\"resource:///modules/CustomizableUI.jsm\", scope);\n          // Add an early overflow event listener that will mark if the\n          // toolbar overflowed during construction.\n          if (scope.CustomizableUI.isAreaOverflowable(this.id)) {\n            this.addEventListener(\"overflow\", this);\n            this.addEventListener(\"underflow\", this);\n          }\n\n          if (document.readyState == \"complete\") {\n            this._init();\n          } else {\n            // Need to wait until XUL overlays are loaded. See bug 554279.\n            let self = this;\n            document.addEventListener(\"readystatechange\", function onReadyStateChange() {\n              if (document.readyState != \"complete\")\n                return;\n              document.removeEventListener(\"readystatechange\", onReadyStateChange);\n              self._init();\n            });\n          }\n      ]]></constructor>\n\n      <method name=\"_init\">\n        <body><![CDATA[\n          let scope = {};\n          Cu.import(\"resource:///modules/CustomizableUI.jsm\", scope);\n          let CustomizableUI = scope.CustomizableUI;\n\n          // Bug 989289: Forcibly set the now unsupported \"mode\" and \"iconsize\"\n          // attributes, just in case they accidentally get restored from\n          // persistence from a user that's been upgrading and downgrading.\n          if (CustomizableUI.isBuiltinToolbar(this.id)) {\n            const kAttributes = new Map([[\"mode\", \"icons\"], [\"iconsize\", \"small\"]]);\n            for (let [attribute, value] of kAttributes) {\n              if (this.getAttribute(attribute) != value) {\n                this.setAttribute(attribute, value);\n                document.persist(this.id, attribute);\n              }\n              if (this.toolbox) {\n                if (this.toolbox.getAttribute(attribute) != value) {\n                  this.toolbox.setAttribute(attribute, value);\n                  document.persist(this.toolbox.id, attribute);\n                }\n              }\n            }\n          }\n\n          // Searching for the toolbox palette in the toolbar binding because\n          // toolbars are constructed first.\n          let toolbox = this.toolbox;\n          if (toolbox && !toolbox.palette) {\n            for (let node of toolbox.children) {\n              if (node.localName == \"toolbarpalette\") {\n                // Hold on to the palette but remove it from the document.\n                toolbox.palette = node;\n                toolbox.removeChild(node);\n                break;\n              }\n            }\n          }\n\n          // pass the current set of children for comparison with placements:\n          let children = Array.from(this.childNodes)\n                              .filter(node => node.getAttribute(\"skipintoolbarset\") != \"true\" && node.id)\n                              .map(node => node.id);\n          CustomizableUI.registerToolbarNode(this, children);\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.type == \"overflow\" && aEvent.detail > 0) {\n            if (this.overflowable && this.overflowable.initialized) {\n              this.overflowable.onOverflow(aEvent);\n            } else {\n              this.overflowedDuringConstruction = aEvent;\n            }\n          } else if (aEvent.type == \"underflow\" && aEvent.detail > 0) {\n            this.overflowedDuringConstruction = null;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"insertItem\">\n        <parameter name=\"aId\"/>\n        <parameter name=\"aBeforeElt\"/>\n        <parameter name=\"aWrapper\"/>\n        <body><![CDATA[\n          if (aWrapper) {\n            Cu.reportError(\"Can't insert \" + aId + \": using insertItem \" +\n                           \"no longer supports wrapper elements.\");\n            return null;\n          }\n\n          // Hack, the customizable UI code makes this be the last position\n          let pos = null;\n          if (aBeforeElt) {\n            let beforeInfo = CustomizableUI.getPlacementOfWidget(aBeforeElt.id);\n            if (beforeInfo.area != this.id) {\n              Cu.reportError(\"Can't insert \" + aId + \" before \" +\n                             aBeforeElt.id + \" which isn't in this area (\" +\n                             this.id + \").\");\n              return null;\n            }\n            pos = beforeInfo.position;\n          }\n\n          CustomizableUI.addWidgetToArea(aId, this.id, pos);\n          return this.ownerDocument.getElementById(aId);\n        ]]></body>\n      </method>\n\n      <property name=\"toolbarName\"\n                onget=\"return this.getAttribute('toolbarname');\"\n                onset=\"this.setAttribute('toolbarname', val); return val;\"/>\n\n      <property name=\"customizationTarget\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._customizationTarget)\n            return this._customizationTarget;\n\n          let id = this.getAttribute(\"customizationtarget\");\n          if (id)\n            this._customizationTarget = document.getElementById(id);\n\n          if (this._customizationTarget)\n            this._customizationTarget.insertItem = this.insertItem.bind(this);\n          else\n            this._customizationTarget = this;\n\n          return this._customizationTarget;\n        ]]></getter>\n      </property>\n\n      <property name=\"toolbox\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._toolbox)\n            return this._toolbox;\n\n          let toolboxId = this.getAttribute(\"toolboxid\");\n          if (toolboxId) {\n            let toolbox = document.getElementById(toolboxId);\n            if (toolbox) {\n              if (toolbox.externalToolbars.indexOf(this) == -1)\n                toolbox.externalToolbars.push(this);\n\n              this._toolbox = toolbox;\n            }\n          }\n\n          if (!this._toolbox && this.parentNode &&\n              this.parentNode.localName == \"toolbox\") {\n            this._toolbox = this.parentNode;\n          }\n\n          return this._toolbox;\n        ]]></getter>\n      </property>\n\n      <property name=\"currentSet\">\n        <getter><![CDATA[\n          let currentWidgets = new Set();\n          for (let node of this.customizationTarget.children) {\n            let realNode = node.localName == \"toolbarpaletteitem\" ? node.firstChild : node;\n            if (realNode.getAttribute(\"skipintoolbarset\") != \"true\") {\n              currentWidgets.add(realNode.id);\n            }\n          }\n          if (this.getAttribute(\"overflowing\") == \"true\") {\n            let overflowTarget = this.getAttribute(\"overflowtarget\");\n            let overflowList = this.ownerDocument.getElementById(overflowTarget);\n            for (let node of overflowList.children) {\n              let realNode = node.localName == \"toolbarpaletteitem\" ? node.firstChild : node;\n              if (realNode.getAttribute(\"skipintoolbarset\") != \"true\") {\n                currentWidgets.add(realNode.id);\n              }\n            }\n          }\n          let orderedPlacements = CustomizableUI.getWidgetIdsInArea(this.id);\n          return orderedPlacements.filter(w => currentWidgets.has(w)).join(\",\");\n        ]]></getter>\n        <setter><![CDATA[\n          // Get list of new and old ids:\n          let newVal = (val || \"\").split(\",\").filter(x => x);\n          let oldIds = CustomizableUI.getWidgetIdsInArea(this.id);\n\n          // Get a list of items only in the new list\n          let newIds = newVal.filter(id => oldIds.indexOf(id) == -1);\n          CustomizableUI.beginBatchUpdate();\n          try {\n            for (let newId of newIds) {\n              oldIds = CustomizableUI.getWidgetIdsInArea(this.id);\n              let nextId = newId;\n              let pos;\n              do {\n                // Get the next item\n                nextId = newVal[newVal.indexOf(nextId) + 1];\n                // Figure out where it is in the old list\n                pos = oldIds.indexOf(nextId);\n                // If it's not in the old list, repeat:\n              } while (pos == -1 && nextId);\n              if (pos == -1) {\n                pos = null; // We didn't find anything, insert at the end\n              }\n              CustomizableUI.addWidgetToArea(newId, this.id, pos);\n            }\n\n            let currentIds = this.currentSet.split(\",\");\n            let removedIds = currentIds.filter(id => newIds.indexOf(id) == -1 && newVal.indexOf(id) == -1);\n            for (let removedId of removedIds) {\n              CustomizableUI.removeWidgetFromArea(removedId);\n            }\n          } finally {\n            CustomizableUI.endBatchUpdate();\n          }\n        ]]></setter>\n      </property>\n\n\n    </implementation>\n  </binding>\n\n  <binding id=\"toolbar-menubar-stub\">\n    <implementation>\n      <property name=\"toolbox\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._toolbox)\n            return this._toolbox;\n\n          if (this.parentNode && this.parentNode.localName == \"toolbox\") {\n            this._toolbox = this.parentNode;\n          }\n\n          return this._toolbox;\n        ]]></getter>\n      </property>\n      <property name=\"currentSet\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.getAttribute(\"defaultset\");\n        ]]></getter>\n      </property>\n      <method name=\"insertItem\">\n        <body><![CDATA[\n          return null;\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n  <!-- The toolbar-menubar-autohide and toolbar-drag bindings are almost\n       verbatim copies of their toolkit counterparts - they just inherit from\n       the customizableui's toolbar binding instead of toolkit's. We're currently\n       OK with the maintainance burden of having two copies of a binding, since\n       the long term goal is to move the customization framework into toolkit. -->\n\n  <binding id=\"toolbar-menubar-autohide\"\n           extends=\"chrome://browser/content/customizableui/toolbar.xml#toolbar\">\n    <implementation>\n      <constructor>\n        this._setInactive();\n      </constructor>\n      <destructor>\n        this._setActive();\n      </destructor>\n\n      <field name=\"_inactiveTimeout\">null</field>\n\n      <field name=\"_contextMenuListener\"><![CDATA[({\n        toolbar: this,\n        contextMenu: null,\n\n        get active() {\n          return !!this.contextMenu;\n        },\n\n        init(event) {\n          let node = event.target;\n          while (node != this.toolbar) {\n            if (node.localName == \"menupopup\")\n              return;\n            node = node.parentNode;\n          }\n\n          let contextMenuId = this.toolbar.getAttribute(\"context\");\n          if (!contextMenuId)\n            return;\n\n          this.contextMenu = document.getElementById(contextMenuId);\n          if (!this.contextMenu)\n            return;\n\n          this.contextMenu.addEventListener(\"popupshown\", this);\n          this.contextMenu.addEventListener(\"popuphiding\", this);\n          this.toolbar.addEventListener(\"mousemove\", this);\n        },\n        handleEvent(event) {\n          switch (event.type) {\n            case \"popupshown\":\n              this.toolbar.removeEventListener(\"mousemove\", this);\n              break;\n            case \"popuphiding\":\n            case \"mousemove\":\n              this.toolbar._setInactiveAsync();\n              this.toolbar.removeEventListener(\"mousemove\", this);\n              this.contextMenu.removeEventListener(\"popuphiding\", this);\n              this.contextMenu.removeEventListener(\"popupshown\", this);\n              this.contextMenu = null;\n              break;\n          }\n        }\n      })]]></field>\n\n      <method name=\"_setInactive\">\n        <body><![CDATA[\n          this.setAttribute(\"inactive\", \"true\");\n        ]]></body>\n      </method>\n\n      <method name=\"_setInactiveAsync\">\n        <body><![CDATA[\n          this._inactiveTimeout = setTimeout(function(self) {\n            if (self.getAttribute(\"autohide\") == \"true\") {\n              self._inactiveTimeout = null;\n              self._setInactive();\n            }\n          }, 0, this);\n        ]]></body>\n      </method>\n\n      <method name=\"_setActive\">\n        <body><![CDATA[\n          if (this._inactiveTimeout) {\n            clearTimeout(this._inactiveTimeout);\n            this._inactiveTimeout = null;\n          }\n          this.removeAttribute(\"inactive\");\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"DOMMenuBarActive\"     action=\"this._setActive();\"/>\n      <handler event=\"popupshowing\"         action=\"this._setActive();\"/>\n      <handler event=\"mousedown\" button=\"2\" action=\"this._contextMenuListener.init(event);\"/>\n      <handler event=\"DOMMenuBarInactive\"><![CDATA[\n        if (!this._contextMenuListener.active)\n          this._setInactiveAsync();\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"toolbar-drag\"\n           extends=\"chrome://browser/content/customizableui/toolbar.xml#toolbar\">\n    <implementation>\n      <field name=\"_dragBindingAlive\">true</field>\n      <constructor><![CDATA[\n        if (!this._draggableStarted) {\n          this._draggableStarted = true;\n          try {\n            let tmp = {};\n            Components.utils.import(\"resource://gre/modules/WindowDraggingUtils.jsm\", tmp);\n            let draggableThis = new tmp.WindowDraggingElement(this);\n            draggableThis.mouseDownCheck = function(e) {\n              return this._dragBindingAlive;\n            };\n          } catch (e) {}\n        }\n      ]]></constructor>\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"download.xml","body":"<?xml version=\"1.0\"?>\n<!-- -*- Mode: HTML; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- -->\n<!-- vim: set ts=2 et sw=2 tw=80: -->\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this file,\n   - You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings SYSTEM \"chrome://browser/locale/downloads/downloads.dtd\">\n\n<bindings id=\"downloadBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"download\"\n           extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <content orient=\"horizontal\"\n             onclick=\"DownloadsView.onDownloadClick(event);\">\n      <xul:hbox class=\"downloadMainArea\"\n                flex=\"1\"\n                align=\"center\">\n        <xul:stack>\n          <xul:image class=\"downloadTypeIcon\"\n                     validate=\"always\"\n                     xbl:inherits=\"src=image\"/>\n          <xul:image class=\"downloadBlockedBadge\" />\n        </xul:stack>\n        <xul:vbox pack=\"center\"\n                  flex=\"1\"\n                  class=\"downloadContainer\"\n                  style=\"width: FROM-DTD-downloadDetails-width\">\n          <!-- We're letting localizers put a min-width in here primarily\n               because of the downloads summary at the bottom of the list of\n               download items. An element in the summary has the same min-width\n               on a description, and we don't want the panel to change size if the\n               summary isn't being displayed, so we ensure that items share the\n               same minimum width.\n               -->\n          <xul:description class=\"downloadTarget\"\n                           crop=\"center\"\n                           style=\"min-width: FROM-DTD-downloadsSummary-minWidth2\"\n                           xbl:inherits=\"value=displayName,tooltiptext=displayName\"/>\n          <xul:progressmeter anonid=\"progressmeter\"\n                             class=\"downloadProgress\"\n                             min=\"0\"\n                             max=\"100\"\n                             xbl:inherits=\"mode=progressmode,value=progress,paused=progresspaused\"/>\n          <xul:description class=\"downloadDetails downloadDetailsNormal\"\n                           crop=\"end\"\n                           xbl:inherits=\"value=status\"/>\n          <xul:description class=\"downloadDetails downloadDetailsHover\"\n                           crop=\"end\"\n                           xbl:inherits=\"value=hoverStatus\"/>\n          <xul:description class=\"downloadDetails downloadDetailsFull\"\n                           crop=\"end\"\n                           xbl:inherits=\"value=fullStatus,tooltiptext=fullStatus\"/>\n          <xul:description class=\"downloadDetails downloadOpenFile\"\n                           crop=\"end\"\n                           value=\"FROM-DTD-openFile-label\"/>\n          <xul:description class=\"downloadDetails downloadShowMoreInfo\"\n                           crop=\"end\"\n                           value=\"FROM-DTD-showMoreInformation-label\"/>\n          <xul:stack class=\"downloadButtonLabels\">\n            <xul:description class=\"downloadDetails downloadShow\"\n                             crop=\"end\"\n\n                             value=\"FROM-DTD-cmd-show-label\"\n\n                             />\n            <xul:description class=\"downloadDetails downloadCancel\"\n                             crop=\"end\"\n                             value=\"FROM-DTD-cancelDownload-label\"/>\n            <xul:description class=\"downloadDetails downloadRetry\"\n                             crop=\"end\"\n                             value=\"FROM-DTD-retryDownload-label\"/>\n          </xul:stack>\n        </xul:vbox>\n      </xul:hbox>\n      <xul:toolbarseparator />\n      <xul:stack class=\"downloadButtonArea\">\n        <xul:button class=\"downloadButton downloadCancel downloadIconCancel\"\n                    tooltiptext=\"FROM-DTD-cmd-cancel-label\"\n                    oncommand=\"DownloadsView.onDownloadCommand(event, 'downloadsCmd_cancel');\"/>\n        <xul:button class=\"downloadButton downloadRetry downloadIconRetry\"\n                    tooltiptext=\"FROM-DTD-cmd-retry-label\"\n                    oncommand=\"DownloadsView.onDownloadCommand(event, 'downloadsCmd_retry');\"/>\n        <xul:button class=\"downloadButton downloadShow downloadIconShow\"\n\n                    tooltiptext=\"FROM-DTD-cmd-show-label\"\n\n                    oncommand=\"DownloadsView.onDownloadCommand(event, 'downloadsCmd_show');\"/>\n        <xul:button class=\"downloadButton downloadConfirmBlock downloadIconCancel\"\n                    tooltiptext=\"FROM-DTD-cmd-removeFile-label\"\n                    oncommand=\"DownloadsView.onDownloadCommand(event, 'downloadsCmd_confirmBlock');\"/>\n        <xul:button class=\"downloadButton downloadChooseUnblock downloadIconShow\"\n                    tooltiptext=\"FROM-DTD-cmd-chooseUnblock-label\"\n                    oncommand=\"DownloadsView.onDownloadCommand(event, 'downloadsCmd_chooseUnblock');\"/>\n        <xul:button class=\"downloadButton downloadChooseOpen downloadIconShow\"\n                    tooltiptext=\"FROM-DTD-cmd-chooseOpen-label\"\n                    oncommand=\"DownloadsView.onDownloadCommand(event, 'downloadsCmd_chooseOpen');\"/>\n        <xul:button class=\"downloadButton downloadShowBlockedInfo\"\n                    tooltiptext=\"FROM-DTD-cmd-chooseUnblock-label\"\n                    oncommand=\"DownloadsView.onDownloadCommand(event, 'downloadsCmd_showBlockedInfo');\"/>\n      </xul:stack>\n    </content>\n  </binding>\n\n  <binding id=\"download-toolbarbutton\"\n           extends=\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton-badged\">\n    <content>\n      <xul:stack class=\"toolbarbutton-badge-stack\">\n        <children />\n        <xul:image class=\"toolbarbutton-icon\" xbl:inherits=\"validate,src=image,label,consumeanchor\"/>\n        <xul:label class=\"toolbarbutton-badge\" xbl:inherits=\"value=badge\" top=\"0\" end=\"0\" crop=\"none\"/>\n      </xul:stack>\n      <xul:label class=\"toolbarbutton-text\" crop=\"right\" flex=\"1\"\n                 xbl:inherits=\"value=label,accesskey,crop,wrap\"/>\n      <xul:label class=\"toolbarbutton-multiline-text\" flex=\"1\"\n                 xbl:inherits=\"xbl:text=label,accesskey,wrap\"/>\n    </content>\n  </binding>\n\n  <binding id=\"download-subview-toolbarbutton\"\n           extends=\"chrome://global/content/bindings/button.xml#menu-button-base\">\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:image class=\"toolbarbutton-icon\" xbl:inherits=\"validate,src=image,label,consumeanchor\"/>\n      <xul:vbox class=\"toolbarbutton-text\" flex=\"1\">\n        <xul:label crop=\"end\" xbl:inherits=\"value=label,accesskey,crop,wrap\"/>\n        <xul:label class=\"status-text status-full\" crop=\"end\" xbl:inherits=\"value=fullStatus\"/>\n        <xul:label class=\"status-text status-open\" crop=\"end\" xbl:inherits=\"value=openLabel\"/>\n        <xul:label class=\"status-text status-retry\" crop=\"end\" xbl:inherits=\"value=retryLabel\"/>\n        <xul:label class=\"status-text status-show\" crop=\"end\" xbl:inherits=\"value=showLabel\"/>\n      </xul:vbox>\n      <xul:toolbarbutton anonid=\"button\" class=\"action-button\"/>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"menu.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"placesMenuBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"places-popup-base\"\n           extends=\"chrome://global/content/bindings/popup.xml#popup\">\n    <content>\n      <xul:hbox flex=\"1\">\n        <xul:vbox class=\"menupopup-drop-indicator-bar\" hidden=\"true\">\n          <xul:image class=\"menupopup-drop-indicator\" mousethrough=\"always\"/>\n        </xul:vbox>\n        <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                            smoothscroll=\"false\">\n          <children/>\n        </xul:arrowscrollbox>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n\n      <field name=\"AppConstants\" readonly=\"true\">\n        (Components.utils.import(\"resource://gre/modules/AppConstants.jsm\", {})).AppConstants;\n      </field>\n\n      <field name=\"_indicatorBar\">\n        document.getAnonymousElementByAttribute(this, \"class\",\n                                                \"menupopup-drop-indicator-bar\");\n      </field>\n\n      <field name=\"_scrollBox\">\n        document.getAnonymousElementByAttribute(this, \"class\",\n                                                \"popup-internal-box\");\n      </field>\n\n      <!-- This is the view that manage the popup -->\n      <field name=\"_rootView\">PlacesUIUtils.getViewForNode(this);</field>\n\n      <!-- Check if we should hide the drop indicator for the target -->\n      <method name=\"_hideDropIndicator\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let target = aEvent.target;\n\n          // Don't draw the drop indicator outside of markers or if current\n          // node is not a Places node.\n          let betweenMarkers =\n            (this._startMarker.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_FOLLOWING) &&\n            (this._endMarker.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_PRECEDING);\n\n          // Hide the dropmarker if current node is not a Places node.\n          return !(target && target._placesNode && betweenMarkers);\n        ]]></body>\n      </method>\n\n      <!-- This function returns information about where to drop when\n           dragging over this popup insertion point -->\n      <method name=\"_getDropPoint\">\n        <parameter name=\"aEvent\"/>\n          <body><![CDATA[\n            // Can't drop if the menu isn't a folder\n            let resultNode = this._placesNode;\n\n            if (!PlacesUtils.nodeIsFolder(resultNode) ||\n                PlacesControllerDragHelper.disallowInsertion(resultNode, this._rootView)) {\n              return null;\n            }\n\n            var dropPoint = { ip: null, folderElt: null };\n\n            // The element we are dragging over\n            let elt = aEvent.target;\n            if (elt.localName == \"menupopup\")\n              elt = elt.parentNode;\n\n            // Calculate positions taking care of arrowscrollbox\n            let scrollbox = this._scrollBox;\n            let eventY = aEvent.layerY + (scrollbox.boxObject.y - this.boxObject.y);\n            let scrollboxOffset = scrollbox.scrollBoxObject.y -\n                                  (scrollbox.boxObject.y - this.boxObject.y);\n            let eltY = elt.boxObject.y - scrollboxOffset;\n            let eltHeight = elt.boxObject.height;\n\n            if (!elt._placesNode) {\n              // If we are dragging over a non places node drop at the end.\n              dropPoint.ip = new InsertionPoint({\n                parentId: PlacesUtils.getConcreteItemId(resultNode),\n                parentGuid: PlacesUtils.getConcreteItemGuid(resultNode)\n              });\n              // We can set folderElt if we are dropping over a static menu that\n              // has an internal placespopup.\n              let isMenu = elt.localName == \"menu\" ||\n                 (elt.localName == \"toolbarbutton\" &&\n                  elt.getAttribute(\"type\") == \"menu\");\n              if (isMenu && elt.lastChild &&\n                  elt.lastChild.hasAttribute(\"placespopup\"))\n                dropPoint.folderElt = elt;\n              return dropPoint;\n            }\n\n            let tagName = PlacesUtils.nodeIsTagQuery(elt._placesNode) ?\n                            elt._placesNode.title : null;\n            if ((PlacesUtils.nodeIsFolder(elt._placesNode) &&\n                 !PlacesUIUtils.isFolderReadOnly(elt._placesNode, this._rootView)) ||\n                PlacesUtils.nodeIsTagQuery(elt._placesNode)) {\n              // This is a folder or a tag container.\n              if (eventY - eltY < eltHeight * 0.20) {\n                // If mouse is in the top part of the element, drop above folder.\n                dropPoint.ip = new InsertionPoint({\n                  parentId: PlacesUtils.getConcreteItemId(resultNode),\n                  parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n                  orientation: Ci.nsITreeView.DROP_BEFORE,\n                  tagName,\n                  dropNearNode: elt._placesNode\n                });\n                return dropPoint;\n              } else if (eventY - eltY < eltHeight * 0.80) {\n                // If mouse is in the middle of the element, drop inside folder.\n                dropPoint.ip = new InsertionPoint({\n                  parentId: PlacesUtils.getConcreteItemId(elt._placesNode),\n                  parentGuid: PlacesUtils.getConcreteItemGuid(elt._placesNode),\n                  tagName\n                });\n                dropPoint.folderElt = elt;\n                return dropPoint;\n              }\n            } else if (eventY - eltY <= eltHeight / 2) {\n              // This is a non-folder node or a readonly folder.\n              // If the mouse is above the middle, drop above this item.\n              dropPoint.ip = new InsertionPoint({\n                parentId: PlacesUtils.getConcreteItemId(resultNode),\n                parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n                orientation: Ci.nsITreeView.DROP_BEFORE,\n                tagName,\n                dropNearNode: elt._placesNode\n              });\n              return dropPoint;\n            }\n\n            // Drop below the item.\n            dropPoint.ip = new InsertionPoint({\n              parentId: PlacesUtils.getConcreteItemId(resultNode),\n              parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n              orientation: Ci.nsITreeView.DROP_AFTER,\n              tagName,\n              dropNearNode: elt._placesNode,\n            });\n            return dropPoint;\n        ]]></body>\n      </method>\n\n      <!-- Sub-menus should be opened when the mouse drags over them, and closed\n           when the mouse drags off.  The overFolder object manages opening and\n           closing of folders when the mouse hovers. -->\n      <field name=\"_overFolder\"><![CDATA[({\n        _self: this,\n        _folder: {elt: null,\n                  openTimer: null,\n                  hoverTime: 350,\n                  closeTimer: null},\n        _closeMenuTimer: null,\n\n        get elt() {\n          return this._folder.elt;\n        },\n        set elt(val) {\n          return this._folder.elt = val;\n        },\n\n        get openTimer() {\n          return this._folder.openTimer;\n        },\n        set openTimer(val) {\n          return this._folder.openTimer = val;\n        },\n\n        get hoverTime() {\n          return this._folder.hoverTime;\n        },\n        set hoverTime(val) {\n          return this._folder.hoverTime = val;\n        },\n\n        get closeTimer() {\n          return this._folder.closeTimer;\n        },\n        set closeTimer(val) {\n          return this._folder.closeTimer = val;\n        },\n\n        get closeMenuTimer() {\n          return this._closeMenuTimer;\n        },\n        set closeMenuTimer(val) {\n          return this._closeMenuTimer = val;\n        },\n\n        setTimer: function OF__setTimer(aTime) {\n          var timer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n          timer.initWithCallback(this, aTime, timer.TYPE_ONE_SHOT);\n          return timer;\n        },\n\n        notify: function OF__notify(aTimer) {\n          // Function to process all timer notifications.\n\n          if (aTimer == this._folder.openTimer) {\n            // Timer to open a submenu that's being dragged over.\n            this._folder.elt.lastChild.setAttribute(\"autoopened\", \"true\");\n            this._folder.elt.lastChild.showPopup(this._folder.elt);\n            this._folder.openTimer = null;\n          } else if (aTimer == this._folder.closeTimer) {\n            // Timer to close a submenu that's been dragged off of.\n            // Only close the submenu if the mouse isn't being dragged over any\n            // of its child menus.\n            var draggingOverChild = PlacesControllerDragHelper\n                                    .draggingOverChildNode(this._folder.elt);\n            if (draggingOverChild)\n              this._folder.elt = null;\n            this.clear();\n\n            // Close any parent folders which aren't being dragged over.\n            // (This is necessary because of the above code that keeps a folder\n            // open while its children are being dragged over.)\n            if (!draggingOverChild)\n              this.closeParentMenus();\n          } else if (aTimer == this.closeMenuTimer) {\n            // Timer to close this menu after the drag exit.\n            var popup = this._self;\n            // if we are no more dragging we can leave the menu open to allow\n            // for better D&D bookmark organization\n            if (PlacesControllerDragHelper.getSession() &&\n                !PlacesControllerDragHelper.draggingOverChildNode(popup.parentNode)) {\n              popup.hidePopup();\n              // Close any parent menus that aren't being dragged over;\n              // otherwise they'll stay open because they couldn't close\n              // while this menu was being dragged over.\n              this.closeParentMenus();\n            }\n            this._closeMenuTimer = null;\n          }\n        },\n\n        //  Helper function to close all parent menus of this menu,\n        //  as long as none of the parent's children are currently being\n        //  dragged over.\n        closeParentMenus: function OF__closeParentMenus() {\n          var popup = this._self;\n          var parent = popup.parentNode;\n          while (parent) {\n            if (parent.localName == \"menupopup\" && parent._placesNode) {\n              if (PlacesControllerDragHelper.draggingOverChildNode(parent.parentNode))\n                break;\n              parent.hidePopup();\n            }\n            parent = parent.parentNode;\n          }\n        },\n\n        //  The mouse is no longer dragging over the stored menubutton.\n        //  Close the menubutton, clear out drag styles, and clear all\n        //  timers for opening/closing it.\n        clear: function OF__clear() {\n          if (this._folder.elt && this._folder.elt.lastChild) {\n            if (!this._folder.elt.lastChild.hasAttribute(\"dragover\"))\n              this._folder.elt.lastChild.hidePopup();\n            // remove menuactive style\n            this._folder.elt.removeAttribute(\"_moz-menuactive\");\n            this._folder.elt = null;\n          }\n          if (this._folder.openTimer) {\n            this._folder.openTimer.cancel();\n            this._folder.openTimer = null;\n          }\n          if (this._folder.closeTimer) {\n            this._folder.closeTimer.cancel();\n            this._folder.closeTimer = null;\n          }\n        }\n      })]]></field>\n\n      <method name=\"_cleanupDragDetails\">\n        <body><![CDATA[\n          // Called on dragend and drop.\n          PlacesControllerDragHelper.currentDropTarget = null;\n          this._rootView._draggedElt = null;\n          this.removeAttribute(\"dragover\");\n          this.removeAttribute(\"dragstart\");\n          this._indicatorBar.hidden = true;\n        ]]></body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"DOMMenuItemActive\"><![CDATA[\n        let elt = event.target;\n        if (elt.parentNode != this)\n          return;\n\n        if (this.AppConstants.platform === \"macosx\") {\n          // XXX: The following check is a temporary hack until bug 420033 is\n          // resolved.\n          let parentElt = elt.parent;\n          while (parentElt) {\n            if (parentElt.id == \"bookmarksMenuPopup\" ||\n                parentElt.id == \"goPopup\")\n              return;\n\n            parentElt = parentElt.parentNode;\n          }\n        }\n\n        if (window.XULBrowserWindow) {\n          let placesNode = elt._placesNode;\n\n          var linkURI;\n          if (placesNode && PlacesUtils.nodeIsURI(placesNode))\n            linkURI = placesNode.uri;\n          else if (elt.hasAttribute(\"targetURI\"))\n            linkURI = elt.getAttribute(\"targetURI\");\n\n          if (linkURI)\n            window.XULBrowserWindow.setOverLink(linkURI, null);\n        }\n      ]]></handler>\n\n      <handler event=\"DOMMenuItemInactive\"><![CDATA[\n        let elt = event.target;\n        if (elt.parentNode != this)\n          return;\n\n        if (window.XULBrowserWindow)\n          window.XULBrowserWindow.setOverLink(\"\", null);\n      ]]></handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        let elt = event.target;\n        if (!elt._placesNode)\n          return;\n\n        let draggedElt = elt._placesNode;\n\n        // Force a copy action if parent node is a query or we are dragging a\n        // not-removable node.\n        if (!PlacesControllerDragHelper.canMoveNode(draggedElt, this._rootView, elt))\n          event.dataTransfer.effectAllowed = \"copyLink\";\n\n        // Activate the view and cache the dragged element.\n        this._rootView._draggedElt = draggedElt;\n        this._rootView.controller.setDataTransfer(event);\n        this.setAttribute(\"dragstart\", \"true\");\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"drop\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = event.target;\n\n        let dropPoint = this._getDropPoint(event);\n        if (dropPoint && dropPoint.ip) {\n          PlacesControllerDragHelper.onDrop(dropPoint.ip, event.dataTransfer)\n                                    .catch(Components.utils.reportError);\n          event.preventDefault();\n        }\n\n        this._cleanupDragDetails();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = event.target;\n        let dt = event.dataTransfer;\n\n        let dropPoint = this._getDropPoint(event);\n        if (!dropPoint || !dropPoint.ip ||\n            !PlacesControllerDragHelper.canDrop(dropPoint.ip, dt)) {\n          this._indicatorBar.hidden = true;\n          event.stopPropagation();\n          return;\n        }\n\n        // Mark this popup as being dragged over.\n        this.setAttribute(\"dragover\", \"true\");\n\n        if (dropPoint.folderElt) {\n          // We are dragging over a folder.\n          // _overFolder should take the care of opening it on a timer.\n          if (this._overFolder.elt &&\n              this._overFolder.elt != dropPoint.folderElt) {\n            // We are dragging over a new folder, let's clear old values\n            this._overFolder.clear();\n          }\n          if (!this._overFolder.elt) {\n            this._overFolder.elt = dropPoint.folderElt;\n            // Create the timer to open this folder.\n            this._overFolder.openTimer = this._overFolder\n                                             .setTimer(this._overFolder.hoverTime);\n          }\n          // Since we are dropping into a folder set the corresponding style.\n          dropPoint.folderElt.setAttribute(\"_moz-menuactive\", true);\n        } else {\n          // We are not dragging over a folder.\n          // Clear out old _overFolder information.\n          this._overFolder.clear();\n        }\n\n        // Autoscroll the popup strip if we drag over the scroll buttons.\n        let anonid = event.originalTarget.getAttribute(\"anonid\");\n        let scrollDir = 0;\n        if (anonid == \"scrollbutton-up\") {\n          scrollDir = -1;\n        } else if (anonid == \"scrollbutton-down\") {\n          scrollDir = 1;\n        }\n        if (scrollDir != 0) {\n          this._scrollBox.scrollByIndex(scrollDir, true);\n        }\n\n        // Check if we should hide the drop indicator for this target.\n        if (dropPoint.folderElt || this._hideDropIndicator(event)) {\n          this._indicatorBar.hidden = true;\n          event.preventDefault();\n          event.stopPropagation();\n          return;\n        }\n\n        // We should display the drop indicator relative to the arrowscrollbox.\n        let sbo = this._scrollBox.scrollBoxObject;\n        let newMarginTop = 0;\n        if (scrollDir == 0) {\n          let elt = this.firstChild;\n          while (elt && event.screenY > elt.boxObject.screenY +\n                                        elt.boxObject.height / 2)\n            elt = elt.nextSibling;\n          newMarginTop = elt ? elt.boxObject.screenY - sbo.screenY :\n                               sbo.height;\n        } else if (scrollDir == 1)\n          newMarginTop = sbo.height;\n\n        // Set the new marginTop based on arrowscrollbox.\n        newMarginTop += sbo.y - this._scrollBox.boxObject.y;\n        this._indicatorBar.firstChild.style.marginTop = newMarginTop + \"px\";\n        this._indicatorBar.hidden = false;\n\n        event.preventDefault();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragexit\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = null;\n        this.removeAttribute(\"dragover\");\n\n        // If we have not moved to a valid new target clear the drop indicator\n        // this happens when moving out of the popup.\n        let target = event.relatedTarget;\n        if (!target || !this.contains(target))\n          this._indicatorBar.hidden = true;\n\n        // Close any folder being hovered over\n        if (this._overFolder.elt) {\n          this._overFolder.closeTimer = this._overFolder\n                                            .setTimer(this._overFolder.hoverTime);\n        }\n\n        // The autoopened attribute is set when this folder was automatically\n        // opened after the user dragged over it.  If this attribute is set,\n        // auto-close the folder on drag exit.\n        // We should also try to close this popup if the drag has started\n        // from here, the timer will check if we are dragging over a child.\n        if (this.hasAttribute(\"autoopened\") ||\n            this.hasAttribute(\"dragstart\")) {\n          this._overFolder.closeMenuTimer = this._overFolder\n                                                .setTimer(this._overFolder.hoverTime);\n        }\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragend\"><![CDATA[\n        this._cleanupDragDetails();\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n  <!-- Most of this is copied from the arrowpanel binding in popup.xml -->\n  <binding id=\"places-popup-arrow\"\n           extends=\"chrome://browser/content/places/menu.xml#places-popup-base\">\n    <content flip=\"both\" side=\"top\" position=\"bottomcenter topright\">\n      <xul:vbox anonid=\"container\" class=\"panel-arrowcontainer\" flex=\"1\"\n               xbl:inherits=\"side,panelopen\">\n        <xul:box anonid=\"arrowbox\" class=\"panel-arrowbox\">\n          <xul:image anonid=\"arrow\" class=\"panel-arrow\" xbl:inherits=\"side\"/>\n        </xul:box>\n        <xul:box class=\"panel-arrowcontent\" xbl:inherits=\"side,align,dir,orient,pack\" flex=\"1\">\n          <xul:vbox class=\"menupopup-drop-indicator-bar\" hidden=\"true\">\n            <xul:image class=\"menupopup-drop-indicator\" mousethrough=\"always\"/>\n          </xul:vbox>\n          <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                              smoothscroll=\"false\">\n            <children/>\n          </xul:arrowscrollbox>\n        </xul:box>\n      </xul:vbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this.style.pointerEvents = \"none\";\n      ]]></constructor>\n      <method name=\"adjustArrowPosition\">\n        <body><![CDATA[\n          var arrow = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrow\");\n\n          var anchor = this.anchorNode;\n          if (!anchor) {\n            arrow.hidden = true;\n            return;\n          }\n\n          var container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n          var arrowbox = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\");\n\n          var position = this.alignmentPosition;\n          var offset = this.alignmentOffset;\n\n          this.setAttribute(\"arrowposition\", position);\n\n          // if this panel has a \"sliding\" arrow, we may have previously set margins...\n          arrowbox.style.removeProperty(\"transform\");\n          if (position.indexOf(\"start_\") == 0 || position.indexOf(\"end_\") == 0) {\n            container.orient = \"horizontal\";\n            arrowbox.orient = \"vertical\";\n            if (position.indexOf(\"_after\") > 0) {\n              arrowbox.pack = \"end\";\n            } else {\n              arrowbox.pack = \"start\";\n            }\n            arrowbox.style.transform = \"translate(0, \" + -offset + \"px)\";\n\n            // The assigned side stays the same regardless of direction.\n            var isRTL = (window.getComputedStyle(this).direction == \"rtl\");\n\n            if (position.indexOf(\"start_\") == 0) {\n              container.dir = \"reverse\";\n              this.setAttribute(\"side\", isRTL ? \"left\" : \"right\");\n            } else {\n              container.dir = \"\";\n              this.setAttribute(\"side\", isRTL ? \"right\" : \"left\");\n            }\n          } else if (position.indexOf(\"before_\") == 0 || position.indexOf(\"after_\") == 0) {\n            container.orient = \"\";\n            arrowbox.orient = \"\";\n            if (position.indexOf(\"_end\") > 0) {\n              arrowbox.pack = \"end\";\n            } else {\n              arrowbox.pack = \"start\";\n            }\n            arrowbox.style.transform = \"translate(\" + -offset + \"px, 0)\";\n\n            if (position.indexOf(\"before_\") == 0) {\n              container.dir = \"reverse\";\n              this.setAttribute(\"side\", \"bottom\");\n            } else {\n              container.dir = \"\";\n              this.setAttribute(\"side\", \"top\");\n            }\n          }\n\n          arrow.hidden = false;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\"><![CDATA[\n        this.adjustArrowPosition();\n        this.setAttribute(\"animate\", \"open\");\n      ]]></handler>\n      <handler event=\"popupshown\" phase=\"target\"><![CDATA[\n        this.setAttribute(\"panelopen\", \"true\");\n        let disablePointerEvents;\n        if (!this.hasAttribute(\"disablepointereventsfortransition\")) {\n          let container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n          let cs = getComputedStyle(container);\n          let transitionProp = cs.transitionProperty;\n          let transitionTime = parseFloat(cs.transitionDuration);\n          disablePointerEvents = (transitionProp.includes(\"transform\") ||\n                                  transitionProp == \"all\") &&\n                                 transitionTime > 0;\n          this.setAttribute(\"disablepointereventsfortransition\", disablePointerEvents);\n        } else {\n          disablePointerEvents = this.getAttribute(\"disablepointereventsfortransition\") == \"true\";\n        }\n        if (!disablePointerEvents) {\n          this.style.removeProperty(\"pointer-events\");\n        }\n      ]]></handler>\n      <handler event=\"transitionend\"><![CDATA[\n        if (event.originalTarget.getAttribute(\"anonid\") == \"container\" &&\n            (event.propertyName == \"transform\" || event.propertyName == \"-moz-window-transform\")) {\n          this.style.removeProperty(\"pointer-events\");\n        }\n      ]]></handler>\n      <handler event=\"popuphiding\" phase=\"target\"><![CDATA[\n        this.setAttribute(\"animate\", \"cancel\");\n      ]]></handler>\n      <handler event=\"popuphidden\" phase=\"target\"><![CDATA[\n        this.removeAttribute(\"panelopen\");\n        if (this.getAttribute(\"disablepointereventsfortransition\") == \"true\") {\n          this.style.pointerEvents = \"none\";\n        }\n        this.removeAttribute(\"animate\");\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"tree.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"placesTreeBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"places-tree\" extends=\"chrome://global/content/bindings/tree.xml#tree\">\n    <implementation>\n      <constructor><![CDATA[\n        // Force an initial build.\n        if (this.place)\n          this.place = this.place;\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // Break the treeviewer->result->treeviewer cycle.\n        // Note: unsetting the result's viewer also unsets\n        // the viewer's reference to our treeBoxObject.\n        var result = this.result;\n        if (result) {\n          result.root.containerOpen = false;\n        }\n\n        // Unregister the controllber before unlinking the view, otherwise it\n        // may still try to update commands on a view with a null result.\n        if (this._controller) {\n          this._controller.terminate();\n          this.controllers.removeController(this._controller);\n        }\n\n        if (this.view) {\n          this.view.uninit();\n        }\n        this.view = null;\n      ]]></destructor>\n\n      <property name=\"controller\"\n                readonly=\"true\"\n                onget=\"return this._controller\"/>\n\n      <!-- overriding -->\n      <property name=\"view\">\n        <getter><![CDATA[\n          try {\n            return this.treeBoxObject.view.wrappedJSObject || null;\n          } catch (e) {\n            return null;\n          }\n        ]]></getter>\n        <setter><![CDATA[\n          return this.treeBoxObject.view = val;\n        ]]></setter>\n      </property>\n\n      <property name=\"associatedElement\"\n                readonly=\"true\"\n                onget=\"return this\"/>\n\n      <method name=\"applyFilter\">\n        <parameter name=\"filterString\"/>\n        <parameter name=\"folderRestrict\"/>\n        <parameter name=\"includeHidden\"/>\n        <body><![CDATA[\n          // preserve grouping\n          var queryNode = PlacesUtils.asQuery(this.result.root);\n          var options = queryNode.queryOptions.clone();\n\n          // Make sure we're getting uri results.\n          // We do not yet support searching into grouped queries or into\n          // tag containers, so we must fall to the default case.\n          if (PlacesUtils.nodeIsHistoryContainer(queryNode) ||\n              options.resultType == options.RESULTS_AS_TAG_QUERY ||\n              options.resultType == options.RESULTS_AS_TAG_CONTENTS)\n            options.resultType = options.RESULTS_AS_URI;\n\n          var query = PlacesUtils.history.getNewQuery();\n          query.searchTerms = filterString;\n\n          if (folderRestrict) {\n            query.setFolders(folderRestrict, folderRestrict.length);\n            options.queryType = options.QUERY_TYPE_BOOKMARKS;\n          }\n\n          options.includeHidden = !!includeHidden;\n\n          this.load([query], options);\n        ]]></body>\n      </method>\n\n      <method name=\"load\">\n        <parameter name=\"queries\"/>\n        <parameter name=\"options\"/>\n        <body><![CDATA[\n          let result = PlacesUtils.history\n                                  .executeQueries(queries, queries.length,\n                                                  options);\n          let callback;\n          if (this.flatList) {\n            let onOpenFlatContainer = this.onOpenFlatContainer;\n            if (onOpenFlatContainer)\n              callback = new Function(\"aContainer\", onOpenFlatContainer);\n          }\n\n          if (!this._controller) {\n            this._controller = new PlacesController(this);\n            this.controllers.appendController(this._controller);\n          }\n\n          let treeView = new PlacesTreeView(this.flatList, callback, this._controller);\n\n          // Observer removal is done within the view itself.  When the tree\n          // goes away, treeboxobject calls view.setTree(null), which then\n          // calls removeObserver.\n          result.addObserver(treeView);\n          this.view = treeView;\n\n          if (this.getAttribute(\"selectfirstnode\") == \"true\" && treeView.rowCount > 0) {\n            treeView.selection.select(0);\n          }\n\n          this._cachedInsertionPoint = undefined;\n        ]]></body>\n      </method>\n\n      <property name=\"flatList\">\n        <getter><![CDATA[\n          return this.getAttribute(\"flatList\") == \"true\";\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.flatList != val) {\n            this.setAttribute(\"flatList\", val);\n            // reload with the last place set\n            if (this.place)\n              this.place = this.place;\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"onOpenFlatContainer\">\n        <getter><![CDATA[\n          return this.getAttribute(\"onopenflatcontainer\");\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.onOpenFlatContainer != val) {\n            this.setAttribute(\"onopenflatcontainer\", val);\n            // reload with the last place set\n            if (this.place)\n              this.place = this.place;\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <!--\n        Causes a particular node represented by the specified placeURI to be\n        selected in the tree. All containers above the node in the hierarchy\n        will be opened, so that the node is visible.\n        -->\n      <method name=\"selectPlaceURI\">\n        <parameter name=\"placeURI\"/>\n        <body><![CDATA[\n          // Do nothing if a node matching the given uri is already selected\n          if (this.hasSelection && this.selectedNode.uri == placeURI)\n            return;\n\n          function findNode(container, nodesURIChecked) {\n            var containerURI = container.uri;\n            if (containerURI == placeURI)\n              return container;\n            if (nodesURIChecked.includes(containerURI))\n              return null;\n\n            // never check the contents of the same query\n            nodesURIChecked.push(containerURI);\n\n            var wasOpen = container.containerOpen;\n            if (!wasOpen)\n              container.containerOpen = true;\n            for (var i = 0; i < container.childCount; ++i) {\n              var child = container.getChild(i);\n              var childURI = child.uri;\n              if (childURI == placeURI)\n                return child;\n              else if (PlacesUtils.nodeIsContainer(child)) {\n                var nested = findNode(PlacesUtils.asContainer(child), nodesURIChecked);\n                if (nested)\n                  return nested;\n              }\n            }\n\n            if (!wasOpen)\n              container.containerOpen = false;\n\n            return null;\n          }\n\n          var container = this.result.root;\n          NS_ASSERT(container, \"No result, cannot select place URI!\");\n          if (!container)\n            return;\n\n          var child = findNode(container, []);\n          if (child)\n            this.selectNode(child);\n          else {\n            // If the specified child could not be located, clear the selection\n            var selection = this.view.selection;\n            selection.clearSelection();\n          }\n        ]]></body>\n      </method>\n\n      <!--\n        Causes a particular node to be selected in the tree, resulting in all\n        containers above the node in the hierarchy to be opened, so that the\n        node is visible.\n        -->\n      <method name=\"selectNode\">\n        <parameter name=\"node\"/>\n        <body><![CDATA[\n          var view = this.view;\n\n          var parent = node.parent;\n          if (parent && !parent.containerOpen) {\n            // Build a list of all of the nodes that are the parent of this one\n            // in the result.\n            var parents = [];\n            var root = this.result.root;\n            while (parent && parent != root) {\n              parents.push(parent);\n              parent = parent.parent;\n            }\n\n            // Walk the list backwards (opening from the root of the hierarchy)\n            // opening each folder as we go.\n            for (var i = parents.length - 1; i >= 0; --i) {\n              let index = view.treeIndexForNode(parents[i]);\n              if (index != Ci.nsINavHistoryResultTreeViewer.INDEX_INVISIBLE &&\n                  view.isContainer(index) && !view.isContainerOpen(index))\n                view.toggleOpenState(index);\n            }\n            // Select the specified node...\n          }\n\n          let index = view.treeIndexForNode(node);\n          if (index == Ci.nsINavHistoryResultTreeViewer.INDEX_INVISIBLE)\n            return;\n\n          view.selection.select(index);\n          // ... and ensure it's visible, not scrolled off somewhere.\n          this.treeBoxObject.ensureRowIsVisible(index);\n        ]]></body>\n      </method>\n\n      <!-- nsIPlacesView -->\n      <property name=\"result\">\n        <getter><![CDATA[\n          try {\n            return this.view.QueryInterface(Ci.nsINavHistoryResultObserver).result;\n          } catch (e) {\n            return null;\n          }\n        ]]></getter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"place\">\n        <getter><![CDATA[\n          return this.getAttribute(\"place\");\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"place\", val);\n\n          var queriesRef = { };\n          var queryCountRef = { };\n          var optionsRef = { };\n          PlacesUtils.history.queryStringToQueries(val, queriesRef, queryCountRef, optionsRef);\n          if (queryCountRef.value == 0)\n            queriesRef.value = [PlacesUtils.history.getNewQuery()];\n          if (!optionsRef.value)\n            optionsRef.value = PlacesUtils.history.getNewQueryOptions();\n\n          this.load(queriesRef.value, optionsRef.value);\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"hasSelection\">\n        <getter><![CDATA[\n          return this.view && this.view.selection.count >= 1;\n        ]]></getter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"selectedNodes\">\n        <getter><![CDATA[\n          let nodes = [];\n          if (!this.hasSelection)\n            return nodes;\n\n          let selection = this.view.selection;\n          let rc = selection.getRangeCount();\n          let resultview = this.view;\n          for (let i = 0; i < rc; ++i) {\n            let min = { }, max = { };\n            selection.getRangeAt(i, min, max);\n            for (let j = min.value; j <= max.value; ++j) {\n              nodes.push(resultview.nodeForTreeIndex(j));\n            }\n          }\n          return nodes;\n        ]]></getter>\n      </property>\n\n      <method name=\"toggleCutNode\">\n        <parameter name=\"aNode\"/>\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          this.view.toggleCutNode(aNode, aValue);\n        ]]></body>\n      </method>\n\n      <!-- nsIPlacesView -->\n      <property name=\"removableSelectionRanges\">\n        <getter><![CDATA[\n          // This property exists in addition to selectedNodes because it\n          // encodes selection ranges (which only occur in list views) into\n          // the return value. For each removed range, the index at which items\n          // will be re-inserted upon the remove transaction being performed is\n          // the first index of the range, so that the view updates correctly.\n          //\n          // For example, if we remove rows 2,3,4 and 7,8 from a list, when we\n          // undo that operation, if we insert what was at row 3 at row 3 again,\n          // it will show up _after_ the item that was at row 5. So we need to\n          // insert all items at row 2, and the tree view will update correctly.\n          //\n          // Also, this function collapses the selection to remove redundant\n          // data, e.g. when deleting this selection:\n          //\n          //      http://www.foo.com/\n          //  (-) Some Folder\n          //        http://www.bar.com/\n          //\n          // ... returning http://www.bar.com/ as part of the selection is\n          // redundant because it is implied by removing \"Some Folder\". We\n          // filter out all such redundancies since some partial amount of\n          // the folder's children may be selected.\n          //\n          let nodes = [];\n          if (!this.hasSelection)\n            return nodes;\n\n          var selection = this.view.selection;\n          var rc = selection.getRangeCount();\n          var resultview = this.view;\n          // This list is kept independently of the range selected (i.e. OUTSIDE\n          // the for loop) since the row index of a container is unique for the\n          // entire view, and we could have some really wacky selection and we\n          // don't want to blow up.\n          var containers = { };\n          for (var i = 0; i < rc; ++i) {\n            var range = [];\n            var min = { }, max = { };\n            selection.getRangeAt(i, min, max);\n\n            for (var j = min.value; j <= max.value; ++j) {\n              if (this.view.isContainer(j))\n                containers[j] = true;\n              if (!(this.view.getParentIndex(j) in containers))\n                range.push(resultview.nodeForTreeIndex(j));\n            }\n            nodes.push(range);\n          }\n          return nodes;\n        ]]></getter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"draggableSelection\"\n                onget=\"return this.selectedNodes\"/>\n\n      <!-- nsIPlacesView -->\n      <property name=\"selectedNode\">\n        <getter><![CDATA[\n          var view = this.view;\n          if (!view || view.selection.count != 1)\n            return null;\n\n          var selection = view.selection;\n          var min = { }, max = { };\n          selection.getRangeAt(0, min, max);\n\n          return this.view.nodeForTreeIndex(min.value);\n        ]]></getter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"insertionPoint\">\n        <getter><![CDATA[\n          // invalidated on selection and focus changes\n          if (this._cachedInsertionPoint !== undefined)\n            return this._cachedInsertionPoint;\n\n          // there is no insertion point for history queries\n          // so bail out now and save a lot of work when updating commands\n          var resultNode = this.result.root;\n          if (PlacesUtils.nodeIsQuery(resultNode) &&\n              PlacesUtils.asQuery(resultNode).queryOptions.queryType ==\n                Ci.nsINavHistoryQueryOptions.QUERY_TYPE_HISTORY)\n              return this._cachedInsertionPoint = null;\n\n          var orientation = Ci.nsITreeView.DROP_BEFORE;\n          // If there is no selection, insert at the end of the container.\n          if (!this.hasSelection) {\n            var index = this.view.rowCount - 1;\n            this._cachedInsertionPoint =\n              this._getInsertionPoint(index, orientation);\n            return this._cachedInsertionPoint;\n          }\n\n          // This is a two-part process. The first part is determining the drop\n          // orientation.\n          // * The default orientation is to drop _before_ the selected item.\n          // * If the selected item is a container, the default orientation\n          //   is to drop _into_ that container.\n          //\n          // Warning: It may be tempting to use tree indexes in this code, but\n          //          you must not, since the tree is nested and as your tree\n          //          index may change when folders before you are opened and\n          //          closed. You must convert your tree index to a node, and\n          //          then use getChildIndex to find your absolute index in\n          //          the parent container instead.\n          //\n          var resultView = this.view;\n          var selection = resultView.selection;\n          var rc = selection.getRangeCount();\n          var min = { }, max = { };\n          selection.getRangeAt(rc - 1, min, max);\n\n          // If the sole selection is a container, and we are not in\n          // a flatlist, insert into it.\n          // Note that this only applies to _single_ selections,\n          // if the last element within a multi-selection is a\n          // container, insert _adjacent_ to the selection.\n          //\n          // If the sole selection is the bookmarks toolbar folder, we insert\n          // into it even if it is not opened\n          if (selection.count == 1 && resultView.isContainer(max.value) &&\n              !this.flatList)\n            orientation = Ci.nsITreeView.DROP_ON;\n\n          this._cachedInsertionPoint =\n            this._getInsertionPoint(max.value, orientation);\n          return this._cachedInsertionPoint;\n        ]]></getter>\n      </property>\n\n      <method name=\"_getInsertionPoint\">\n        <parameter name=\"index\"/>\n        <parameter name=\"orientation\"/>\n        <body><![CDATA[\n          var result = this.result;\n          var resultview = this.view;\n          var container = result.root;\n          var dropNearNode = null;\n          NS_ASSERT(container, \"null container\");\n          // When there's no selection, assume the container is the container\n          // the view is populated from (i.e. the result's itemId).\n          if (index != -1) {\n            var lastSelected = resultview.nodeForTreeIndex(index);\n            if (resultview.isContainer(index) && orientation == Ci.nsITreeView.DROP_ON) {\n              // If the last selected item is an open container, append _into_\n              // it, rather than insert adjacent to it.\n              container = lastSelected;\n              index = -1;\n            } else if (lastSelected.containerOpen &&\n                       orientation == Ci.nsITreeView.DROP_AFTER &&\n                       lastSelected.hasChildren) {\n             // If the last selected item is an open container and the user is\n             // trying to drag into it as a first item, really insert into it.\n             container = lastSelected;\n             orientation = Ci.nsITreeView.DROP_ON;\n             index = 0;\n            } else {\n              // Use the last-selected node's container.\n              container = lastSelected.parent;\n\n              // See comment in the treeView.js's copy of this method\n              if (!container || !container.containerOpen)\n                return null;\n\n              // Avoid the potentially expensive call to getChildIndex\n              // if we know this container doesn't allow insertion\n              if (PlacesControllerDragHelper.disallowInsertion(container, this))\n                return null;\n\n              var queryOptions = PlacesUtils.asQuery(result.root).queryOptions;\n              if (queryOptions.sortingMode !=\n                    Ci.nsINavHistoryQueryOptions.SORT_BY_NONE) {\n                // If we are within a sorted view, insert at the end\n                index = -1;\n              } else if (queryOptions.excludeItems ||\n                         queryOptions.excludeQueries ||\n                         queryOptions.excludeReadOnlyFolders) {\n                // Some item may be invisible, insert near last selected one.\n                // We don't replace index here to avoid requests to the db,\n                // instead it will be calculated later by the controller.\n                index = -1;\n                dropNearNode = lastSelected;\n              } else {\n                var lsi = container.getChildIndex(lastSelected);\n                index = orientation == Ci.nsITreeView.DROP_BEFORE ? lsi : lsi + 1;\n              }\n            }\n          }\n\n          if (PlacesControllerDragHelper.disallowInsertion(container, this))\n            return null;\n\n          // TODO (Bug 1160193): properly support dropping on a tag root.\n          let tagName = null;\n          if (PlacesUtils.nodeIsTagQuery(container)) {\n            tagName = container.title;\n            if (!tagName)\n              return null;\n          }\n\n          return new InsertionPoint({\n            parentId: PlacesUtils.getConcreteItemId(container),\n            parentGuid: PlacesUtils.getConcreteItemGuid(container),\n            index, orientation, tagName, dropNearNode\n          });\n        ]]></body>\n      </method>\n\n      <!-- nsIPlacesView -->\n      <method name=\"selectAll\">\n        <body><![CDATA[\n          this.view.selection.selectAll();\n        ]]></body>\n      </method>\n\n      <!-- This method will select the first node in the tree that matches\n           each given item id. It will open any folder nodes that it needs\n           to in order to show the selected items.\n      -->\n      <method name=\"selectItems\">\n        <parameter name=\"aIDs\"/>\n        <parameter name=\"aOpenContainers\"/>\n        <body><![CDATA[\n          // Never open containers in flat lists.\n          if (this.flatList)\n            aOpenContainers = false;\n          // By default, we do search and select within containers which were\n          // closed (note that containers in which nodes were not found are\n          // closed).\n          if (aOpenContainers === undefined)\n            aOpenContainers = true;\n\n          var ids = aIDs; // don't manipulate the caller's array\n\n          // Array of nodes found by findNodes which are to be selected\n          var nodes = [];\n\n          // Array of nodes found by findNodes which should be opened\n          var nodesToOpen = [];\n\n          // A set of GUIDs of container-nodes that were previously searched,\n          // and thus shouldn't be searched again. This is empty at the initial\n          // start of the recursion and gets filled in as the recursion\n          // progresses.\n          var checkedGuidsSet = new Set();\n\n          /**\n           * Recursively search through a node's children for items\n           * with the given IDs. When a matching item is found, remove its ID\n           * from the IDs array, and add the found node to the nodes dictionary.\n           *\n           * NOTE: This method will leave open any node that had matching items\n           * in its subtree.\n           */\n          function findNodes(node) {\n            var foundOne = false;\n            // See if node matches an ID we wanted; add to results.\n            // For simple folder queries, check both itemId and the concrete\n            // item id.\n            var index = ids.indexOf(node.itemId);\n            if (index == -1 &&\n                node.type == Ci.nsINavHistoryResultNode.RESULT_TYPE_FOLDER_SHORTCUT)\n              index = ids.indexOf(PlacesUtils.asQuery(node).folderItemId);\n\n            if (index != -1) {\n              nodes.push(node);\n              foundOne = true;\n              ids.splice(index, 1);\n            }\n\n            var concreteGuid = PlacesUtils.getConcreteItemGuid(node);\n            if (ids.length == 0 || !PlacesUtils.nodeIsContainer(node) ||\n                checkedGuidsSet.has(concreteGuid))\n              return foundOne;\n\n            // Only follow a query if it has been been explicitly opened by the caller.\n            let shouldOpen = aOpenContainers && PlacesUtils.nodeIsFolder(node);\n            PlacesUtils.asContainer(node);\n            if (!node.containerOpen && !shouldOpen)\n              return foundOne;\n\n            checkedGuidsSet.add(concreteGuid);\n\n            // Remember the beginning state so that we can re-close\n            // this node if we don't find any additional results here.\n            var previousOpenness = node.containerOpen;\n            node.containerOpen = true;\n            for (var child = 0; child < node.childCount && ids.length > 0; child++) {\n              var childNode = node.getChild(child);\n              var found = findNodes(childNode);\n              if (!foundOne)\n                foundOne = found;\n            }\n\n            // If we didn't find any additional matches in this node's\n            // subtree, revert the node to its previous openness.\n            if (foundOne)\n              nodesToOpen.unshift(node);\n            node.containerOpen = previousOpenness;\n            return foundOne;\n          }\n\n          // Disable notifications while looking for nodes.\n          let result = this.result;\n          let didSuppressNotifications = result.suppressNotifications;\n          if (!didSuppressNotifications)\n            result.suppressNotifications = true\n          try {\n            findNodes(this.result.root);\n          } finally {\n            if (!didSuppressNotifications)\n              result.suppressNotifications = false;\n          }\n\n          // For all the nodes we've found, highlight the corresponding\n          // index in the tree.\n          var resultview = this.view;\n          var selection = this.view.selection;\n          selection.selectEventsSuppressed = true;\n          selection.clearSelection();\n          // Open nodes containing found items\n          for (let i = 0; i < nodesToOpen.length; i++) {\n            nodesToOpen[i].containerOpen = true;\n          }\n          for (let i = 0; i < nodes.length; i++) {\n            var index = resultview.treeIndexForNode(nodes[i]);\n            if (index == Ci.nsINavHistoryResultTreeViewer.INDEX_INVISIBLE)\n              continue;\n            selection.rangedSelect(index, index, true);\n          }\n          selection.selectEventsSuppressed = false;\n        ]]></body>\n      </method>\n\n      <field name=\"_contextMenuShown\">false</field>\n\n      <method name=\"buildContextMenu\">\n        <parameter name=\"aPopup\"/>\n        <body><![CDATA[\n          this._contextMenuShown = true;\n          return this.controller.buildContextMenu(aPopup);\n        ]]></body>\n      </method>\n\n      <method name=\"destroyContextMenu\">\n        <parameter name=\"aPopup\"/>\n          this._contextMenuShown = false;\n        <body/>\n      </method>\n\n      <property name=\"ownerWindow\"\n                readonly=\"true\"\n                onget=\"return window;\"/>\n\n      <field name=\"_active\">true</field>\n      <property name=\"active\"\n                onget=\"return this._active\"\n                onset=\"return this._active = val\"/>\n\n    </implementation>\n    <handlers>\n      <handler event=\"focus\"><![CDATA[\n        this._cachedInsertionPoint = undefined;\n\n        // See select handler. We need the sidebar's places commandset to be\n        // updated as well\n        document.commandDispatcher.updateCommands(\"focus\");\n      ]]></handler>\n      <handler event=\"select\"><![CDATA[\n        this._cachedInsertionPoint = undefined;\n\n        // This additional complexity is here for the sidebars\n        var win = window;\n        while (true) {\n          win.document.commandDispatcher.updateCommands(\"focus\");\n          if (win == window.top)\n            break;\n\n          win = win.parent;\n        }\n      ]]></handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        if (event.target.localName != \"treechildren\")\n          return;\n\n        let nodes = this.selectedNodes;\n        for (let i = 0; i < nodes.length; i++) {\n          let node = nodes[i];\n\n          // Disallow dragging the root node of a tree.\n          if (!node.parent) {\n            event.preventDefault();\n            event.stopPropagation();\n            return;\n          }\n\n          // If this node is child of a readonly container (e.g. a livemark)\n          // or cannot be moved, we must force a copy.\n          if (!PlacesControllerDragHelper.canMoveNode(node, this)) {\n            event.dataTransfer.effectAllowed = \"copyLink\";\n            break;\n          }\n        }\n\n        this._controller.setDataTransfer(event);\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        if (event.target.localName != \"treechildren\")\n          return;\n\n        let cell = this.treeBoxObject.getCellAt(event.clientX, event.clientY);\n        let node = cell.row != -1 ?\n                   this.view.nodeForTreeIndex(cell.row) :\n                   this.result.root;\n        // cache the dropTarget for the view\n        PlacesControllerDragHelper.currentDropTarget = node;\n\n        // We have to calculate the orientation since view.canDrop will use\n        // it and we want to be consistent with the dropfeedback.\n        let tbo = this.treeBoxObject;\n        let rowHeight = tbo.rowHeight;\n        let eventY = event.clientY - tbo.treeBody.boxObject.y -\n                     rowHeight * (cell.row - tbo.getFirstVisibleRow());\n\n        let orientation = Ci.nsITreeView.DROP_BEFORE;\n\n        if (cell.row == -1) {\n          // If the row is not valid we try to insert inside the resultNode.\n          orientation = Ci.nsITreeView.DROP_ON;\n        } else if (PlacesUtils.nodeIsContainer(node) &&\n                 eventY > rowHeight * 0.75) {\n          // If we are below the 75% of a container the treeview we try\n          // to drop after the node.\n          orientation = Ci.nsITreeView.DROP_AFTER;\n        } else if (PlacesUtils.nodeIsContainer(node) &&\n                 eventY > rowHeight * 0.25) {\n          // If we are below the 25% of a container the treeview we try\n          // to drop inside the node.\n          orientation = Ci.nsITreeView.DROP_ON;\n        }\n\n        if (!this.view.canDrop(cell.row, orientation, event.dataTransfer))\n          return;\n\n        event.preventDefault();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragend\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = null;\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"handlers.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n<!-- import-globals-from in-content/main.js -->\n\n<!DOCTYPE overlay [\n  <!ENTITY % brandDTD SYSTEM \"chrome://branding/locale/brand.dtd\">\n  <!ENTITY % applicationsDTD SYSTEM \"chrome://browser/locale/preferences/applications.dtd\">\n  <!ENTITY % containersDTD SYSTEM \"chrome://browser/locale/preferences/containers.dtd\">\n  %brandDTD;\n  %applicationsDTD;\n  %containersDTD;\n]>\n\n<bindings id=\"handlerBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"handler-base\" extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <implementation>\n      <property name=\"type\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"type\");\n        </getter>\n      </property>\n    </implementation>\n  </binding>\n\n  <binding id=\"handler\" extends=\"chrome://browser/content/preferences/handlers.xml#handler-base\">\n    <content>\n      <xul:hbox flex=\"1\" equalsize=\"always\">\n        <xul:hbox flex=\"1\" align=\"center\" xbl:inherits=\"tooltiptext=typeDescription\">\n          <xul:image src=\"moz-icon://goat?size=16\" class=\"typeIcon\"\n                     xbl:inherits=\"src=typeIcon\" height=\"16\" width=\"16\"/>\n          <xul:label flex=\"1\" crop=\"end\" xbl:inherits=\"value=typeDescription\"/>\n        </xul:hbox>\n        <xul:hbox flex=\"1\" align=\"center\" xbl:inherits=\"tooltiptext=actionDescription\">\n          <xul:image xbl:inherits=\"src=actionIcon\" height=\"16\" width=\"16\" class=\"actionIcon\"/>\n          <xul:label flex=\"1\" crop=\"end\" xbl:inherits=\"value=actionDescription\"/>\n        </xul:hbox>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"handler-selected\" extends=\"chrome://browser/content/preferences/handlers.xml#handler-base\">\n    <content>\n      <xul:hbox flex=\"1\" equalsize=\"always\">\n        <xul:hbox flex=\"1\" align=\"center\" xbl:inherits=\"tooltiptext=typeDescription\">\n          <xul:image src=\"moz-icon://goat?size=16\" class=\"typeIcon\"\n                     xbl:inherits=\"src=typeIcon\" height=\"16\" width=\"16\"/>\n          <xul:label flex=\"1\" crop=\"end\" xbl:inherits=\"value=typeDescription\"/>\n        </xul:hbox>\n        <xul:hbox flex=\"1\">\n          <xul:menulist class=\"actionsMenu\" flex=\"1\" crop=\"end\" selectedIndex=\"1\"\n                        xbl:inherits=\"tooltiptext=actionDescription\"\n                        oncommand=\"gMainPane.onSelectAction(event.originalTarget)\">\n            <xul:menupopup/>\n          </xul:menulist>\n        </xul:hbox>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <constructor>\n        gMainPane.rebuildActionsMenu();\n      </constructor>\n    </implementation>\n\n  </binding>\n\n  <binding id=\"container\">\n    <content>\n      <xul:hbox flex=\"1\" equalsize=\"always\">\n        <xul:hbox flex=\"1\" align=\"center\">\n          <xul:hbox xbl:inherits=\"data-identity-icon=containerIcon,data-identity-color=containerColor\" height=\"24\" width=\"24\" class=\"userContext-icon\"/>\n          <xul:label flex=\"1\" crop=\"end\" xbl:inherits=\"xbl:text=containerName,highlightable\"/>\n        </xul:hbox>\n        <xul:hbox flex=\"1\" align=\"right\">\n          <xul:button anonid=\"preferencesButton\"\n                      label=\"FROM-DTD-preferencesButton-label\"\n                      xbl:inherits=\"value=userContextId\"\n                      onclick=\"gContainersPane.onPreferenceClick(event.originalTarget)\">\n          </xul:button>\n          <xul:button anonid=\"removeButton\"\n                      label=\"FROM-DTD-removeButton-label\"\n                      xbl:inherits=\"value=userContextId\"\n                      onclick=\"gContainersPane.onRemoveClick(event.originalTarget)\">\n          </xul:button>\n        </xul:hbox>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"offlineapp\"\n\t   extends=\"chrome://global/content/bindings/listbox.xml#listitem\">\n    <content>\n      <children>\n\t<xul:listcell xbl:inherits=\"label=origin\"/>\n\t<xul:listcell xbl:inherits=\"label=usage\"/>\n      </children>\n    </content>\n  </binding>\n\n</bindings>\n"},{"file":"siteListItem.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n<!-- import-globals-from siteDataSettings.js -->\n\n<!DOCTYPE overlay [\n  <!ENTITY % brandDTD SYSTEM \"chrome://branding/locale/brand.dtd\">\n  <!ENTITY % applicationsDTD SYSTEM \"chrome://browser/locale/preferences/siteDataSettings.dtd\">\n  %brandDTD;\n  %applicationsDTD;\n]>\n\n<bindings id=\"siteListItemBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"siteListItem\" extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <content>\n      <xul:hbox flex=\"1\">\n        <xul:hbox flex=\"4\" width=\"50\" class=\"item-box\" align=\"center\" xbl:inherits=\"tooltiptext=host\">\n          <xul:label flex=\"1\" crop=\"end\" xbl:inherits=\"value=host\"/>\n        </xul:hbox>\n        <xul:hbox flex=\"2\" width=\"50\" class=\"item-box\" align=\"center\" xbl:inherits=\"tooltiptext=status\">\n          <xul:label flex=\"1\" crop=\"end\" xbl:inherits=\"value=status\"/>\n        </xul:hbox>\n        <xul:hbox flex=\"1\" width=\"50\" class=\"item-box\" align=\"center\" xbl:inherits=\"tooltiptext=usage\">\n          <xul:label flex=\"1\" crop=\"end\" xbl:inherits=\"value=usage\"/>\n        </xul:hbox>\n      </xul:hbox>\n    </content>\n  </binding>\n\n</bindings>\n"},{"file":"search.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This file is imported into the browser window. -->\n<!-- eslint-env mozilla/browser-window -->\n\n<!-- XULCommandEvent is a specialised global. -->\n<!-- global XULCommandEvent -->\n\n<!DOCTYPE bindings [\n<!ENTITY % browserDTD SYSTEM \"chrome://browser/locale/browser.dtd\">\n%browserDTD;\n]>\n\n<bindings id=\"SearchBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"searchbar\">\n    <resources>\n      <stylesheet src=\"chrome://browser/content/search/searchbarBindings.css\"/>\n      <stylesheet src=\"chrome://browser/skin/searchbar.css\"/>\n    </resources>\n    <content>\n      <xul:stringbundle src=\"chrome://browser/locale/search.properties\"\n                        anonid=\"searchbar-stringbundle\"/>\n      <!--\n      There is a dependency between \"maxrows\" attribute and\n      \"SuggestAutoComplete._historyLimit\" (nsSearchSuggestions.js). Changing\n      one of them requires changing the other one.\n      -->\n      <xul:textbox class=\"searchbar-textbox\"\n                   anonid=\"searchbar-textbox\"\n                   type=\"autocomplete\"\n                   inputtype=\"search\"\n                   placeholder=\"FROM-DTD-searchInput-placeholder\"\n                   flex=\"1\"\n                   autocompletepopup=\"PopupSearchAutoComplete\"\n                   autocompletesearch=\"search-autocomplete\"\n                   autocompletesearchparam=\"searchbar-history\"\n                   maxrows=\"10\"\n                   completeselectedindex=\"true\"\n                   minresultsforpopup=\"0\"\n                   xbl:inherits=\"disabled,disableautocomplete,searchengine,src,newlines\">\n        <!--\n        Empty <box> to properly position the icon within the autocomplete\n        binding's anonymous children (the autocomplete binding positions <box>\n        children differently)\n        -->\n        <xul:box>\n          <xul:hbox class=\"searchbar-search-button\"\n                    anonid=\"searchbar-search-button\"\n                    xbl:inherits=\"addengines\"\n                    tooltiptext=\"FROM-DTD-searchIcon-tooltip\">\n            <xul:image class=\"searchbar-search-icon\"/>\n            <xul:image class=\"searchbar-search-icon-overlay\"/>\n          </xul:hbox>\n        </xul:box>\n        <xul:hbox class=\"search-go-container\">\n          <xul:image class=\"search-go-button urlbar-icon\" hidden=\"true\"\n                     anonid=\"search-go-button\"\n                     onclick=\"handleSearchCommand(event);\"\n                     tooltiptext=\"FROM-DTD-contentSearchSubmit-tooltip\"/>\n        </xul:hbox>\n      </xul:textbox>\n    </content>\n\n    <implementation implements=\"nsIObserver\">\n      <constructor><![CDATA[\n        if (this.parentNode.parentNode.localName == \"toolbarpaletteitem\")\n          return;\n\n        Services.obs.addObserver(this, \"browser-search-engine-modified\");\n\n        this._initialized = true;\n\n        (window.delayedStartupPromise || Promise.resolve()).then(() => {\n          window.requestIdleCallback(() => {\n            Services.search.init(aStatus => {\n              // Bail out if the binding's been destroyed\n              if (!this._initialized)\n                return;\n\n              if (Components.isSuccessCode(aStatus)) {\n                // Refresh the display (updating icon, etc)\n                this.updateDisplay();\n                BrowserSearch.updateOpenSearchBadge();\n              } else {\n                Components.utils.reportError(\"Cannot initialize search service, bailing out: \" + aStatus);\n              }\n            });\n          });\n        });\n\n        // Wait until the popupshowing event to avoid forcing immediate\n        // attachment of the search-one-offs binding.\n        this.textbox.popup.addEventListener(\"popupshowing\", () => {\n          let oneOffButtons = this.textbox.popup.oneOffButtons;\n          // Some accessibility tests create their own <searchbar> that doesn't\n          // use the popup binding below, so null-check oneOffButtons.\n          if (oneOffButtons) {\n            oneOffButtons.telemetryOrigin = \"searchbar\";\n            // Set .textbox first, since the popup setter will cause\n            // a _rebuild call that uses it.\n            oneOffButtons.textbox = this.textbox;\n            oneOffButtons.popup = this.textbox.popup;\n          }\n        }, {capturing: true, once: true});\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        this.destroy();\n      ]]></destructor>\n\n      <method name=\"destroy\">\n        <body><![CDATA[\n        if (this._initialized) {\n          this._initialized = false;\n\n          Services.obs.removeObserver(this, \"browser-search-engine-modified\");\n        }\n\n        // Make sure to break the cycle from _textbox to us. Otherwise we leak\n        // the world. But make sure it's actually pointing to us.\n        // Also make sure the textbox has ever been constructed, otherwise the\n        // _textbox getter will cause the textbox constructor to run, add an\n        // observer, and leak the world too.\n        if (this._textboxInitialized && this._textbox.mController.input == this)\n          this._textbox.mController.input = null;\n        ]]></body>\n      </method>\n\n      <field name=\"_ignoreFocus\">false</field>\n      <field name=\"_clickClosedPopup\">false</field>\n      <field name=\"_stringBundle\">document.getAnonymousElementByAttribute(this,\n          \"anonid\", \"searchbar-stringbundle\");</field>\n      <field name=\"_textboxInitialized\">false</field>\n      <field name=\"_textbox\">document.getAnonymousElementByAttribute(this,\n          \"anonid\", \"searchbar-textbox\");</field>\n      <field name=\"_engines\">null</field>\n      <field name=\"FormHistory\" readonly=\"true\">\n        (Components.utils.import(\"resource://gre/modules/FormHistory.jsm\", {})).FormHistory;\n      </field>\n\n      <property name=\"engines\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._engines)\n            this._engines = Services.search.getVisibleEngines();\n          return this._engines;\n        ]]></getter>\n      </property>\n\n      <property name=\"currentEngine\">\n        <setter><![CDATA[\n          Services.search.currentEngine = val;\n          return val;\n        ]]></setter>\n        <getter><![CDATA[\n          var currentEngine = Services.search.currentEngine;\n          // Return a dummy engine if there is no currentEngine\n          return currentEngine || {name: \"\", uri: null};\n        ]]></getter>\n      </property>\n\n      <!-- textbox is used by sanitize.js to clear the undo history when\n           clearing form information. -->\n      <property name=\"textbox\" readonly=\"true\"\n                onget=\"return this._textbox;\"/>\n\n      <property name=\"value\" onget=\"return this._textbox.value;\"\n                             onset=\"return this._textbox.value = val;\"/>\n\n      <method name=\"focus\">\n        <body><![CDATA[\n          this._textbox.focus();\n        ]]></body>\n      </method>\n\n      <method name=\"select\">\n        <body><![CDATA[\n          this._textbox.select();\n        ]]></body>\n      </method>\n\n      <method name=\"observe\">\n        <parameter name=\"aEngine\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aVerb\"/>\n        <body><![CDATA[\n          if (aTopic == \"browser-search-engine-modified\") {\n            switch (aVerb) {\n            case \"engine-removed\":\n              this.offerNewEngine(aEngine);\n              break;\n            case \"engine-added\":\n              this.hideNewEngine(aEngine);\n              break;\n            case \"engine-changed\":\n              // An engine was removed (or hidden) or added, or an icon was\n              // changed.  Do nothing special.\n            }\n\n            // Make sure the engine list is refetched next time it's needed\n            this._engines = null;\n\n            // Update the popup header and update the display after any modification.\n            this._textbox.popup.updateHeader();\n            this.updateDisplay();\n          }\n        ]]></body>\n      </method>\n\n      <!-- There are two seaprate lists of search engines, whose uses intersect\n      in this file.  The search service (nsIBrowserSearchService and\n      nsSearchService.js) maintains a list of Engine objects which is used to\n      populate the searchbox list of available engines and to perform queries.\n      That list is accessed here via this.SearchService, and it's that sort of\n      Engine that is passed to this binding's observer as aEngine.\n\n      In addition, browser.js fills two lists of autodetected search engines\n      (browser.engines and browser.hiddenEngines) as properties of\n      mCurrentBrowser.  Those lists contain unnamed JS objects of the form\n      { uri:, title:, icon: }, and that's what the searchbar uses to determine\n      whether to show any \"Add <EngineName>\" menu items in the drop-down.\n\n      The two types of engines are currently related by their identifying\n      titles (the Engine object's 'name'), although that may change; see bug\n      335102.  -->\n\n      <!-- If the engine that was just removed from the searchbox list was\n      autodetected on this page, move it to each browser's active list so it\n      will be offered to be added again. -->\n      <method name=\"offerNewEngine\">\n        <parameter name=\"aEngine\"/>\n        <body><![CDATA[\n          for (let browser of gBrowser.browsers) {\n            if (browser.hiddenEngines) {\n              // XXX This will need to be changed when engines are identified by\n              // URL rather than title; see bug 335102.\n              var removeTitle = aEngine.wrappedJSObject.name;\n              for (var i = 0; i < browser.hiddenEngines.length; i++) {\n                if (browser.hiddenEngines[i].title == removeTitle) {\n                  if (!browser.engines)\n                    browser.engines = [];\n                  browser.engines.push(browser.hiddenEngines[i]);\n                  browser.hiddenEngines.splice(i, 1);\n                  break;\n                }\n              }\n            }\n          }\n          BrowserSearch.updateOpenSearchBadge();\n        ]]></body>\n      </method>\n\n      <!-- If the engine that was just added to the searchbox list was\n      autodetected on this page, move it to each browser's hidden list so it is\n      no longer offered to be added. -->\n      <method name=\"hideNewEngine\">\n        <parameter name=\"aEngine\"/>\n        <body><![CDATA[\n          for (let browser of gBrowser.browsers) {\n            if (browser.engines) {\n              // XXX This will need to be changed when engines are identified by\n              // URL rather than title; see bug 335102.\n              var removeTitle = aEngine.wrappedJSObject.name;\n              for (var i = 0; i < browser.engines.length; i++) {\n                if (browser.engines[i].title == removeTitle) {\n                  if (!browser.hiddenEngines)\n                    browser.hiddenEngines = [];\n                  browser.hiddenEngines.push(browser.engines[i]);\n                  browser.engines.splice(i, 1);\n                  break;\n                }\n              }\n            }\n          }\n          BrowserSearch.updateOpenSearchBadge();\n        ]]></body>\n      </method>\n\n      <method name=\"setIcon\">\n        <parameter name=\"element\"/>\n        <parameter name=\"uri\"/>\n        <body><![CDATA[\n          element.setAttribute(\"src\", uri);\n        ]]></body>\n      </method>\n\n      <method name=\"updateDisplay\">\n        <body><![CDATA[\n          var uri = this.currentEngine.iconURI;\n          this.setIcon(this, uri ? uri.spec : \"\");\n\n          var name = this.currentEngine.name;\n          var text = this._stringBundle.getFormattedString(\"searchtip\", [name]);\n          this._textbox.label = text;\n          this._textbox.tooltipText = text;\n        ]]></body>\n      </method>\n\n      <method name=\"updateGoButtonVisibility\">\n        <body><![CDATA[\n          document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                  \"search-go-button\")\n                  .hidden = !this._textbox.value;\n        ]]></body>\n      </method>\n\n      <method name=\"openSuggestionsPanel\">\n        <parameter name=\"aShowOnlySettingsIfEmpty\"/>\n        <body><![CDATA[\n          if (this._textbox.open)\n            return;\n\n          this._textbox.showHistoryPopup();\n\n          if (this._textbox.value) {\n            // showHistoryPopup does a startSearch(\"\") call, ensure the\n            // controller handles the text from the input box instead:\n            this._textbox.mController.handleText();\n          } else if (aShowOnlySettingsIfEmpty) {\n            this.setAttribute(\"showonlysettings\", \"true\");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"selectEngine\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"isNextEngine\"/>\n        <body><![CDATA[\n          // Find the new index\n          var newIndex = this.engines.indexOf(this.currentEngine);\n          newIndex += isNextEngine ? 1 : -1;\n\n          if (newIndex >= 0 && newIndex < this.engines.length) {\n            this.currentEngine = this.engines[newIndex];\n          }\n\n          aEvent.preventDefault();\n          aEvent.stopPropagation();\n\n          this.openSuggestionsPanel();\n        ]]></body>\n      </method>\n\n      <method name=\"handleSearchCommand\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aEngine\"/>\n        <parameter name=\"aForceNewTab\"/>\n        <body><![CDATA[\n          var where = \"current\";\n          let params;\n\n          // Open ctrl/cmd clicks on one-off buttons in a new background tab.\n          if (aEvent && aEvent.originalTarget.getAttribute(\"anonid\") == \"search-go-button\") {\n            if (aEvent.button == 2)\n              return;\n            where = whereToOpenLink(aEvent, false, true);\n          } else if (aForceNewTab) {\n            where = \"tab\";\n            if (Services.prefs.getBoolPref(\"browser.tabs.loadInBackground\"))\n              where += \"-background\";\n          } else {\n            var newTabPref = Services.prefs.getBoolPref(\"browser.search.openintab\");\n            if (((aEvent instanceof KeyboardEvent) && aEvent.altKey) ^ newTabPref)\n              where = \"tab\";\n            if ((aEvent instanceof MouseEvent) &&\n                (aEvent.button == 1 || aEvent.getModifierState(\"Accel\"))) {\n              where = \"tab\";\n              params = {\n                inBackground: true,\n              };\n            }\n          }\n\n          this.handleSearchCommandWhere(aEvent, aEngine, where, params);\n        ]]></body>\n      </method>\n\n      <method name=\"handleSearchCommandWhere\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aEngine\"/>\n        <parameter name=\"aWhere\"/>\n        <parameter name=\"aParams\"/>\n        <body><![CDATA[\n          var textBox = this._textbox;\n          var textValue = textBox.value;\n\n          let selection = this.telemetrySearchDetails;\n          let oneOffRecorded = false;\n\n          BrowserUsageTelemetry.recordSearchbarSelectedResultMethod(\n            aEvent,\n            selection ? selection.index : -1\n          );\n\n          if (!selection || (selection.index == -1)) {\n            oneOffRecorded = this.textbox.popup.oneOffButtons\n                                 .maybeRecordTelemetry(aEvent, aWhere, aParams);\n            if (!oneOffRecorded) {\n              let source = \"unknown\";\n              let type = \"unknown\";\n              let target = aEvent.originalTarget;\n              if (aEvent instanceof KeyboardEvent) {\n                type = \"key\";\n              } else if (aEvent instanceof MouseEvent) {\n                type = \"mouse\";\n                if (target.classList.contains(\"search-panel-header\") ||\n                    target.parentNode.classList.contains(\"search-panel-header\")) {\n                  source = \"header\";\n                }\n              } else if (aEvent instanceof XULCommandEvent) {\n                if (target.getAttribute(\"anonid\") == \"paste-and-search\") {\n                  source = \"paste\";\n                }\n              }\n              if (!aEngine) {\n                aEngine = this.currentEngine;\n              }\n              BrowserSearch.recordOneoffSearchInTelemetry(aEngine, source, type,\n                                                          aWhere);\n            }\n          }\n\n          // This is a one-off search only if oneOffRecorded is true.\n          this.doSearch(textValue, aWhere, aEngine, aParams, oneOffRecorded);\n\n          if (aWhere == \"tab\" && aParams && aParams.inBackground)\n            this.focus();\n        ]]></body>\n      </method>\n\n      <method name=\"doSearch\">\n        <parameter name=\"aData\"/>\n        <parameter name=\"aWhere\"/>\n        <parameter name=\"aEngine\"/>\n        <parameter name=\"aParams\"/>\n        <parameter name=\"aOneOff\"/>\n        <body><![CDATA[\n          var textBox = this._textbox;\n\n          // Save the current value in the form history\n          if (aData && !PrivateBrowsingUtils.isWindowPrivate(window) && this.FormHistory.enabled) {\n            this.FormHistory.update(\n              { op: \"bump\",\n                fieldname: textBox.getAttribute(\"autocompletesearchparam\"),\n                value: aData },\n              { handleError(aError) {\n                  Components.utils.reportError(\"Saving search to form history failed: \" + aError.message);\n              }});\n          }\n\n          let engine = aEngine || this.currentEngine;\n          var submission = engine.getSubmission(aData, null, \"searchbar\");\n          let telemetrySearchDetails = this.telemetrySearchDetails;\n          this.telemetrySearchDetails = null;\n          if (telemetrySearchDetails && telemetrySearchDetails.index == -1) {\n            telemetrySearchDetails = null;\n          }\n          // If we hit here, we come either from a one-off, a plain search or a suggestion.\n          const details = {\n            isOneOff: aOneOff,\n            isSuggestion: (!aOneOff && telemetrySearchDetails),\n            selection: telemetrySearchDetails\n          };\n          BrowserSearch.recordSearchInTelemetry(engine, \"searchbar\", details);\n          // null parameter below specifies HTML response for search\n          let params = {\n            postData: submission.postData,\n          };\n          if (aParams) {\n            for (let key in aParams) {\n              params[key] = aParams[key];\n            }\n          }\n          openUILinkIn(submission.uri.spec, aWhere, params);\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"command\"><![CDATA[\n        const target = event.originalTarget;\n        if (target.engine) {\n          this.currentEngine = target.engine;\n        } else if (target.classList.contains(\"addengine-item\")) {\n          // Select the installed engine if the installation succeeds\n          var installCallback = {\n            onSuccess: engine => this.currentEngine = engine\n          }\n          Services.search.addEngine(target.getAttribute(\"uri\"), null,\n                                    target.getAttribute(\"src\"), false,\n                                    installCallback);\n        } else\n          return;\n\n        this.focus();\n        this.select();\n      ]]></handler>\n\n      <handler event=\"DOMMouseScroll\"\n               phase=\"capturing\"\n               modifiers=\"accel\"\n               action=\"this.selectEngine(event, (event.detail > 0));\"/>\n\n      <handler event=\"input\" action=\"this.updateGoButtonVisibility();\"/>\n      <handler event=\"drop\" action=\"this.updateGoButtonVisibility();\"/>\n\n      <handler event=\"blur\">\n      <![CDATA[\n        // If the input field is still focused then a different window has\n        // received focus, ignore the next focus event.\n        this._ignoreFocus = (document.activeElement == this._textbox.inputField);\n      ]]></handler>\n\n      <handler event=\"focus\">\n      <![CDATA[\n        // Speculatively connect to the current engine's search URI (and\n        // suggest URI, if different) to reduce request latency\n        this.currentEngine.speculativeConnect({window,\n                                               originAttributes: gBrowser.contentPrincipal\n                                                                         .originAttributes});\n\n        if (this._ignoreFocus) {\n          // This window has been re-focused, don't show the suggestions\n          this._ignoreFocus = false;\n          return;\n        }\n\n        // Don't open the suggestions if there is no text in the textbox.\n        if (!this._textbox.value)\n          return;\n\n        // Don't open the suggestions if the mouse was used to focus the\n        // textbox, that will be taken care of in the click handler.\n        if (Services.focus.getLastFocusMethod(window) & Services.focus.FLAG_BYMOUSE)\n          return;\n\n        this.openSuggestionsPanel();\n      ]]></handler>\n\n      <handler event=\"mousedown\" phase=\"capturing\">\n      <![CDATA[\n        if (event.originalTarget.getAttribute(\"anonid\") == \"searchbar-search-button\") {\n          this._clickClosedPopup = this._textbox.popup._isHiding;\n        }\n      ]]></handler>\n\n      <handler event=\"mousedown\" button=\"0\">\n      <![CDATA[\n        // Ignore clicks on the search go button.\n        if (event.originalTarget.getAttribute(\"anonid\") == \"search-go-button\") {\n          return;\n        }\n\n        let isIconClick = event.originalTarget.getAttribute(\"anonid\") == \"searchbar-search-button\";\n\n        // Ignore clicks on the icon if they were made to close the popup\n        if (isIconClick && this._clickClosedPopup) {\n          return;\n        }\n\n        // Open the suggestions whenever clicking on the search icon or if there\n        // is text in the textbox.\n        if (isIconClick || this._textbox.value) {\n          this.openSuggestionsPanel(true);\n        }\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n  <binding id=\"searchbar-textbox\"\n      extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete\">\n    <implementation>\n      <constructor><![CDATA[\n        if (document.getBindingParent(this).parentNode.parentNode.localName ==\n            \"toolbarpaletteitem\")\n          return;\n\n        if (Services.prefs.getBoolPref(\"browser.urlbar.clickSelectsAll\"))\n          this.setAttribute(\"clickSelectsAll\", true);\n\n        var textBox = document.getAnonymousElementByAttribute(this,\n                                              \"anonid\", \"textbox-input-box\");\n        var cxmenu = document.getAnonymousElementByAttribute(textBox,\n                                          \"anonid\", \"input-box-contextmenu\");\n        cxmenu.addEventListener(\"popupshowing\",\n                                () => { this.initContextMenu(cxmenu); },\n                                {capturing: true, once: true});\n\n        this.setAttribute(\"aria-owns\", this.popup.id);\n        document.getBindingParent(this)._textboxInitialized = true;\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // If the context menu has never been opened, there won't be anything\n        // to remove here.\n        // Also, XBL and the customize toolbar code sometimes interact poorly.\n        try {\n          this.controllers.removeController(this.searchbarController);\n        } catch (ex) { }\n      ]]></destructor>\n\n      // Add items to context menu and attach controller to handle them the\n      // first time the context menu is opened.\n      <method name=\"initContextMenu\">\n        <parameter name=\"aMenu\"/>\n        <body><![CDATA[\n          const kXULNS =\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          let stringBundle = document.getBindingParent(this)._stringBundle;\n\n          let pasteAndSearch, suggestMenuItem;\n          let element, label, akey;\n\n          element = document.createElementNS(kXULNS, \"menuseparator\");\n          aMenu.appendChild(element);\n\n          let insertLocation = aMenu.firstChild;\n          while (insertLocation.nextSibling &&\n                 insertLocation.getAttribute(\"cmd\") != \"cmd_paste\")\n            insertLocation = insertLocation.nextSibling;\n          if (insertLocation) {\n            element = document.createElementNS(kXULNS, \"menuitem\");\n            label = stringBundle.getString(\"cmd_pasteAndSearch\");\n            element.setAttribute(\"label\", label);\n            element.setAttribute(\"anonid\", \"paste-and-search\");\n            element.setAttribute(\"oncommand\", \"BrowserSearch.pasteAndSearch(event)\");\n            aMenu.insertBefore(element, insertLocation.nextSibling);\n            pasteAndSearch = element;\n          }\n\n          element = document.createElementNS(kXULNS, \"menuitem\");\n          label = stringBundle.getString(\"cmd_clearHistory\");\n          akey = stringBundle.getString(\"cmd_clearHistory_accesskey\");\n          element.setAttribute(\"label\", label);\n          element.setAttribute(\"accesskey\", akey);\n          element.setAttribute(\"cmd\", \"cmd_clearhistory\");\n          aMenu.appendChild(element);\n\n          element = document.createElementNS(kXULNS, \"menuitem\");\n          label = stringBundle.getString(\"cmd_showSuggestions\");\n          akey = stringBundle.getString(\"cmd_showSuggestions_accesskey\");\n          element.setAttribute(\"anonid\", \"toggle-suggest-item\");\n          element.setAttribute(\"label\", label);\n          element.setAttribute(\"accesskey\", akey);\n          element.setAttribute(\"cmd\", \"cmd_togglesuggest\");\n          element.setAttribute(\"type\", \"checkbox\");\n          element.setAttribute(\"autocheck\", \"false\");\n          suggestMenuItem = element;\n          aMenu.appendChild(element);\n\n          if (AppConstants.platform == \"macosx\") {\n            this.addEventListener(\"keypress\", aEvent => {\n              if (aEvent.keyCode == KeyEvent.DOM_VK_F4)\n                this.openSearch()\n            }, true);\n          }\n\n          this.controllers.appendController(this.searchbarController);\n\n          let onpopupshowing = function() {\n            BrowserSearch.searchBar._textbox.closePopup();\n            if (suggestMenuItem) {\n              let enabled =\n                Services.prefs.getBoolPref(\"browser.search.suggest.enabled\");\n              suggestMenuItem.setAttribute(\"checked\", enabled);\n            }\n\n            if (!pasteAndSearch)\n              return;\n            let controller = document.commandDispatcher.getControllerForCommand(\"cmd_paste\");\n            let enabled = controller.isCommandEnabled(\"cmd_paste\");\n            if (enabled)\n              pasteAndSearch.removeAttribute(\"disabled\");\n            else\n              pasteAndSearch.setAttribute(\"disabled\", \"true\");\n          };\n          aMenu.addEventListener(\"popupshowing\", onpopupshowing);\n          onpopupshowing();\n        ]]></body>\n      </method>\n\n      <!--\n        This overrides the searchParam property in autocomplete.xml.  We're\n        hijacking this property as a vehicle for delivering the privacy\n        information about the window into the guts of nsSearchSuggestions.\n\n        Note that the setter is the same as the parent.  We were not sure whether\n        we can override just the getter.  If that proves to be the case, the setter\n        can be removed.\n      -->\n      <property name=\"searchParam\"\n                onget=\"return this.getAttribute('autocompletesearchparam') +\n                       (PrivateBrowsingUtils.isWindowPrivate(window) ? '|private' : '');\"\n                onset=\"this.setAttribute('autocompletesearchparam', val); return val;\"/>\n\n      <!-- This is implemented so that when textbox.value is set directly (e.g.,\n           by tests), the one-off query is updated. -->\n      <method name=\"onBeforeValueSet\">\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          this.popup.oneOffButtons.query = aValue;\n          return aValue;\n        ]]></body>\n      </method>\n\n      <!--\n        This method overrides the autocomplete binding's openPopup (essentially\n        duplicating the logic from the autocomplete popup binding's\n        openAutocompletePopup method), modifying it so that the popup is aligned with\n        the inner textbox, but sized to not extend beyond the search bar border.\n      -->\n      <method name=\"openPopup\">\n        <body><![CDATA[\n          // Entering customization mode after the search bar had focus causes\n          // the popup to appear again, due to focus returning after the\n          // hamburger panel closes. Don't open in that spurious event.\n          if (document.documentElement.getAttribute(\"customizing\") == \"true\") {\n            return;\n          }\n\n          var popup = this.popup;\n          if (!popup.mPopupOpen) {\n            // Initially the panel used for the searchbar (PopupSearchAutoComplete\n            // in browser.xul) is hidden to avoid impacting startup / new\n            // window performance. The base binding's openPopup would normally\n            // call the overriden openAutocompletePopup in\n            // browser-search-autocomplete-result-popup binding to unhide the popup,\n            // but since we're overriding openPopup we need to unhide the panel\n            // ourselves.\n            popup.hidden = false;\n\n            // Don't roll up on mouse click in the anchor for the search UI.\n            if (popup.id == \"PopupSearchAutoComplete\") {\n              popup.setAttribute(\"norolluponanchor\", \"true\");\n            }\n\n            popup.mInput = this;\n            popup.view = this.controller.QueryInterface(Ci.nsITreeView);\n            popup.invalidate();\n\n            popup.showCommentColumn = this.showCommentColumn;\n            popup.showImageColumn = this.showImageColumn;\n\n            document.popupNode = null;\n\n            const isRTL = getComputedStyle(this, \"\").direction == \"rtl\";\n\n            var outerRect = this.getBoundingClientRect();\n            var innerRect = this.inputField.getBoundingClientRect();\n            let width = isRTL ?\n                        innerRect.right - outerRect.left :\n                        outerRect.right - innerRect.left;\n            popup.setAttribute(\"width\", width > 100 ? width : 100);\n\n            var yOffset = outerRect.bottom - innerRect.bottom;\n            popup.openPopup(this.inputField, \"after_start\", 0, yOffset, false, false);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"openSearch\">\n        <body>\n          <![CDATA[\n            if (!this.popupOpen) {\n              document.getBindingParent(this).openSuggestionsPanel();\n              return false;\n            }\n            return true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"handleEnter\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          // Toggle the open state of the add-engine menu button if it's\n          // selected.  We're using handleEnter for this instead of listening\n          // for the command event because a command event isn't fired.\n          if (this.selectedButton &&\n              this.selectedButton.getAttribute(\"anonid\") ==\n                \"addengine-menu-button\") {\n            this.selectedButton.open = !this.selectedButton.open;\n            return true;\n          }\n          // Otherwise, \"call super\": do what the autocomplete binding's\n          // handleEnter implementation does.\n          return this.mController.handleEnter(false, event || null);\n        ]]></body>\n      </method>\n\n      <!-- override |onTextEntered| in autocomplete.xml -->\n      <method name=\"onTextEntered\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let engine;\n          let oneOff = this.selectedButton;\n          if (oneOff) {\n            if (!oneOff.engine) {\n              oneOff.doCommand();\n              return;\n            }\n            engine = oneOff.engine;\n          }\n          if (this._selectionDetails &&\n              this._selectionDetails.currentIndex != -1) {\n            BrowserSearch.searchBar.telemetrySearchDetails = this._selectionDetails;\n            this._selectionDetails = null;\n          }\n          document.getBindingParent(this).handleSearchCommand(aEvent, engine);\n        ]]></body>\n      </method>\n\n      <property name=\"selectedButton\">\n        <getter><![CDATA[\n          return this.popup.oneOffButtons.selectedButton;\n        ]]></getter>\n        <setter><![CDATA[\n          return this.popup.oneOffButtons.selectedButton = val;\n        ]]></setter>\n      </property>\n\n      <method name=\"handleKeyboardNavigation\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let popup = this.popup;\n          if (!popup.popupOpen)\n            return;\n\n          // accel + up/down changes the default engine and shouldn't affect\n          // the selection on the one-off buttons.\n          if (aEvent.getModifierState(\"Accel\"))\n            return;\n\n          let suggestionsHidden =\n            popup.tree.getAttribute(\"collapsed\") == \"true\";\n          let numItems = suggestionsHidden ? 0 : this.popup.view.rowCount;\n          this.popup.oneOffButtons.handleKeyPress(aEvent, numItems, true);\n        ]]></body>\n      </method>\n\n      <!-- nsIController -->\n      <field name=\"searchbarController\" readonly=\"true\"><![CDATA[({\n        _self: this,\n        supportsCommand(aCommand) {\n          return aCommand == \"cmd_clearhistory\" ||\n                 aCommand == \"cmd_togglesuggest\";\n        },\n\n        isCommandEnabled(aCommand) {\n          return true;\n        },\n\n        doCommand(aCommand) {\n          switch (aCommand) {\n            case \"cmd_clearhistory\":\n              var param = this._self.getAttribute(\"autocompletesearchparam\");\n\n              BrowserSearch.searchBar.FormHistory.update({ op: \"remove\", fieldname: param }, null);\n              this._self.value = \"\";\n              break;\n            case \"cmd_togglesuggest\":\n              let enabled =\n                Services.prefs.getBoolPref(\"browser.search.suggest.enabled\");\n              Services.prefs.setBoolPref(\"browser.search.suggest.enabled\",\n                                         !enabled);\n              break;\n            default:\n              // do nothing with unrecognized command\n          }\n        }\n      })]]></field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"input\"><![CDATA[\n        this.popup.removeAttribute(\"showonlysettings\");\n      ]]></handler>\n\n      <handler event=\"keypress\" phase=\"capturing\"\n               action=\"return this.handleKeyboardNavigation(event);\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"accel\"\n               phase=\"capturing\"\n               action=\"document.getBindingParent(this).selectEngine(event, false);\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"accel\"\n               phase=\"capturing\"\n               action=\"document.getBindingParent(this).selectEngine(event, true);\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"alt\"\n               phase=\"capturing\"\n               action=\"return this.openSearch();\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"alt\"\n               phase=\"capturing\"\n               action=\"return this.openSearch();\"/>\n\n      <handler event=\"dragover\">\n      <![CDATA[\n        var types = event.dataTransfer.types;\n        if (types.includes(\"text/plain\") || types.includes(\"text/x-moz-text-internal\"))\n          event.preventDefault();\n      ]]>\n      </handler>\n\n      <handler event=\"drop\">\n      <![CDATA[\n        var dataTransfer = event.dataTransfer;\n        var data = dataTransfer.getData(\"text/plain\");\n        if (!data)\n          data = dataTransfer.getData(\"text/x-moz-text-internal\");\n        if (data) {\n          event.preventDefault();\n          this.value = data;\n          document.getBindingParent(this).openSuggestionsPanel();\n        }\n      ]]>\n      </handler>\n\n    </handlers>\n  </binding>\n\n  <binding id=\"browser-search-autocomplete-result-popup\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-result-popup\">\n    <resources>\n      <stylesheet src=\"chrome://browser/content/search/searchbarBindings.css\"/>\n      <stylesheet src=\"chrome://browser/skin/searchbar.css\"/>\n    </resources>\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\">\n      <xul:hbox anonid=\"searchbar-engine\" xbl:inherits=\"showonlysettings\"\n                class=\"search-panel-header search-panel-current-engine\">\n        <xul:image class=\"searchbar-engine-image\" xbl:inherits=\"src\"/>\n        <xul:label anonid=\"searchbar-engine-name\" flex=\"1\" crop=\"end\"\n                   role=\"presentation\"/>\n      </xul:hbox>\n      <xul:tree anonid=\"tree\" flex=\"1\"\n                class=\"autocomplete-tree plain search-panel-tree\"\n                hidecolumnpicker=\"true\" seltype=\"single\">\n        <xul:treecols anonid=\"treecols\">\n          <xul:treecol id=\"treecolAutoCompleteValue\" class=\"autocomplete-treecol\" flex=\"1\" overflow=\"true\"/>\n        </xul:treecols>\n        <xul:treechildren class=\"autocomplete-treebody searchbar-treebody\"/>\n      </xul:tree>\n      <xul:vbox anonid=\"search-one-off-buttons\" class=\"search-one-offs\"/>\n    </content>\n    <implementation>\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body><![CDATA[\n          // initially the panel is hidden\n          // to avoid impacting startup / new window performance\n          aInput.popup.hidden = false;\n\n          // this method is defined on the base binding\n          this._openAutocompletePopup(aInput, aElement);\n        ]]></body>\n      </method>\n\n      <method name=\"onPopupClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          // Ignore all right-clicks\n          if (aEvent.button == 2)\n            return;\n\n          var controller = this.view.QueryInterface(Components.interfaces.nsIAutoCompleteController);\n\n          var searchBar = BrowserSearch.searchBar;\n          var popupForSearchBar = searchBar && searchBar.textbox == this.mInput;\n          if (popupForSearchBar) {\n            searchBar.telemetrySearchDetails = {\n              index: controller.selection.currentIndex,\n              kind: \"mouse\"\n            };\n          }\n\n          // Check for unmodified left-click, and use default behavior\n          if (aEvent.button == 0 && !aEvent.shiftKey && !aEvent.ctrlKey &&\n              !aEvent.altKey && !aEvent.metaKey) {\n            controller.handleEnter(true, aEvent);\n            return;\n          }\n\n          // Check for middle-click or modified clicks on the search bar\n          if (popupForSearchBar) {\n            BrowserUsageTelemetry.recordSearchbarSelectedResultMethod(\n              aEvent,\n              this.selectedIndex\n            );\n\n            // Handle search bar popup clicks\n            var search = controller.getValueAt(this.selectedIndex);\n\n            // open the search results according to the clicking subtlety\n            var where = whereToOpenLink(aEvent, false, true);\n            let params = {};\n\n            // But open ctrl/cmd clicks on autocomplete items in a new background tab.\n            let modifier = AppConstants.platform == \"macosx\" ?\n                           aEvent.metaKey :\n                           aEvent.ctrlKey;\n            if (where == \"tab\" && (aEvent instanceof MouseEvent) &&\n                (aEvent.button == 1 || modifier))\n              params.inBackground = true;\n\n            // leave the popup open for background tab loads\n            if (!(where == \"tab\" && params.inBackground)) {\n              // close the autocomplete popup and revert the entered search term\n              this.closePopup();\n              controller.handleEscape();\n            }\n\n            searchBar.doSearch(search, where, null, params);\n            if (where == \"tab\" && params.inBackground)\n              searchBar.focus();\n            else\n              searchBar.value = search;\n          }\n        ]]></body>\n      </method>\n\n      <!-- Popup rollup is triggered by native events before the mousedown event\n           reaches the DOM. The will be set to true by the popuphiding event and\n           false after the mousedown event has been triggered to detect what\n           caused rollup. -->\n      <field name=\"_isHiding\">false</field>\n      <field name=\"_bundle\">null</field>\n      <property name=\"bundle\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (!this._bundle) {\n              const kBundleURI = \"chrome://browser/locale/search.properties\";\n              this._bundle = Services.strings.createBundle(kBundleURI);\n            }\n            return this._bundle;\n          ]]>\n        </getter>\n      </property>\n\n      <field name=\"oneOffButtons\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"search-one-off-buttons\");\n      </field>\n\n      <method name=\"updateHeader\">\n        <body><![CDATA[\n          let currentEngine = Services.search.currentEngine;\n          let uri = currentEngine.iconURI;\n          if (uri) {\n            this.setAttribute(\"src\", uri.spec);\n          } else {\n            // If the default has just been changed to a provider without icon,\n            // avoid showing the icon of the previous default provider.\n            this.removeAttribute(\"src\");\n          }\n\n          let headerText = this.bundle.formatStringFromName(\"searchHeader\",\n                                                            [currentEngine.name], 1);\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"searchbar-engine-name\")\n                  .setAttribute(\"value\", headerText);\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"searchbar-engine\")\n                  .engine = currentEngine;\n        ]]></body>\n      </method>\n\n      <!-- This is called when a one-off is clicked and when \"search in new tab\"\n           is selected from a one-off context menu. -->\n      <method name=\"handleOneOffSearch\">\n        <parameter name=\"event\"/>\n        <parameter name=\"engine\"/>\n        <parameter name=\"where\"/>\n        <parameter name=\"params\"/>\n        <body><![CDATA[\n          let searchbar = document.getElementById(\"searchbar\");\n          searchbar.handleSearchCommandWhere(event, engine, where, params);\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // Force the panel to have the width of the searchbar rather than\n        // the width of the textfield.\n        let DOMUtils = window.QueryInterface(Ci.nsIInterfaceRequestor)\n                             .getInterface(Ci.nsIDOMWindowUtils);\n        let textboxRect = DOMUtils.getBoundsWithoutFlushing(this.mInput);\n        let inputRect = DOMUtils.getBoundsWithoutFlushing(this.mInput.inputField);\n\n        // Ensure the panel is wide enough to fit at least 3 engines.\n        let minWidth = Math.max(textboxRect.width,\n                                this.oneOffButtons.buttonWidth * 3);\n        this.style.minWidth = Math.round(minWidth) + \"px\";\n        // Alignment of the panel with the searchbar is obtained with negative\n        // margins.\n        this.style.marginLeft = (textboxRect.left - inputRect.left) + \"px\";\n        // This second margin is needed when the direction is reversed,\n        // eg. when using command+shift+X.\n        this.style.marginRight = (inputRect.right - textboxRect.right) + \"px\";\n\n        // First handle deciding if we are showing the reduced version of the\n        // popup containing only the preferences button. We do this if the\n        // glass icon has been clicked if the text field is empty.\n        let searchbar = document.getElementById(\"searchbar\");\n        if (searchbar.hasAttribute(\"showonlysettings\")) {\n          searchbar.removeAttribute(\"showonlysettings\");\n          this.setAttribute(\"showonlysettings\", \"true\");\n\n          // Setting this with an xbl-inherited attribute gets overridden the\n          // second time the user clicks the glass icon for some reason...\n          this.tree.collapsed = true;\n        } else {\n          this.removeAttribute(\"showonlysettings\");\n          // Uncollapse as long as we have a tree with a view which has >= 1 row.\n          // The autocomplete binding itself will take care of uncollapsing later,\n          // if we currently have no rows but end up having some in the future\n          // when the search string changes\n          this.tree.collapsed = !this.tree.view || !this.tree.view.rowCount;\n        }\n\n        // Show the current default engine in the top header of the panel.\n        this.updateHeader();\n      ]]></handler>\n\n      <handler event=\"popuphiding\"><![CDATA[\n        this._isHiding = true;\n        Services.tm.dispatchToMainThread(() => {\n          this._isHiding = false;\n        });\n      ]]></handler>\n\n      <!-- This handles clicks on the topmost \"Foo Search\" header in the\n           popup (hbox[anonid=\"searchbar-engine\"]). -->\n      <handler event=\"click\"><![CDATA[\n        if (event.button == 2) {\n          // Ignore right clicks.\n          return;\n        }\n        let button = event.originalTarget;\n        let engine = button.parentNode.engine;\n        if (!engine) {\n          return;\n        }\n        this.oneOffButtons.handleSearchCommand(event, engine);\n      ]]></handler>\n    </handlers>\n\n  </binding>\n\n\n  <!-- This is the same as the autocomplete-treebody binding except it does not\n       select rows on mousemove. -->\n  <binding id=\"searchbar-treebody\"\n           extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-treebody\">\n    <handlers>\n      <handler event=\"mousemove\"><![CDATA[\n        // Cancel the event so that the base binding doesn't select the row.\n        event.preventDefault();\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <!-- Used for additional open search providers in the search panel. -->\n  <binding id=\"addengine-icon\" extends=\"xul:box\">\n    <content>\n      <xul:image class=\"addengine-icon\" xbl:inherits=\"src\"/>\n      <xul:image class=\"addengine-badge\"/>\n    </content>\n  </binding>\n\n  <binding id=\"search-one-offs\">\n    <content context=\"_child\">\n      <xul:deck anonid=\"search-panel-one-offs-header\"\n                selectedIndex=\"0\"\n                class=\"search-panel-header search-panel-current-input\">\n        <xul:label anonid=\"searchbar-oneoffheader-search\"\n                   value=\"FROM-DTD-searchWithHeader-label\"/>\n        <xul:hbox anonid=\"search-panel-searchforwith\"\n                  class=\"search-panel-current-input\">\n          <xul:label anonid=\"searchbar-oneoffheader-before\"\n                     value=\"FROM-DTD-searchFor-label\"/>\n          <xul:label anonid=\"searchbar-oneoffheader-searchtext\"\n                     class=\"search-panel-input-value\"\n                     flex=\"1\"\n                     crop=\"end\"/>\n          <xul:label anonid=\"searchbar-oneoffheader-after\"\n                     flex=\"10000\"\n                     value=\"FROM-DTD-searchWith-label\"/>\n        </xul:hbox>\n        <xul:hbox anonid=\"search-panel-searchonengine\"\n                  class=\"search-panel-current-input\">\n          <xul:label anonid=\"searchbar-oneoffheader-beforeengine\"\n                     value=\"FROM-DTD-search-label\"/>\n          <xul:label anonid=\"searchbar-oneoffheader-engine\"\n                     class=\"search-panel-input-value\"\n                     flex=\"1\"\n                     crop=\"end\"/>\n          <xul:label anonid=\"searchbar-oneoffheader-afterengine\"\n                     flex=\"10000\"\n                     value=\"FROM-DTD-searchAfter-label\"/>\n        </xul:hbox>\n      </xul:deck>\n      <xul:description anonid=\"search-panel-one-offs\"\n                       role=\"group\"\n                       class=\"search-panel-one-offs\"\n                       xbl:inherits=\"compact\">\n        <xul:button anonid=\"search-settings-compact\"\n                    oncommand=\"showSettings();\"\n                    class=\"searchbar-engine-one-off-item search-setting-button-compact\"\n                    tooltiptext=\"FROM-DTD-changeSearchSettings-tooltip\"\n                    xbl:inherits=\"compact\"/>\n      </xul:description>\n      <xul:vbox anonid=\"add-engines\" class=\"search-add-engines\"/>\n      <xul:button anonid=\"search-settings\"\n                  oncommand=\"showSettings();\"\n                  class=\"search-setting-button search-panel-header\"\n                  label=\"FROM-DTD-changeSearchSettings-button\"\n                  xbl:inherits=\"compact\"/>\n      <xul:menupopup anonid=\"search-one-offs-context-menu\">\n        <xul:menuitem anonid=\"search-one-offs-context-open-in-new-tab\"\n                      label=\"FROM-DTD-searchInNewTab-label\"\n                      accesskey=\"FROM-DTD-searchInNewTab-accesskey\"/>\n        <xul:menuitem anonid=\"search-one-offs-context-set-default\"\n                      label=\"FROM-DTD-searchSetAsDefault-label\"\n                      accesskey=\"FROM-DTD-searchSetAsDefault-accesskey\"/>\n      </xul:menupopup>\n    </content>\n\n    <implementation implements=\"nsIDOMEventListener,nsIObserver,nsIWeakReference\">\n\n      <!-- Width in pixels of the one-off buttons.  49px is the min-width of\n           each search engine button, adapt this const when changing the css.\n           It's actually 48px + 1px of right border. -->\n      <property name=\"buttonWidth\" readonly=\"true\" onget=\"return 49;\"/>\n\n      <field name=\"_popup\">null</field>\n\n      <!-- The popup that contains the one-offs.  This is required, so it should\n           never be null or undefined, except possibly before the one-offs are\n           used. -->\n      <property name=\"popup\">\n        <getter><![CDATA[\n          return this._popup;\n        ]]></getter>\n        <setter><![CDATA[\n          let events = [\n            \"popupshowing\",\n            \"popuphidden\",\n          ];\n          if (this._popup) {\n            for (let event of events) {\n              this._popup.removeEventListener(event, this);\n            }\n          }\n          if (val) {\n            for (let event of events) {\n              val.addEventListener(event, this);\n            }\n          }\n          this._popup = val;\n\n          // If the popup is already open, rebuild the one-offs now.  The\n          // popup may be opening, so check that the state is not closed\n          // instead of checking popupOpen.\n          if (val && val.state != \"closed\") {\n            this._rebuild();\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <field name=\"_textbox\">null</field>\n      <field name=\"_textboxWidth\">0</field>\n\n      <!-- The textbox associated with the one-offs.  Set this to a textbox to\n           automatically keep the related one-offs UI up to date.  Otherwise you\n           can leave it null/undefined, and in that case you should update the\n           query property manually. -->\n      <property name=\"textbox\">\n        <getter><![CDATA[\n          return this._textbox;\n        ]]></getter>\n        <setter><![CDATA[\n          if (this._textbox) {\n            this._textbox.removeEventListener(\"input\", this);\n          }\n          if (val) {\n            val.addEventListener(\"input\", this);\n          }\n          return this._textbox = val;\n        ]]></setter>\n      </property>\n\n      <!-- Set this to a string that identifies your one-offs consumer.  It'll\n           be appended to telemetry recorded with maybeRecordTelemetry(). -->\n      <field name=\"telemetryOrigin\">\"\"</field>\n\n      <field name=\"_query\">\"\"</field>\n\n      <!-- The query string currently shown in the one-offs.  If the textbox\n           property is non-null, then this is automatically updated on\n           input. -->\n      <property name=\"query\">\n        <getter><![CDATA[\n          return this._query;\n        ]]></getter>\n        <setter><![CDATA[\n          this._query = val;\n          if (this.popup && this.popup.popupOpen) {\n            this._updateAfterQueryChanged();\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <field name=\"_selectedButton\">null</field>\n\n      <!-- The selected one-off, a xul:button, including the add-engine button\n           and the search-settings button.  Null if no one-off is selected. -->\n      <property name=\"selectedButton\">\n        <getter><![CDATA[\n          return this._selectedButton;\n        ]]></getter>\n        <setter><![CDATA[\n          if (val && val.classList.contains(\"dummy\")) {\n            // Never select dummy buttons.\n            val = null;\n          }\n          if (this._selectedButton) {\n            this._selectedButton.removeAttribute(\"selected\");\n          }\n          if (val) {\n            val.setAttribute(\"selected\", \"true\");\n          }\n          this._selectedButton = val;\n          this._updateStateForButton(null);\n          if (val && !val.engine) {\n            // If the button doesn't have an engine, then clear the popup's\n            // selection to indicate that pressing Return while the button is\n            // selected will do the button's command, not search.\n            this.popup.selectedIndex = -1;\n          }\n          let event = document.createEvent(\"Events\");\n          event.initEvent(\"SelectedOneOffButtonChanged\", true, false);\n          this.dispatchEvent(event);\n          return val;\n        ]]></setter>\n      </property>\n\n      <!-- The index of the selected one-off, including the add-engine button\n           and the search-settings button.  -1 if no one-off is selected. -->\n      <property name=\"selectedButtonIndex\">\n        <getter><![CDATA[\n          let buttons = this.getSelectableButtons(true);\n          for (let i = 0; i < buttons.length; i++) {\n            if (buttons[i] == this._selectedButton) {\n              return i;\n            }\n          }\n          return -1;\n        ]]></getter>\n        <setter><![CDATA[\n          let buttons = this.getSelectableButtons(true);\n          this.selectedButton = buttons[val];\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"compact\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.getAttribute(\"compact\") == \"true\";\n        ]]></getter>\n      </property>\n\n      <field name=\"buttons\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"search-panel-one-offs\");\n      </field>\n      <field name=\"header\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"search-panel-one-offs-header\");\n      </field>\n      <field name=\"addEngines\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"add-engines\");\n      </field>\n      <field name=\"settingsButton\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"search-settings\");\n      </field>\n      <field name=\"settingsButtonCompact\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"search-settings-compact\");\n      </field>\n\n      <field name=\"_bundle\">null</field>\n\n      <property name=\"bundle\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._bundle) {\n            const kBundleURI = \"chrome://browser/locale/search.properties\";\n            this._bundle = Services.strings.createBundle(kBundleURI);\n          }\n          return this._bundle;\n        ]]></getter>\n      </property>\n\n      <!-- When a context menu is opened on a one-off button, this is set to the\n           engine of that button for use with the context menu actions. -->\n      <field name=\"_contextEngine\">null</field>\n\n      <constructor><![CDATA[\n        // Prevent popup events from the context menu from reaching the autocomplete\n        // binding (or other listeners).\n        let menu = document.getAnonymousElementByAttribute(this, \"anonid\", \"search-one-offs-context-menu\");\n        let listener = aEvent => aEvent.stopPropagation();\n        menu.addEventListener(\"popupshowing\", listener);\n        menu.addEventListener(\"popuphiding\", listener);\n        menu.addEventListener(\"popupshown\", aEvent => {\n          this._ignoreMouseEvents = true;\n          aEvent.stopPropagation();\n        });\n        menu.addEventListener(\"popuphidden\", aEvent => {\n          this._ignoreMouseEvents = false;\n          aEvent.stopPropagation();\n        });\n\n        // Add weak referenced observers to invalidate our cached list of engines.\n        Services.prefs.addObserver(\"browser.search.hiddenOneOffs\", this, true);\n        Services.obs.addObserver(this, \"browser-search-engine-modified\", true);\n\n        // Rebuild the buttons when the theme changes.  See bug 1357800 for\n        // details.  Summary: On Linux, switching between themes can cause a row\n        // of buttons to disappear.\n        Services.obs.addObserver(this, \"lightweight-theme-changed\", true);\n      ]]></constructor>\n\n      <!-- This handles events outside the one-off buttons, like on the popup\n           and textbox. -->\n      <method name=\"handleEvent\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          switch (event.type) {\n            case \"input\":\n              // Allow the consumer's input to override its value property with\n              // a oneOffSearchQuery property.  That way if the value is not\n              // actually what the user typed (e.g., it's autofilled, or it's a\n              // mozaction URI), the consumer has some way of providing it.\n              this.query = event.target.oneOffSearchQuery || event.target.value;\n              break;\n            case \"popupshowing\":\n              this._rebuild();\n              break;\n            case \"popuphidden\":\n              Services.tm.dispatchToMainThread(() => {\n                this.selectedButton = null;\n                this._contextEngine = null;\n              });\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"observe\">\n        <parameter name=\"aEngine\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aData\"/>\n        <body><![CDATA[\n          // Make sure the engine list is refetched next time it's needed.\n          this._engines = null;\n        ]]></body>\n      </method>\n\n      <method name=\"showSettings\">\n        <body><![CDATA[\n          BrowserUITelemetry.countSearchSettingsEvent(this.telemetryOrigin);\n\n          openPreferences(\"paneSearch\", {origin: \"contentSearch\"});\n\n          // If the preference tab was already selected, the panel doesn't\n          // close itself automatically.\n          this.popup.hidePopup();\n        ]]></body>\n      </method>\n\n      <!-- Updates the parts of the UI that show the query string. -->\n      <method name=\"_updateAfterQueryChanged\">\n        <body><![CDATA[\n          let headerSearchText =\n            document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                    \"searchbar-oneoffheader-searchtext\");\n          headerSearchText.setAttribute(\"value\", this.query);\n          let groupText;\n          let isOneOffSelected =\n            this.selectedButton &&\n            this.selectedButton.classList.contains(\"searchbar-engine-one-off-item\");\n          // Typing de-selects the settings or opensearch buttons at the bottom\n          // of the search panel, as typing shows the user intends to search.\n          if (this.selectedButton && !isOneOffSelected)\n            this.selectedButton = null;\n          if (this.query) {\n            groupText = headerSearchText.previousSibling.value +\n                        '\"' + headerSearchText.value + '\"' +\n                        headerSearchText.nextSibling.value;\n            if (!isOneOffSelected)\n              this.header.selectedIndex = 1;\n          } else {\n            let noSearchHeader =\n              document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                      \"searchbar-oneoffheader-search\");\n            groupText = noSearchHeader.value;\n            if (!isOneOffSelected)\n              this.header.selectedIndex = 0;\n          }\n          this.buttons.setAttribute(\"aria-label\", groupText);\n        ]]></body>\n      </method>\n\n      <field name=\"_engines\">null</field>\n      <property name=\"engines\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._engines)\n            return this._engines;\n          let currentEngineNameToIgnore;\n          if (!this.getAttribute(\"includecurrentengine\"))\n            currentEngineNameToIgnore = Services.search.currentEngine.name;\n\n          let pref = Services.prefs.getStringPref(\"browser.search.hiddenOneOffs\");\n          let hiddenList = pref ? pref.split(\",\") : [];\n\n          this._engines = Services.search.getVisibleEngines().filter(e => {\n            let name = e.name;\n            return (!currentEngineNameToIgnore ||\n                    name != currentEngineNameToIgnore) &&\n                   !hiddenList.includes(name);\n          });\n\n          return this._engines;\n        ]]></getter>\n      </property>\n\n      <!-- Builds all the UI. -->\n      <method name=\"_rebuild\">\n        <body><![CDATA[\n          // Update the 'Search for <keywords> with:\" header.\n          this._updateAfterQueryChanged();\n\n          // Handle opensearch items. This needs to be done before building the\n          // list of one off providers, as that code will return early if all the\n          // alternative engines are hidden.\n          // Skip this in compact mode, ie. for the urlbar.\n          if (!this.compact)\n            this._rebuildAddEngineList();\n\n          // Check if the one-off buttons really need to be rebuilt.\n          if (this._textbox) {\n            // We can't get a reliable value for the popup width without flushing,\n            // but the popup width won't change if the textbox width doesn't.\n            let DOMUtils = window.QueryInterface(Ci.nsIInterfaceRequestor)\n                                 .getInterface(Ci.nsIDOMWindowUtils);\n            let textboxWidth =\n              DOMUtils.getBoundsWithoutFlushing(this._textbox).width;\n            // We can return early if neither the list of engines nor the panel\n            // width has changed.\n            if (this._engines && this._textboxWidth == textboxWidth) {\n              return;\n            }\n            this._textboxWidth = textboxWidth;\n          }\n\n          // Finally, build the list of one-off buttons.\n          while (this.buttons.firstChild != this.settingsButtonCompact)\n            this.buttons.firstChild.remove();\n          // Remove the trailing empty text node introduced by the binding's\n          // content markup above.\n          if (this.settingsButtonCompact.nextSibling)\n            this.settingsButtonCompact.nextSibling.remove();\n\n          let engines = this.engines;\n          let oneOffCount = engines.length;\n\n          // header is a xul:deck so collapsed doesn't work on it, see bug 589569.\n          this.header.hidden = this.buttons.collapsed = !oneOffCount;\n\n          if (!oneOffCount)\n            return;\n\n          let panelWidth = parseInt(this.popup.clientWidth);\n\n          // There's one weird thing to guard against: when layout pixels\n          // aren't an integral multiple of device pixels, the last button\n          // of each row sometimes gets pushed to the next row, depending on the\n          // panel and button widths.\n          // This is likely because the clientWidth getter rounds the value, but\n          // the panel's border width is not an integer.\n          // As a workaround, decrement the width if the scale is not an integer.\n          let scale = window.QueryInterface(Ci.nsIInterfaceRequestor)\n                            .getInterface(Ci.nsIDOMWindowUtils)\n                            .screenPixelsPerCSSPixel;\n          if (Math.floor(scale) != scale) {\n            --panelWidth;\n          }\n\n          // The + 1 is because the last button doesn't have a right border.\n          let enginesPerRow = Math.floor((panelWidth + 1) / this.buttonWidth);\n          let buttonWidth = Math.floor(panelWidth / enginesPerRow);\n          // There will be an emtpy area of:\n          //   panelWidth - enginesPerRow * buttonWidth  px\n          // at the end of each row.\n\n          // If the <description> tag with the list of search engines doesn't have\n          // a fixed height, the panel will be sized incorrectly, causing the bottom\n          // of the suggestion <tree> to be hidden.\n          if (this.compact)\n            ++oneOffCount;\n          let rowCount = Math.ceil(oneOffCount / enginesPerRow);\n          let height = rowCount * 33; // 32px per row, 1px border.\n          this.buttons.setAttribute(\"height\", height + \"px\");\n\n          // Ensure we can refer to the settings buttons by ID:\n          let origin = this.telemetryOrigin;\n          this.settingsButton.id = origin + \"-anon-search-settings\";\n          this.settingsButtonCompact.id = origin + \"-anon-search-settings-compact\";\n\n          const kXULNS =\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\n          let dummyItems = enginesPerRow - (oneOffCount % enginesPerRow || enginesPerRow);\n          for (let i = 0; i < engines.length; ++i) {\n            let engine = engines[i];\n            let button = document.createElementNS(kXULNS, \"button\");\n            button.id = this._buttonIDForEngine(engine);\n            let uri = \"chrome://browser/skin/search-engine-placeholder.png\";\n            if (engine.iconURI) {\n              uri = engine.iconURI.spec;\n            }\n            button.setAttribute(\"image\", uri);\n            button.setAttribute(\"class\", \"searchbar-engine-one-off-item\");\n            button.setAttribute(\"tooltiptext\", engine.name);\n            button.setAttribute(\"width\", buttonWidth);\n            button.engine = engine;\n\n            if ((i + 1) % enginesPerRow == 0)\n              button.classList.add(\"last-of-row\");\n\n            if (i + 1 == engines.length)\n              button.classList.add(\"last-engine\");\n\n            if (i >= oneOffCount + dummyItems - enginesPerRow)\n              button.classList.add(\"last-row\");\n\n            this.buttons.insertBefore(button, this.settingsButtonCompact);\n          }\n\n          let hasDummyItems = !!dummyItems;\n          while (dummyItems) {\n            let button = document.createElementNS(kXULNS, \"button\");\n            button.setAttribute(\"class\", \"searchbar-engine-one-off-item dummy last-row\");\n            button.setAttribute(\"width\", buttonWidth);\n\n            if (!--dummyItems)\n              button.classList.add(\"last-of-row\");\n\n            this.buttons.insertBefore(button, this.settingsButtonCompact);\n          }\n\n          if (this.compact) {\n            this.settingsButtonCompact.setAttribute(\"width\", buttonWidth);\n            if (rowCount == 1 && hasDummyItems) {\n              // When there's only one row, make the compact settings button\n              // hug the right edge of the panel.  It may not due to the panel's\n              // width not being an integral multiple of the button width.  (See\n              // the \"There will be an emtpy area\" comment above.)  Increase the\n              // width of the last dummy item by the remainder.\n              let remainder = panelWidth - (enginesPerRow * buttonWidth);\n              let width = remainder + buttonWidth;\n              let lastDummyItem = this.settingsButtonCompact.previousSibling;\n              lastDummyItem.setAttribute(\"width\", width);\n            }\n          }\n        ]]></body>\n      </method>\n\n      <!-- If a page offers more than this number of engines, the add-engines\n           menu button is shown, instead of showing the engines directly in the\n           popup. -->\n      <field name=\"_addEngineMenuThreshold\">5</field>\n\n      <method name=\"_rebuildAddEngineList\">\n        <body><![CDATA[\n        let list = this.addEngines;\n        while (list.firstChild) {\n          list.firstChild.remove();\n        }\n\n        // Add a button for each engine that the page in the selected browser\n        // offers, except when there are too many offered engines.\n        // The popup isn't designed to handle too many (by scrolling for\n        // example), so a page could break the popup by offering too many.\n        // Instead, add a single menu button with a submenu of all the engines.\n\n        if (!gBrowser.selectedBrowser.engines) {\n          return;\n        }\n\n        const kXULNS =\n          \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\n        let engines = gBrowser.selectedBrowser.engines;\n        let tooManyEngines = engines.length > this._addEngineMenuThreshold;\n\n        if (tooManyEngines) {\n          // Make the top-level menu button.\n          let button = document.createElementNS(kXULNS, \"button\");\n          list.appendChild(button);\n          button.classList.add(\"addengine-item\");\n          button.setAttribute(\"anonid\", \"addengine-menu-button\");\n          button.setAttribute(\"type\", \"menu\");\n          button.setAttribute(\"label\",\n            this.bundle.GetStringFromName(\"cmd_addFoundEngineMenu\"));\n          button.setAttribute(\"crop\", \"end\");\n          button.setAttribute(\"pack\", \"start\");\n\n          // Set the menu button's image to the image of the first engine.  The\n          // offered engines may have differing images, so there's no perfect\n          // choice here.\n          let engine = engines[0];\n          if (engine.icon) {\n            button.setAttribute(\"image\", engine.icon);\n          }\n\n          // Now make the button's child menupopup.\n          list = document.createElementNS(kXULNS, \"menupopup\");\n          button.appendChild(list);\n          list.setAttribute(\"anonid\", \"addengine-menu\");\n          list.setAttribute(\"position\", \"topright topleft\");\n\n          // Events from child menupopups bubble up to the autocomplete binding,\n          // which breaks it, so prevent these events from propagating.\n          let suppressEventTypes = [\n            \"popupshowing\",\n            \"popuphiding\",\n            \"popupshown\",\n            \"popuphidden\",\n          ];\n          for (let type of suppressEventTypes) {\n            list.addEventListener(type, event => {\n              event.stopPropagation();\n            });\n          }\n        }\n\n        // Finally, add the engines to the list.  If there aren't too many\n        // engines, the list is the add-engines vbox.  Otherwise it's the\n        // menupopup created earlier.  In the latter case, create menuitem\n        // elements instead of buttons, because buttons don't get keyboard\n        // handling for free inside menupopups.\n        let eltType = tooManyEngines ? \"menuitem\" : \"button\";\n        for (let engine of engines) {\n          let button = document.createElementNS(kXULNS, eltType);\n          button.classList.add(\"addengine-item\");\n          button.id = this.telemetryOrigin + \"-add-engine-\" +\n                      this._fixUpEngineNameForID(engine.title);\n          let label = this.bundle.formatStringFromName(\"cmd_addFoundEngine\",\n                                                       [engine.title], 1);\n          button.setAttribute(\"label\", label);\n          button.setAttribute(\"crop\", \"end\");\n          button.setAttribute(\"tooltiptext\", engine.title + \"\\n\" + engine.uri);\n          button.setAttribute(\"uri\", engine.uri);\n          button.setAttribute(\"title\", engine.title);\n          if (engine.icon) {\n            button.setAttribute(\"image\", engine.icon);\n          }\n          if (tooManyEngines) {\n            button.classList.add(\"menuitem-iconic\");\n          } else {\n            button.setAttribute(\"pack\", \"start\");\n          }\n          list.appendChild(button);\n        }\n        ]]></body>\n      </method>\n\n      <method name=\"_buttonIDForEngine\">\n        <parameter name=\"engine\"/>\n        <body><![CDATA[\n          return this.telemetryOrigin + \"-engine-one-off-item-\" +\n                 this._fixUpEngineNameForID(engine.name);\n        ]]></body>\n      </method>\n\n      <method name=\"_fixUpEngineNameForID\">\n        <parameter name=\"name\"/>\n        <body><![CDATA[\n          return name.replace(/ /g, \"-\");\n        ]]></body>\n      </method>\n\n      <method name=\"_buttonForEngine\">\n        <parameter name=\"engine\"/>\n        <body><![CDATA[\n          return document.getElementById(this._buttonIDForEngine(engine));\n        ]]></body>\n      </method>\n\n      <!--\n        Updates the popup and textbox for the currently selected or moused-over\n        button.\n\n        @param mousedOverButton\n               The currently moused-over button, or null if there isn't one.\n      -->\n      <method name=\"_updateStateForButton\">\n        <parameter name=\"mousedOverButton\"/>\n        <body><![CDATA[\n          let button = mousedOverButton;\n\n          // Ignore dummy buttons.\n          if (button && button.classList.contains(\"dummy\")) {\n            button = null;\n          }\n\n          // If there's no moused-over button, then the one-offs should reflect\n          // the selected button, if any.\n          button = button || this.selectedButton;\n\n          if (!button) {\n            this.header.selectedIndex = this.query ? 1 : 0;\n            if (this.textbox) {\n              this.textbox.removeAttribute(\"aria-activedescendant\");\n            }\n            return;\n          }\n\n          if (button.classList.contains(\"searchbar-engine-one-off-item\") &&\n              button.engine) {\n            let headerEngineText =\n              document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                      \"searchbar-oneoffheader-engine\");\n            this.header.selectedIndex = 2;\n            headerEngineText.value = button.engine.name;\n          } else {\n            this.header.selectedIndex = this.query ? 1 : 0;\n          }\n          if (this.textbox) {\n            this.textbox.setAttribute(\"aria-activedescendant\", button.id);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"getSelectableButtons\">\n        <parameter name=\"aIncludeNonEngineButtons\"/>\n        <body><![CDATA[\n          let buttons = [];\n          for (let oneOff = this.buttons.firstChild; oneOff; oneOff = oneOff.nextSibling) {\n            // oneOff may be a text node since the list xul:description contains\n            // whitespace and the compact settings button.  See the markup\n            // above.  _rebuild removes text nodes, but it may not have been\n            // called yet (because e.g. the popup hasn't been opened yet).\n            if (oneOff.nodeType == Node.ELEMENT_NODE) {\n              if (oneOff.classList.contains(\"dummy\") ||\n                  oneOff.classList.contains(\"search-setting-button-compact\"))\n                break;\n              buttons.push(oneOff);\n            }\n          }\n\n          if (aIncludeNonEngineButtons) {\n            for (let addEngine = this.addEngines.firstChild; addEngine; addEngine = addEngine.nextSibling) {\n              buttons.push(addEngine);\n            }\n            buttons.push(this.compact ? this.settingsButtonCompact : this.settingsButton);\n          }\n\n          return buttons;\n        ]]></body>\n      </method>\n\n      <method name=\"handleSearchCommand\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aEngine\"/>\n        <parameter name=\"aForceNewTab\"/>\n        <body><![CDATA[\n          let where = \"current\";\n          let params;\n\n          // Open ctrl/cmd clicks on one-off buttons in a new background tab.\n          if (aForceNewTab) {\n            where = \"tab\";\n            if (Services.prefs.getBoolPref(\"browser.tabs.loadInBackground\")) {\n              params = {\n                inBackground: true,\n              };\n            }\n          } else {\n            var newTabPref = Services.prefs.getBoolPref(\"browser.search.openintab\");\n            if (((aEvent instanceof KeyboardEvent) && aEvent.altKey) ^ newTabPref)\n              where = \"tab\";\n            if ((aEvent instanceof MouseEvent) &&\n                (aEvent.button == 1 || aEvent.getModifierState(\"Accel\"))) {\n              where = \"tab\";\n              params = {\n                inBackground: true,\n              };\n            }\n          }\n\n          this.popup.handleOneOffSearch(aEvent, aEngine, where, params);\n        ]]></body>\n      </method>\n\n      <!--\n        Increments or decrements the index of the currently selected one-off.\n\n        @param aForward\n               If true, the index is incremented, and if false, the index is\n               decremented.\n        @param aIncludeNonEngineButtons\n               If true, non-dummy buttons that do not have engines are included.\n               These buttons include the OpenSearch and settings buttons.  For\n               example, if the currently selected button is an engine button,\n               the next button is the settings button, and you pass true for\n               aForward, then passing true for this value would cause the\n               settings to be selected.  Passing false for this value would\n               cause the selection to clear or wrap around, depending on what\n               value you passed for the aWrapAround parameter.\n        @param aWrapAround\n               If true, the selection wraps around between the first and last\n               buttons.\n        @return True if the selection can continue to advance after this method\n                returns and false if not.\n      -->\n      <method name=\"advanceSelection\">\n        <parameter name=\"aForward\"/>\n        <parameter name=\"aIncludeNonEngineButtons\"/>\n        <parameter name=\"aWrapAround\"/>\n        <body><![CDATA[\n          let buttons = this.getSelectableButtons(aIncludeNonEngineButtons);\n          let index;\n          if (this.selectedButton) {\n            let inc = aForward ? 1 : -1;\n            let oldIndex = buttons.indexOf(this.selectedButton);\n            index = ((oldIndex + inc) + buttons.length) % buttons.length;\n            if (!aWrapAround &&\n                ((aForward && index <= oldIndex) ||\n                 (!aForward && oldIndex <= index))) {\n              // The index has wrapped around, but wrapping around isn't\n              // allowed.\n              index = -1;\n            }\n          } else {\n            index = aForward ? 0 : buttons.length - 1;\n          }\n          this.selectedButton = index < 0 ? null : buttons[index];\n        ]]></body>\n      </method>\n\n      <!--\n        This handles key presses specific to the one-off buttons like Tab and\n        Alt+Up/Down, and Up/Down keys within the buttons.  Since one-off buttons\n        are always used in conjunction with a list of some sort (in this.popup),\n        it also handles Up/Down keys that cross the boundaries between list\n        items and the one-off buttons.\n\n        If this method handles the key press, then event.defaultPrevented will\n        be true when it returns.\n\n        @param event\n               The key event.\n        @param numListItems\n               The number of items in the list.  The reason that this is a\n               parameter at all is that the list may contain items at the end\n               that should be ignored, depending on the consumer.  That's true\n               for the urlbar for example.\n        @param allowEmptySelection\n               Pass true if it's OK that neither the list nor the one-off\n               buttons contains a selection.  Pass false if either the list or\n               the one-off buttons (or both) should always contain a selection.\n        @param textboxUserValue\n               When the last list item is selected and the user presses Down,\n               the first one-off becomes selected and the textbox value is\n               restored to the value that the user typed.  Pass that value here.\n               However, if you pass true for allowEmptySelection, you don't need\n               to pass anything for this parameter.  (Pass undefined or null.)\n      -->\n      <method name=\"handleKeyPress\">\n        <parameter name=\"event\"/>\n        <parameter name=\"numListItems\"/>\n        <parameter name=\"allowEmptySelection\"/>\n        <parameter name=\"textboxUserValue\"/>\n        <body><![CDATA[\n          if (!this.popup) {\n            return;\n          }\n          let handled = this._handleKeyPress(event, numListItems,\n                                             allowEmptySelection,\n                                             textboxUserValue);\n          if (handled) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_handleKeyPress\">\n        <parameter name=\"event\"/>\n        <parameter name=\"numListItems\"/>\n        <parameter name=\"allowEmptySelection\"/>\n        <parameter name=\"textboxUserValue\"/>\n        <body><![CDATA[\n          if (event.keyCode == KeyEvent.DOM_VK_RIGHT &&\n              this.selectedButton &&\n              this.selectedButton.getAttribute(\"anonid\") ==\n                \"addengine-menu-button\") {\n            // If the add-engine overflow menu item is selected and the user\n            // presses the right arrow key, open the submenu.  Unfortunately\n            // handling the left arrow key -- to close the popup -- isn't\n            // straightforward.  Once the popup is open, it consumes all key\n            // events.  Setting ignorekeys=handled on it doesn't help, since the\n            // popup handles all arrow keys.  Setting ignorekeys=true on it does\n            // mean that the popup no longer consumes the left arrow key, but\n            // then it no longer handles up/down keys to select items in the\n            // popup.\n            this.selectedButton.open = true;\n            return true;\n          }\n\n          // Handle the Tab key, but only if non-Shift modifiers aren't also\n          // pressed to avoid clobbering other shortcuts (like the Alt+Tab\n          // browser tab switcher).  The reason this uses getModifierState() and\n          // checks for \"AltGraph\" is that when you press Shift-Alt-Tab,\n          // event.altKey is actually false for some reason, at least on macOS.\n          // getModifierState(\"Alt\") is also false, but \"AltGraph\" is true.\n          if (event.keyCode == KeyEvent.DOM_VK_TAB &&\n              !event.getModifierState(\"Alt\") &&\n              !event.getModifierState(\"AltGraph\") &&\n              !event.getModifierState(\"Control\") &&\n              !event.getModifierState(\"Meta\")) {\n            if (this.getAttribute(\"disabletab\") == \"true\" ||\n                (event.shiftKey &&\n                  this.selectedButtonIndex <= 0) ||\n                (!event.shiftKey &&\n                 this.selectedButtonIndex ==\n                   this.getSelectableButtons(true).length - 1)) {\n              this.selectedButton = null;\n              return false;\n            }\n            this.popup.selectedIndex = -1;\n            this.advanceSelection(!event.shiftKey, true, false);\n            return !!this.selectedButton;\n          }\n\n          if (event.keyCode == Ci.nsIDOMKeyEvent.DOM_VK_UP) {\n            if (event.altKey) {\n              // Keep the currently selected result in the list (if any) as a\n              // secondary \"alt\" selection and move the selection up within the\n              // buttons.\n              this.advanceSelection(false, false, false);\n              return true;\n            }\n            if (numListItems == 0) {\n              this.advanceSelection(false, true, false);\n              return true;\n            }\n            if (this.popup.selectedIndex > 0) {\n              // Moving up within the list.  The autocomplete controller should\n              // handle this case.  A button may be selected, so null it.\n              this.selectedButton = null;\n              return false;\n            }\n            if (this.popup.selectedIndex == 0) {\n              // Moving up from the top of the list.\n              if (allowEmptySelection) {\n                // Let the autocomplete controller remove selection in the list\n                // and revert the typed text in the textbox.\n                return false;\n              }\n              // Wrap selection around to the last button.\n              if (this.textbox && typeof(textboxUserValue) == \"string\") {\n                this.textbox.value = textboxUserValue;\n              }\n              this.advanceSelection(false, true, true);\n              return true;\n            }\n            if (!this.selectedButton) {\n              // Moving up from no selection in the list or the buttons, back\n              // down to the last button.\n              this.advanceSelection(false, true, true);\n              return true;\n            }\n            if (this.selectedButtonIndex == 0) {\n              // Moving up from the buttons to the bottom of the list.\n              this.selectedButton = null;\n              return false;\n            }\n            // Moving up/left within the buttons.\n            this.advanceSelection(false, true, false);\n            return true;\n          }\n\n          if (event.keyCode == Ci.nsIDOMKeyEvent.DOM_VK_DOWN) {\n            if (event.altKey) {\n              // Keep the currently selected result in the list (if any) as a\n              // secondary \"alt\" selection and move the selection down within\n              // the buttons.\n              this.advanceSelection(true, false, false);\n              return true;\n            }\n            if (numListItems == 0) {\n              this.advanceSelection(true, true, false);\n              return true;\n            }\n            if (this.popup.selectedIndex >= 0 &&\n                this.popup.selectedIndex < numListItems - 1) {\n              // Moving down within the list.  The autocomplete controller\n              // should handle this case.  A button may be selected, so null it.\n              this.selectedButton = null;\n              return false;\n            }\n            if (this.popup.selectedIndex == numListItems - 1) {\n              // Moving down from the last item in the list to the buttons.\n              this.selectedButtonIndex = 0;\n              if (allowEmptySelection) {\n                // Let the autocomplete controller remove selection in the list\n                // and revert the typed text in the textbox.\n                return false;\n              }\n              if (this.textbox && typeof(textboxUserValue) == \"string\") {\n                this.textbox.value = textboxUserValue;\n              }\n              this.popup.selectedIndex = -1;\n              return true;\n            }\n            if (this.selectedButton) {\n              let buttons = this.getSelectableButtons(true);\n              if (this.selectedButtonIndex == buttons.length - 1) {\n                // Moving down from the buttons back up to the top of the list.\n                this.selectedButton = null;\n                if (allowEmptySelection) {\n                  // Prevent the selection from wrapping around to the top of\n                  // the list by returning true, since the list currently has no\n                  // selection.  Nothing should be selected after handling this\n                  // Down key.\n                  return true;\n                }\n                return false;\n              }\n              // Moving down/right within the buttons.\n              this.advanceSelection(true, true, false);\n              return true;\n            }\n            return false;\n          }\n\n          if (event.keyCode == Ci.nsIDOMKeyEvent.DOM_VK_LEFT) {\n            if (this.selectedButton &&\n                (this.compact || this.selectedButton.engine)) {\n              // Moving left within the buttons.\n              this.advanceSelection(false, this.compact, true);\n              return true;\n            }\n            return false;\n          }\n\n          if (event.keyCode == Ci.nsIDOMKeyEvent.DOM_VK_RIGHT) {\n            if (this.selectedButton &&\n                (this.compact || this.selectedButton.engine)) {\n              // Moving right within the buttons.\n              this.advanceSelection(true, this.compact, true);\n              return true;\n            }\n            return false;\n          }\n\n          return false;\n        ]]></body>\n      </method>\n\n      <!--\n        If the given event is related to the one-offs, this method records\n        one-off telemetry for it.  this.telemetryOrigin will be appended to the\n        computed source, so make sure you set that first.\n\n        @param aEvent\n               An event, like a click on a one-off button.\n        @param aOpenUILinkWhere\n               The \"where\" passed to openUILink.\n        @param aOpenUILinkParams\n               The \"params\" passed to openUILink.\n        @return True if telemetry was recorded and false if not.\n      -->\n      <method name=\"maybeRecordTelemetry\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aOpenUILinkWhere\"/>\n        <parameter name=\"aOpenUILinkParams\"/>\n        <body><![CDATA[\n          if (!aEvent) {\n            return false;\n          }\n\n          let source = null;\n          let type = \"unknown\";\n          let engine = null;\n          let target = aEvent.originalTarget;\n\n          if (aEvent instanceof KeyboardEvent) {\n            type = \"key\";\n            if (this.selectedButton) {\n              source = \"oneoff\";\n              engine = this.selectedButton.engine;\n            }\n          } else if (aEvent instanceof MouseEvent) {\n            type = \"mouse\";\n            if (target.classList.contains(\"searchbar-engine-one-off-item\")) {\n              source = \"oneoff\";\n              engine = target.engine;\n            }\n          } else if ((aEvent instanceof XULCommandEvent) &&\n                     target.getAttribute(\"anonid\") ==\n                       \"search-one-offs-context-open-in-new-tab\") {\n            source = \"oneoff-context\";\n            engine = this._contextEngine;\n          }\n\n          if (!source) {\n            return false;\n          }\n\n          if (this.telemetryOrigin) {\n            source += \"-\" + this.telemetryOrigin;\n          }\n\n          let tabBackground = aOpenUILinkWhere == \"tab\" &&\n                              aOpenUILinkParams &&\n                              aOpenUILinkParams.inBackground;\n          let where = tabBackground ? \"tab-background\" : aOpenUILinkWhere;\n          BrowserSearch.recordOneoffSearchInTelemetry(engine, source, type,\n                                                      where);\n          return true;\n        ]]></body>\n      </method>\n\n      <!-- All this stuff is to make the add-engines menu button behave like an\n           actual menu.  The add-engines menu button is shown when there are\n           many engines offered by the current site. -->\n      <field name=\"_addEngineMenuTimeoutMs\">200</field>\n      <field name=\"_addEngineMenuTimeout\">null</field>\n      <field name=\"_addEngineMenuShouldBeOpen\">false</field>\n\n      <method name=\"_resetAddEngineMenuTimeout\">\n        <body><![CDATA[\n        if (this._addEngineMenuTimeout) {\n          clearTimeout(this._addEngineMenuTimeout);\n        }\n        this._addEngineMenuTimeout = setTimeout(() => {\n          delete this._addEngineMenuTimeout;\n          let button = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"addengine-menu-button\"\n          );\n          button.open = this._addEngineMenuShouldBeOpen;\n        }, this._addEngineMenuTimeoutMs);\n        ]]></body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n\n      <handler event=\"mousedown\"><![CDATA[\n        let target = event.originalTarget;\n        if (target.getAttribute(\"anonid\") == \"addengine-menu-button\") {\n          return;\n        }\n        // Required to receive click events from the buttons on Linux.\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"mousemove\"><![CDATA[\n        let target = event.originalTarget;\n\n        // Handle mouseover on the add-engine menu button and its popup items.\n        if (target.getAttribute(\"anonid\") == \"addengine-menu-button\" ||\n            (target.localName == \"menuitem\" &&\n             target.classList.contains(\"addengine-item\"))) {\n          let menuButton = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"addengine-menu-button\"\n          );\n          this._updateStateForButton(menuButton);\n          this._addEngineMenuShouldBeOpen = true;\n          this._resetAddEngineMenuTimeout();\n          return;\n        }\n\n        if (target.localName != \"button\")\n          return;\n\n        // Ignore mouse events when the context menu is open.\n         if (this._ignoreMouseEvents)\n           return;\n\n        let isOneOff =\n          target.classList.contains(\"searchbar-engine-one-off-item\") &&\n          !target.classList.contains(\"dummy\");\n        if (isOneOff ||\n            target.classList.contains(\"addengine-item\") ||\n            target.classList.contains(\"search-setting-button\")) {\n          this._updateStateForButton(target);\n        }\n      ]]></handler>\n\n      <handler event=\"mouseout\"><![CDATA[\n\n        let target = event.originalTarget;\n\n        // Handle mouseout on the add-engine menu button and its popup items.\n        if (target.getAttribute(\"anonid\") == \"addengine-menu-button\" ||\n            (target.localName == \"menuitem\" &&\n             target.classList.contains(\"addengine-item\"))) {\n          this._updateStateForButton(null);\n          this._addEngineMenuShouldBeOpen = false;\n          this._resetAddEngineMenuTimeout();\n          return;\n        }\n\n        if (target.localName != \"button\") {\n          return;\n        }\n\n        // Don't update the mouseover state if the context menu is open.\n        if (this._ignoreMouseEvents)\n          return;\n\n        this._updateStateForButton(null);\n      ]]></handler>\n\n      <handler event=\"click\"><![CDATA[\n        if (event.button == 2)\n          return; // ignore right clicks.\n\n        let button = event.originalTarget;\n        let engine = button.engine;\n\n        if (!engine)\n          return;\n\n        // Select the clicked button so that consumers can easily tell which\n        // button was acted on.\n        this.selectedButton = button;\n        this.handleSearchCommand(event, engine);\n      ]]></handler>\n\n      <handler event=\"command\"><![CDATA[\n        let target = event.originalTarget;\n        if (target.classList.contains(\"addengine-item\")) {\n          // On success, hide the panel and tell event listeners to reshow it to\n          // show the new engine.\n          let installCallback = {\n            onSuccess: engine => {\n              this._rebuild();\n            },\n            onError(errorCode) {\n              if (errorCode != Ci.nsISearchInstallCallback.ERROR_DUPLICATE_ENGINE) {\n                // Download error is shown by the search service\n                return;\n              }\n              const kSearchBundleURI = \"chrome://global/locale/search/search.properties\";\n              let searchBundle = Services.strings.createBundle(kSearchBundleURI);\n              let brandBundle = document.getElementById(\"bundle_brand\");\n              let brandName = brandBundle.getString(\"brandShortName\");\n              let title = searchBundle.GetStringFromName(\"error_invalid_engine_title\");\n              let text = searchBundle.formatStringFromName(\"error_duplicate_engine_msg\",\n                                                           [brandName, target.getAttribute(\"uri\")], 2);\n              Services.prompt.QueryInterface(Ci.nsIPromptFactory);\n              let prompt = Services.prompt.getPrompt(gBrowser.contentWindow, Ci.nsIPrompt);\n              prompt.QueryInterface(Ci.nsIWritablePropertyBag2);\n              prompt.setPropertyAsBool(\"allowTabModal\", true);\n              prompt.alert(title, text);\n            }\n          }\n          Services.search.addEngine(target.getAttribute(\"uri\"), null,\n                                    target.getAttribute(\"image\"), false,\n                                    installCallback);\n        }\n        let anonid = target.getAttribute(\"anonid\");\n        if (anonid == \"search-one-offs-context-open-in-new-tab\") {\n          // Select the context-clicked button so that consumers can easily\n          // tell which button was acted on.\n          this.selectedButton = this._buttonForEngine(this._contextEngine);\n          this.handleSearchCommand(event, this._contextEngine, true);\n        }\n        if (anonid == \"search-one-offs-context-set-default\") {\n          let currentEngine = Services.search.currentEngine;\n\n          if (!this.getAttribute(\"includecurrentengine\")) {\n            // Make the target button of the context menu reflect the current\n            // search engine first. Doing this as opposed to rebuilding all the\n            // one-off buttons avoids flicker.\n            let button = this._buttonForEngine(this._contextEngine);\n            button.id = this._buttonIDForEngine(currentEngine);\n            let uri = \"chrome://browser/skin/search-engine-placeholder.png\";\n            if (currentEngine.iconURI)\n              uri = currentEngine.iconURI.spec;\n            button.setAttribute(\"image\", uri);\n            button.setAttribute(\"tooltiptext\", currentEngine.name);\n            button.engine = currentEngine;\n          }\n\n          Services.search.currentEngine = this._contextEngine;\n        }\n      ]]></handler>\n\n      <handler event=\"contextmenu\"><![CDATA[\n        let target = event.originalTarget;\n        // Prevent the context menu from appearing except on the one off buttons.\n        if (!target.classList.contains(\"searchbar-engine-one-off-item\") ||\n            target.classList.contains(\"dummy\")) {\n          event.preventDefault();\n          return;\n        }\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"search-one-offs-context-set-default\")\n                .setAttribute(\"disabled\", target.engine == Services.search.currentEngine);\n\n        this._contextEngine = target.engine;\n      ]]></handler>\n    </handlers>\n\n  </binding>\n\n</bindings>\n"},{"file":"translation-infobar.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- eslint-env mozilla/browser-window -->\n\n<!DOCTYPE bindings [\n<!ENTITY % notificationDTD SYSTEM \"chrome://global/locale/notification.dtd\">\n%notificationDTD;\n<!ENTITY % translationDTD SYSTEM \"chrome://browser/locale/translation.dtd\" >\n%translationDTD;\n]>\n\n<bindings id=\"translationBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n  <binding id=\"translationbar\" extends=\"chrome://global/content/bindings/notification.xml#notification\" role=\"xul:alert\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/notification.css\"/>\n    </resources>\n    <content>\n      <xul:hbox class=\"notification-inner\" flex=\"1\" xbl:inherits=\"type\">\n        <xul:hbox anonid=\"details\" align=\"center\" flex=\"1\">\n          <xul:image class=\"translate-infobar-element messageImage\"\n                     anonid=\"messageImage\"/>\n          <xul:panel anonid=\"welcomePanel\" class=\"translation-welcome-panel\"\n                     type=\"arrow\" align=\"start\">\n            <xul:image class=\"translation-welcome-logo\"/>\n            <xul:vbox flex=\"1\" class=\"translation-welcome-content\">\n              <xul:description class=\"translation-welcome-headline\"\n                               anonid=\"welcomeHeadline\"/>\n              <xul:description class=\"translation-welcome-body\" anonid=\"welcomeBody\"/>\n              <xul:hbox align=\"center\">\n                <xul:label anonid=\"learnMore\" class=\"plain text-link\"\n                           onclick=\"openUILinkIn('https://support.mozilla.org/kb/automatic-translation', 'tab'); this.parentNode.parentNode.parentNode.hidePopup();\"/>\n                <xul:spacer flex=\"1\"/>\n                <xul:button class=\"translate-infobar-element\" anonid=\"thanksButton\"\n                            onclick=\"this.parentNode.parentNode.parentNode.hidePopup();\"/>\n              </xul:hbox>\n            </xul:vbox>\n          </xul:panel>\n          <xul:deck anonid=\"translationStates\" selectedIndex=\"0\">\n\n            <!-- offer to translate -->\n            <xul:hbox class=\"translate-offer-box\" align=\"center\">\n              <xul:label class=\"translate-infobar-element\" value=\"FROM-DTD-translation-thisPageIsIn-label\"/>\n              <xul:menulist class=\"translate-infobar-element\" anonid=\"detectedLanguage\">\n                <xul:menupopup/>\n              </xul:menulist>\n              <xul:label class=\"translate-infobar-element\" value=\"FROM-DTD-translation-translateThisPage-label\"/>\n              <xul:button class=\"translate-infobar-element\"\n                          label=\"FROM-DTD-translation-translate-button\"\n                          anonid=\"translate\"\n                          oncommand=\"document.getBindingParent(this).translate();\"/>\n              <xul:button class=\"translate-infobar-element\"\n                          label=\"FROM-DTD-translation-notNow-button\" anonid=\"notNow\"\n                          oncommand=\"document.getBindingParent(this).closeCommand();\"/>\n            </xul:hbox>\n\n            <!-- translating -->\n            <xul:vbox class=\"translating-box\" pack=\"center\">\n              <xul:label class=\"translate-infobar-element\"\n                         value=\"FROM-DTD-translation-translatingContent-label\"/>\n            </xul:vbox>\n\n            <!-- translated -->\n            <xul:hbox class=\"translated-box\" align=\"center\">\n              <xul:label class=\"translate-infobar-element\"\n                         value=\"FROM-DTD-translation-translatedFrom-label\"/>\n              <xul:menulist class=\"translate-infobar-element\"\n                            anonid=\"fromLanguage\"\n                            oncommand=\"document.getBindingParent(this).translate()\">\n                <xul:menupopup/>\n              </xul:menulist>\n              <xul:label class=\"translate-infobar-element\"\n                         value=\"FROM-DTD-translation-translatedTo-label\"/>\n              <xul:menulist class=\"translate-infobar-element\"\n                            anonid=\"toLanguage\"\n                            oncommand=\"document.getBindingParent(this).translate()\">\n                <xul:menupopup/>\n              </xul:menulist>\n              <xul:label class=\"translate-infobar-element\"\n                         value=\"FROM-DTD-translation-translatedToSuffix-label\"/>\n              <xul:button anonid=\"showOriginal\"\n                          class=\"translate-infobar-element\"\n                          label=\"FROM-DTD-translation-showOriginal-button\"\n                          oncommand=\"document.getBindingParent(this).showOriginal();\"/>\n              <xul:button anonid=\"showTranslation\"\n                          class=\"translate-infobar-element\"\n                          label=\"FROM-DTD-translation-showTranslation-button\"\n                          oncommand=\"document.getBindingParent(this).showTranslation();\"/>\n            </xul:hbox>\n\n            <!-- error -->\n            <xul:hbox class=\"translation-error\" align=\"center\">\n              <xul:label class=\"translate-infobar-element\"\n                         value=\"FROM-DTD-translation-errorTranslating-label\"/>\n              <xul:button class=\"translate-infobar-element\"\n                          label=\"FROM-DTD-translation-tryAgain-button\"\n                          anonid=\"tryAgain\"\n                          oncommand=\"document.getBindingParent(this).translate();\"/>\n            </xul:hbox>\n\n            <!-- unavailable -->\n            <xul:vbox class=\"translation-unavailable\" pack=\"center\">\n              <xul:label class=\"translate-infobar-element\"\n                         value=\"FROM-DTD-translation-serviceUnavailable-label\"/>\n            </xul:vbox>\n\n          </xul:deck>\n          <xul:spacer flex=\"1\"/>\n\n          <xul:button type=\"menu\"\n                      class=\"translate-infobar-element options-menu-button\"\n                      anonid=\"options\"\n                      label=\"FROM-DTD-translation-options-menu\">\n            <xul:menupopup class=\"translation-menupopup cui-widget-panel cui-widget-panelview\n                                  cui-widget-panelWithFooter PanelUI-subView\"\n                           onpopupshowing=\"document.getBindingParent(this).optionsShowing();\">\n              <xul:menuitem anonid=\"neverForLanguage\"\n                            oncommand=\"document.getBindingParent(this).neverForLanguage();\"/>\n              <xul:menuitem anonid=\"neverForSite\"\n                            oncommand=\"document.getBindingParent(this).neverForSite();\"\n                            label=\"FROM-DTD-translation-options-neverForSite-label\"\n                            accesskey=\"FROM-DTD-translation-options-neverForSite-accesskey\"/>\n              <xul:menuseparator/>\n              <xul:menuitem oncommand=\"openPreferences('paneGeneral', {origin:'translationInfobar'});\"\n                            label=\"FROM-DTD-translation-options-preferences-label\"\n                            accesskey=\"FROM-DTD-translation-options-preferences-accesskey\"/>\n              <xul:menuitem class=\"subviewbutton panel-subview-footer\"\n                            oncommand=\"document.getBindingParent(this).openProviderAttribution();\">\n                <xul:deck anonid=\"translationEngine\" selectedIndex=\"0\">\n                  <xul:hbox class=\"translation-attribution\">\n                    <xul:label>FROM-DTD-translation-options-attribution-beforeLogo</xul:label>\n                    <xul:image src=\"chrome://browser/content/microsoft-translator-attribution.png\"\n                               aria-label=\"Microsoft Translator\"/>\n                    <xul:label>FROM-DTD-translation-options-attribution-afterLogo</xul:label>\n                  </xul:hbox>\n                  <xul:label class=\"translation-attribution\">FROM-DTD-translation-options-attribution-yandexTranslate</xul:label>\n                </xul:deck>\n              </xul:menuitem>\n            </xul:menupopup>\n          </xul:button>\n\n        </xul:hbox>\n        <xul:toolbarbutton ondblclick=\"event.stopPropagation();\"\n                           anonid=\"closeButton\"\n                           class=\"messageCloseButton close-icon tabbable\"\n                           xbl:inherits=\"hidden=hideclose\"\n                           tooltiptext=\"FROM-DTD-closeNotification-tooltip\"\n                           oncommand=\"document.getBindingParent(this).closeCommand();\"/>\n      </xul:hbox>\n    </content>\n    <implementation>\n      <property name=\"state\"\n                onget=\"return this._getAnonElt('translationStates').selectedIndex;\">\n        <setter>\n          <![CDATA[\n          let deck = this._getAnonElt(\"translationStates\");\n\n          let activeElt = document.activeElement;\n          if (activeElt && deck.contains(activeElt))\n            activeElt.blur();\n\n          let stateName;\n          for (let name of [\"OFFER\", \"TRANSLATING\", \"TRANSLATED\", \"ERROR\"]) {\n            if (Translation[\"STATE_\" + name] == val) {\n              stateName = name.toLowerCase();\n              break;\n            }\n          }\n          this.setAttribute(\"state\", stateName);\n\n          if (val == Translation.STATE_TRANSLATED)\n            this._handleButtonHiding();\n\n          deck.selectedIndex = val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"init\">\n        <parameter name=\"aTranslation\"/>\n        <body>\n          <![CDATA[\n            this.translation = aTranslation;\n            let bundle = Services.strings.createBundle(\"chrome://global/locale/languageNames.properties\");\n            let sortByLocalizedName = function(aList) {\n              return aList.map(code => [code, bundle.GetStringFromName(code)])\n                          .sort((a, b) => a[1].localeCompare(b[1]));\n            };\n\n            // Fill the lists of supported source languages.\n            let detectedLanguage = this._getAnonElt(\"detectedLanguage\");\n            let fromLanguage = this._getAnonElt(\"fromLanguage\");\n            let sourceLanguages =\n              sortByLocalizedName(Translation.supportedSourceLanguages);\n            for (let [code, name] of sourceLanguages) {\n              detectedLanguage.appendItem(name, code);\n              fromLanguage.appendItem(name, code);\n            }\n            detectedLanguage.value = this.translation.detectedLanguage;\n\n            // translatedFrom is only set if we have already translated this page.\n            if (aTranslation.translatedFrom)\n              fromLanguage.value = aTranslation.translatedFrom;\n\n            // Fill the list of supported target languages.\n            let toLanguage = this._getAnonElt(\"toLanguage\");\n            let targetLanguages =\n              sortByLocalizedName(Translation.supportedTargetLanguages);\n            for (let [code, name] of targetLanguages)\n              toLanguage.appendItem(name, code);\n\n            if (aTranslation.translatedTo)\n              toLanguage.value = aTranslation.translatedTo;\n\n            if (aTranslation.state)\n              this.state = aTranslation.state;\n\n            // Show attribution for the preferred translator.\n            let engineIndex = Object.keys(Translation.supportedEngines)\n              .indexOf(Translation.translationEngine);\n            if (engineIndex != -1) {\n              this._getAnonElt(\"translationEngine\").selectedIndex = engineIndex;\n            }\n\n            const kWelcomePref = \"browser.translation.ui.welcomeMessageShown\";\n            if (Services.prefs.prefHasUserValue(kWelcomePref) ||\n                this.translation.browser != gBrowser.selectedBrowser)\n              return;\n\n            this.addEventListener(\"transitionend\", function() {\n              // These strings are hardcoded because they need to reach beta\n              // without riding the trains.\n              let localizedStrings = {\n                en: [\"Hey look! It's something new!\",\n                     \"Now the Web is even more accessible with our new in-page translation feature. Click the translate button to try it!\",\n                     \"Learn more.\",\n                     \"Thanks\"],\n                \"es-AR\": [\"\\xA1Mir\\xE1! \\xA1Hay algo nuevo!\",\n                          \"Ahora la web es a\\xFAn m\\xE1s accesible con nuestra nueva funcionalidad de traducci\\xF3n integrada. \\xA1Hac\\xE9 clic en el bot\\xF3n traducir para probarla!\",\n                          \"Conoc\\xE9 m\\xE1s.\",\n                          \"Gracias\"],\n                \"es-ES\": [\"\\xA1Mira! \\xA1Hay algo nuevo!\",\n                          \"Con la nueva funcionalidad de traducci\\xF3n integrada, ahora la Web es a\\xFAn m\\xE1s accesible. \\xA1Pulsa el bot\\xF3n Traducir y pru\\xE9bala!\",\n                          \"M\\xE1s informaci\\xF3n.\",\n                          \"Gracias\"],\n                pl: [\"Sp\\xF3jrz tutaj! To co\\u015B nowego!\",\n                     \"Sie\\u0107 sta\\u0142a si\\u0119 w\\u0142a\\u015Bnie jeszcze bardziej dost\\u0119pna dzi\\u0119ki opcji bezpo\\u015Bredniego t\\u0142umaczenia stron. Kliknij przycisk t\\u0142umaczenia, aby spr\\xF3bowa\\u0107!\",\n                     \"Dowiedz si\\u0119 wi\\u0119cej\",\n                     \"Dzi\\u0119kuj\\u0119\"],\n                tr: [\"Bak\\u0131n, burada yeni bir \\u015Fey var!\",\n                     \"Yeni sayfa i\\xE7i \\xE7eviri \\xF6zelli\\u011Fimiz sayesinde Web art\\u0131k \\xE7ok daha anla\\u015F\\u0131l\\u0131r olacak. Denemek i\\xE7in \\xC7evir d\\xFC\\u011Fmesine t\\u0131klay\\u0131n!\",\n                     \"Daha fazla bilgi al\\u0131n.\",\n                     \"Te\\u015Fekk\\xFCrler\"],\n                vi: [\"Nh\\xECn n\\xE0y! \\u0110\\u1ED3 m\\u1EDBi!\",\n                     \"Gi\\u1EDD \\u0111\\xE2y ch\\xFAng ta c\\xF3 th\\u1EC3 ti\\u1EBFp c\\u1EADn web d\\u1EC5 d\\xE0ng h\\u01A1n n\\u1EEFa v\\u1EDBi t\\xEDnh n\\u0103ng d\\u1ECBch ngay trong trang.  Hay nh\\u1EA5n n\\xFAt d\\u1ECBch \\u0111\\u1EC3 th\\u1EED!\",\n                     \"T\\xECm hi\\u1EC3u th\\xEAm.\",\n                     \"C\\u1EA3m \\u01A1n\"]\n              };\n\n              let locale = Services.locale.getAppLocaleAsLangTag();\n              if (!(locale in localizedStrings))\n                locale = \"en\";\n              let strings = localizedStrings[locale];\n\n              this._getAnonElt(\"welcomeHeadline\").setAttribute(\"value\", strings[0]);\n              this._getAnonElt(\"welcomeBody\").textContent = strings[1];\n              this._getAnonElt(\"learnMore\").setAttribute(\"value\", strings[2]);\n              this._getAnonElt(\"thanksButton\").setAttribute(\"label\", strings[3]);\n\n              let panel = this._getAnonElt(\"welcomePanel\");\n              panel.openPopup(this._getAnonElt(\"messageImage\"),\n                              \"bottomcenter topleft\");\n\n              Services.prefs.setBoolPref(kWelcomePref, true);\n            }, {once: true});\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_getAnonElt\">\n        <parameter name=\"aAnonId\"/>\n        <body>\n          return document.getAnonymousElementByAttribute(this, \"anonid\", aAnonId);\n        </body>\n      </method>\n\n      <method name=\"translate\">\n        <body>\n          <![CDATA[\n            if (this.state == Translation.STATE_OFFER) {\n              this._getAnonElt(\"fromLanguage\").value =\n                this._getAnonElt(\"detectedLanguage\").value;\n              this._getAnonElt(\"toLanguage\").value =\n                Translation.defaultTargetLanguage;\n            }\n\n            this.translation.translate(this._getAnonElt(\"fromLanguage\").value,\n                                       this._getAnonElt(\"toLanguage\").value);\n          ]]>\n        </body>\n      </method>\n\n      <!-- To be called when the infobar should be closed per user's wish (e.g.\n           by clicking the notification's close button -->\n      <method name=\"closeCommand\">\n        <body>\n          <![CDATA[\n            this.close();\n            this.translation.infobarClosed();\n          ]]>\n        </body>\n      </method>\n      <method name=\"_handleButtonHiding\">\n        <body>\n          <![CDATA[\n            let originalShown = this.translation.originalShown;\n            this._getAnonElt(\"showOriginal\").hidden = originalShown;\n            this._getAnonElt(\"showTranslation\").hidden = !originalShown;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"showOriginal\">\n        <body>\n          <![CDATA[\n            this.translation.showOriginalContent();\n            this._handleButtonHiding();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"showTranslation\">\n        <body>\n          <![CDATA[\n            this.translation.showTranslatedContent();\n            this._handleButtonHiding();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"optionsShowing\">\n        <body>\n          <![CDATA[\n            // Get the source language name.\n            let lang;\n            if (this.state == Translation.STATE_OFFER)\n              lang = this._getAnonElt(\"detectedLanguage\").value;\n            else {\n              lang = this._getAnonElt(\"fromLanguage\").value;\n\n              // If we have never attempted to translate the page before the\n              // service became unavailable, \"fromLanguage\" isn't set.\n              if (!lang && this.state == Translation.STATE_UNAVAILABLE)\n                lang = this.translation.detectedLanguage;\n            }\n\n            let langBundle =\n              Services.strings.createBundle(\"chrome://global/locale/languageNames.properties\");\n            let langName = langBundle.GetStringFromName(lang);\n\n            // Set the label and accesskey on the menuitem.\n            let bundle =\n              Services.strings.createBundle(\"chrome://browser/locale/translation.properties\");\n            let item = this._getAnonElt(\"neverForLanguage\");\n            const kStrId = \"translation.options.neverForLanguage\";\n            item.setAttribute(\"label\",\n                              bundle.formatStringFromName(kStrId + \".label\",\n                                                          [langName], 1));\n            item.setAttribute(\"accesskey\",\n                              bundle.GetStringFromName(kStrId + \".accesskey\"));\n            item.langCode = lang;\n\n            // We may need to disable the menuitems if they have already been used.\n            // Check if translation is already disabled for this language:\n            let neverForLangs =\n              Services.prefs.getCharPref(\"browser.translation.neverForLanguages\");\n            item.disabled = neverForLangs.split(\",\").indexOf(lang) != -1;\n\n            // Check if translation is disabled for the domain:\n            let uri = this.translation.browser.currentURI;\n            let perms = Services.perms;\n            item = this._getAnonElt(\"neverForSite\");\n            item.disabled =\n              perms.testExactPermission(uri, \"translate\") == perms.DENY_ACTION;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"neverForLanguage\">\n        <body>\n          <![CDATA[\n            const kPrefName = \"browser.translation.neverForLanguages\";\n\n            let val = Services.prefs.getCharPref(kPrefName);\n            if (val)\n              val += \",\";\n            val += this._getAnonElt(\"neverForLanguage\").langCode;\n\n            Services.prefs.setCharPref(kPrefName, val);\n\n            this.closeCommand();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"neverForSite\">\n        <body>\n          <![CDATA[\n            let uri = this.translation.browser.currentURI;\n            let perms = Services.perms;\n            perms.add(uri, \"translate\", perms.DENY_ACTION);\n\n            this.closeCommand();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"openProviderAttribution\">\n        <body>\n          <![CDATA[\n            Translation.openProviderAttribution();\n          ]]>\n        </body>\n      </method>\n\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"formautofill.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"formautofillBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"autocomplete-profile-listitem-base\" extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <resources>\n      <stylesheet src=\"chrome://formautofill-shared/skin/autocomplete-item.css\"/>\n      <stylesheet src=\"chrome://formautofill/skin/autocomplete-item.css\"/>\n    </resources>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n      </constructor>\n      <!-- For form autofill, we want to unify the selection no matter by\n      keyboard navigation or mouseover in order not to confuse user which\n      profile preview is being shown. This field is set to true to indicate\n      that selectedIndex of popup should be changed while mouseover item -->\n      <field name=\"selectedByMouseOver\">true</field>\n\n      <property name=\"_stringBundle\">\n        <getter><![CDATA[\n          /* global Services */\n          if (!this.__stringBundle) {\n            this.__stringBundle = Services.strings.createBundle(\"chrome://formautofill/locale/formautofill.properties\");\n          }\n          return this.__stringBundle;\n        ]]></getter>\n      </property>\n\n      <method name=\"_cleanup\">\n        <body>\n        <![CDATA[\n          this.removeAttribute(\"formautofillattached\");\n          if (this._itemBox) {\n            this._itemBox.removeAttribute(\"size\");\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_onOverflow\">\n        <body></body>\n      </method>\n\n      <method name=\"_onUnderflow\">\n        <body></body>\n      </method>\n\n      <method name=\"handleOverUnderflow\">\n        <body></body>\n      </method>\n\n      <method name=\"_adjustAutofillItemLayout\">\n        <body>\n        <![CDATA[\n          let outerBoxRect = this.parentNode.getBoundingClientRect();\n\n          // Make item fit in popup as XUL box could not constrain\n          // item's width\n          this._itemBox.style.width = outerBoxRect.width + \"px\";\n          // Use two-lines layout when width is smaller than 150px or\n          // 185px if an image precedes the label.\n          let oneLineMinRequiredWidth = this.getAttribute(\"ac-image\") ? 185 : 150;\n\n          if (outerBoxRect.width <= oneLineMinRequiredWidth) {\n            this._itemBox.setAttribute(\"size\", \"small\");\n          } else {\n            this._itemBox.removeAttribute(\"size\");\n          }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-profile-listitem\" extends=\"chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base\">\n    <xbl:content xmlns=\"http://www.w3.org/1999/xhtml\">\n      <div anonid=\"autofill-item-box\" class=\"autofill-item-box\" xbl:inherits=\"ac-image\">\n        <div class=\"profile-label-col profile-item-col\">\n          <span anonid=\"profile-label-affix\" class=\"profile-label-affix\"></span>\n          <span anonid=\"profile-label\" class=\"profile-label\"></span>\n        </div>\n        <div class=\"profile-comment-col profile-item-col\">\n          <span anonid=\"profile-comment\" class=\"profile-comment\"></span>\n        </div>\n      </div>\n    </xbl:content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n        <![CDATA[\n          this._itemBox = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"autofill-item-box\"\n          );\n          this._labelAffix = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"profile-label-affix\"\n          );\n          this._label = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"profile-label\"\n          );\n          this._comment = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"profile-comment\"\n          );\n\n          this._adjustAcItem();\n        ]]>\n      </constructor>\n\n      <property name=\"selected\" onget=\"return this.getAttribute('selected') == 'true';\">\n        <setter><![CDATA[\n          /* global Cu */\n          if (val) {\n            this.setAttribute(\"selected\", \"true\");\n          } else {\n            this.removeAttribute(\"selected\");\n          }\n\n          let {AutoCompletePopup} = Cu.import(\"resource://gre/modules/AutoCompletePopup.jsm\", {});\n\n          AutoCompletePopup.sendMessageToBrowser(\"FormAutofill:PreviewProfile\");\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <method name=\"_adjustAcItem\">\n        <body>\n        <![CDATA[\n          this._adjustAutofillItemLayout();\n          this.setAttribute(\"formautofillattached\", \"true\");\n          this._itemBox.style.setProperty(\"--primary-icon\", `url(${this.getAttribute(\"ac-image\")})`);\n\n          let {primaryAffix, primary, secondary} = JSON.parse(this.getAttribute(\"ac-value\"));\n\n          this._labelAffix.textContent = primaryAffix;\n          this._label.textContent = primary;\n          this._comment.textContent = secondary;\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-profile-listitem-footer\" extends=\"chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base\">\n    <xbl:content xmlns=\"http://www.w3.org/1999/xhtml\">\n      <div anonid=\"autofill-footer\" class=\"autofill-item-box autofill-footer\">\n        <div anonid=\"autofill-warning\" class=\"autofill-footer-row autofill-warning\">\n        </div>\n        <div anonid=\"autofill-option-button\" class=\"autofill-footer-row autofill-option-button\">\n        </div>\n      </div>\n    </xbl:content>\n\n    <handlers>\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        window.openPreferences(\"panePrivacy\", {origin: \"autofillFooter\"});\n      ]]></handler>\n    </handlers>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n        <![CDATA[\n          this._itemBox = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"autofill-footer\"\n          );\n          this._optionButton = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"autofill-option-button\"\n          );\n          this._warningTextBox = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"autofill-warning\"\n          );\n\n          /**\n           * A handler for updating warning message once selectedIndex has been changed.\n           *\n           * There're three different states of warning message:\n           * 1. None of addresses were selected: We show all the categories intersection of fields in the\n           *    form and fields in the results.\n           * 2. An address was selested: Show the additional categories that will also be filled.\n           * 3. An address was selected, but the focused category is the same as the only one category: Only show\n           * the exact category that we're going to fill in.\n           *\n           * @private\n           * @param {string[]} data.categories\n           *        The categories of all the fields contained in the selected address.\n           */\n          const namespace = \"category.\";\n          this._updateWarningNote = ({data} = {}) => {\n            let categories = (data && data.categories) ? data.categories : this._allFieldCategories;\n            // If the length of categories is 1, that means all the fillable fields are in the same\n            // category. We will change the way to inform user according to this flag. When the value\n            // is true, we show \"Also autofills ...\", otherwise, show \"Autofills ...\" only.\n            let hasExtraCategories = categories.length > 1;\n            // Show the categories in certain order to conform with the spec.\n            let orderedCategoryList = [\"address\", \"name\", \"organization\", \"tel\", \"email\"];\n            let showCategories = hasExtraCategories ?\n              orderedCategoryList.filter(category => categories.includes(category) && category != this._focusedCategory) :\n              [this._focusedCategory];\n\n            let separator = this._stringBundle.GetStringFromName(\"fieldNameSeparator\");\n            let warningTextTmplKey = hasExtraCategories ? \"phishingWarningMessage\" : \"phishingWarningMessage2\";\n            let categoriesText = showCategories.map(category => this._stringBundle.GetStringFromName(namespace + category)).join(separator);\n\n            this._warningTextBox.textContent = this._stringBundle.formatStringFromName(warningTextTmplKey,\n              [categoriesText], 1);\n            this.parentNode.parentNode.adjustHeight();\n          };\n\n          this._adjustAcItem();\n        ]]>\n      </constructor>\n\n      <method name=\"_onCollapse\">\n        <body>\n        <![CDATA[\n          /* global messageManager */\n\n          if (this.showWarningText) {\n            messageManager.removeMessageListener(\"FormAutofill:UpdateWarningMessage\", this._updateWarningNote);\n          }\n\n          this._itemBox.removeAttribute(\"no-warning\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_adjustAcItem\">\n        <body>\n        <![CDATA[\n          /* global Cu */\n          this._adjustAutofillItemLayout();\n          this.setAttribute(\"formautofillattached\", \"true\");\n\n          let {AppConstants} = Cu.import(\"resource://gre/modules/AppConstants.jsm\", {});\n          let buttonTextBundleKey = AppConstants.platform == \"macosx\" ?\n            \"autocompleteFooterOptionOSX\" : \"autocompleteFooterOption\";\n          // If the popup shows up with small layout, we should use short string to\n          // have a better fit in the box.\n          if (this._itemBox.getAttribute(\"size\") == \"small\") {\n            buttonTextBundleKey += \"Short\";\n          }\n          let buttonText = this._stringBundle.GetStringFromName(buttonTextBundleKey);\n          this._optionButton.textContent = buttonText;\n\n          let value = JSON.parse(this.getAttribute(\"ac-value\"));\n\n          this._allFieldCategories = value.categories;\n          this._focusedCategory = value.focusedCategory;\n          this.showWarningText = this._allFieldCategories && this._focusedCategory;\n\n          if (this.showWarningText) {\n            messageManager.addMessageListener(\"FormAutofill:UpdateWarningMessage\", this._updateWarningNote);\n\n            this._updateWarningNote();\n          } else {\n            this._itemBox.setAttribute(\"no-warning\", \"true\");\n          }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-creditcard-insecure-field\" extends=\"chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base\">\n    <xbl:content xmlns=\"http://www.w3.org/1999/xhtml\">\n      <div anonid=\"autofill-item-box\" class=\"autofill-insecure-item\">\n      </div>\n    </xbl:content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n      <![CDATA[\n        this._itemBox = document.getAnonymousElementByAttribute(\n          this, \"anonid\", \"autofill-item-box\"\n        );\n\n        this._adjustAcItem();\n      ]]>\n      </constructor>\n\n      <property name=\"selected\" onget=\"return this.getAttribute('selected') == 'true';\">\n        <setter><![CDATA[\n          // Make this item unselectable since we see this item as a pure message.\n          return false;\n        ]]></setter>\n      </property>\n\n      <method name=\"_adjustAcItem\">\n        <body>\n        <![CDATA[\n          this._adjustAutofillItemLayout();\n          this.setAttribute(\"formautofillattached\", \"true\");\n\n          let value = this.getAttribute(\"ac-value\");\n          this._itemBox.textContent = value;\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"organizer.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"organizerBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"toolbarbutton-dropdown\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:image class=\"menubar-left\" xbl:inherits=\"src=image\"/>\n      <xul:label class=\"menubar-text\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\"/>\n      <xul:hbox class=\"menubar-right\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"autocomplete.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"autocompleteBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"autocomplete\" role=\"xul:combobox\"\n           extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <resources>\n      <stylesheet src=\"chrome://global/content/autocomplete.css\"/>\n      <stylesheet src=\"chrome://global/skin/autocomplete.css\"/>\n    </resources>\n\n    <content sizetopopup=\"pref\">\n      <xul:hbox class=\"autocomplete-textbox-container\" flex=\"1\" xbl:inherits=\"focused\">\n        <children includes=\"image|deck|stack|box\"/>\n\n        <xul:hbox anonid=\"textbox-input-box\" class=\"textbox-input-box\" flex=\"1\" xbl:inherits=\"tooltiptext=inputtooltiptext\">\n          <children/>\n          <html:input anonid=\"input\" class=\"autocomplete-textbox textbox-input\"\n                      allowevents=\"true\"\n                      xbl:inherits=\"tooltiptext=inputtooltiptext,value,type=inputtype,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,mozactionhint\"/>\n        </xul:hbox>\n        <children includes=\"hbox\"/>\n      </xul:hbox>\n\n      <xul:popupset anonid=\"popupset\" class=\"autocomplete-result-popupset\"/>\n\n      <children includes=\"toolbarbutton\"/>\n    </content>\n\n    <implementation implements=\"nsIAutoCompleteInput, nsIDOMXULMenuListElement\">\n      <field name=\"mController\">null</field>\n      <field name=\"mSearchNames\">null</field>\n      <field name=\"mIgnoreInput\">false</field>\n\n      <field name=\"_searchBeginHandler\">null</field>\n      <field name=\"_searchCompleteHandler\">null</field>\n      <field name=\"_textEnteredHandler\">null</field>\n      <field name=\"_textRevertedHandler\">null</field>\n\n      <constructor><![CDATA[\n        this.mController = Components.classes[\"@mozilla.org/autocomplete/controller;1\"].\n          getService(Components.interfaces.nsIAutoCompleteController);\n\n        this._searchBeginHandler = this.initEventHandler(\"searchbegin\");\n        this._searchCompleteHandler = this.initEventHandler(\"searchcomplete\");\n        this._textEnteredHandler = this.initEventHandler(\"textentered\");\n        this._textRevertedHandler = this.initEventHandler(\"textreverted\");\n\n        // For security reasons delay searches on pasted values.\n        this.inputField.controllers.insertControllerAt(0, this._pasteController);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        this.inputField.controllers.removeController(this._pasteController);\n      ]]></destructor>\n\n      <!-- =================== nsIAutoCompleteInput =================== -->\n\n      <field name=\"_popup\">null</field>\n      <property name=\"popup\" readonly=\"true\">\n        <getter><![CDATA[\n          // Memoize the result in a field rather than replacing this property,\n          // so that it can be reset along with the binding.\n          if (this._popup) {\n            return this._popup;\n          }\n\n          let popup = null;\n          let popupId = this.getAttribute(\"autocompletepopup\");\n          if (popupId) {\n            popup = document.getElementById(popupId);\n          }\n          if (!popup) {\n            popup = document.createElement(\"panel\");\n            popup.setAttribute(\"type\", \"autocomplete\");\n            popup.setAttribute(\"noautofocus\", \"true\");\n\n            let popupset = document.getAnonymousElementByAttribute(this, \"anonid\", \"popupset\");\n            popupset.appendChild(popup);\n          }\n          popup.mInput = this;\n\n          return this._popup = popup;\n        ]]></getter>\n      </property>\n\n      <property name=\"controller\" onget=\"return this.mController;\" readonly=\"true\"/>\n\n      <property name=\"popupOpen\"\n                onget=\"return this.popup.popupOpen;\"\n                onset=\"if (val) this.openPopup(); else this.closePopup();\"/>\n\n      <property name=\"disableAutoComplete\"\n                onset=\"this.setAttribute('disableautocomplete', val); return val;\"\n                onget=\"return this.getAttribute('disableautocomplete') == 'true';\"/>\n\n      <property name=\"completeDefaultIndex\"\n                onset=\"this.setAttribute('completedefaultindex', val); return val;\"\n                onget=\"return this.getAttribute('completedefaultindex') == 'true';\"/>\n\n      <property name=\"completeSelectedIndex\"\n                onset=\"this.setAttribute('completeselectedindex', val); return val;\"\n                onget=\"return this.getAttribute('completeselectedindex') == 'true';\"/>\n\n      <property name=\"forceComplete\"\n                onset=\"this.setAttribute('forcecomplete', val); return val;\"\n                onget=\"return this.getAttribute('forcecomplete') == 'true';\"/>\n\n      <property name=\"minResultsForPopup\"\n                onset=\"this.setAttribute('minresultsforpopup', val); return val;\"\n                onget=\"var m = parseInt(this.getAttribute('minresultsforpopup')); return isNaN(m) ? 1 : m;\"/>\n\n      <property name=\"showCommentColumn\"\n                onset=\"this.setAttribute('showcommentcolumn', val); return val;\"\n                onget=\"return this.getAttribute('showcommentcolumn') == 'true';\"/>\n\n      <property name=\"showImageColumn\"\n                onset=\"this.setAttribute('showimagecolumn', val); return val;\"\n                onget=\"return this.getAttribute('showimagecolumn') == 'true';\"/>\n\n      <property name=\"timeout\"\n                onset=\"this.setAttribute('timeout', val); return val;\">\n        <getter><![CDATA[\n          // For security reasons delay searches on pasted values.\n          if (this._valueIsPasted) {\n            let t = parseInt(this.getAttribute(\"pastetimeout\"));\n            return isNaN(t) ? 1000 : t;\n          }\n\n          let t = parseInt(this.getAttribute(\"timeout\"));\n          return isNaN(t) ? 50 : t;\n        ]]></getter>\n      </property>\n\n      <property name=\"searchParam\"\n                onget=\"return this.getAttribute('autocompletesearchparam') || '';\"\n                onset=\"this.setAttribute('autocompletesearchparam', val); return val;\"/>\n\n      <property name=\"searchCount\" readonly=\"true\"\n                onget=\"this.initSearchNames(); return this.mSearchNames.length;\"/>\n\n      <field name=\"shrinkDelay\" readonly=\"true\">\n        parseInt(this.getAttribute(\"shrinkdelay\")) || 0\n      </field>\n\n      <property name=\"PrivateBrowsingUtils\" readonly=\"true\">\n        <getter><![CDATA[\n          let module = {};\n          Components.utils.import(\"resource://gre/modules/PrivateBrowsingUtils.jsm\", module);\n          Object.defineProperty(this, \"PrivateBrowsingUtils\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: module.PrivateBrowsingUtils\n          });\n          return module.PrivateBrowsingUtils;\n        ]]></getter>\n      </property>\n\n      <property name=\"inPrivateContext\" readonly=\"true\"\n                onget=\"return this.PrivateBrowsingUtils.isWindowPrivate(window);\"/>\n\n      <property name=\"noRollupOnCaretMove\" readonly=\"true\"\n                onget=\"return this.popup.getAttribute('norolluponanchor') == 'true'\"/>\n\n      <!-- This is the maximum number of drop-down rows we get when we\n            hit the drop marker beside fields that have it (like the URLbar).-->\n      <field name=\"maxDropMarkerRows\" readonly=\"true\">14</field>\n\n      <method name=\"getSearchAt\">\n        <parameter name=\"aIndex\"/>\n        <body><![CDATA[\n          this.initSearchNames();\n          return this.mSearchNames[aIndex];\n        ]]></body>\n      </method>\n\n      <method name=\"setTextValueWithReason\">\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aReason\"/>\n        <body><![CDATA[\n          if (aReason == Components.interfaces.nsIAutoCompleteInput\n                                   .TEXTVALUE_REASON_COMPLETEDEFAULT) {\n            this._disableTrim = true;\n          }\n          this.textValue = aValue;\n          this._disableTrim = false;\n        ]]></body>\n      </method>\n\n      <property name=\"textValue\">\n        <getter><![CDATA[\n          if (typeof this.onBeforeTextValueGet == \"function\") {\n            let result = this.onBeforeTextValueGet();\n            if (result) {\n              return result.value;\n            }\n          }\n          return this.value;\n        ]]></getter>\n        <setter><![CDATA[\n          if (typeof this.onBeforeTextValueSet == \"function\")\n            val = this.onBeforeTextValueSet(val);\n\n          this.value = val;\n\n          // Completing a result should simulate the user typing the result, so\n          // fire an input event.\n          let evt = document.createEvent(\"UIEvents\");\n          evt.initUIEvent(\"input\", true, false, window, 0);\n          this.mIgnoreInput = true;\n          this.dispatchEvent(evt);\n          this.mIgnoreInput = false;\n\n          return this.value;\n        ]]></setter>\n      </property>\n\n      <method name=\"selectTextRange\">\n        <parameter name=\"aStartIndex\"/>\n        <parameter name=\"aEndIndex\"/>\n        <body><![CDATA[\n          this.inputField.setSelectionRange(aStartIndex, aEndIndex);\n        ]]></body>\n      </method>\n\n      <method name=\"onSearchBegin\">\n        <body><![CDATA[\n          if (this.popup && typeof this.popup.onSearchBegin == \"function\")\n            this.popup.onSearchBegin();\n          if (this._searchBeginHandler)\n            this._searchBeginHandler();\n        ]]></body>\n      </method>\n\n      <method name=\"onSearchComplete\">\n        <body><![CDATA[\n          if (this.mController.matchCount == 0)\n            this.setAttribute(\"nomatch\", \"true\");\n          else\n            this.removeAttribute(\"nomatch\");\n\n          if (this.ignoreBlurWhileSearching && !this.focused) {\n            this.handleEnter();\n            this.detachController();\n          }\n\n          if (this._searchCompleteHandler)\n            this._searchCompleteHandler();\n        ]]></body>\n      </method>\n\n      <method name=\"onTextEntered\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let rv = false;\n          if (this._textEnteredHandler) {\n            rv = this._textEnteredHandler(event);\n          }\n          return rv;\n        ]]></body>\n      </method>\n\n      <method name=\"onTextReverted\">\n        <body><![CDATA[\n          if (this._textRevertedHandler)\n            return this._textRevertedHandler();\n          return false;\n        ]]></body>\n      </method>\n\n      <!-- =================== nsIDOMXULMenuListElement =================== -->\n\n      <property name=\"editable\" readonly=\"true\"\n                onget=\"return true;\" />\n\n      <property name=\"crop\"\n                onset=\"this.setAttribute('crop',val); return val;\"\n                onget=\"return this.getAttribute('crop');\"/>\n\n      <property name=\"open\"\n                onget=\"return this.getAttribute('open') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.showHistoryPopup();\n          else\n            this.closePopup();\n        ]]></setter>\n      </property>\n\n      <!-- =================== PUBLIC MEMBERS =================== -->\n\n      <field name=\"valueIsTyped\">false</field>\n      <field name=\"_disableTrim\">false</field>\n      <property name=\"value\">\n        <getter><![CDATA[\n          if (typeof this.onBeforeValueGet == \"function\") {\n            var result = this.onBeforeValueGet();\n            if (result)\n              return result.value;\n          }\n          return this.inputField.value;\n        ]]></getter>\n        <setter><![CDATA[\n          this.mIgnoreInput = true;\n\n          if (typeof this.onBeforeValueSet == \"function\")\n            val = this.onBeforeValueSet(val);\n\n          if (typeof this.trimValue == \"function\" && !this._disableTrim)\n            val = this.trimValue(val);\n\n          this.valueIsTyped = false;\n          this.inputField.value = val;\n\n          if (typeof this.formatValue == \"function\")\n            this.formatValue();\n\n          this.mIgnoreInput = false;\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"ValueChange\", true, true);\n          this.inputField.dispatchEvent(event);\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"focused\" readonly=\"true\"\n                onget=\"return this.getAttribute('focused') == 'true';\"/>\n\n      <!-- maximum number of rows to display at a time -->\n      <property name=\"maxRows\"\n                onset=\"this.setAttribute('maxrows', val); return val;\"\n                onget=\"return parseInt(this.getAttribute('maxrows')) || 0;\"/>\n\n      <!-- option to allow scrolling through the list via the tab key, rather than\n           tab moving focus out of the textbox -->\n      <property name=\"tabScrolling\"\n                onset=\"this.setAttribute('tabscrolling', val); return val;\"\n                onget=\"return this.getAttribute('tabscrolling') == 'true';\"/>\n\n      <!-- option to completely ignore any blur events while searches are\n           still going on. -->\n      <property name=\"ignoreBlurWhileSearching\"\n                onset=\"this.setAttribute('ignoreblurwhilesearching', val); return val;\"\n                onget=\"return this.getAttribute('ignoreblurwhilesearching') == 'true';\"/>\n\n      <!-- disable key navigation handling in the popup results -->\n      <property name=\"disableKeyNavigation\"\n                onset=\"this.setAttribute('disablekeynavigation', val); return val;\"\n                onget=\"return this.getAttribute('disablekeynavigation') == 'true';\"/>\n\n      <!-- option to highlight entries that don't have any matches -->\n      <property name=\"highlightNonMatches\"\n                onset=\"this.setAttribute('highlightnonmatches', val); return val;\"\n                onget=\"return this.getAttribute('highlightnonmatches') == 'true';\"/>\n\n      <!-- =================== PRIVATE MEMBERS =================== -->\n\n      <!-- ::::::::::::: autocomplete controller ::::::::::::: -->\n\n      <method name=\"attachController\">\n        <body><![CDATA[\n          this.mController.input = this;\n        ]]></body>\n      </method>\n\n      <method name=\"detachController\">\n        <body><![CDATA[\n          if (this.mController.input == this)\n            this.mController.input = null;\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: popup opening ::::::::::::: -->\n\n      <method name=\"openPopup\">\n        <body><![CDATA[\n          if (this.focused)\n            this.popup.openAutocompletePopup(this, this);\n        ]]></body>\n      </method>\n\n      <method name=\"closePopup\">\n        <body><![CDATA[\n          this.popup.closePopup();\n        ]]></body>\n      </method>\n\n      <method name=\"showHistoryPopup\">\n        <body><![CDATA[\n          // Store our \"normal\" maxRows on the popup, so that it can reset the\n          // value when the popup is hidden.\n          this.popup._normalMaxRows = this.maxRows;\n\n          // Increase our maxRows temporarily, since we want the dropdown to\n          // be bigger in this case. The popup's popupshowing/popuphiding\n          // handlers will take care of resetting this.\n          this.maxRows = this.maxDropMarkerRows;\n\n          // Ensure that we have focus.\n          if (!this.focused)\n            this.focus();\n          this.attachController();\n          this.mController.startSearch(\"\");\n        ]]></body>\n      </method>\n\n      <method name=\"toggleHistoryPopup\">\n        <body><![CDATA[\n          if (!this.popup.popupOpen)\n            this.showHistoryPopup();\n          else\n            this.closePopup();\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: event dispatching ::::::::::::: -->\n\n      <method name=\"initEventHandler\">\n        <parameter name=\"aEventType\"/>\n        <body><![CDATA[\n          let handlerString = this.getAttribute(\"on\" + aEventType);\n          if (handlerString) {\n            return (new Function(\"eventType\", \"param\", handlerString)).bind(this, aEventType);\n          }\n          return null;\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: key handling ::::::::::::: -->\n\n      <field name=\"_selectionDetails\">null</field>\n      <method name=\"onKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          return this.handleKeyPress(aEvent);\n        ]]></body>\n      </method>\n\n      <method name=\"handleKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.target.localName != \"textbox\")\n            return true; // Let child buttons of autocomplete take input\n\n          // Re: urlbarDeferred, see the comment in urlbarBindings.xml.\n          if (aEvent.defaultPrevented && !aEvent.urlbarDeferred) {\n            return false;\n          }\n\n          var cancel = false;\n\n          // Catch any keys that could potentially move the caret. Ctrl can be\n          // used in combination with these keys on Windows and Linux; and Alt\n          // can be used on OS X, so make sure the unused one isn't used.\n          let metaKey = /Mac/.test(navigator.platform) ? aEvent.ctrlKey : aEvent.altKey;\n          if (!this.disableKeyNavigation && !metaKey) {\n            switch (aEvent.keyCode) {\n              case KeyEvent.DOM_VK_LEFT:\n              case KeyEvent.DOM_VK_RIGHT:\n              case KeyEvent.DOM_VK_HOME:\n                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);\n                break;\n            }\n          }\n\n          // Handle keys that are not part of a keyboard shortcut (no Ctrl or Alt)\n          if (!this.disableKeyNavigation && !aEvent.ctrlKey && !aEvent.altKey) {\n            switch (aEvent.keyCode) {\n              case KeyEvent.DOM_VK_TAB:\n                if (this.tabScrolling && this.popup.popupOpen)\n                  cancel = this.mController.handleKeyNavigation(aEvent.shiftKey ?\n                                                                KeyEvent.DOM_VK_UP :\n                                                                KeyEvent.DOM_VK_DOWN);\n                else if (this.forceComplete && this.mController.matchCount >= 1)\n                  this.mController.handleTab();\n                break;\n              case KeyEvent.DOM_VK_UP:\n              case KeyEvent.DOM_VK_DOWN:\n              case KeyEvent.DOM_VK_PAGE_UP:\n              case KeyEvent.DOM_VK_PAGE_DOWN:\n                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);\n                break;\n            }\n          }\n\n          // Handle keys we know aren't part of a shortcut, even with Alt or\n          // Ctrl.\n          switch (aEvent.keyCode) {\n            case KeyEvent.DOM_VK_ESCAPE:\n              cancel = this.mController.handleEscape();\n              break;\n            case KeyEvent.DOM_VK_RETURN:\n              if (/Mac/.test(navigator.platform)) {\n                // Prevent the default action, since it will beep on Mac\n                if (aEvent.metaKey)\n                  aEvent.preventDefault();\n              }\n              if (this.mController.selection) {\n                this._selectionDetails = {\n                  index: this.mController.selection.currentIndex,\n                  kind: \"key\"\n                };\n              }\n              cancel = this.handleEnter(aEvent);\n              break;\n            case KeyEvent.DOM_VK_DELETE:\n              if (/Mac/.test(navigator.platform) && !aEvent.shiftKey) {\n                break;\n              }\n              cancel = this.handleDelete();\n              break;\n            case KeyEvent.DOM_VK_BACK_SPACE:\n              if (/Mac/.test(navigator.platform) && aEvent.shiftKey) {\n                cancel = this.handleDelete();\n              }\n              break;\n            case KeyEvent.DOM_VK_DOWN:\n            case KeyEvent.DOM_VK_UP:\n              if (aEvent.altKey)\n                this.toggleHistoryPopup();\n              break;\n            case KeyEvent.DOM_VK_F4:\n              if (!/Mac/.test(navigator.platform)) {\n                this.toggleHistoryPopup();\n              }\n              break;\n          }\n\n          if (cancel) {\n            aEvent.stopPropagation();\n            aEvent.preventDefault();\n          }\n\n          return true;\n        ]]></body>\n      </method>\n\n      <method name=\"handleEnter\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          return this.mController.handleEnter(false, event || null);\n        ]]></body>\n      </method>\n\n      <method name=\"handleDelete\">\n        <body><![CDATA[\n          return this.mController.handleDelete();\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: miscellaneous ::::::::::::: -->\n\n      <method name=\"initSearchNames\">\n        <body><![CDATA[\n          if (!this.mSearchNames) {\n            var names = this.getAttribute(\"autocompletesearch\");\n            if (!names)\n              this.mSearchNames = [];\n            else\n              this.mSearchNames = names.split(\" \");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_focus\">\n        <!-- doesn't reset this.mController -->\n        <body><![CDATA[\n          this._dontBlur = true;\n          this.focus();\n          this._dontBlur = false;\n        ]]></body>\n      </method>\n\n      <method name=\"resetActionType\">\n        <body><![CDATA[\n          if (this.mIgnoreInput)\n            return;\n          this.removeAttribute(\"actiontype\");\n        ]]></body>\n      </method>\n\n      <field name=\"_valueIsPasted\">false</field>\n      <field name=\"_pasteController\"><![CDATA[\n        ({\n          _autocomplete: this,\n          _kGlobalClipboard: Components.interfaces.nsIClipboard.kGlobalClipboard,\n          supportsCommand: aCommand => aCommand == \"cmd_paste\",\n          doCommand(aCommand) {\n            this._autocomplete._valueIsPasted = true;\n            this._autocomplete.editor.paste(this._kGlobalClipboard);\n            this._autocomplete._valueIsPasted = false;\n          },\n          isCommandEnabled(aCommand) {\n            return this._autocomplete.editor.isSelectionEditable &&\n                   this._autocomplete.editor.canPaste(this._kGlobalClipboard);\n          },\n          onEvent() {}\n        })\n      ]]></field>\n\n      <method name=\"onInput\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this.mIgnoreInput && this.mController.input == this) {\n            this.valueIsTyped = true;\n            this.mController.handleText();\n          }\n          this.resetActionType();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"input\"><![CDATA[\n        this.onInput(event);\n      ]]></handler>\n\n      <handler event=\"keypress\" phase=\"capturing\"\n               action=\"return this.onKeyPress(event);\"/>\n\n      <handler event=\"compositionstart\" phase=\"capturing\"\n               action=\"if (this.mController.input == this) this.mController.handleStartComposition();\"/>\n\n      <handler event=\"compositionend\" phase=\"capturing\"\n               action=\"if (this.mController.input == this) this.mController.handleEndComposition();\"/>\n\n      <handler event=\"focus\" phase=\"capturing\"><![CDATA[\n        this.attachController();\n        if (window.gBrowser && window.gBrowser.selectedBrowser.hasAttribute(\"usercontextid\")) {\n          this.userContextId = parseInt(window.gBrowser.selectedBrowser.getAttribute(\"usercontextid\"));\n        } else {\n          this.userContextId = 0;\n        }\n      ]]></handler>\n\n      <handler event=\"blur\" phase=\"capturing\"><![CDATA[\n        if (!this._dontBlur) {\n          if (this.forceComplete && this.mController.matchCount >= 1) {\n            // mousemove sets selected index. Don't blindly use that selected\n            // index in this blur handler since if the popup is open you can\n            // easily \"select\" another match just by moving the mouse over it.\n            let filledVal = this.value.replace(/.+ >> /, \"\").toLowerCase();\n            let selectedVal = null;\n            if (this.popup.selectedIndex >= 0) {\n              selectedVal = this.mController.getFinalCompleteValueAt(\n                this.popup.selectedIndex);\n            }\n            if (selectedVal && filledVal != selectedVal.toLowerCase()) {\n              for (let i = 0; i < this.mController.matchCount; i++) {\n                let matchVal = this.mController.getFinalCompleteValueAt(i);\n                if (matchVal.toLowerCase() == filledVal) {\n                  this.popup.selectedIndex = i;\n                  break;\n                }\n              }\n            }\n            this.mController.handleEnter(false);\n          }\n          if (!this.ignoreBlurWhileSearching)\n            this.detachController();\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autocomplete-result-popup\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-base-popup\">\n    <resources>\n      <stylesheet src=\"chrome://global/content/autocomplete.css\"/>\n      <stylesheet src=\"chrome://global/skin/tree.css\"/>\n      <stylesheet src=\"chrome://global/skin/autocomplete.css\"/>\n    </resources>\n\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\">\n      <xul:tree anonid=\"tree\" class=\"autocomplete-tree plain\" hidecolumnpicker=\"true\" flex=\"1\" seltype=\"single\">\n        <xul:treecols anonid=\"treecols\">\n          <xul:treecol id=\"treecolAutoCompleteValue\" class=\"autocomplete-treecol\" flex=\"1\" overflow=\"true\"/>\n        </xul:treecols>\n        <xul:treechildren class=\"autocomplete-treebody\"/>\n      </xul:tree>\n    </content>\n\n    <implementation>\n      <field name=\"mShowCommentColumn\">false</field>\n      <field name=\"mShowImageColumn\">false</field>\n\n      <property name=\"showCommentColumn\"\n                   onget=\"return this.mShowCommentColumn;\">\n        <setter>\n          <![CDATA[\n          if (!val && this.mShowCommentColumn) {\n            // reset the flex on the value column and remove the comment column\n            document.getElementById(\"treecolAutoCompleteValue\").setAttribute(\"flex\", 1);\n            this.removeColumn(\"treecolAutoCompleteComment\");\n          } else if (val && !this.mShowCommentColumn) {\n            // reset the flex on the value column and add the comment column\n            document.getElementById(\"treecolAutoCompleteValue\").setAttribute(\"flex\", 2);\n            this.addColumn({id: \"treecolAutoCompleteComment\", flex: 1});\n          }\n          this.mShowCommentColumn = val;\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"showImageColumn\"\n                onget=\"return this.mShowImageColumn;\">\n        <setter>\n          <![CDATA[\n          if (!val && this.mShowImageColumn) {\n            // remove the image column\n            this.removeColumn(\"treecolAutoCompleteImage\");\n          } else if (val && !this.mShowImageColumn) {\n            // add the image column\n            this.addColumn({id: \"treecolAutoCompleteImage\", flex: 1});\n          }\n          this.mShowImageColumn = val;\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n\n      <method name=\"addColumn\">\n        <parameter name=\"aAttrs\"/>\n        <body>\n          <![CDATA[\n          var col = document.createElement(\"treecol\");\n          col.setAttribute(\"class\", \"autocomplete-treecol\");\n          for (var name in aAttrs)\n            col.setAttribute(name, aAttrs[name]);\n          this.treecols.appendChild(col);\n          return col;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"removeColumn\">\n        <parameter name=\"aColId\"/>\n        <body>\n          <![CDATA[\n          return this.treecols.removeChild(document.getElementById(aColId));\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"selectedIndex\"\n                onget=\"return this.tree.currentIndex;\">\n        <setter>\n          <![CDATA[\n          this.tree.view.selection.select(val);\n          if (this.tree.treeBoxObject.height > 0)\n            this.tree.treeBoxObject.ensureRowIsVisible(val < 0 ? 0 : val);\n          // Fire select event on xul:tree so that accessibility API\n          // support layer can fire appropriate accessibility events.\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"select\", true, true);\n          this.tree.dispatchEvent(event);\n          return val;\n        ]]></setter>\n      </property>\n\n      <method name=\"adjustHeight\">\n        <body>\n          <![CDATA[\n          // detect the desired height of the tree\n          var bx = this.tree.treeBoxObject;\n          var view = this.tree.view;\n          if (!view)\n            return;\n          var rows = this.maxRows;\n          if (!view.rowCount || (rows && view.rowCount < rows))\n            rows = view.rowCount;\n\n          var height = rows * bx.rowHeight;\n\n          if (height == 0) {\n            this.tree.setAttribute(\"collapsed\", \"true\");\n          } else {\n            if (this.tree.hasAttribute(\"collapsed\"))\n              this.tree.removeAttribute(\"collapsed\");\n\n            this.tree.setAttribute(\"height\", height);\n          }\n          this.tree.setAttribute(\"hidescrollbar\", view.rowCount <= rows);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body><![CDATA[\n          // until we have \"baseBinding\", (see bug #373652) this allows\n          // us to override openAutocompletePopup(), but still call\n          // the method on the base class\n          this._openAutocompletePopup(aInput, aElement);\n        ]]></body>\n      </method>\n\n      <method name=\"_openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body><![CDATA[\n          if (!this.mPopupOpen) {\n            this.mInput = aInput;\n            this.view = aInput.controller.QueryInterface(Components.interfaces.nsITreeView);\n            this.invalidate();\n\n            this.showCommentColumn = this.mInput.showCommentColumn;\n            this.showImageColumn = this.mInput.showImageColumn;\n\n            var rect = aElement.getBoundingClientRect();\n            var nav = aElement.ownerGlobal.QueryInterface(Components.interfaces.nsIInterfaceRequestor)\n                              .getInterface(Components.interfaces.nsIWebNavigation);\n            var docShell = nav.QueryInterface(Components.interfaces.nsIDocShell);\n            var docViewer = docShell.contentViewer;\n            var width = (rect.right - rect.left) * docViewer.fullZoom;\n            this.setAttribute(\"width\", width > 100 ? width : 100);\n\n            // Adjust the direction of the autocomplete popup list based on the textbox direction, bug 649840\n            var popupDirection = aElement.ownerGlobal.getComputedStyle(aElement).direction;\n            this.style.direction = popupDirection;\n\n            this.openPopup(aElement, \"after_start\", 0, 0, false, false);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"invalidate\">\n        <body><![CDATA[\n          this.adjustHeight();\n          this.tree.treeBoxObject.invalidate();\n        ]]></body>\n      </method>\n\n      <method name=\"selectBy\">\n        <parameter name=\"aReverse\"/>\n        <parameter name=\"aPage\"/>\n        <body><![CDATA[\n          try {\n            var amount = aPage ? 5 : 1;\n            this.selectedIndex = this.getNextIndex(aReverse, amount, this.selectedIndex, this.tree.view.rowCount - 1);\n            if (this.selectedIndex == -1) {\n              this.input._focus();\n            }\n          } catch (ex) {\n            // do nothing - occasionally timer-related js errors happen here\n            // e.g. \"this.selectedIndex has no properties\", when you type fast and hit a\n            // navigation key before this popup has opened\n          }\n        ]]></body>\n      </method>\n\n      <!-- =================== PUBLIC MEMBERS =================== -->\n\n      <field name=\"tree\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"tree\");\n      </field>\n\n      <field name=\"treecols\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"treecols\");\n      </field>\n\n      <property name=\"view\"\n                onget=\"return this.mView;\">\n        <setter><![CDATA[\n          // We must do this by hand because the tree binding may not be ready yet\n          this.mView = val;\n          this.tree.boxObject.view = val;\n        ]]></setter>\n      </property>\n\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-base-popup\" role=\"none\"\nextends=\"chrome://global/content/bindings/popup.xml#popup\">\n    <implementation implements=\"nsIAutoCompletePopup\">\n      <field name=\"mInput\">null</field>\n      <field name=\"mPopupOpen\">false</field>\n\n      <!-- =================== nsIAutoCompletePopup =================== -->\n\n      <property name=\"input\" readonly=\"true\"\n                onget=\"return this.mInput\"/>\n\n      <property name=\"overrideValue\" readonly=\"true\"\n                onget=\"return null;\"/>\n\n      <property name=\"popupOpen\" readonly=\"true\"\n                onget=\"return this.mPopupOpen;\"/>\n\n      <method name=\"closePopup\">\n        <body>\n          <![CDATA[\n          if (this.mPopupOpen) {\n            this.hidePopup();\n            this.removeAttribute(\"width\");\n          }\n        ]]>\n        </body>\n      </method>\n\n      <!-- This is the default number of rows that we give the autocomplete\n           popup when the textbox doesn't have a \"maxrows\" attribute\n           for us to use. -->\n      <field name=\"defaultMaxRows\" readonly=\"true\">6</field>\n\n      <!-- In some cases (e.g. when the input's dropmarker button is clicked),\n           the input wants to display a popup with more rows. In that case, it\n           should increase its maxRows property and store the \"normal\" maxRows\n           in this field. When the popup is hidden, we restore the input's\n           maxRows to the value stored in this field.\n\n           This field is set to -1 between uses so that we can tell when it's\n           been set by the input and when we need to set it in the popupshowing\n           handler. -->\n      <field name=\"_normalMaxRows\">-1</field>\n\n      <property name=\"maxRows\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n          return (this.mInput && this.mInput.maxRows) || this.defaultMaxRows;\n        ]]>\n        </getter>\n      </property>\n\n      <method name=\"getNextIndex\">\n        <parameter name=\"aReverse\"/>\n        <parameter name=\"aAmount\"/>\n        <parameter name=\"aIndex\"/>\n        <parameter name=\"aMaxRow\"/>\n        <body><![CDATA[\n          if (aMaxRow < 0)\n            return -1;\n\n          var newIdx = aIndex + (aReverse ? -1 : 1) * aAmount;\n          if (aReverse && aIndex == -1 || newIdx > aMaxRow && aIndex != aMaxRow)\n            newIdx = aMaxRow;\n          else if (!aReverse && aIndex == -1 || newIdx < 0 && aIndex != 0)\n            newIdx = 0;\n\n          if (newIdx < 0 && aIndex == 0 || newIdx > aMaxRow && aIndex == aMaxRow)\n            aIndex = -1;\n          else\n            aIndex = newIdx;\n\n          return aIndex;\n        ]]></body>\n      </method>\n\n      <method name=\"onPopupClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          var controller = this.view.QueryInterface(Components.interfaces.nsIAutoCompleteController);\n          controller.handleEnter(true, aEvent);\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // If normalMaxRows wasn't already set by the input, then set it here\n        // so that we restore the correct number when the popup is hidden.\n\n        // Null-check this.mInput; see bug 1017914\n        if (this._normalMaxRows < 0 && this.mInput) {\n          this._normalMaxRows = this.mInput.maxRows;\n        }\n\n        // Set an attribute for styling the popup based on the input.\n        let inputID = \"\";\n        if (this.mInput && this.mInput.ownerDocument &&\n            this.mInput.ownerDocument.documentURIObject.schemeIs(\"chrome\")) {\n          inputID = this.mInput.id;\n          // Take care of elements with no id that are inside xbl bindings\n          if (!inputID) {\n            let bindingParent = this.mInput.ownerDocument.getBindingParent(this.mInput);\n            if (bindingParent) {\n              inputID = bindingParent.id;\n            }\n          }\n        }\n        this.setAttribute(\"autocompleteinput\", inputID);\n\n        this.mPopupOpen = true;\n      ]]></handler>\n\n      <handler event=\"popuphiding\"><![CDATA[\n        var isListActive = true;\n        if (this.selectedIndex == -1)\n          isListActive = false;\n        var controller = this.view.QueryInterface(Components.interfaces.nsIAutoCompleteController);\n        controller.stopSearch();\n\n        this.removeAttribute(\"autocompleteinput\");\n        this.mPopupOpen = false;\n\n        // Reset the maxRows property to the cached \"normal\" value (if there's\n        // any), and reset normalMaxRows so that we can detect whether it was set\n        // by the input when the popupshowing handler runs.\n\n        // Null-check this.mInput; see bug 1017914\n        if (this.mInput && this._normalMaxRows > 0) {\n          this.mInput.maxRows = this._normalMaxRows;\n        }\n        this._normalMaxRows = -1;\n        // If the list was being navigated and then closed, make sure\n        // we fire accessible focus event back to textbox\n\n        // Null-check this.mInput; see bug 1017914\n        if (isListActive && this.mInput) {\n          this.mInput.mIgnoreFocus = true;\n          this.mInput._focus();\n          this.mInput.mIgnoreFocus = false;\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autocomplete-rich-result-popup\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-base-popup\">\n    <resources>\n      <stylesheet src=\"chrome://global/content/autocomplete.css\"/>\n      <stylesheet src=\"chrome://global/skin/autocomplete.css\"/>\n    </resources>\n\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\">\n      <xul:richlistbox anonid=\"richlistbox\" class=\"autocomplete-richlistbox\" flex=\"1\"/>\n      <xul:hbox>\n        <children/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIAutoCompletePopup\">\n      <field name=\"_currentIndex\">0</field>\n      <field name=\"_rlbAnimated\">false</field>\n\n      <!-- =================== nsIAutoCompletePopup =================== -->\n\n      <property name=\"selectedIndex\"\n                onget=\"return this.richlistbox.selectedIndex;\">\n        <setter>\n          <![CDATA[\n          this.richlistbox.selectedIndex = val;\n          // Since ensureElementIsVisible may cause an expensive Layout flush,\n          // invoke it only if there may be a scrollbar, so if we could fetch\n          // more results than we can show at once.\n          // maxResults is the maximum number of fetched results, maxRows is the\n          // maximum number of rows we show at once, without a scrollbar.\n          if (this.mPopupOpen && this.maxResults > this.maxRows) {\n            // when clearing the selection (val == -1, so selectedItem will be\n            // null), we want to scroll back to the top.  see bug #406194\n            this.richlistbox.ensureElementIsVisible(\n              this.richlistbox.selectedItem || this.richlistbox.firstChild);\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"onSearchBegin\">\n        <body><![CDATA[\n          this.richlistbox.mousedOverIndex = -1;\n\n          if (typeof this._onSearchBegin == \"function\") {\n            this._onSearchBegin();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          // until we have \"baseBinding\", (see bug #373652) this allows\n          // us to override openAutocompletePopup(), but still call\n          // the method on the base class\n          this._openAutocompletePopup(aInput, aElement);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          if (!this.mPopupOpen) {\n            // It's possible that the panel is hidden initially\n            // to avoid impacting startup / new window performance\n            aInput.popup.hidden = false;\n\n            this.mInput = aInput;\n            // clear any previous selection, see bugs 400671 and 488357\n            this.selectedIndex = -1;\n\n            var width = aElement.getBoundingClientRect().width;\n            this.setAttribute(\"width\", width > 100 ? width : 100);\n            // invalidate() depends on the width attribute\n            this._invalidate();\n\n            this.openPopup(aElement, \"after_start\", 0, 0, false, false);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"invalidate\">\n        <parameter name=\"reason\"/>\n        <body>\n          <![CDATA[\n          // Don't bother doing work if we're not even showing\n          if (!this.mPopupOpen)\n            return;\n\n          this._invalidate(reason);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_invalidate\">\n        <parameter name=\"reason\"/>\n        <body>\n          <![CDATA[\n          // collapsed if no matches\n          this.richlistbox.collapsed = (this._matchCount == 0);\n\n          // Update the richlistbox height.\n          if (this._adjustHeightTimeout) {\n            clearTimeout(this._adjustHeightTimeout);\n          }\n          if (this._shrinkTimeout) {\n            clearTimeout(this._shrinkTimeout);\n          }\n\n          if (this.mPopupOpen) {\n            delete this._adjustHeightOnPopupShown;\n            this._adjustHeightTimeout = setTimeout(() => this.adjustHeight(), 0);\n          } else {\n            this._adjustHeightOnPopupShown = true;\n          }\n\n          this._currentIndex = 0;\n          if (this._appendResultTimeout) {\n            clearTimeout(this._appendResultTimeout);\n          }\n          this._appendCurrentResult(reason);\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"maxResults\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            // This is how many richlistitems will be kept around.\n            // Note, this getter may be overridden, or instances\n            // can have the nomaxresults attribute set to have no\n            // limit.\n            if (this.getAttribute(\"nomaxresults\") == \"true\") {\n              return Infinity;\n            }\n\n            return 20;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"_matchCount\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n          return Math.min(this.mInput.controller.matchCount, this.maxResults);\n          ]]>\n        </getter>\n      </property>\n\n      <method name=\"_collapseUnusedItems\">\n        <body>\n          <![CDATA[\n            let existingItemsCount = this.richlistbox.childNodes.length;\n            for (let i = this._matchCount; i < existingItemsCount; ++i) {\n              let item = this.richlistbox.childNodes[i];\n\n              item.collapsed = true;\n              if (typeof item._onCollapse == \"function\") {\n                item._onCollapse();\n              }\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"adjustHeight\">\n        <body>\n          <![CDATA[\n          // Figure out how many rows to show\n          let rows = this.richlistbox.childNodes;\n          let numRows = Math.min(this._matchCount, this.maxRows, rows.length);\n\n          this.removeAttribute(\"height\");\n\n          // Default the height to 0 if we have no rows to show\n          let height = 0;\n          if (numRows) {\n            let firstRowRect = rows[0].getBoundingClientRect();\n            if (this._rlbPadding == undefined) {\n              let style = window.getComputedStyle(this.richlistbox);\n\n              let transition = style.transitionProperty;\n              this._rlbAnimated = transition && transition != \"none\";\n\n              let paddingTop = parseInt(style.paddingTop) || 0;\n              let paddingBottom = parseInt(style.paddingBottom) || 0;\n              this._rlbPadding = paddingTop + paddingBottom;\n            }\n\n            if (numRows > this.maxRows) {\n              // Set a fixed max-height to avoid flicker when growing the panel.\n              let lastVisibleRowRect = rows[this.maxRows - 1].getBoundingClientRect();\n              let visibleHeight = lastVisibleRowRect.bottom - firstRowRect.top;\n              this.richlistbox.style.maxHeight =\n                visibleHeight + this._rlbPadding + \"px\";\n            }\n\n            // The class `forceHandleUnderflow` is for the item might need to\n            // handle OverUnderflow or Overflow when the height of an item will\n            // be changed dynamically.\n            for (let i = 0; i < numRows; i++) {\n              if (rows[i].classList.contains(\"forceHandleUnderflow\")) {\n                rows[i].handleOverUnderflow();\n              }\n            }\n\n            let lastRowRect = rows[numRows - 1].getBoundingClientRect();\n            // Calculate the height to have the first row to last row shown\n            height = lastRowRect.bottom - firstRowRect.top +\n                     this._rlbPadding;\n          }\n\n          let animate = this._rlbAnimated &&\n                        this.getAttribute(\"dontanimate\") != \"true\";\n          let currentHeight = this.richlistbox.getBoundingClientRect().height;\n          if (height > currentHeight) {\n            // Grow immediately.\n            if (animate) {\n              this.richlistbox.removeAttribute(\"height\");\n              this.richlistbox.style.height = height + \"px\";\n            } else {\n              this.richlistbox.style.removeProperty(\"height\");\n              this.richlistbox.height = height;\n            }\n          } else {\n            // Delay shrinking to avoid flicker.\n            this._shrinkTimeout = setTimeout(() => {\n              this._collapseUnusedItems();\n              if (animate) {\n                this.richlistbox.removeAttribute(\"height\");\n                this.richlistbox.style.height = height + \"px\";\n              } else {\n                this.richlistbox.style.removeProperty(\"height\");\n                this.richlistbox.height = height;\n              }\n            }, this.mInput.shrinkDelay);\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_appendCurrentResult\">\n        <parameter name=\"invalidateReason\"/>\n        <body>\n          <![CDATA[\n          var controller = this.mInput.controller;\n          var matchCount = this._matchCount;\n          var existingItemsCount = this.richlistbox.childNodes.length;\n\n          // Process maxRows per chunk to improve performance and user experience\n          for (let i = 0; i < this.maxRows; i++) {\n            if (this._currentIndex >= matchCount) {\n              break;\n            }\n            let item;\n            let reusable = false;\n            let itemExists = this._currentIndex < existingItemsCount;\n\n            let originalValue, originalText, originalType;\n            let value = controller.getValueAt(this._currentIndex);\n            let label = controller.getLabelAt(this._currentIndex);\n            let comment = controller.getCommentAt(this._currentIndex);\n            let style = controller.getStyleAt(this._currentIndex);\n            let image = controller.getImageAt(this._currentIndex);\n            // trim the leading/trailing whitespace\n            let trimmedSearchString = controller.searchString.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n\n            if (itemExists) {\n              item = this.richlistbox.childNodes[this._currentIndex];\n\n              // Url may be a modified version of value, see _adjustACItem().\n              originalValue = item.getAttribute(\"url\") || item.getAttribute(\"ac-value\");\n              originalText = item.getAttribute(\"ac-text\");\n              originalType = item.getAttribute(\"originaltype\");\n\n              // All of types are reusable except for autofill-profile,\n              // which has different structure of <content> and overrides\n              // _adjustAcItem().\n              reusable = originalType === style ||\n                         (style !== \"autofill-profile\" && originalType !== \"autofill-profile\" &&\n                         style !== \"autofill-footer\" && originalType !== \"autofill-footer\");\n            } else {\n              // need to create a new item\n              item = document.createElementNS(\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\", \"richlistitem\");\n            }\n\n            item.setAttribute(\"dir\", this.style.direction);\n            item.setAttribute(\"ac-image\", image);\n            item.setAttribute(\"ac-value\", value);\n            item.setAttribute(\"ac-label\", label);\n            item.setAttribute(\"ac-comment\", comment);\n            item.setAttribute(\"ac-text\", trimmedSearchString);\n\n            // Completely reuse the existing richlistitem for invalidation\n            // due to new results, but only when: the item is the same, *OR*\n            // we are about to replace the currently moused-over item, to\n            // avoid surprising the user.\n            let iface = Components.interfaces.nsIAutoCompletePopup;\n            if (reusable &&\n                originalText == trimmedSearchString &&\n                invalidateReason == iface.INVALIDATE_REASON_NEW_RESULT &&\n                (originalValue == value ||\n                 this.richlistbox.mousedOverIndex === this._currentIndex)) {\n\n              // try to re-use the existing item\n              let reused = item._reuseAcItem();\n              if (reused) {\n                this._currentIndex++;\n                continue;\n              }\n            } else {\n              if (typeof item._cleanup == \"function\") {\n                item._cleanup();\n              }\n              item.setAttribute(\"originaltype\", style);\n            }\n\n            if (itemExists) {\n              // Adjust only when the result's type is reusable for existing\n              // item's. Otherwise, we might insensibly call old _adjustAcItem()\n              // as new binding has not been attached yet.\n              // We don't need to worry about switching to new binding, since\n              // _adjustAcItem() will fired by its own constructor accordingly.\n              if (reusable) {\n                item._adjustAcItem();\n              }\n              item.collapsed = false;\n            } else {\n              // set the class at the end so we can use the attributes\n              // in the xbl constructor\n              item.className = \"autocomplete-richlistitem\";\n              this.richlistbox.appendChild(item);\n            }\n\n            this._currentIndex++;\n          }\n\n          if (typeof this.onResultsAdded == \"function\")\n            this.onResultsAdded();\n\n          if (this._currentIndex < matchCount) {\n            // yield after each batch of items so that typing the url bar is\n            // responsive\n            this._appendResultTimeout = setTimeout(() => this._appendCurrentResult(), 0);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"overflowPadding\"\n                onget=\"return Number(this.getAttribute('overflowpadding'))\"\n                readonly=\"true\" />\n\n      <method name=\"selectBy\">\n        <parameter name=\"aReverse\"/>\n        <parameter name=\"aPage\"/>\n        <body>\n          <![CDATA[\n          try {\n            var amount = aPage ? 5 : 1;\n\n            // because we collapsed unused items, we can't use this.richlistbox.getRowCount(), we need to use the matchCount\n            this.selectedIndex = this.getNextIndex(aReverse, amount, this.selectedIndex, this._matchCount - 1);\n            if (this.selectedIndex == -1) {\n              this.input._focus();\n            }\n          } catch (ex) {\n            // do nothing - occasionally timer-related js errors happen here\n            // e.g. \"this.selectedIndex has no properties\", when you type fast and hit a\n            // navigation key before this popup has opened\n          }\n            ]]>\n        </body>\n      </method>\n\n      <field name=\"richlistbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"richlistbox\");\n      </field>\n\n      <property name=\"view\"\n                onget=\"return this.mInput.controller;\"\n                onset=\"return val;\"/>\n\n    </implementation>\n    <handlers>\n      <handler event=\"popupshown\">\n        <![CDATA[\n          if (this._adjustHeightOnPopupShown) {\n            delete this._adjustHeightOnPopupShown;\n            this.adjustHeight();\n          }\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autocomplete-richlistitem-insecure-field\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-richlistitem\">\n    <content align=\"center\"\n             onoverflow=\"this._onOverflow();\"\n             onunderflow=\"this._onUnderflow();\">\n      <xul:image anonid=\"type-icon\"\n                 class=\"ac-type-icon\"\n                 xbl:inherits=\"selected,current,type\"/>\n      <xul:image anonid=\"site-icon\"\n                 class=\"ac-site-icon\"\n                 xbl:inherits=\"src=image,selected,type\"/>\n      <xul:vbox class=\"ac-title\"\n                align=\"left\"\n                xbl:inherits=\"\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"title-text\"\n                           class=\"ac-title-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:vbox>\n      <xul:hbox anonid=\"tags\"\n                class=\"ac-tags\"\n                align=\"center\"\n                xbl:inherits=\"selected\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"tags-text\"\n                           class=\"ac-tags-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox anonid=\"separator\"\n                class=\"ac-separator\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype,type\">\n        <xul:description class=\"ac-separator-text\"></xul:description>\n      </xul:hbox>\n      <xul:hbox class=\"ac-url\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"url-text\"\n                           class=\"ac-url-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox class=\"ac-action\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"action-text\"\n                           class=\"ac-action-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n    </content>\n\n    <handlers>\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        let baseURL = Services.urlFormatter.formatURLPref(\"app.support.baseURL\");\n        window.openUILinkIn(baseURL + \"insecure-password\", \"tab\", {\n          relatedToCurrent: true,\n        });\n      ]]></handler>\n    </handlers>\n\n    <implementation>\n      <constructor><![CDATA[\n        // Unlike other autocomplete items, the height of the insecure warning\n        // increases by wrapping. So \"forceHandleUnderflow\" is for container to\n        // recalculate an item's height and width.\n        this.classList.add(\"forceHandleUnderflow\");\n      ]]></constructor>\n\n      <property name=\"_learnMoreString\">\n        <getter><![CDATA[\n          if (!this.__learnMoreString) {\n            this.__learnMoreString =\n              Services.strings.createBundle(\"chrome://passwordmgr/locale/passwordmgr.properties\").\n              GetStringFromName(\"insecureFieldWarningLearnMore\");\n          }\n          return this.__learnMoreString;\n        ]]></getter>\n      </property>\n\n      <!-- Override _getSearchTokens to have the Learn More text emphasized -->\n      <method name=\"_getSearchTokens\">\n        <parameter name=\"aSearch\"/>\n        <body>\n          <![CDATA[\n            return [this._learnMoreString.toLowerCase()];\n          ]]>\n        </body>\n      </method>\n\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-richlistitem\" extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n\n    <content align=\"center\"\n             onoverflow=\"this._onOverflow();\"\n             onunderflow=\"this._onUnderflow();\">\n      <xul:image anonid=\"type-icon\"\n                 class=\"ac-type-icon\"\n                 xbl:inherits=\"selected,current,type\"/>\n      <xul:image anonid=\"site-icon\"\n                 class=\"ac-site-icon\"\n                 xbl:inherits=\"src=image,selected,type\"/>\n      <xul:hbox class=\"ac-title\"\n                align=\"center\"\n                xbl:inherits=\"selected\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"title-text\"\n                           class=\"ac-title-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox anonid=\"tags\"\n                class=\"ac-tags\"\n                align=\"center\"\n                xbl:inherits=\"selected\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"tags-text\"\n                           class=\"ac-tags-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox anonid=\"separator\"\n                class=\"ac-separator\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype,type\">\n        <xul:description class=\"ac-separator-text\"></xul:description>\n      </xul:hbox>\n      <xul:hbox class=\"ac-url\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"url-text\"\n                           class=\"ac-url-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox class=\"ac-action\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"action-text\"\n                           class=\"ac-action-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n        <![CDATA[\n          this._typeIcon = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"type-icon\"\n          );\n          this._siteIcon = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"site-icon\"\n          );\n          this._titleText = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"title-text\"\n          );\n          this._tags = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"tags\"\n          );\n          this._tagsText = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"tags-text\"\n          );\n          this._separator = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"separator\"\n          );\n          this._urlText = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"url-text\"\n          );\n          this._actionText = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"action-text\"\n          );\n          this._adjustAcItem();\n        ]]>\n      </constructor>\n\n      <method name=\"_cleanup\">\n        <body>\n        <![CDATA[\n          this.removeAttribute(\"url\");\n          this.removeAttribute(\"image\");\n          this.removeAttribute(\"title\");\n          this.removeAttribute(\"text\");\n          this.removeAttribute(\"displayurl\");\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"label\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            // This property is a string that is read aloud by screen readers,\n            // so it must not contain anything that should not be user-facing.\n\n            let parts = [\n              this.getAttribute(\"title\"),\n              this.getAttribute(\"displayurl\"),\n            ];\n            let label = parts.filter(str => str).join(\" \")\n\n            // allow consumers that have extended popups to override\n            // the label values for the richlistitems\n            let panel = this.parentNode.parentNode;\n            if (panel.createResultLabel) {\n              return panel.createResultLabel(this, label);\n            }\n\n            return label;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"_stringBundle\">\n        <getter><![CDATA[\n          if (!this.__stringBundle) {\n            this.__stringBundle = Services.strings.createBundle(\"chrome://global/locale/autocomplete.properties\");\n          }\n          return this.__stringBundle;\n        ]]></getter>\n      </property>\n\n      <field name=\"_boundaryCutoff\">null</field>\n\n      <property name=\"boundaryCutoff\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n          if (!this._boundaryCutoff) {\n            this._boundaryCutoff =\n              Components.classes[\"@mozilla.org/preferences-service;1\"].\n              getService(Components.interfaces.nsIPrefBranch).\n              getIntPref(\"toolkit.autocomplete.richBoundaryCutoff\");\n          }\n          return this._boundaryCutoff;\n          ]]>\n        </getter>\n      </property>\n\n      <field name=\"_inOverflow\">false</field>\n\n      <method name=\"_onOverflow\">\n        <body>\n          <![CDATA[\n          this._inOverflow = true;\n          this._handleOverflow();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_onUnderflow\">\n        <body>\n          <![CDATA[\n          this._inOverflow = false;\n          this._handleOverflow();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_getBoundaryIndices\">\n        <parameter name=\"aText\"/>\n        <parameter name=\"aSearchTokens\"/>\n        <body>\n          <![CDATA[\n          // Short circuit for empty search ([\"\"] == \"\")\n          if (aSearchTokens == \"\")\n            return [0, aText.length];\n\n          // Find which regions of text match the search terms\n          let regions = [];\n          for (let search of Array.prototype.slice.call(aSearchTokens)) {\n            let matchIndex = -1;\n            let searchLen = search.length;\n\n            // Find all matches of the search terms, but stop early for perf\n            let lowerText = aText.substr(0, this.boundaryCutoff).toLowerCase();\n            while ((matchIndex = lowerText.indexOf(search, matchIndex + 1)) >= 0) {\n              regions.push([matchIndex, matchIndex + searchLen]);\n            }\n          }\n\n          // Sort the regions by start position then end position\n          regions = regions.sort((a, b) => {\n            let start = a[0] - b[0];\n            return (start == 0) ? a[1] - b[1] : start;\n          });\n\n          // Generate the boundary indices from each region\n          let start = 0;\n          let end = 0;\n          let boundaries = [];\n          let len = regions.length;\n          for (let i = 0; i < len; i++) {\n            // We have a new boundary if the start of the next is past the end\n            let region = regions[i];\n            if (region[0] > end) {\n              // First index is the beginning of match\n              boundaries.push(start);\n              // Second index is the beginning of non-match\n              boundaries.push(end);\n\n              // Track the new region now that we've stored the previous one\n              start = region[0];\n            }\n\n            // Push back the end index for the current or new region\n            end = Math.max(end, region[1]);\n          }\n\n          // Add the last region\n          boundaries.push(start);\n          boundaries.push(end);\n\n          // Put on the end boundary if necessary\n          if (end < aText.length)\n            boundaries.push(aText.length);\n\n          // Skip the first item because it's always 0\n          return boundaries.slice(1);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_getSearchTokens\">\n        <parameter name=\"aSearch\"/>\n        <body>\n          <![CDATA[\n          let search = aSearch.toLowerCase();\n          return search.split(/\\s+/);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_setUpDescription\">\n        <parameter name=\"aDescriptionElement\"/>\n        <parameter name=\"aText\"/>\n        <parameter name=\"aNoEmphasis\"/>\n        <body>\n          <![CDATA[\n          // Get rid of all previous text\n          if (!aDescriptionElement) {\n            return;\n          }\n          while (aDescriptionElement.hasChildNodes())\n            aDescriptionElement.firstChild.remove();\n\n          // If aNoEmphasis is specified, don't add any emphasis\n          if (aNoEmphasis) {\n            aDescriptionElement.appendChild(document.createTextNode(aText));\n            return;\n          }\n\n          // Get the indices that separate match and non-match text\n          let search = this.getAttribute(\"text\");\n          let tokens = this._getSearchTokens(search);\n          let indices = this._getBoundaryIndices(aText, tokens);\n\n          this._appendDescriptionSpans(indices, aText, aDescriptionElement,\n                                       aDescriptionElement);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_appendDescriptionSpans\">\n        <parameter name=\"indices\"/>\n        <parameter name=\"text\"/>\n        <parameter name=\"spansParentElement\"/>\n        <parameter name=\"descriptionElement\"/>\n        <body>\n          <![CDATA[\n          let next;\n          let start = 0;\n          let len = indices.length;\n          // Even indexed boundaries are matches, so skip the 0th if it's empty\n          for (let i = indices[0] == 0 ? 1 : 0; i < len; i++) {\n            next = indices[i];\n            let spanText = text.substr(start, next - start);\n            start = next;\n\n            if (i % 2 == 0) {\n              // Emphasize the text for even indices\n              let span = spansParentElement.appendChild(\n                document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"span\"));\n              this._setUpEmphasisSpan(span, descriptionElement);\n              span.textContent = spanText;\n            } else {\n              // Otherwise, it's plain text\n              spansParentElement.appendChild(document.createTextNode(spanText));\n            }\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_setUpTags\">\n        <parameter name=\"tags\"/>\n        <body>\n          <![CDATA[\n          while (this._tagsText.hasChildNodes()) {\n            this._tagsText.firstChild.remove();\n          }\n\n          let anyTagsMatch = false;\n\n          // Include only tags that match the search string.\n          for (let tag of tags) {\n            // Check if the tag matches the search string.\n            let search = this.getAttribute(\"text\");\n            let tokens = this._getSearchTokens(search);\n            let indices = this._getBoundaryIndices(tag, tokens);\n\n            if (indices.length == 2 &&\n                indices[0] == 0 &&\n                indices[1] == tag.length) {\n              // The tag doesn't match the search string, so don't include it.\n              continue;\n            }\n\n            anyTagsMatch = true;\n\n            let tagSpan =\n              document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"span\");\n            tagSpan.classList.add(\"ac-tag\");\n            this._tagsText.appendChild(tagSpan);\n\n            this._appendDescriptionSpans(indices, tag, tagSpan, this._tagsText);\n          }\n\n          return anyTagsMatch;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_setUpEmphasisSpan\">\n        <parameter name=\"aSpan\"/>\n        <parameter name=\"aDescriptionElement\"/>\n        <body>\n          <![CDATA[\n          aSpan.classList.add(\"ac-emphasize-text\");\n          switch (aDescriptionElement) {\n            case this._titleText:\n              aSpan.classList.add(\"ac-emphasize-text-title\");\n              break;\n            case this._tagsText:\n              aSpan.classList.add(\"ac-emphasize-text-tag\");\n              break;\n            case this._urlText:\n              aSpan.classList.add(\"ac-emphasize-text-url\");\n              break;\n            case this._actionText:\n              aSpan.classList.add(\"ac-emphasize-text-action\");\n              break;\n          }\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        This will generate an array of emphasis pairs for use with\n        _setUpEmphasisedSections(). Each pair is a tuple (array) that\n        represents a block of text - containing the text of that block, and a\n        boolean for whether that block should have an emphasis styling applied\n        to it.\n\n        These pairs are generated by parsing a localised string (aSourceString)\n        with parameters, in the format that is used by\n        nsIStringBundle.formatStringFromName():\n\n          \"textA %1$S textB textC %2$S\"\n\n        Or:\n\n          \"textA %S\"\n\n        Where \"%1$S\", \"%2$S\", and \"%S\" are intended to be replaced by provided\n        replacement strings. These are specified an array of tuples\n        (aReplacements), each containing the replacement text and a boolean for\n        whether that text should have an emphasis styling applied. This is used\n        as a 1-based array - ie, \"%1$S\" is replaced by the item in the first\n        index of aReplacements, \"%2$S\" by the second, etc. \"%S\" will always\n        match the first index.\n      -->\n      <method name=\"_generateEmphasisPairs\">\n        <parameter name=\"aSourceString\"/>\n        <parameter name=\"aReplacements\"/>\n        <body>\n          <![CDATA[\n            let pairs = [];\n\n            // Split on %S, %1$S, %2$S, etc. ie:\n            //   \"textA %S\"\n            //     becomes [\"textA \", \"%S\"]\n            //   \"textA %1$S textB textC %2$S\"\n            //     becomes [\"textA \", \"%1$S\", \" textB textC \", \"%2$S\"]\n            let parts = aSourceString.split(/(%(?:[0-9]+\\$)?S)/);\n\n            for (let part of parts) {\n              // The above regex will actually give us an empty string at the\n              // end - we don't want that, as we don't want to later generate an\n              // empty text node for it.\n              if (part.length === 0)\n                continue;\n\n              // Determine if this token is a replacement token or a normal text\n              // token. If it is a replacement token, we want to extract the\n              // numerical number. However, we still want to match on \"$S\".\n              let match = part.match(/^%(?:([0-9]+)\\$)?S$/);\n\n              if (match) {\n                // \"%S\" doesn't have a numerical number in it, but will always\n                // be assumed to be 1. Furthermore, the input string specifies\n                // these with a 1-based index, but we want a 0-based index.\n                let index = (match[1] || 1) - 1;\n\n                if (index >= 0 && index < aReplacements.length) {\n                  pairs.push([...aReplacements[index]]);\n                }\n              } else {\n                pairs.push([part]);\n              }\n            }\n\n            return pairs;\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        _setUpEmphasisedSections() has the same use as _setUpDescription,\n        except instead of taking a string and highlighting given tokens, it takes\n        an array of pairs generated by _generateEmphasisPairs(). This allows\n        control over emphasising based on specific blocks of text, rather than\n        search for substrings.\n      -->\n      <method name=\"_setUpEmphasisedSections\">\n        <parameter name=\"aDescriptionElement\"/>\n        <parameter name=\"aTextPairs\"/>\n        <body>\n          <![CDATA[\n          // Get rid of all previous text\n          while (aDescriptionElement.hasChildNodes())\n            aDescriptionElement.firstChild.remove();\n\n          for (let [text, emphasise] of aTextPairs) {\n            if (emphasise) {\n              let span = aDescriptionElement.appendChild(\n                document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"span\"));\n              span.textContent = text;\n              switch (emphasise) {\n                case \"match\":\n                  this._setUpEmphasisSpan(span, aDescriptionElement);\n                  break;\n              }\n            } else {\n              aDescriptionElement.appendChild(document.createTextNode(text));\n            }\n          }\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"_textToSubURI\">null</field>\n      <method name=\"_unescapeUrl\">\n        <parameter name=\"url\"/>\n        <body>\n          <![CDATA[\n          if (!this._textToSubURI) {\n            this._textToSubURI =\n              Components.classes[\"@mozilla.org/intl/texttosuburi;1\"]\n                        .getService(Components.interfaces.nsITextToSubURI);\n          }\n          return this._textToSubURI.unEscapeURIForUI(\"UTF-8\", url);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_reuseAcItem\">\n        <body>\n          <![CDATA[\n            let action = this._parseActionUrl(this.getAttribute(\"url\"));\n            let popup = this.parentNode.parentNode;\n\n            // If the item is a searchengine action, then it should\n            // only be reused if the engine name is the same as the\n            // popup's override engine name, if any.\n            if (!action ||\n                action.type != \"searchengine\" ||\n                !popup.overrideSearchEngineName ||\n                action.params.engineName == popup.overrideSearchEngineName) {\n\n              this.collapsed = false;\n\n              // The popup may have changed size between now and the last\n              // time the item was shown, so always handle over/underflow.\n              let dwu = window.getInterface(Ci.nsIDOMWindowUtils);\n              let popupWidth = dwu.getBoundsWithoutFlushing(this.parentNode).width;\n              if (!this._previousPopupWidth || this._previousPopupWidth != popupWidth) {\n                this._previousPopupWidth = popupWidth;\n                this.handleOverUnderflow();\n              }\n\n              return true;\n            }\n\n            return false;\n          ]]>\n        </body>\n      </method>\n\n\n      <method name=\"_adjustAcItem\">\n        <body>\n          <![CDATA[\n          let originalUrl = this.getAttribute(\"ac-value\");\n          let title = this.getAttribute(\"ac-comment\");\n          this.setAttribute(\"url\", originalUrl);\n          this.setAttribute(\"image\", this.getAttribute(\"ac-image\"));\n          this.setAttribute(\"title\", title);\n          this.setAttribute(\"text\", this.getAttribute(\"ac-text\"));\n\n          let popup = this.parentNode.parentNode;\n          let titleLooksLikeUrl = false;\n          let displayUrl;\n          let emphasiseUrl = true;\n\n          let type = this.getAttribute(\"originaltype\");\n          let types = new Set(type.split(/\\s+/));\n          let initialTypes = new Set(types);\n          // Remove types that should ultimately not be in the `type` string.\n          types.delete(\"action\");\n          types.delete(\"autofill\");\n          types.delete(\"heuristic\");\n          type = [...types][0] || \"\";\n\n          let action;\n\n          if (initialTypes.has(\"autofill\")) {\n            // Treat autofills as visiturl actions.\n            action = {\n              type: \"visiturl\",\n              params: {\n                url: this.getAttribute(\"title\"),\n              },\n            };\n          }\n\n          this.removeAttribute(\"actiontype\");\n          this.classList.remove(\"overridable-action\");\n\n          // If the type includes an action, set up the item appropriately.\n          if (initialTypes.has(\"action\") || action) {\n            action = action || this._parseActionUrl(originalUrl);\n            this.setAttribute(\"actiontype\", action.type);\n\n            if (action.type == \"switchtab\") {\n              this.classList.add(\"overridable-action\");\n              displayUrl = this._unescapeUrl(action.params.url);\n              let desc = this._stringBundle.GetStringFromName(\"switchToTab2\");\n              this._setUpDescription(this._actionText, desc, true);\n            } else if (action.type == \"remotetab\") {\n              displayUrl = this._unescapeUrl(action.params.url);\n              let desc = action.params.deviceName;\n              this._setUpDescription(this._actionText, desc, true);\n            } else if (action.type == \"searchengine\") {\n              emphasiseUrl = false;\n\n              // The order here is not localizable, we default to appending\n              // \"- Search with Engine\" to the search string, to be able to\n              // properly generate emphasis pairs. That said, no localization\n              // changed the order while it was possible, so doesn't look like\n              // there's a strong need for that.\n              let {engineName, searchSuggestion, searchQuery} = action.params;\n\n              // Override the engine name if the popup defines an override.\n              let override = popup.overrideSearchEngineName;\n              if (override && override != engineName) {\n                engineName = override;\n                action.params.engineName = override;\n                let newURL =\n                  PlacesUtils.mozActionURI(action.type, action.params);\n                this.setAttribute(\"url\", newURL);\n              }\n\n              let engineStr =\n                this._stringBundle.formatStringFromName(\"searchWithEngine\",\n                                                        [engineName], 1);\n              this._setUpDescription(this._actionText, engineStr, true);\n\n              // Make the title by generating an array of pairs and its\n              // corresponding interpolation string (e.g., \"%1$S\") to pass to\n              // _generateEmphasisPairs.\n              let pairs;\n              if (searchSuggestion) {\n                // Check if the search query appears in the suggestion.  It may\n                // not.  If it does, then emphasize the query in the suggestion\n                // and otherwise just include the suggestion without emphasis.\n                let idx = searchSuggestion.indexOf(searchQuery);\n                if (idx >= 0) {\n                  pairs = [\n                    [searchSuggestion.substring(0, idx), \"\"],\n                    [searchQuery, \"match\"],\n                    [searchSuggestion.substring(idx + searchQuery.length), \"\"],\n                  ];\n                } else {\n                  pairs = [\n                    [searchSuggestion, \"\"],\n                  ];\n                }\n              } else {\n                pairs = [\n                  [searchQuery, \"\"],\n                ];\n              }\n              let interpStr = pairs.map((pair, i) => `%${i + 1}$S`).join(\"\");\n              title = this._generateEmphasisPairs(interpStr, pairs);\n\n              // If this is a default search match, we remove the image so we\n              // can style it ourselves with a generic search icon.\n              // We don't do this when matching an aliased search engine,\n              // because the icon helps with recognising which engine will be\n              // used (when using the default engine, we don't need that\n              // recognition).\n              if (!action.params.alias && !initialTypes.has(\"favicon\")) {\n                this.removeAttribute(\"image\");\n              }\n            } else if (action.type == \"visiturl\") {\n              emphasiseUrl = false;\n              displayUrl = this._unescapeUrl(action.params.url);\n              title = displayUrl;\n              titleLooksLikeUrl = true;\n              let visitStr = this._stringBundle.GetStringFromName(\"visit\");\n              this._setUpDescription(this._actionText, visitStr, true);\n            } else if (action.type == \"extension\") {\n              let content = action.params.content;\n              displayUrl = content;\n              this._setUpDescription(this._actionText, content, true);\n            }\n          }\n\n          if (!displayUrl) {\n            let input = popup.input;\n            let url = typeof(input.trimValue) == \"function\" ?\n                      input.trimValue(originalUrl) :\n                      originalUrl;\n            displayUrl = this._unescapeUrl(url);\n          }\n          // For performance reasons we may want to limit the displayUrl size.\n          if (popup.textRunsMaxLen) {\n            displayUrl = displayUrl.substr(0, popup.textRunsMaxLen);\n          }\n          this.setAttribute(\"displayurl\", displayUrl);\n\n          // Show the domain as the title if we don't have a title.\n          if (!title) {\n            title = displayUrl;\n            titleLooksLikeUrl = true;\n            try {\n              let uri = Services.io.newURI(originalUrl);\n              // Not all valid URLs have a domain.\n              if (uri.host)\n                title = uri.host;\n            } catch (e) {}\n          }\n\n          this._tags.setAttribute(\"empty\", \"true\");\n\n          if (type == \"tag\" || type == \"bookmark-tag\") {\n            // The title is separated from the tags by an endash\n            let tags;\n            [, title, tags] = title.match(/^(.+) \\u2013 (.+)$/);\n\n            // Each tag is split by a comma in an undefined order, so sort it\n            let sortedTags = tags.split(/\\s*,\\s*/).sort((a, b) => {\n              return a.localeCompare(a);\n            });\n\n            let anyTagsMatch = this._setUpTags(sortedTags);\n            if (anyTagsMatch) {\n              this._tags.removeAttribute(\"empty\");\n            }\n            if (type == \"bookmark-tag\") {\n              type = \"bookmark\";\n            }\n          } else if (type == \"keyword\") {\n            // Note that this is a moz-action with action.type == keyword.\n            emphasiseUrl = false;\n            let keywordArg = this.getAttribute(\"text\").replace(/^[^\\s]+\\s*/, \"\");\n            if (!keywordArg) {\n              // Treat keyword searches without arguments as visiturl actions.\n              type = \"visiturl\";\n              this.setAttribute(\"actiontype\", \"visiturl\");\n              let visitStr = this._stringBundle.GetStringFromName(\"visit\");\n              this._setUpDescription(this._actionText, visitStr, true);\n            } else {\n              let pairs = [[title, \"\"], [keywordArg, \"match\"]];\n              let interpStr =\n                this._stringBundle.GetStringFromName(\"bookmarkKeywordSearch\");\n              title = this._generateEmphasisPairs(interpStr, pairs);\n              // The action box will be visible since this is a moz-action, but\n              // we want it to appear as if it were not visible, so set its text\n              // to the empty string.\n              this._setUpDescription(this._actionText, \"\", false);\n            }\n          }\n\n          this.setAttribute(\"type\", type);\n\n          if (titleLooksLikeUrl) {\n            this._titleText.setAttribute(\"lookslikeurl\", \"true\");\n          } else {\n            this._titleText.removeAttribute(\"lookslikeurl\");\n          }\n\n          if (Array.isArray(title)) {\n            // For performance reasons we may want to limit the title size.\n            if (popup.textRunsMaxLen) {\n              title = title.map(t => t.substr(0, popup.textRunsMaxLen));\n            }\n            this._setUpEmphasisedSections(this._titleText, title);\n          } else {\n            // For performance reasons we may want to limit the title size.\n            if (popup.textRunsMaxLen) {\n              title = title.substr(0, popup.textRunsMaxLen);\n            }\n            this._setUpDescription(this._titleText, title, false);\n          }\n          this._setUpDescription(this._urlText, displayUrl, !emphasiseUrl);\n\n          // Removing the max-width may be jarring when the item is visible, but\n          // we have no other choice to properly crop the text.\n          // Removing max-widths may cause overflow or underflow events, that\n          // will set the _inOverflow property. In case both the old and the new\n          // text are overflowing, the overflow event won't happen, and we must\n          // enforce an _handleOverflow() call to update the max-widths.\n          let wasInOverflow = this._inOverflow;\n          this._removeMaxWidths();\n          if (wasInOverflow && this._inOverflow) {\n            this._handleOverflow();\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_removeMaxWidths\">\n        <body>\n          <![CDATA[\n          if (this._hasMaxWidths) {\n            this._titleText.style.removeProperty(\"max-width\");\n            this._tagsText.style.removeProperty(\"max-width\");\n            this._urlText.style.removeProperty(\"max-width\");\n            this._actionText.style.removeProperty(\"max-width\");\n            this._hasMaxWidths = false;\n          }\n          ]]>\n        </body>\n      </method>\n\n      <!-- This method truncates the displayed strings as necessary. -->\n      <method name=\"_handleOverflow\">\n        <body><![CDATA[\n          let itemRect = this.parentNode.getBoundingClientRect();\n          let titleRect = this._titleText.getBoundingClientRect();\n          let tagsRect = this._tagsText.getBoundingClientRect();\n          let separatorRect = this._separator.getBoundingClientRect();\n          let urlRect = this._urlText.getBoundingClientRect();\n          let actionRect = this._actionText.getBoundingClientRect();\n          let separatorURLActionWidth =\n            separatorRect.width + Math.max(urlRect.width, actionRect.width);\n\n          // Total width for the title and URL/action is the width of the item\n          // minus the start of the title text minus a little optional extra padding.\n          // This extra padding amount is basically arbitrary but keeps the text\n          // from getting too close to the popup's edge.\n          let dir = this.getAttribute(\"dir\");\n          let titleStart = dir == \"rtl\" ? itemRect.right - titleRect.right\n                                        : titleRect.left - itemRect.left;\n\n          let popup = this.parentNode.parentNode;\n          let itemWidth = itemRect.width - titleStart - popup.overflowPadding -\n                          (popup.margins ? popup.margins.end : 0);\n\n          if (this._tags.hasAttribute(\"empty\")) {\n            // The tags box is not displayed in this case.\n            tagsRect.width = 0;\n          }\n\n          let titleTagsWidth = titleRect.width + tagsRect.width;\n          if (titleTagsWidth + separatorURLActionWidth > itemWidth) {\n            // Title + tags + URL/action overflows the item width.\n\n            // The percentage of the item width allocated to the title and tags.\n            let titleTagsPct = 0.66;\n\n            let titleTagsAvailable = itemWidth - separatorURLActionWidth;\n            let titleTagsMaxWidth = Math.max(\n              titleTagsAvailable,\n              itemWidth * titleTagsPct\n            );\n            if (titleTagsWidth > titleTagsMaxWidth) {\n              // Title + tags overflows the max title + tags width.\n\n              // The percentage of the title + tags width allocated to the\n              // title.\n              let titlePct = 0.33;\n\n              let titleAvailable = titleTagsMaxWidth - tagsRect.width;\n              let titleMaxWidth = Math.max(\n                titleAvailable,\n                titleTagsMaxWidth * titlePct\n              );\n              let tagsAvailable = titleTagsMaxWidth - titleRect.width;\n              let tagsMaxWidth = Math.max(\n                tagsAvailable,\n                titleTagsMaxWidth * (1 - titlePct)\n              );\n              this._titleText.style.maxWidth = titleMaxWidth + \"px\";\n              this._tagsText.style.maxWidth = tagsMaxWidth + \"px\";\n            }\n            let urlActionMaxWidth = Math.max(\n              itemWidth - titleTagsWidth,\n              itemWidth * (1 - titleTagsPct)\n            );\n            urlActionMaxWidth -= separatorRect.width;\n            this._urlText.style.maxWidth = urlActionMaxWidth + \"px\";\n            this._actionText.style.maxWidth = urlActionMaxWidth + \"px\";\n            this._hasMaxWidths = true;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"handleOverUnderflow\">\n        <body>\n          <![CDATA[\n          this._removeMaxWidths();\n          this._handleOverflow();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_parseActionUrl\">\n        <parameter name=\"aUrl\"/>\n        <body><![CDATA[\n          if (!aUrl.startsWith(\"moz-action:\"))\n            return null;\n\n          // URL is in the format moz-action:ACTION,PARAMS\n          // Where PARAMS is a JSON encoded object.\n          let [, type, params] = aUrl.match(/^moz-action:([^,]+),(.*)$/);\n\n          let action = {\n            type,\n          };\n\n          try {\n            action.params = JSON.parse(params);\n            for (let key in action.params) {\n              action.params[key] = decodeURIComponent(action.params[key]);\n            }\n          } catch (e) {\n            // If this failed, we assume that params is not a JSON object, and\n            // is instead just a flat string. This may happen for legacy\n            // search components.\n            action.params = {\n              url: params,\n            }\n          }\n\n          return action;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <!--\n        This overrides listitem's mousedown handler because we want to set the\n        selected item even when the shift or accel keys are pressed.\n      -->\n      <handler event=\"mousedown\"><![CDATA[\n        // Call this.control only once since it's not a simple getter.\n        let control = this.control;\n        if (!control || control.disabled) {\n          return;\n        }\n        if (!this.selected) {\n          control.selectItem(this);\n        }\n        control.currentItem = this;\n      ]]></handler>\n\n      <handler event=\"mouseover\"><![CDATA[\n        // The point of implementing this handler is to allow drags to change\n        // the selected item.  If the user mouses down on an item, it becomes\n        // selected.  If they then drag the mouse to another item, select it.\n        // Handle all three primary mouse buttons: right, left, and wheel, since\n        // all three change the selection on mousedown.\n        let mouseDown = event.buttons & 0b111;\n        if (!mouseDown) {\n          return;\n        }\n        // Call this.control only once since it's not a simple getter.\n        let control = this.control;\n        if (!control || control.disabled) {\n          return;\n        }\n        if (!this.selected) {\n          control.selectItem(this);\n        }\n        control.currentItem = this;\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autocomplete-tree\" extends=\"chrome://global/content/bindings/tree.xml#tree\">\n    <content>\n      <children includes=\"treecols\"/>\n      <xul:treerows class=\"autocomplete-treerows tree-rows\" xbl:inherits=\"hidescrollbar\" flex=\"1\">\n        <children/>\n      </xul:treerows>\n    </content>\n  </binding>\n\n  <binding id=\"autocomplete-richlistbox\" extends=\"chrome://global/content/bindings/richlistbox.xml#richlistbox\">\n    <implementation>\n      <field name=\"mLastMoveTime\">Date.now()</field>\n      <field name=\"mousedOverIndex\">-1</field>\n    </implementation>\n    <handlers>\n      <handler event=\"mouseup\">\n        <![CDATA[\n        // don't call onPopupClick for the scrollbar buttons, thumb, slider, etc.\n        let item = event.originalTarget;\n        while (item && item.localName != \"richlistitem\") {\n          item = item.parentNode;\n        }\n\n        if (!item)\n          return;\n\n        this.parentNode.onPopupClick(event);\n      ]]>\n      </handler>\n\n      <handler event=\"mousemove\">\n        <![CDATA[\n        if (Date.now() - this.mLastMoveTime <= 30) {\n          return;\n        }\n\n        let item = event.target;\n        while (item && item.localName != \"richlistitem\") {\n          item = item.parentNode;\n        }\n\n        if (!item) {\n          return;\n        }\n\n        let index = this.getIndexOfItem(item);\n\n        this.mousedOverIndex = index;\n\n        if (item.selectedByMouseOver) {\n          this.selectedIndex = index;\n        }\n\n        this.mLastMoveTime = Date.now();\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autocomplete-treebody\">\n    <implementation>\n      <field name=\"mLastMoveTime\">Date.now()</field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"mouseup\" action=\"this.parentNode.parentNode.onPopupClick(event);\"/>\n\n      <handler event=\"mousedown\"><![CDATA[\n         var rc = this.parentNode.treeBoxObject.getRowAt(event.clientX, event.clientY);\n         if (rc != this.parentNode.currentIndex)\n            this.parentNode.view.selection.select(rc);\n      ]]></handler>\n\n      <handler event=\"mousemove\"><![CDATA[\n        if (event.defaultPrevented) {\n          // Allow bindings that extend this one to cancel the event so that\n          // nothing is selected.\n          return;\n        }\n        if (Date.now() - this.mLastMoveTime > 30) {\n         var rc = this.parentNode.treeBoxObject.getRowAt(event.clientX, event.clientY);\n         if (rc != this.parentNode.currentIndex)\n            this.parentNode.view.selection.select(rc);\n         this.mLastMoveTime = Date.now();\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autocomplete-treerows\">\n    <content>\n      <xul:hbox flex=\"1\" class=\"tree-bodybox\">\n        <children/>\n      </xul:hbox>\n      <xul:scrollbar xbl:inherits=\"collapsed=hidescrollbar\" orient=\"vertical\" class=\"tree-scrollbar\"/>\n    </content>\n  </binding>\n\n</bindings>\n"},{"file":"browser.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"browserBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"browser\" extends=\"xul:browser\" role=\"outerdoc\">\n    <content clickthrough=\"never\">\n      <children/>\n    </content>\n    <implementation type=\"application/javascript\" implements=\"nsIObserver, nsIDOMEventListener, nsIMessageListener, nsIBrowser\">\n      <property name=\"autoscrollEnabled\">\n        <getter>\n          <![CDATA[\n            if (this.getAttribute(\"autoscroll\") == \"false\")\n              return false;\n\n            return this.mPrefs.getBoolPref(\"general.autoScroll\", true);\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"canGoBack\"\n                onget=\"return this.webNavigation.canGoBack;\"\n                readonly=\"true\"/>\n\n      <property name=\"canGoForward\"\n                onget=\"return this.webNavigation.canGoForward;\"\n                readonly=\"true\"/>\n\n      <method name=\"_wrapURIChangeCall\">\n        <parameter name=\"fn\"/>\n        <body>\n          <![CDATA[\n            if (!this.isRemoteBrowser) {\n              this.inLoadURI = true;\n              try {\n                fn();\n              } finally {\n                this.inLoadURI = false;\n              }\n            } else {\n              fn();\n            }\n          ]]>\n        </body>\n      </method>\n\n\n      <method name=\"goBack\">\n        <body>\n          <![CDATA[\n            var webNavigation = this.webNavigation;\n            if (webNavigation.canGoBack)\n              this._wrapURIChangeCall(() => webNavigation.goBack());\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"goForward\">\n        <body>\n          <![CDATA[\n            var webNavigation = this.webNavigation;\n            if (webNavigation.canGoForward)\n              this._wrapURIChangeCall(() => webNavigation.goForward());\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"reload\">\n        <body>\n          <![CDATA[\n            const nsIWebNavigation = Components.interfaces.nsIWebNavigation;\n            const flags = nsIWebNavigation.LOAD_FLAGS_NONE;\n            this.reloadWithFlags(flags);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"reloadWithFlags\">\n        <parameter name=\"aFlags\"/>\n        <body>\n          <![CDATA[\n            this.webNavigation.reload(aFlags);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"stop\">\n        <body>\n          <![CDATA[\n            const nsIWebNavigation = Components.interfaces.nsIWebNavigation;\n            const flags = nsIWebNavigation.STOP_ALL;\n            this.webNavigation.stop(flags);\n          ]]>\n        </body>\n      </method>\n\n      <!-- throws exception for unknown schemes -->\n      <method name=\"loadURI\">\n        <parameter name=\"aURI\"/>\n        <parameter name=\"aReferrerURI\"/>\n        <parameter name=\"aCharset\"/>\n        <body>\n          <![CDATA[\n            const nsIWebNavigation = Components.interfaces.nsIWebNavigation;\n            const flags = nsIWebNavigation.LOAD_FLAGS_NONE;\n            this._wrapURIChangeCall(() =>\n              this.loadURIWithFlags(aURI, flags, aReferrerURI, aCharset));\n          ]]>\n        </body>\n      </method>\n\n      <!-- throws exception for unknown schemes -->\n      <method name=\"loadURIWithFlags\">\n        <parameter name=\"aURI\"/>\n        <parameter name=\"aFlags\"/>\n        <parameter name=\"aReferrerURI\"/>\n        <parameter name=\"aCharset\"/>\n        <parameter name=\"aPostData\"/>\n        <body>\n          <![CDATA[\n            if (!aURI)\n              aURI = \"about:blank\";\n\n            var aReferrerPolicy = Components.interfaces.nsIHttpChannel.REFERRER_POLICY_UNSET;\n            var aTriggeringPrincipal;\n\n            // Check for loadURIWithFlags(uri, { ... });\n            var params = arguments[1];\n            if (params && typeof(params) == \"object\") {\n              aFlags = params.flags;\n              aReferrerURI = params.referrerURI;\n              if (\"referrerPolicy\" in params) {\n                aReferrerPolicy = params.referrerPolicy;\n              }\n              if (\"triggeringPrincipal\" in params) {\n                aTriggeringPrincipal = params.triggeringPrincipal;\n              }\n              aCharset = params.charset;\n              aPostData = params.postData;\n            }\n\n            this._wrapURIChangeCall(() =>\n              this.webNavigation.loadURIWithOptions(\n                  aURI, aFlags, aReferrerURI, aReferrerPolicy,\n                  aPostData, null, null, aTriggeringPrincipal));\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"goHome\">\n        <body>\n          <![CDATA[\n            try {\n              this.loadURI(this.homePage);\n            } catch (e) {\n            }\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"homePage\">\n        <getter>\n          <![CDATA[\n            var uri;\n\n            if (this.hasAttribute(\"homepage\"))\n              uri = this.getAttribute(\"homepage\");\n            else\n              uri = \"http://www.mozilla.org/\"; // widget pride\n\n            return uri;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            this.setAttribute(\"homepage\", val);\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"gotoIndex\">\n        <parameter name=\"aIndex\"/>\n        <body>\n          <![CDATA[\n            this._wrapURIChangeCall(() => this.webNavigation.gotoIndex(aIndex));\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"currentURI\" readonly=\"true\">\n       <getter><![CDATA[\n          if (this.webNavigation) {\n            return this.webNavigation.currentURI;\n          }\n          return null;\n       ]]>\n       </getter>\n      </property>\n\n      <!--\n        Used by session restore to ensure that currentURI is set so\n        that switch-to-tab works before the tab is fully\n        restored. This function also invokes onLocationChanged\n        listeners in tabbrowser.xml.\n      -->\n      <method name=\"_setCurrentURI\">\n        <parameter name=\"aURI\"/>\n        <body><![CDATA[\n          this.docShell.setCurrentURI(aURI);\n        ]]></body>\n      </method>\n\n      <property name=\"documentURI\"\n                onget=\"return this.contentDocument.documentURIObject;\"\n                readonly=\"true\"/>\n\n      <property name=\"documentContentType\"\n                onget=\"return this.contentDocument ? this.contentDocument.contentType : null;\"\n                readonly=\"true\"/>\n\n      <property name=\"preferences\"\n                onget=\"return this.mPrefs.QueryInterface(Components.interfaces.nsIPrefService);\"\n                readonly=\"true\"/>\n\n      <!--\n        Weak reference to an optional frame loader that can be used to influence\n        process selection for this browser.\n        See nsIBrowser.sameProcessAsFrameLoader.\n      -->\n      <field name=\"_sameProcessAsFrameLoader\">null</field>\n      <property name=\"sameProcessAsFrameLoader\">\n        <getter><![CDATA[\n          return this._sameProcessAsFrameLoader && this._sameProcessAsFrameLoader.get();\n        ]]></getter>\n        <setter><![CDATA[\n          this._sameProcessAsFrameLoader = Components.utils.getWeakReference(val);\n        ]]></setter>\n      </property>\n\n      <field name=\"_docShell\">null</field>\n\n      <property name=\"docShell\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._docShell)\n            return this._docShell;\n\n          let {frameLoader} = this;\n          if (!frameLoader)\n            return null;\n          this._docShell = frameLoader.docShell;\n          return this._docShell;\n        ]]></getter>\n      </property>\n\n      <field name=\"_loadContext\">null</field>\n\n      <property name=\"loadContext\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._loadContext)\n            return this._loadContext;\n\n          let {frameLoader} = this;\n          if (!frameLoader)\n            return null;\n          this._loadContext = frameLoader.loadContext;\n          return this._loadContext;\n        ]]></getter>\n      </property>\n\n      <property name=\"autoCompletePopup\"\n                onget=\"return document.getElementById(this.getAttribute('autocompletepopup'))\"\n                readonly=\"true\"/>\n\n      <property name=\"dateTimePicker\"\n                onget=\"return document.getElementById(this.getAttribute('datetimepicker'))\"\n                readonly=\"true\"/>\n\n      <property name=\"docShellIsActive\">\n        <getter>\n          <![CDATA[\n            return this.docShell && this.docShell.isActive;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            if (this.docShell)\n              return this.docShell.isActive = val;\n            return false;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"preserveLayers\">\n        <parameter name=\"preserve\"/>\n        <body>\n          // Only useful for remote browsers.\n        </body>\n      </method>\n\n      <property name=\"imageDocument\"\n                readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var document = this.contentDocument;\n            if (!document || !(document instanceof Components.interfaces.nsIImageDocument))\n              return null;\n\n            try {\n                return {width: document.imageRequest.image.width, height: document.imageRequest.image.height };\n            } catch (e) {}\n            return null;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"isRemoteBrowser\"\n                onget=\"return (this.getAttribute('remote') == 'true');\"\n                readonly=\"true\"/>\n\n      <property name=\"remoteType\"\n                readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (!this.isRemoteBrowser) {\n              return null;\n            }\n\n            let remoteType = this.getAttribute(\"remoteType\");\n            if (remoteType) {\n              return remoteType;\n            }\n\n            let E10SUtils = Components.utils.import(\"resource://gre/modules/E10SUtils.jsm\", {}).E10SUtils;\n            return E10SUtils.DEFAULT_REMOTE_TYPE;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"messageManager\"\n                readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (this.frameLoader) {\n              return this.frameLoader.messageManager;\n            }\n            return null;\n          ]]>\n        </getter>\n\n      </property>\n\n      <field name=\"_webNavigation\">null</field>\n\n      <property name=\"webNavigation\"\n                readonly=\"true\">\n        <getter>\n        <![CDATA[\n          if (!this._webNavigation) {\n            if (!this.docShell) {\n              return null;\n            }\n            this._webNavigation = this.docShell.QueryInterface(Components.interfaces.nsIWebNavigation);\n          }\n          return this._webNavigation;\n        ]]>\n        </getter>\n      </property>\n\n      <field name=\"_webBrowserFind\">null</field>\n\n      <property name=\"webBrowserFind\"\n                readonly=\"true\">\n        <getter>\n        <![CDATA[\n          if (!this._webBrowserFind)\n            this._webBrowserFind = this.docShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIWebBrowserFind);\n          return this._webBrowserFind;\n        ]]>\n        </getter>\n      </property>\n\n      <method name=\"getTabBrowser\">\n        <body>\n          <![CDATA[\n            for (let node = this.parentNode; node instanceof Element; node = node.parentNode) {\n              if (node.localName == \"tabbrowser\")\n                return node;\n            }\n            return null;\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"_finder\">null</field>\n\n      <property name=\"finder\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._finder) {\n            if (!this.docShell)\n              return null;\n\n            let Finder = Components.utils.import(\"resource://gre/modules/Finder.jsm\", {}).Finder;\n            this._finder = new Finder(this.docShell);\n          }\n          return this._finder;\n        ]]></getter>\n      </property>\n\n      <field name=\"_fastFind\">null</field>\n      <property name=\"fastFind\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._fastFind) {\n            if (!(\"@mozilla.org/typeaheadfind;1\" in Components.classes))\n              return null;\n\n            var tabBrowser = this.getTabBrowser();\n            if (tabBrowser && \"fastFind\" in tabBrowser)\n              return this._fastFind = tabBrowser.fastFind;\n\n            if (!this.docShell)\n              return null;\n\n            this._fastFind = Components.classes[\"@mozilla.org/typeaheadfind;1\"]\n                                       .createInstance(Components.interfaces.nsITypeAheadFind);\n            this._fastFind.init(this.docShell);\n          }\n          return this._fastFind;\n        ]]></getter>\n      </property>\n\n      <property name=\"outerWindowID\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.contentWindow\n                     .QueryInterface(Components.interfaces.nsIInterfaceRequestor)\n                     .getInterface(Components.interfaces.nsIDOMWindowUtils)\n                     .outerWindowID;\n        ]]></getter>\n      </property>\n\n      <property name=\"innerWindowID\" readonly=\"true\">\n        <getter><![CDATA[\n          try {\n            return this.contentWindow\n                       .QueryInterface(Components.interfaces.nsIInterfaceRequestor)\n                       .getInterface(Components.interfaces.nsIDOMWindowUtils)\n                       .currentInnerWindowID;\n          } catch (e) {\n            if (e.result != Cr.NS_ERROR_NOT_AVAILABLE) {\n              throw e;\n            }\n            return null;\n          }\n        ]]></getter>\n      </property>\n\n      <field name=\"_lastSearchString\">null</field>\n\n      <property name=\"webProgress\"\n                readonly=\"true\"\n                onget=\"return this.docShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIWebProgress);\"/>\n\n      <field name=\"_contentWindow\">null</field>\n\n      <property name=\"contentWindow\"\n                readonly=\"true\"\n                onget=\"return this._contentWindow || (this._contentWindow = this.docShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindow));\"/>\n\n      <property name=\"contentWindowAsCPOW\"\n                readonly=\"true\"\n                onget=\"return this.contentWindow;\"/>\n\n      <property name=\"sessionHistory\"\n                onget=\"return this.webNavigation.sessionHistory;\"\n                readonly=\"true\"/>\n\n      <property name=\"markupDocumentViewer\"\n                onget=\"return this.docShell.contentViewer;\"\n                readonly=\"true\"/>\n\n      <property name=\"contentViewerEdit\"\n                onget=\"return this.docShell.contentViewer.QueryInterface(Components.interfaces.nsIContentViewerEdit);\"\n                readonly=\"true\"/>\n\n      <property name=\"contentDocument\"\n                onget=\"return this.webNavigation.document;\"\n                readonly=\"true\"/>\n\n      <property name=\"contentDocumentAsCPOW\"\n                onget=\"return this.contentDocument;\"\n                readonly=\"true\"/>\n\n      <property name=\"contentTitle\"\n                onget=\"return this.contentDocument.title;\"\n                readonly=\"true\"/>\n\n      <property name=\"characterSet\"\n                onget=\"return this.docShell.charset;\">\n        <setter><![CDATA[\n          this.docShell.charset = val;\n          this.docShell.gatherCharsetMenuTelemetry();\n        ]]></setter>\n      </property>\n\n      <property name=\"mayEnableCharacterEncodingMenu\"\n                onget=\"return this.docShell.mayEnableCharacterEncodingMenu;\"\n                readonly=\"true\"/>\n\n      <property name=\"contentPrincipal\"\n                onget=\"return this.contentDocument.nodePrincipal;\"\n                readonly=\"true\"/>\n\n      <property name=\"contentRequestContextID\" readonly=\"true\">\n        <getter><![CDATA[\n          try {\n            return this.contentDocument.documentLoadGroup\n                       .requestContextID;\n          } catch (e) {\n            return null;\n          }\n        ]]></getter>\n      </property>\n\n      <property name=\"showWindowResizer\"\n                onset=\"if (val) this.setAttribute('showresizer', 'true');\n                       else this.removeAttribute('showresizer');\n                       return val;\"\n                onget=\"return this.getAttribute('showresizer') == 'true';\"/>\n\n      <property name=\"manifestURI\"\n                readonly=\"true\">\n        <getter><![CDATA[\n          return this.contentDocument.documentElement &&\n                 this.contentDocument.documentElement.getAttribute(\"manifest\");\n        ]]></getter>\n      </property>\n\n      <property name=\"fullZoom\">\n        <getter><![CDATA[\n          return this.markupDocumentViewer.fullZoom;\n        ]]></getter>\n        <setter><![CDATA[\n          this.markupDocumentViewer.fullZoom = val;\n        ]]></setter>\n      </property>\n\n      <property name=\"deviceFullZoom\"\n                readonly=\"true\">\n        <getter><![CDATA[\n          return this.markupDocumentViewer.deviceFullZoom;\n        ]]></getter>\n      </property>\n\n      <property name=\"textZoom\">\n        <getter><![CDATA[\n          return this.markupDocumentViewer.textZoom;\n        ]]></getter>\n        <setter><![CDATA[\n          this.markupDocumentViewer.textZoom = val;\n        ]]></setter>\n      </property>\n\n      <property name=\"effectiveTextZoom\"\n                readonly=\"true\">\n        <getter><![CDATA[\n          return this.markupDocumentViewer.effectiveTextZoom;\n        ]]></getter>\n      </property>\n\n      <property name=\"isSyntheticDocument\">\n        <getter><![CDATA[\n          return this.contentDocument.mozSyntheticDocument;\n        ]]></getter>\n      </property>\n\n      <property name=\"hasContentOpener\">\n        <getter><![CDATA[\n          return !!this.contentWindow.opener;\n        ]]></getter>\n      </property>\n\n      <field name=\"mPrefs\" readonly=\"true\">\n        Components.classes[\"@mozilla.org/preferences-service;1\"]\n                  .getService(Components.interfaces.nsIPrefBranch);\n      </field>\n\n      <field name=\"_mStrBundle\">null</field>\n\n      <property name=\"mStrBundle\">\n        <getter>\n        <![CDATA[\n          if (!this._mStrBundle) {\n            // need to create string bundle manually instead of using <xul:stringbundle/>\n            // see bug 63370 for details\n            this._mStrBundle = Components.classes[\"@mozilla.org/intl/stringbundle;1\"]\n                                         .getService(Components.interfaces.nsIStringBundleService)\n                                         .createBundle(\"chrome://global/locale/browser.properties\");\n          }\n          return this._mStrBundle;\n        ]]></getter>\n      </property>\n\n      <method name=\"addProgressListener\">\n        <parameter name=\"aListener\"/>\n        <parameter name=\"aNotifyMask\"/>\n        <body>\n          <![CDATA[\n            if (!aNotifyMask) {\n              aNotifyMask = Components.interfaces.nsIWebProgress.NOTIFY_ALL;\n            }\n            this.webProgress.addProgressListener(aListener, aNotifyMask);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeProgressListener\">\n        <parameter name=\"aListener\"/>\n        <body>\n          <![CDATA[\n            this.webProgress.removeProgressListener(aListener);\n         ]]>\n        </body>\n      </method>\n\n      <method name=\"findChildShell\">\n        <parameter name=\"aDocShell\"/>\n        <parameter name=\"aSoughtURI\"/>\n        <body>\n          <![CDATA[\n            if (aDocShell.QueryInterface(Components.interfaces.nsIWebNavigation)\n                         .currentURI.spec == aSoughtURI.spec)\n              return aDocShell;\n            var node = aDocShell.QueryInterface(\n                                   Components.interfaces.nsIDocShellTreeItem);\n            for (var i = 0; i < node.childCount; ++i) {\n              var docShell = node.getChildAt(i);\n              docShell = this.findChildShell(docShell, aSoughtURI);\n              if (docShell)\n                return docShell;\n            }\n            return null;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"onPageHide\">\n        <parameter name=\"aEvent\"/>\n        <body>\n          <![CDATA[\n            // Delete the feeds cache if we're hiding the topmost page\n            // (as opposed to one of its iframes).\n            if (this.feeds && aEvent.target == this.contentDocument)\n              this.feeds = null;\n            if (!this.docShell || !this.fastFind)\n              return;\n            var tabBrowser = this.getTabBrowser();\n            if (!tabBrowser || !(\"fastFind\" in tabBrowser) ||\n                tabBrowser.selectedBrowser == this)\n              this.fastFind.setDocShell(this.docShell);\n         ]]>\n        </body>\n      </method>\n\n      <method name=\"updateBlockedPopups\">\n        <body>\n          <![CDATA[\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"DOMUpdatePageReport\", true, true);\n            this.dispatchEvent(event);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"retrieveListOfBlockedPopups\">\n        <body>\n          <![CDATA[\n          this.messageManager.sendAsyncMessage(\"PopupBlocking:GetBlockedPopupList\", null);\n          return new Promise(resolve => {\n            let self = this;\n            this.messageManager.addMessageListener(\"PopupBlocking:ReplyGetBlockedPopupList\",\n              function replyReceived(msg) {\n                self.messageManager.removeMessageListener(\"PopupBlocking:ReplyGetBlockedPopupList\",\n                                                          replyReceived);\n                resolve(msg.data.popupData);\n              }\n            );\n          });\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"unblockPopup\">\n        <parameter name=\"aPopupIndex\"/>\n        <body><![CDATA[\n          this.messageManager.sendAsyncMessage(\"PopupBlocking:UnblockPopup\",\n                                               {index: aPopupIndex});\n        ]]></body>\n      </method>\n\n      <field name=\"blockedPopups\">null</field>\n\n      <!-- Obsolete name for blockedPopups. Used by android. -->\n      <property name=\"pageReport\"\n         onget=\"return this.blockedPopups;\"\n         readonly=\"true\"/>\n\n      <method name=\"audioPlaybackStarted\">\n        <body>\n          <![CDATA[\n            if (this._audioMuted) {\n              return;\n            }\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"DOMAudioPlaybackStarted\", true, false);\n            this.dispatchEvent(event);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"audioPlaybackStopped\">\n        <body>\n          <![CDATA[\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"DOMAudioPlaybackStopped\", true, false);\n            this.dispatchEvent(event);\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        When the pref \"media.block-autoplay-until-in-foreground\" is on, all\n        windows would be blocked by default in gecko. The \"block\" means the\n        autoplay media can't be started in that tab unless the tab has been\n        visited or resumed by tab's play tab icon. Since the window is blocked\n        by default, there's no method to signal entering that state.\n        (1) If the window is resumed, no matter it has autoplay media or not\n            - will call mediaBlockStopped()\n        (2) If the window has blocked any autoplay media\n            - will call activeMediaBlockStarted()\n        (3) If the window has resumed any autoplay media\n            - will call activeMediaBlockStopped()\n       -->\n      <method name=\"activeMediaBlockStarted\">\n        <body>\n          <![CDATA[\n            this._hasAnyPlayingMediaBeenBlocked = true;\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"DOMAudioPlaybackBlockStarted\", true, false);\n            this.dispatchEvent(event);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"activeMediaBlockStopped\">\n        <body>\n          <![CDATA[\n            if (!this._hasAnyPlayingMediaBeenBlocked) {\n              return;\n            }\n            this._hasAnyPlayingMediaBeenBlocked = false;\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"DOMAudioPlaybackBlockStopped\", true, false);\n            this.dispatchEvent(event);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"mediaBlockStopped\">\n        <body>\n          <![CDATA[\n            this._mediaBlocked = false;\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"_audioMuted\">false</field>\n      <property name=\"audioMuted\"\n                onget=\"return this._audioMuted;\"\n                readonly=\"true\"/>\n\n      <field name=\"_mediaBlocked\">true</field>\n      <property name=\"mediaBlocked\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (this.mPrefs.getBoolPref(\"media.block-autoplay-until-in-foreground\", true)) {\n              return this._mediaBlocked;\n            }\n            return false;\n          ]]>\n        </getter>\n      </property>\n\n      <field name=\"_hasAnyPlayingMediaBeenBlocked\">false</field>\n\n      <method name=\"mute\">\n        <parameter name=\"transientState\"/>\n        <body>\n          <![CDATA[\n            if (!transientState) {\n              this._audioMuted = true;\n            }\n            this.messageManager.sendAsyncMessage(\"AudioPlayback\",\n                                                 {type: \"mute\"});\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"unmute\">\n        <body>\n          <![CDATA[\n            this._audioMuted = false;\n            this.messageManager.sendAsyncMessage(\"AudioPlayback\",\n                                                 {type: \"unmute\"});\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"pauseMedia\">\n        <parameter name=\"disposable\"/>\n        <body>\n          <![CDATA[\n            let suspendedReason;\n            if (disposable) {\n              suspendedReason = \"mediaControlPaused\";\n            } else {\n              suspendedReason = \"lostAudioFocusTransiently\";\n            }\n\n            this.messageManager.sendAsyncMessage(\"AudioPlayback\",\n                                                 {type: suspendedReason});\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"stopMedia\">\n        <body>\n          <![CDATA[\n            this.messageManager.sendAsyncMessage(\"AudioPlayback\",\n                                                 {type: \"mediaControlStopped\"});\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"resumeMedia\">\n        <body>\n          <![CDATA[\n            this._mediaBlocked = false;\n            this.messageManager.sendAsyncMessage(\"AudioPlayback\",\n                                                 {type: \"resumeMedia\"});\n            if (this._hasAnyPlayingMediaBeenBlocked) {\n              this._hasAnyPlayingMediaBeenBlocked = false;\n              let event = document.createEvent(\"Events\");\n              event.initEvent(\"DOMAudioPlaybackBlockStopped\", true, false);\n              this.dispatchEvent(event);\n            }\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        Only send the message \"Browser:UnselectedTabHover\" when someone requests\n        for the message, which can reduce non-necessary communication.\n      -->\n      <field name=\"_shouldSendUnselectedTabHover\">false</field>\n      <field name=\"_unselectedTabHoverMessageListenerCount\">0</field>\n      <property name=\"shouldHandleUnselectedTabHover\"\n                onget=\"return this._shouldSendUnselectedTabHover;\"\n                readonly=\"true\"/>\n\n      <method name=\"unselectedTabHover\">\n        <parameter name=\"hovered\"/>\n        <body>\n          <![CDATA[\n            if (!this._shouldSendUnselectedTabHover) {\n              return;\n            }\n            this.messageManager.sendAsyncMessage(\"Browser:UnselectedTabHover\",\n              { hovered });\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"securityUI\">\n        <getter>\n          <![CDATA[\n            if (!this.docShell.securityUI) {\n              const SECUREBROWSERUI_CONTRACTID = \"@mozilla.org/secure_browser_ui;1\";\n              if (!this.hasAttribute(\"disablesecurity\") &&\n                  SECUREBROWSERUI_CONTRACTID in Components.classes) {\n                var securityUI = Components.classes[SECUREBROWSERUI_CONTRACTID]\n                                           .createInstance(Components.interfaces.nsISecureBrowserUI);\n                securityUI.init(this.contentWindow);\n              }\n            }\n\n            return this.docShell.securityUI;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            this.docShell.securityUI = val;\n          ]]>\n        </setter>\n      </property>\n\n      <field name=\"urlbarChangeTracker\">\n        ({\n          _startedLoadSinceLastUserTyping: false,\n\n          startedLoad() {\n            this._startedLoadSinceLastUserTyping = true;\n          },\n          finishedLoad() {\n            this._startedLoadSinceLastUserTyping = false;\n          },\n          userTyped() {\n            this._startedLoadSinceLastUserTyping = false;\n          },\n        })\n      </field>\n\n      <method name=\"didStartLoadSinceLastUserTyping\">\n        <body><![CDATA[\n          return !this.inLoadURI &&\n                 this.urlbarChangeTracker._startedLoadSinceLastUserTyping;\n        ]]></body>\n      </method>\n\n      <field name=\"_userTypedValue\">\n        null\n      </field>\n\n      <property name=\"userTypedValue\"\n                onget=\"return this._userTypedValue;\">\n        <setter><![CDATA[\n          this.urlbarChangeTracker.userTyped();\n          this._userTypedValue = val;\n          return val;\n        ]]></setter>\n      </property>\n\n      <field name=\"mFormFillAttached\">\n        false\n      </field>\n\n      <field name=\"isShowingMessage\">\n        false\n      </field>\n\n      <field name=\"droppedLinkHandler\">\n        null\n      </field>\n\n      <field name=\"mIconURL\">null</field>\n\n      <!-- This is managed by the tabbrowser -->\n      <field name=\"lastURI\">null</field>\n\n      <field name=\"mDestroyed\">false</field>\n\n      <constructor>\n        <![CDATA[\n          try {\n            // |webNavigation.sessionHistory| will have been set by the frame\n            // loader when creating the docShell as long as this xul:browser\n            // doesn't have the 'disablehistory' attribute set.\n            if (this.docShell && this.webNavigation.sessionHistory) {\n              var os = Components.classes[\"@mozilla.org/observer-service;1\"]\n                                 .getService(Components.interfaces.nsIObserverService);\n              os.addObserver(this, \"browser:purge-session-history\", true);\n\n              // enable global history if we weren't told otherwise\n              if (!this.hasAttribute(\"disableglobalhistory\") && !this.isRemoteBrowser) {\n                try {\n                  this.docShell.useGlobalHistory = true;\n                } catch (ex) {\n                  // This can occur if the Places database is locked\n                  Components.utils.reportError(\"Error enabling browser global history: \" + ex);\n                }\n              }\n            }\n          } catch (e) {\n            Components.utils.reportError(e);\n          }\n          try {\n            // Ensures the securityUI is initialized.\n            var securityUI = this.securityUI; // eslint-disable-line no-unused-vars\n          } catch (e) {\n          }\n\n          // tabbrowser.xml sets \"sameProcessAsFrameLoader\" as a direct property\n          // on some browsers before they are put into a DOM (and get a\n          // binding).  This hack makes sure that we hold a weak reference to\n          // the other browser (and go through the proper getter and setter).\n          if (this.hasOwnProperty(\"sameProcessAsFrameLoader\")) {\n            var sameProcessAsFrameLoader = this.sameProcessAsFrameLoader;\n            delete this.sameProcessAsFrameLoader;\n            this.sameProcessAsFrameLoader = sameProcessAsFrameLoader;\n          }\n\n          if (!this.isRemoteBrowser) {\n            this.addEventListener(\"pagehide\", this.onPageHide, true);\n          }\n\n          if (this.messageManager) {\n            this.messageManager.addMessageListener(\"PopupBlocking:UpdateBlockedPopups\", this);\n            this.messageManager.addMessageListener(\"Autoscroll:Start\", this);\n            this.messageManager.addMessageListener(\"Autoscroll:Cancel\", this);\n            this.messageManager.addMessageListener(\"AudioPlayback:Start\", this);\n            this.messageManager.addMessageListener(\"AudioPlayback:Stop\", this);\n            this.messageManager.addMessageListener(\"AudioPlayback:ActiveMediaBlockStart\", this);\n            this.messageManager.addMessageListener(\"AudioPlayback:ActiveMediaBlockStop\", this);\n            this.messageManager.addMessageListener(\"AudioPlayback:MediaBlockStop\", this);\n            this.messageManager.addMessageListener(\"UnselectedTabHover:Toggle\", this);\n\n            if (this.hasAttribute(\"selectmenulist\")) {\n              this.messageManager.addMessageListener(\"Forms:ShowDropDown\", this);\n              this.messageManager.addMessageListener(\"Forms:HideDropDown\", this);\n            }\n\n          }\n        ]]>\n      </constructor>\n\n      <destructor>\n        <![CDATA[\n          this.destroy();\n        ]]>\n      </destructor>\n\n      <!-- This is necessary because the destructor doesn't always get called when\n           we are removed from a tabbrowser. This will be explicitly called by tabbrowser.\n\n           Note: this function is overriden in remote-browser.xml, so any clean-up that\n           also applies to browser.isRemoteBrowser = true must be duplicated there. -->\n      <method name=\"destroy\">\n        <body>\n          <![CDATA[\n          // Make sure that any open select is closed.\n          if (this._selectParentHelper) {\n            let menulist = document.getElementById(this.getAttribute(\"selectmenulist\"));\n            this._selectParentHelper.hide(menulist, this);\n          }\n          if (this.mDestroyed)\n            return;\n          this.mDestroyed = true;\n\n          if (this.docShell && this.webNavigation.sessionHistory) {\n            var os = Components.classes[\"@mozilla.org/observer-service;1\"]\n                               .getService(Components.interfaces.nsIObserverService);\n            try {\n              os.removeObserver(this, \"browser:purge-session-history\");\n            } catch (ex) {\n              // It's not clear why this sometimes throws an exception.\n            }\n          }\n\n          this._fastFind = null;\n          this._webBrowserFind = null;\n\n          // The feeds cache can keep the document inside this browser alive.\n          this.feeds = null;\n\n          this.lastURI = null;\n\n          if (!this.isRemoteBrowser) {\n            this.removeEventListener(\"pagehide\", this.onPageHide, true);\n          }\n\n          if (this._autoScrollNeedsCleanup) {\n            // we polluted the global scope, so clean it up\n            this._autoScrollPopup.remove();\n          }\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        We call this _receiveMessage (and alias receiveMessage to it) so that\n        bindings that inherit from this one can delegate to it.\n      -->\n      <method name=\"_receiveMessage\">\n        <parameter name=\"aMessage\"/>\n        <body><![CDATA[\n          let data = aMessage.data;\n          switch (aMessage.name) {\n            case \"PopupBlocking:UpdateBlockedPopups\": {\n              this.blockedPopups = {\n                length: data.count,\n                reported: !data.freshPopup,\n              };\n\n              this.updateBlockedPopups();\n              break;\n            }\n            case \"Autoscroll:Start\": {\n              if (!this.autoscrollEnabled) {\n                return {autoscrollEnabled: false, usingApz: false};\n              }\n              this.startScroll(data.scrolldir, data.screenX, data.screenY);\n              let usingApz = false;\n              if (this.isRemoteBrowser && data.scrollId != null &&\n                  this.mPrefs.getBoolPref(\"apz.autoscroll.enabled\", false)) {\n                let { tabParent } = this.frameLoader;\n                if (tabParent) {\n                  // If APZ is handling the autoscroll, it may decide to cancel\n                  // it of its own accord, so register an observer to allow it\n                  // to notify us of that.\n                  var os = Components.classes[\"@mozilla.org/observer-service;1\"]\n                                     .getService(Components.interfaces.nsIObserverService);\n                  os.addObserver(this, \"apz:cancel-autoscroll\", true);\n\n                  usingApz = tabParent.startApzAutoscroll(\n                      data.screenX, data.screenY,\n                      data.scrollId, data.presShellId);\n                }\n                // Save the IDs for later\n                this._autoScrollScrollId = data.scrollId;\n                this._autoScrollPresShellId = data.presShellId;\n              }\n              return {autoscrollEnabled: true, usingApz};\n            }\n            case \"Autoscroll:Cancel\":\n              this._autoScrollPopup.hidePopup();\n              break;\n            case \"AudioPlayback:Start\":\n              this.audioPlaybackStarted();\n              break;\n            case \"AudioPlayback:Stop\":\n              this.audioPlaybackStopped();\n              break;\n            case \"AudioPlayback:ActiveMediaBlockStart\":\n              this.activeMediaBlockStarted();\n              break;\n            case \"AudioPlayback:ActiveMediaBlockStop\":\n              this.activeMediaBlockStopped();\n              break;\n            case \"AudioPlayback:MediaBlockStop\":\n              this.mediaBlockStopped();\n              break;\n            case \"UnselectedTabHover:Toggle\":\n              this._shouldSendUnselectedTabHover = data.enable ?\n                ++this._unselectedTabHoverMessageListenerCount > 0 :\n                --this._unselectedTabHoverMessageListenerCount == 0;\n              break;\n            case \"Forms:ShowDropDown\": {\n              if (!this._selectParentHelper) {\n                this._selectParentHelper =\n                  Cu.import(\"resource://gre/modules/SelectParentHelper.jsm\", {}).SelectParentHelper;\n              }\n\n              let menulist = document.getElementById(this.getAttribute(\"selectmenulist\"));\n              menulist.menupopup.style.direction = data.direction;\n              this._selectParentHelper.populate(menulist, data.options, data.selectedIndex, this._fullZoom,\n                                                data.uaBackgroundColor, data.uaColor,\n                                                data.uaSelectBackgroundColor, data.uaSelectColor,\n                                                data.selectBackgroundColor, data.selectColor, data.selectTextShadow);\n              this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);\n              break;\n            }\n\n            case \"Forms:HideDropDown\": {\n              if (this._selectParentHelper) {\n                let menulist = document.getElementById(this.getAttribute(\"selectmenulist\"));\n                this._selectParentHelper.hide(menulist, this);\n              }\n              break;\n            }\n\n          }\n          return undefined;\n        ]]></body>\n      </method>\n\n      <method name=\"receiveMessage\">\n        <parameter name=\"aMessage\"/>\n        <body><![CDATA[\n          return this._receiveMessage(aMessage);\n        ]]></body>\n      </method>\n\n      <method name=\"observe\">\n        <parameter name=\"aSubject\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aState\"/>\n        <body>\n          <![CDATA[\n            if (aTopic == \"browser:purge-session-history\") {\n              this.purgeSessionHistory();\n            } else if (aTopic == \"apz:cancel-autoscroll\") {\n              if (aState == this._autoScrollScrollId) {\n                this._autoScrollPopup.hidePopup();\n\n                // Set this._autoScrollScrollId to null, so in stopScroll() we\n                // don't call stopApzAutoscroll() (since it's APZ that\n                // initiated the stopping).\n                this._autoScrollScrollId = null;\n                this._autoScrollPresShellId = null;\n              }\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"purgeSessionHistory\">\n        <body>\n          <![CDATA[\n            this.messageManager.sendAsyncMessage(\"Browser:PurgeSessionHistory\");\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"createAboutBlankContentViewer\">\n        <parameter name=\"aPrincipal\"/>\n        <body>\n          <![CDATA[\n            let principal = BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);\n            this.docShell.createAboutBlankContentViewer(principal);\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"_AUTOSCROLL_SNAP\">10</field>\n      <field name=\"_scrolling\">false</field>\n      <field name=\"_startX\">null</field>\n      <field name=\"_startY\">null</field>\n      <field name=\"_autoScrollPopup\">null</field>\n      <field name=\"_autoScrollNeedsCleanup\">false</field>\n      <!-- These IDs identify the scroll frame being autoscrolled. -->\n      <field name=\"_autoScrollScrollId\">null</field>\n      <field name=\"_autoScrollPresShellId\">null</field>\n\n      <method name=\"stopScroll\">\n        <body>\n          <![CDATA[\n            if (this._scrolling) {\n              this._scrolling = false;\n              window.removeEventListener(\"mousemove\", this, true);\n              window.removeEventListener(\"mousedown\", this, true);\n              window.removeEventListener(\"mouseup\", this, true);\n              window.removeEventListener(\"DOMMouseScroll\", this, true);\n              window.removeEventListener(\"contextmenu\", this, true);\n              window.removeEventListener(\"keydown\", this, true);\n              window.removeEventListener(\"keypress\", this, true);\n              window.removeEventListener(\"keyup\", this, true);\n              this.messageManager.sendAsyncMessage(\"Autoscroll:Stop\");\n\n              var os = Components.classes[\"@mozilla.org/observer-service;1\"]\n                                 .getService(Components.interfaces.nsIObserverService);\n              try {\n                os.removeObserver(this, \"apz:cancel-autoscroll\");\n              } catch (ex) {\n                // It's not clear why this sometimes throws an exception\n              }\n\n              if (this.isRemoteBrowser && this._autoScrollScrollId != null) {\n                let { tabParent } = this.frameLoader;\n                if (tabParent) {\n                  tabParent.stopApzAutoscroll(this._autoScrollScrollId,\n                                              this._autoScrollPresShellId);\n                }\n                this._autoScrollScrollId = null;\n                this._autoScrollPresShellId = null;\n              }\n            }\n         ]]>\n       </body>\n     </method>\n\n      <method name=\"_createAutoScrollPopup\">\n        <body>\n          <![CDATA[\n            const XUL_NS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n            var popup = document.createElementNS(XUL_NS, \"panel\");\n            popup.className = \"autoscroller\";\n            // We set this attribute on the element so that mousemove\n            // events can be handled by browser-content.js.\n            popup.setAttribute(\"mousethrough\", \"always\");\n            popup.setAttribute(\"rolluponmousewheel\", \"true\");\n            popup.setAttribute(\"hidden\", \"true\");\n            return popup;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"startScroll\">\n        <parameter name=\"scrolldir\"/>\n        <parameter name=\"screenX\"/>\n        <parameter name=\"screenY\"/>\n        <body><![CDATA[\n            if (!this._autoScrollPopup) {\n              if (this.hasAttribute(\"autoscrollpopup\")) {\n                // our creator provided a popup to share\n                this._autoScrollPopup = document.getElementById(this.getAttribute(\"autoscrollpopup\"));\n              } else {\n                // we weren't provided a popup; we have to use the global scope\n                this._autoScrollPopup = this._createAutoScrollPopup();\n                document.documentElement.appendChild(this._autoScrollPopup);\n                this._autoScrollNeedsCleanup = true;\n              }\n            }\n\n            // we need these attributes so themers don't need to create per-platform packages\n            if (screen.colorDepth > 8) { // need high color for transparency\n              // Exclude second-rate platforms\n              this._autoScrollPopup.setAttribute(\"transparent\", !/BeOS|OS\\/2/.test(navigator.appVersion));\n              // Enable translucency on Windows and Mac\n              this._autoScrollPopup.setAttribute(\"translucent\", /Win|Mac/.test(navigator.platform));\n            }\n\n            this._autoScrollPopup.removeAttribute(\"hidden\");\n            this._autoScrollPopup.setAttribute(\"noautofocus\", \"true\");\n            this._autoScrollPopup.setAttribute(\"scrolldir\", scrolldir);\n            this._autoScrollPopup.addEventListener(\"popuphidden\", this, true);\n            this._autoScrollPopup.showPopup(document.documentElement,\n                                            screenX,\n                                            screenY,\n                                            \"popup\", null, null);\n            this._ignoreMouseEvents = true;\n            this._scrolling = true;\n            this._startX = screenX;\n            this._startY = screenY;\n\n            window.addEventListener(\"mousemove\", this, true);\n            window.addEventListener(\"mousedown\", this, true);\n            window.addEventListener(\"mouseup\", this, true);\n            window.addEventListener(\"DOMMouseScroll\", this, true);\n            window.addEventListener(\"contextmenu\", this, true);\n            window.addEventListener(\"keydown\", this, true);\n            window.addEventListener(\"keypress\", this, true);\n            window.addEventListener(\"keyup\", this, true);\n         ]]>\n        </body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          if (this._scrolling) {\n            switch (aEvent.type) {\n              case \"mousemove\": {\n                var x = aEvent.screenX - this._startX;\n                var y = aEvent.screenY - this._startY;\n\n                if ((x > this._AUTOSCROLL_SNAP || x < -this._AUTOSCROLL_SNAP) ||\n                    (y > this._AUTOSCROLL_SNAP || y < -this._AUTOSCROLL_SNAP))\n                  this._ignoreMouseEvents = false;\n                break;\n              }\n              case \"mouseup\":\n              case \"mousedown\":\n              case \"contextmenu\": {\n                if (!this._ignoreMouseEvents) {\n                  // Use a timeout to prevent the mousedown from opening the popup again.\n                  // Ideally, we could use preventDefault here, but contenteditable\n                  // and middlemouse paste don't interact well. See bug 1188536.\n                  setTimeout(() => this._autoScrollPopup.hidePopup(), 0);\n                }\n                this._ignoreMouseEvents = false;\n                break;\n              }\n              case \"DOMMouseScroll\": {\n                this._autoScrollPopup.hidePopup();\n                aEvent.preventDefault();\n                break;\n              }\n              case \"popuphidden\": {\n                this._autoScrollPopup.removeEventListener(\"popuphidden\", this, true);\n                this.stopScroll();\n                break;\n              }\n              case \"keydown\": {\n                if (aEvent.keyCode == aEvent.DOM_VK_ESCAPE) {\n                  // the escape key will be processed by\n                  // nsXULPopupManager::KeyDown and the panel will be closed.\n                  // So, don't consume the key event here.\n                  break;\n                }\n                // don't break here. we need to eat keydown events.\n              }\n              case \"keypress\":\n              case \"keyup\": {\n                // All keyevents should be eaten here during autoscrolling.\n                aEvent.stopPropagation();\n                aEvent.preventDefault();\n                break;\n              }\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"closeBrowser\">\n        <body>\n        <![CDATA[\n          // The request comes from a XPCOM component, we'd want to redirect\n          // the request to tabbrowser.\n          let tabbrowser = this.getTabBrowser();\n          if (tabbrowser) {\n            let tab = tabbrowser.getTabForBrowser(this);\n            if (tab) {\n              tabbrowser.removeTab(tab);\n              return;\n            }\n          }\n\n          throw new Error(\"Closing a browser which was not attached to a tabbrowser is unsupported.\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"swapBrowsers\">\n        <parameter name=\"aOtherBrowser\"/>\n        <parameter name=\"aFlags\"/>\n        <body>\n        <![CDATA[\n          // The request comes from a XPCOM component, we'd want to redirect\n          // the request to tabbrowser so tabbrowser will be setup correctly,\n          // and it will eventually call swapDocShells.\n          let ourTabBrowser = this.getTabBrowser();\n          let otherTabBrowser = aOtherBrowser.getTabBrowser();\n          if (ourTabBrowser && otherTabBrowser) {\n            let ourTab = ourTabBrowser.getTabForBrowser(this);\n            let otherTab = otherTabBrowser.getTabForBrowser(aOtherBrowser);\n            ourTabBrowser.swapBrowsers(ourTab, otherTab, aFlags);\n            return;\n          }\n\n          // One of us is not connected to a tabbrowser, so just swap.\n          this.swapDocShells(aOtherBrowser);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"swapDocShells\">\n        <parameter name=\"aOtherBrowser\"/>\n        <body>\n        <![CDATA[\n          if (this.isRemoteBrowser != aOtherBrowser.isRemoteBrowser)\n            throw new Error(\"Can only swap docshells between browsers in the same process.\");\n\n          // Give others a chance to swap state.\n          // IMPORTANT: Since a swapDocShells call does not swap the messageManager\n          //            instances attached to a browser to aOtherBrowser, others\n          //            will need to add the message listeners to the new\n          //            messageManager.\n          //            This is not a bug in swapDocShells or the FrameLoader,\n          //            merely a design decision: If message managers were swapped,\n          //            so that no new listeners were needed, the new\n          //            aOtherBrowser.messageManager would have listeners pointing\n          //            to the JS global of the current browser, which would rather\n          //            easily create leaks while swapping.\n          // IMPORTANT2: When the current browser element is removed from DOM,\n          //             which is quite common after a swpDocShells call, its\n          //             frame loader is destroyed, and that destroys the relevant\n          //             message manager, which will remove the listeners.\n          let event = new CustomEvent(\"SwapDocShells\", {\"detail\": aOtherBrowser});\n          this.dispatchEvent(event);\n          event = new CustomEvent(\"SwapDocShells\", {\"detail\": this});\n          aOtherBrowser.dispatchEvent(event);\n\n          // We need to swap fields that are tied to our docshell or related to\n          // the loaded page\n          // Fields which are built as a result of notifactions (pageshow/hide,\n          // DOMLinkAdded/Removed, onStateChange) should not be swapped here,\n          // because these notifications are dispatched again once the docshells\n          // are swapped.\n          var fieldsToSwap = [\n            \"_docShell\",\n            \"_webBrowserFind\",\n            \"_contentWindow\",\n            \"_webNavigation\"\n          ];\n\n          if (this.isRemoteBrowser) {\n            fieldsToSwap.push(...[\n              \"_remoteWebNavigation\",\n              \"_remoteWebNavigationImpl\",\n              \"_remoteWebProgressManager\",\n              \"_remoteWebProgress\",\n              \"_remoteFinder\",\n              \"_securityUI\",\n              \"_documentURI\",\n              \"_documentContentType\",\n              \"_contentTitle\",\n              \"_characterSet\",\n              \"_mayEnableCharacterEncodingMenu\",\n              \"_contentPrincipal\",\n              \"_imageDocument\",\n              \"_fullZoom\",\n              \"_textZoom\",\n              \"_isSyntheticDocument\",\n              \"_innerWindowID\",\n              \"_manifestURI\",\n            ]);\n          }\n\n          var ourFieldValues = {};\n          var otherFieldValues = {};\n          for (let field of fieldsToSwap) {\n            ourFieldValues[field] = this[field];\n            otherFieldValues[field] = aOtherBrowser[field];\n          }\n\n          if (window.PopupNotifications)\n            PopupNotifications._swapBrowserNotifications(aOtherBrowser, this);\n\n          try {\n            this.swapFrameLoaders(aOtherBrowser);\n          } catch (ex) {\n            // This may not be implemented for browser elements that are not\n            // attached to a BrowserDOMWindow.\n          }\n\n          for (let field of fieldsToSwap) {\n            this[field] = otherFieldValues[field];\n            aOtherBrowser[field] = ourFieldValues[field];\n          }\n\n          if (!this.isRemoteBrowser) {\n            // Null the current nsITypeAheadFind instances so that they're\n            // lazily re-created on access. We need to do this because they\n            // might have attached the wrong docShell.\n            this._fastFind = aOtherBrowser._fastFind = null;\n          } else {\n            // Rewire the remote listeners\n            this._remoteWebNavigationImpl.swapBrowser(this);\n            aOtherBrowser._remoteWebNavigationImpl.swapBrowser(aOtherBrowser);\n\n            if (this._remoteWebProgressManager && aOtherBrowser._remoteWebProgressManager) {\n              this._remoteWebProgressManager.swapBrowser(this);\n              aOtherBrowser._remoteWebProgressManager.swapBrowser(aOtherBrowser);\n            }\n\n            if (this._remoteFinder)\n              this._remoteFinder.swapBrowser(this);\n            if (aOtherBrowser._remoteFinder)\n              aOtherBrowser._remoteFinder.swapBrowser(aOtherBrowser);\n          }\n\n          event = new CustomEvent(\"EndSwapDocShells\", {\"detail\": aOtherBrowser});\n          this.dispatchEvent(event);\n          event = new CustomEvent(\"EndSwapDocShells\", {\"detail\": this});\n          aOtherBrowser.dispatchEvent(event);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getInPermitUnload\">\n        <parameter name=\"aCallback\"/>\n        <body>\n        <![CDATA[\n          if (!this.docShell || !this.docShell.contentViewer) {\n            aCallback(false);\n            return;\n          }\n          aCallback(this.docShell.contentViewer.inPermitUnload);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"permitUnload\">\n        <body>\n        <![CDATA[\n          if (!this.docShell || !this.docShell.contentViewer) {\n            return {permitUnload: true, timedOut: false};\n          }\n          return {permitUnload: this.docShell.contentViewer.permitUnload(), timedOut: false};\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"print\">\n        <parameter name=\"aOuterWindowID\"/>\n        <parameter name=\"aPrintSettings\"/>\n        <parameter name=\"aPrintProgressListener\"/>\n        <body>\n          <![CDATA[\n            if (!this.frameLoader) {\n              throw Components.Exception(\"No frame loader.\",\n                                         Components.results.NS_ERROR_FAILURE);\n            }\n\n            this.frameLoader.print(aOuterWindowID, aPrintSettings,\n                                   aPrintProgressListener);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"dropLinks\">\n        <parameter name=\"aLinksCount\"/>\n        <parameter name=\"aLinks\"/>\n        <parameter name=\"aTriggeringPrincipal\"/>\n        <body><![CDATA[\n          if (!this.droppedLinkHandler) {\n            return false;\n          }\n          let links = [];\n          for (let i = 0; i < aLinksCount; i += 3) {\n            links.push({\n              url: aLinks[i],\n              name: aLinks[i + 1],\n              type: aLinks[i + 2],\n            });\n          }\n          this.droppedLinkHandler(null, links, aTriggeringPrincipal);\n          return true;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_F7\" group=\"system\">\n        <![CDATA[\n          if (event.defaultPrevented || !event.isTrusted)\n            return;\n\n          const kPrefShortcutEnabled = \"accessibility.browsewithcaret_shortcut.enabled\";\n          const kPrefWarnOnEnable    = \"accessibility.warn_on_browsewithcaret\";\n          const kPrefCaretBrowsingOn = \"accessibility.browsewithcaret\";\n\n          var isEnabled = this.mPrefs.getBoolPref(kPrefShortcutEnabled);\n          if (!isEnabled)\n            return;\n\n          // Toggle browse with caret mode\n          var browseWithCaretOn = this.mPrefs.getBoolPref(kPrefCaretBrowsingOn, false);\n          var warn = this.mPrefs.getBoolPref(kPrefWarnOnEnable, true);\n          if (warn && !browseWithCaretOn) {\n            var checkValue = {value: false};\n            var promptService = Components.classes[\"@mozilla.org/embedcomp/prompt-service;1\"]\n                                          .getService(Components.interfaces.nsIPromptService);\n\n            var buttonPressed = promptService.confirmEx(window,\n              this.mStrBundle.GetStringFromName(\"browsewithcaret.checkWindowTitle\"),\n              this.mStrBundle.GetStringFromName(\"browsewithcaret.checkLabel\"),\n              // Make \"No\" the default:\n              promptService.STD_YES_NO_BUTTONS | promptService.BUTTON_POS_1_DEFAULT,\n              null, null, null, this.mStrBundle.GetStringFromName(\"browsewithcaret.checkMsg\"),\n              checkValue);\n            if (buttonPressed != 0) {\n              if (checkValue.value) {\n                try {\n                  this.mPrefs.setBoolPref(kPrefShortcutEnabled, false);\n                } catch (ex) {\n                }\n              }\n              return;\n            }\n            if (checkValue.value) {\n              try {\n                this.mPrefs.setBoolPref(kPrefWarnOnEnable, false);\n              } catch (ex) {\n              }\n            }\n          }\n\n          // Toggle the pref\n          try {\n            this.mPrefs.setBoolPref(kPrefCaretBrowsingOn, !browseWithCaretOn);\n          } catch (ex) {\n          }\n        ]]>\n      </handler>\n      <handler event=\"dragover\" group=\"system\">\n      <![CDATA[\n        if (!this.droppedLinkHandler || event.defaultPrevented)\n          return;\n\n        // For drags that appear to be internal text (for example, tab drags),\n        // set the dropEffect to 'none'. This prevents the drop even if some\n        // other listener cancelled the event.\n        var types = event.dataTransfer.types;\n        if (types.includes(\"text/x-moz-text-internal\") && !types.includes(\"text/plain\")) {\n          event.dataTransfer.dropEffect = \"none\";\n          event.stopPropagation();\n          event.preventDefault();\n        }\n\n        // No need to handle \"dragover\" in e10s, since nsDocShellTreeOwner.cpp in the child process\n        // handles that case using \"@mozilla.org/content/dropped-link-handler;1\" service.\n        if (this.isRemoteBrowser)\n          return;\n\n        let linkHandler = Components.classes[\"@mozilla.org/content/dropped-link-handler;1\"].\n                            getService(Components.interfaces.nsIDroppedLinkHandler);\n        if (linkHandler.canDropLink(event, false))\n          event.preventDefault();\n      ]]>\n      </handler>\n      <handler event=\"drop\" group=\"system\">\n      <![CDATA[\n        // No need to handle \"drop\" in e10s, since nsDocShellTreeOwner.cpp in the child process\n        // handles that case using \"@mozilla.org/content/dropped-link-handler;1\" service.\n        if (!this.droppedLinkHandler || event.defaultPrevented || this.isRemoteBrowser)\n          return;\n\n        let linkHandler = Components.classes[\"@mozilla.org/content/dropped-link-handler;1\"].\n                            getService(Components.interfaces.nsIDroppedLinkHandler);\n        try {\n          // Pass true to prevent the dropping of javascript:/data: URIs\n          var links = linkHandler.dropLinks(event, true);\n        } catch (ex) {\n          return;\n        }\n\n        if (links.length) {\n          let triggeringPrincipal = linkHandler.getTriggeringPrincipal(event);\n          this.droppedLinkHandler(event, links, triggeringPrincipal);\n        }\n      ]]>\n      </handler>\n    </handlers>\n\n  </binding>\n\n</bindings>\n"},{"file":"button.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"buttonBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"button-base\" extends=\"chrome://global/content/bindings/general.xml#basetext\" role=\"xul:button\">\n    <implementation implements=\"nsIDOMXULButtonElement\">\n      <property name=\"type\"\n                onget=\"return this.getAttribute('type');\"\n                onset=\"this.setAttribute('type', val); return val;\"/>\n\n      <property name=\"dlgType\"\n                onget=\"return this.getAttribute('dlgtype');\"\n                onset=\"this.setAttribute('dlgtype', val); return val;\"/>\n\n      <property name=\"group\"\n                onget=\"return this.getAttribute('group');\"\n                onset=\"this.setAttribute('group', val); return val;\"/>\n\n      <property name=\"open\" onget=\"return this.hasAttribute('open');\">\n        <setter><![CDATA[\n          if (this.boxObject instanceof MenuBoxObject) {\n            this.boxObject.openMenu(val);\n          } else if (val) {\n            // Fall back to just setting the attribute\n            this.setAttribute(\"open\", \"true\");\n          } else {\n            this.removeAttribute(\"open\");\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"checked\" onget=\"return this.hasAttribute('checked');\">\n        <setter><![CDATA[\n          if (this.type == \"checkbox\") {\n            this.checkState = val ? 1 : 0;\n          } else if (this.type == \"radio\" && val) {\n            var sibs = this.parentNode.getElementsByAttribute(\"group\", this.group);\n            for (var i = 0; i < sibs.length; ++i)\n              sibs[i].removeAttribute(\"checked\");\n          }\n\n          if (val)\n            this.setAttribute(\"checked\", \"true\");\n          else\n            this.removeAttribute(\"checked\");\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"checkState\">\n        <getter><![CDATA[\n          var state = this.getAttribute(\"checkState\");\n          if (state == \"\")\n            return this.checked ? 1 : 0;\n          if (state == \"0\")\n            return 0;\n          if (state == \"2\")\n            return 2;\n          return 1;\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"checkState\", val);\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"autoCheck\"\n                onget=\"return this.getAttribute('autoCheck') == 'true';\"\n                onset=\"this.setAttribute('autoCheck', val); return val;\"/>\n\n      <method name =\"filterButtons\">\n        <parameter name=\"node\"/>\n        <body>\n        <![CDATA[\n          // if the node isn't visible, don't descend into it.\n          var cs = node.ownerGlobal.getComputedStyle(node);\n          if (cs.visibility != \"visible\" || cs.display == \"none\") {\n            return NodeFilter.FILTER_REJECT;\n          }\n          // but it may be a popup element, in which case we look at \"state\"...\n          if (cs.display == \"-moz-popup\" && node.state != \"open\") {\n            return NodeFilter.FILTER_REJECT;\n          }\n          // OK - the node seems visible, so it is a candidate.\n          if (node.localName == \"button\" && node.accessKey && !node.disabled)\n            return NodeFilter.FILTER_ACCEPT;\n          return NodeFilter.FILTER_SKIP;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"fireAccessKeyButton\">\n        <parameter name=\"aSubtree\"/>\n        <parameter name=\"aAccessKeyLower\"/>\n        <body>\n        <![CDATA[\n          var iterator = aSubtree.ownerDocument.createTreeWalker(aSubtree,\n                                                                 NodeFilter.SHOW_ELEMENT,\n                                                                 this.filterButtons);\n          while (iterator.nextNode()) {\n            var test = iterator.currentNode;\n            if (test.accessKey.toLowerCase() == aAccessKeyLower &&\n                !test.disabled && !test.collapsed && !test.hidden) {\n              test.focus();\n              test.click();\n              return true;\n            }\n          }\n          return false;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_handleClick\">\n        <body>\n        <![CDATA[\n          if (!this.disabled &&\n              (this.autoCheck || !this.hasAttribute(\"autoCheck\"))) {\n\n            if (this.type == \"checkbox\") {\n              this.checked = !this.checked;\n            } else if (this.type == \"radio\") {\n              this.checked = true;\n            }\n          }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <!-- While it would seem we could do this by handling oncommand, we can't\n           because any external oncommand handlers might get called before ours,\n           and then they would see the incorrect value of checked. Additionally\n           a command attribute would redirect the command events anyway.-->\n      <handler event=\"click\" button=\"0\" action=\"this._handleClick();\"/>\n      <handler event=\"keypress\" key=\" \">\n      <![CDATA[\n        this._handleClick();\n        // Prevent page from scrolling on the space key.\n        event.preventDefault();\n      ]]>\n      </handler>\n\n      <handler event=\"keypress\">\n      <![CDATA[\n        if (this.boxObject instanceof MenuBoxObject) {\n          if (this.open)\n            return;\n        } else {\n          if (event.keyCode == KeyEvent.DOM_VK_UP ||\n              (event.keyCode == KeyEvent.DOM_VK_LEFT &&\n                document.defaultView.getComputedStyle(this.parentNode)\n                        .direction == \"ltr\") ||\n              (event.keyCode == KeyEvent.DOM_VK_RIGHT &&\n                document.defaultView.getComputedStyle(this.parentNode)\n                        .direction == \"rtl\")) {\n            event.preventDefault();\n            window.document.commandDispatcher.rewindFocus();\n            return;\n          }\n\n          if (event.keyCode == KeyEvent.DOM_VK_DOWN ||\n              (event.keyCode == KeyEvent.DOM_VK_RIGHT &&\n                document.defaultView.getComputedStyle(this.parentNode)\n                        .direction == \"ltr\") ||\n              (event.keyCode == KeyEvent.DOM_VK_LEFT &&\n                document.defaultView.getComputedStyle(this.parentNode)\n                        .direction == \"rtl\")) {\n            event.preventDefault();\n            window.document.commandDispatcher.advanceFocus();\n            return;\n          }\n        }\n\n        if (event.keyCode || event.charCode <= 32 || event.altKey ||\n            event.ctrlKey || event.metaKey)\n          return;  // No printable char pressed, not a potential accesskey\n\n        // Possible accesskey pressed\n        var charPressedLower = String.fromCharCode(event.charCode).toLowerCase();\n\n        // If the accesskey of the current button is pressed, just activate it\n        if (this.accessKey.toLowerCase() == charPressedLower) {\n          this.click();\n          return;\n        }\n\n        // Search for accesskey in the list of buttons for this doc and each subdoc\n        // Get the buttons for the main document and all sub-frames\n        for (var frameCount = -1; frameCount < window.top.frames.length; frameCount++) {\n          var doc = (frameCount == -1) ? window.top.document :\n            window.top.frames[frameCount].document\n          if (this.fireAccessKeyButton(doc.documentElement, charPressedLower))\n            return;\n        }\n\n        // Test anonymous buttons\n        var dlg = window.top.document;\n        var buttonBox = dlg.getAnonymousElementByAttribute(dlg.documentElement,\n                                                         \"anonid\", \"buttons\");\n        if (buttonBox)\n          this.fireAccessKeyButton(buttonBox, charPressedLower);\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"button\" display=\"xul:button\"\n           extends=\"chrome://global/content/bindings/button.xml#button-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/button.css\"/>\n    </resources>\n\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:hbox class=\"box-inherit button-box\" xbl:inherits=\"align,dir,pack,orient\"\n                align=\"center\" pack=\"center\" flex=\"1\" anonid=\"button-box\">\n        <children>\n          <xul:image class=\"button-icon\" xbl:inherits=\"src=image\"/>\n          <xul:label class=\"button-text\" xbl:inherits=\"value=label,accesskey,crop,highlightable\"/>\n          <xul:label class=\"button-highlightable-text\" xbl:inherits=\"xbl:text=label,accesskey,crop,highlightable\"/>\n        </children>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"menu\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/button.xml#button\">\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:hbox class=\"box-inherit button-box\" xbl:inherits=\"align,dir,pack,orient\"\n                align=\"center\" pack=\"center\" flex=\"1\">\n        <children>\n          <xul:hbox class=\"box-inherit\" xbl:inherits=\"align,dir,pack,orient\"\n                    align=\"center\" pack=\"center\" flex=\"1\">\n            <xul:image class=\"button-icon\" xbl:inherits=\"src=image\"/>\n            <xul:label class=\"button-text\" xbl:inherits=\"value=label,accesskey,crop\"/>\n          </xul:hbox>\n          <xul:dropmarker class=\"button-menu-dropmarker\" xbl:inherits=\"open,disabled,label\"/>\n        </children>\n      </xul:hbox>\n    </content>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\" action=\"this.open = true;\"/>\n      <handler event=\"keypress\" key=\" \">\n      <![CDATA[\n        this.open = true;\n        // Prevent page from scrolling on the space key.\n        event.preventDefault();\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"menu-button-base\"\n           extends=\"chrome://global/content/bindings/button.xml#button-base\">\n    <implementation implements=\"nsIDOMEventListener\">\n      <constructor>\n        this.init();\n      </constructor>\n\n      <method name=\"init\">\n        <body>\n        <![CDATA[\n          var btn = document.getAnonymousElementByAttribute(this, \"anonid\", \"button\");\n          if (!btn)\n            throw \"XBL binding for <button type=\\\"menu-button\\\"/> binding must contain an element with anonid=\\\"button\\\"\";\n\n          var menubuttonParent = this;\n          btn.addEventListener(\"mouseover\", function() {\n            if (!this.disabled)\n              menubuttonParent.buttonover = true;\n          }, true);\n          btn.addEventListener(\"mouseout\", function() {\n            menubuttonParent.buttonover = false;\n          }, true);\n          btn.addEventListener(\"mousedown\", function() {\n            if (!this.disabled) {\n              menubuttonParent.buttondown = true;\n              document.addEventListener(\"mouseup\", menubuttonParent, true);\n            }\n          }, true);\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"buttonover\" onget=\"return this.getAttribute('buttonover');\">\n        <setter>\n        <![CDATA[\n          var v = val || val == \"true\";\n          if (!v && this.buttondown) {\n            this.buttondown = false;\n            this._pendingActive = true;\n          } else if (this._pendingActive) {\n            this.buttondown = true;\n            this._pendingActive = false;\n          }\n\n          if (v)\n            this.setAttribute(\"buttonover\", \"true\");\n          else\n            this.removeAttribute(\"buttonover\");\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"buttondown\" onget=\"return this.getAttribute('buttondown') == 'true';\">\n        <setter>\n        <![CDATA[\n          if (val || val == \"true\")\n            this.setAttribute(\"buttondown\", \"true\");\n          else\n            this.removeAttribute(\"buttondown\");\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <field name=\"_pendingActive\">false</field>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          this._pendingActive = false;\n          this.buttondown = false;\n          document.removeEventListener(\"mouseup\", this, true);\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\">\n        if (event.originalTarget == this)\n          this.open = true;\n      </handler>\n      <handler event=\"keypress\" key=\" \">\n        if (event.originalTarget == this) {\n          this.open = true;\n          // Prevent page from scrolling on the space key.\n          event.preventDefault();\n        }\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"menu-button\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/button.xml#menu-button-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/button.css\"/>\n    </resources>\n\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:button class=\"box-inherit button-menubutton-button\"\n                  anonid=\"button\" flex=\"1\" allowevents=\"true\"\n                  xbl:inherits=\"disabled,crop,image,label,accesskey,command,\n                                buttonover,buttondown,align,dir,pack,orient\">\n        <children/>\n      </xul:button>\n      <xul:dropmarker class=\"button-menubutton-dropmarker\" xbl:inherits=\"open,disabled,label\"/>\n    </content>\n  </binding>\n\n  <binding id=\"button-image\" display=\"xul:button\"\n           extends=\"chrome://global/content/bindings/button.xml#button\">\n    <content>\n      <xul:image class=\"button-image-icon\" xbl:inherits=\"src=image\"/>\n    </content>\n  </binding>\n\n  <binding id=\"button-repeat\" display=\"xul:autorepeatbutton\"\n           extends=\"chrome://global/content/bindings/button.xml#button\"/>\n\n</bindings>\n"},{"file":"checkbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"checkboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"checkbox\" extends=\"chrome://global/content/bindings/checkbox.xml#checkbox-baseline\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/checkbox.css\"/>\n    </resources>\n  </binding>\n\n  <binding id=\"checkbox-baseline\" role=\"xul:checkbox\"\n    extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <content>\n      <xul:image class=\"checkbox-check\" xbl:inherits=\"checked,disabled\"/>\n      <xul:hbox class=\"checkbox-label-box\" flex=\"1\">\n        <xul:image class=\"checkbox-icon\" xbl:inherits=\"src\"/>\n        <xul:label class=\"checkbox-label\" xbl:inherits=\"xbl:text=label,accesskey,crop\" flex=\"1\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULCheckboxElement\">\n      <method name=\"setChecked\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          var change = (aValue != (this.getAttribute(\"checked\") == \"true\"));\n          if (aValue)\n            this.setAttribute(\"checked\", \"true\");\n          else\n            this.removeAttribute(\"checked\");\n          if (change) {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"CheckboxStateChange\", true, true);\n            this.dispatchEvent(event);\n          }\n          return aValue;\n        ]]>\n        </body>\n      </method>\n\n      <!-- public implementation -->\n      <property name=\"checked\"    onset=\"return this.setChecked(val);\"\n                                  onget=\"return this.getAttribute('checked') == 'true';\"/>\n    </implementation>\n\n    <handlers>\n      <!-- While it would seem we could do this by handling oncommand, we need can't\n           because any external oncommand handlers might get called before ours, and\n           then they would see the incorrect value of checked. -->\n      <handler event=\"click\" button=\"0\" action=\"if (!this.disabled) this.checked = !this.checked;\"/>\n      <handler event=\"keypress\" key=\" \">\n        <![CDATA[\n          this.checked = !this.checked;\n          // Prevent page from scrolling on the space key.\n          event.preventDefault();\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"colorpicker.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"colorpickerBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"colorpicker\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/colorpicker.css\"/>\n    </resources>\n\n    <content>\n      <xul:vbox flex=\"1\">\n\n        <xul:hbox>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#FFFFFF\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#FFCCCC\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#FFCC99\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#FFFF99\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#FFFFCC\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#99FF99\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#99FFFF\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#CCFFFF\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#CCCCFF\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#FFCCFF\"/>\n        </xul:hbox>\n        <xul:hbox>\n          <xul:image class=\"colorpickertile\" color=\"#CCCCCC\"/>\n          <xul:image class=\"colorpickertile\" color=\"#FF6666\"/>\n          <xul:image class=\"colorpickertile\" color=\"#FF9966\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#FFFF66\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#FFFF33\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#66FF99\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#33FFFF\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#66FFFF\"/>\n          <xul:image class=\"colorpickertile\" color=\"#9999FF\"/>\n          <xul:image class=\"colorpickertile\" color=\"#FF99FF\"/>\n        </xul:hbox>\n        <xul:hbox>\n          <xul:image class=\"colorpickertile\" color=\"#C0C0C0\"/>\n          <xul:image class=\"colorpickertile\" color=\"#FF0000\"/>\n          <xul:image class=\"colorpickertile\" color=\"#FF9900\"/>\n          <xul:image class=\"colorpickertile\" color=\"#FFCC66\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#FFFF00\"/>\n          <xul:image class=\"colorpickertile cp-light\" color=\"#33FF33\"/>\n          <xul:image class=\"colorpickertile\" color=\"#66CCCC\"/>\n          <xul:image class=\"colorpickertile\" color=\"#33CCFF\"/>\n          <xul:image class=\"colorpickertile\" color=\"#6666CC\"/>\n          <xul:image class=\"colorpickertile\" color=\"#CC66CC\"/>\n        </xul:hbox>\n        <xul:hbox>\n          <xul:image class=\"colorpickertile\" color=\"#999999\"/>\n          <xul:image class=\"colorpickertile\" color=\"#CC0000\"/>\n          <xul:image class=\"colorpickertile\" color=\"#FF6600\"/>\n          <xul:image class=\"colorpickertile\" color=\"#FFCC33\"/>\n          <xul:image class=\"colorpickertile\" color=\"#FFCC00\"/>\n          <xul:image class=\"colorpickertile\" color=\"#33CC00\"/>\n          <xul:image class=\"colorpickertile\" color=\"#00CCCC\"/>\n          <xul:image class=\"colorpickertile\" color=\"#3366FF\"/>\n          <xul:image class=\"colorpickertile\" color=\"#6633FF\"/>\n          <xul:image class=\"colorpickertile\" color=\"#CC33CC\"/>\n        </xul:hbox>\n        <xul:hbox>\n          <xul:image class=\"colorpickertile\" color=\"#666666\"/>\n          <xul:image class=\"colorpickertile\" color=\"#990000\"/>\n          <xul:image class=\"colorpickertile\" color=\"#CC6600\"/>\n          <xul:image class=\"colorpickertile\" color=\"#CC9933\"/>\n          <xul:image class=\"colorpickertile\" color=\"#999900\"/>\n          <xul:image class=\"colorpickertile\" color=\"#009900\"/>\n          <xul:image class=\"colorpickertile\" color=\"#339999\"/>\n          <xul:image class=\"colorpickertile\" color=\"#3333FF\"/>\n          <xul:image class=\"colorpickertile\" color=\"#6600CC\"/>\n          <xul:image class=\"colorpickertile\" color=\"#993399\"/>\n        </xul:hbox>\n        <xul:hbox>\n          <xul:image class=\"colorpickertile\" color=\"#333333\"/>\n          <xul:image class=\"colorpickertile\" color=\"#660000\"/>\n          <xul:image class=\"colorpickertile\" color=\"#993300\"/>\n          <xul:image class=\"colorpickertile\" color=\"#996633\"/>\n          <xul:image class=\"colorpickertile\" color=\"#666600\"/>\n          <xul:image class=\"colorpickertile\" color=\"#006600\"/>\n          <xul:image class=\"colorpickertile\" color=\"#336666\"/>\n          <xul:image class=\"colorpickertile\" color=\"#000099\"/>\n          <xul:image class=\"colorpickertile\" color=\"#333399\"/>\n          <xul:image class=\"colorpickertile\" color=\"#663366\"/>\n        </xul:hbox>\n        <xul:hbox>\n          <xul:image class=\"colorpickertile\" color=\"#000000\"/>\n          <xul:image class=\"colorpickertile\" color=\"#330000\"/>\n          <xul:image class=\"colorpickertile\" color=\"#663300\"/>\n          <xul:image class=\"colorpickertile\" color=\"#663333\"/>\n          <xul:image class=\"colorpickertile\" color=\"#333300\"/>\n          <xul:image class=\"colorpickertile\" color=\"#003300\"/>\n          <xul:image class=\"colorpickertile\" color=\"#003333\"/>\n          <xul:image class=\"colorpickertile\" color=\"#000066\"/>\n          <xul:image class=\"colorpickertile\" color=\"#330099\"/>\n          <xul:image class=\"colorpickertile\" color=\"#330033\"/>\n        </xul:hbox>\n      </xul:vbox>\n      <!-- Something to take tab focus\n      <button style=\"border : 0px; width: 0px; height: 0px;\"/>\n      -->\n    </content>\n\n    <implementation implements=\"nsIDOMEventListener\">\n      <property name=\"color\">\n        <getter><![CDATA[\n          return this.mSelectedCell ? this.mSelectedCell.getAttribute(\"color\") : null;\n        ]]></getter>\n        <setter><![CDATA[\n          if (!val)\n            return val;\n          var uppercaseVal = val.toUpperCase();\n          // Translate standard HTML color strings:\n          if (uppercaseVal[0] != \"#\") {\n            switch (uppercaseVal) {\n              case \"GREEN\":\n                uppercaseVal = \"#008000\";\n                break;\n              case \"LIME\":\n                uppercaseVal = \"#00FF00\";\n                break;\n              case \"OLIVE\":\n                uppercaseVal = \"#808000\";\n                break;\n              case \"TEAL\":\n                uppercaseVal = \"#008080\";\n                break;\n              case \"YELLOW\":\n                uppercaseVal = \"#FFFF00\";\n                break;\n              case \"RED\":\n                uppercaseVal = \"#FF0000\";\n                break;\n              case \"MAROON\":\n                uppercaseVal = \"#800000\";\n                break;\n              case \"PURPLE\":\n                uppercaseVal = \"#800080\";\n                break;\n              case \"FUCHSIA\":\n                uppercaseVal = \"#FF00FF\";\n                break;\n              case \"NAVY\":\n                uppercaseVal = \"#000080\";\n                break;\n              case \"BLUE\":\n                uppercaseVal = \"#0000FF\";\n                break;\n              case \"AQUA\":\n                uppercaseVal = \"#00FFFF\";\n                break;\n              case \"WHITE\":\n                uppercaseVal = \"#FFFFFF\";\n                break;\n              case \"SILVER\":\n                uppercaseVal = \"#C0C0C0\";\n                break;\n              case \"GRAY\":\n                uppercaseVal = \"#808080\";\n                break;\n              default: // BLACK\n                uppercaseVal = \"#000000\";\n                break;\n            }\n          }\n          var cells = this.mBox.getElementsByAttribute(\"color\", uppercaseVal);\n          if (cells.item(0)) {\n            this.selectCell(cells[0]);\n            this.hoverCell(this.mSelectedCell);\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <method name=\"initColor\">\n        <parameter name=\"aColor\"/>\n        <body><![CDATA[\n          // Use this to initialize color without\n          //  triggering the \"onselect\" handler,\n          //  which closes window when it's a popup\n          this.mDoOnSelect = false;\n          this.color = aColor;\n          this.mDoOnSelect = true;\n        ]]></body>\n      </method>\n\n      <method name=\"initialize\">\n        <body><![CDATA[\n          this.mSelectedCell = null;\n          this.mHoverCell = null;\n          this.mBox = document.getAnonymousNodes(this)[0];\n          this.mIsPopup = false;\n          this.mDoOnSelect = true;\n\n          let imageEls = this.mBox.querySelectorAll(\"image\");\n          // We set the background of the picker tiles here using images in\n          // order for the color to show up even when author colors are\n          // disabled or the user is using high contrast mode.\n          for (let el of imageEls) {\n            let dataURI = \"data:image/svg+xml,<svg style='background-color: \" +\n                          encodeURIComponent(el.getAttribute(\"color\")) +\n                          \"' xmlns='http://www.w3.org/2000/svg' />\";\n            el.setAttribute(\"src\", dataURI);\n          }\n\n          this.hoverCell(this.mBox.childNodes[0].childNodes[0]);\n\n          // used to capture keydown at the document level\n          this.mPickerKeyDown = function(aEvent) {\n            document._focusedPicker.pickerKeyDown(aEvent);\n          }\n\n        ]]></body>\n      </method>\n\n      <method name=\"_fireEvent\">\n        <parameter name=\"aTarget\"/>\n        <parameter name=\"aEventName\"/>\n        <body>\n        <![CDATA[\n          try {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(aEventName, true, true);\n            var cancel = !aTarget.dispatchEvent(event);\n            if (aTarget.hasAttribute(\"on\" + aEventName)) {\n              var fn = new Function(\"event\", aTarget.getAttribute(\"on\" + aEventName));\n              var rv = fn.call(aTarget, event);\n              if (rv == false)\n                cancel = true;\n            }\n            return !cancel;\n          } catch (e) {\n            Components.utils.reportError(e);\n          }\n          return false;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"resetHover\">\n        <body><![CDATA[\n          if (this.mHoverCell)\n            this.mHoverCell.removeAttribute(\"hover\");\n        ]]></body>\n      </method>\n\n      <method name=\"getColIndex\">\n        <parameter name=\"aCell\"/>\n        <body><![CDATA[\n          var cell = aCell;\n          var idx;\n          for (idx = -1; cell; idx++)\n            cell = cell.previousSibling;\n\n          return idx;\n        ]]></body>\n      </method>\n\n      <method name=\"isColorCell\">\n        <parameter name=\"aCell\"/>\n        <body><![CDATA[\n          return aCell && aCell.hasAttribute(\"color\");\n        ]]></body>\n      </method>\n\n      <method name=\"hoverLeft\">\n        <body><![CDATA[\n          var cell = this.mHoverCell.previousSibling;\n          this.hoverCell(cell);\n        ]]></body>\n      </method>\n\n      <method name=\"hoverRight\">\n        <body><![CDATA[\n          var cell = this.mHoverCell.nextSibling;\n          this.hoverCell(cell);\n        ]]></body>\n      </method>\n\n      <method name=\"hoverUp\">\n        <body><![CDATA[\n          var row = this.mHoverCell.parentNode.previousSibling;\n          if (row) {\n            var colIdx = this.getColIndex(this.mHoverCell);\n            var cell = row.childNodes[colIdx];\n            this.hoverCell(cell);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"hoverDown\">\n        <body><![CDATA[\n          var row = this.mHoverCell.parentNode.nextSibling;\n          if (row) {\n            var colIdx = this.getColIndex(this.mHoverCell);\n            var cell = row.childNodes[colIdx];\n            this.hoverCell(cell);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"hoverTo\">\n        <parameter name=\"aRow\"/>\n        <parameter name=\"aCol\"/>\n\n        <body><![CDATA[\n          var row = this.mBox.childNodes[aRow];\n          if (!row) return;\n          var cell = row.childNodes[aCol];\n          if (!cell) return;\n          this.hoverCell(cell);\n        ]]></body>\n      </method>\n\n      <method name=\"hoverCell\">\n        <parameter name=\"aCell\"/>\n\n        <body><![CDATA[\n          if (this.isColorCell(aCell)) {\n            this.resetHover();\n            aCell.setAttribute(\"hover\", \"true\");\n            this.mHoverCell = aCell;\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"DOMMenuItemActive\", true, true);\n            aCell.dispatchEvent(event);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"selectHoverCell\">\n        <body><![CDATA[\n          this.selectCell(this.mHoverCell);\n        ]]></body>\n      </method>\n\n      <method name=\"selectCell\">\n        <parameter name=\"aCell\"/>\n\n        <body><![CDATA[\n          if (this.isColorCell(aCell)) {\n            if (this.mSelectedCell)\n              this.mSelectedCell.removeAttribute(\"selected\");\n\n            this.mSelectedCell = aCell;\n            aCell.setAttribute(\"selected\", \"true\");\n\n            if (this.mDoOnSelect)\n              this._fireEvent(this, \"select\");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.keyCode) {\n            case 37: // left\n              this.hoverLeft();\n              break;\n            case 38: // up\n              this.hoverUp();\n              break;\n            case 39: // right\n              this.hoverRight();\n              break;\n            case 40: // down\n              this.hoverDown();\n              break;\n            case 13: // enter\n            case 32: // space\n              this.selectHoverCell();\n              break;\n          }\n        ]]></body>\n      </method>\n\n\t  <constructor><![CDATA[\n        this.initialize();\n      ]]></constructor>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"mouseover\"><![CDATA[\n        this.hoverCell(event.originalTarget);\n      ]]></handler>\n\n      <handler event=\"click\"><![CDATA[\n        if (event.originalTarget.hasAttribute(\"color\")) {\n          this.selectCell(event.originalTarget);\n          this.hoverCell(this.mSelectedCell);\n        }\n      ]]></handler>\n\n\n      <handler event=\"focus\" phase=\"capturing\">\n      <![CDATA[\n        if (!this.mIsPopup && this.getAttribute(\"focused\") != \"true\") {\n          this.setAttribute(\"focused\", \"true\");\n          document.addEventListener(\"keydown\", this, true);\n          if (this.mSelectedCell)\n            this.hoverCell(this.mSelectedCell);\n        }\n      ]]>\n      </handler>\n\n      <handler event=\"blur\" phase=\"capturing\">\n      <![CDATA[\n        if (!this.mIsPopup && this.getAttribute(\"focused\") == \"true\") {\n          document.removeEventListener(\"keydown\", this, true);\n          this.removeAttribute(\"focused\");\n          this.resetHover();\n        }\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"colorpicker-button\" display=\"xul:menu\" role=\"xul:colorpicker\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/colorpicker.css\"/>\n    </resources>\n\n    <content>\n      <xul:image class=\"colorpicker-button-colorbox\" anonid=\"colorbox\" flex=\"1\" xbl:inherits=\"disabled\"/>\n\n      <xul:panel class=\"colorpicker-button-menupopup\"\n                 anonid=\"colorpopup\" noautofocus=\"true\" level=\"top\"\n                 onmousedown=\"event.stopPropagation()\"\n                 onpopupshowing=\"this._colorPicker.onPopupShowing()\"\n                 onpopuphiding=\"this._colorPicker.onPopupHiding()\"\n                 onselect=\"this._colorPicker.pickerChange()\">\n        <xul:colorpicker xbl:inherits=\"palettename,disabled\" allowevents=\"true\" anonid=\"colorpicker\"/>\n      </xul:panel>\n    </content>\n\n    <implementation>\n      <property name=\"open\"\n                onget=\"return this.getAttribute('open') == 'true'\"\n                onset=\"this.showPopup();\"/>\n      <property name=\"color\">\n        <getter><![CDATA[\n          return this.getAttribute(\"color\");\n        ]]></getter>\n        <setter><![CDATA[\n          this.mColorBox.setAttribute(\"src\",\n            \"data:image/svg+xml,<svg style='background-color: \" +\n            encodeURIComponent(val) +\n            \"' xmlns='http://www.w3.org/2000/svg' />\");\n          this.setAttribute(\"color\", val);\n          return val;\n        ]]></setter>\n      </property>\n\n      <method name=\"initialize\">\n        <body><![CDATA[\n          this.mColorBox = document.getAnonymousElementByAttribute(this, \"anonid\", \"colorbox\");\n          this.mColorBox.setAttribute(\"src\",\n            \"data:image/svg+xml,<svg style='background-color: \" +\n            encodeURIComponent(this.color) +\n            \"' xmlns='http://www.w3.org/2000/svg' />\");\n\n          var popup = document.getAnonymousElementByAttribute(this, \"anonid\", \"colorpopup\")\n          popup._colorPicker = this;\n\n          this.mPicker = document.getAnonymousElementByAttribute(this, \"anonid\", \"colorpicker\")\n        ]]></body>\n      </method>\n\n      <method name=\"_fireEvent\">\n        <parameter name=\"aTarget\"/>\n        <parameter name=\"aEventName\"/>\n        <body>\n        <![CDATA[\n          try {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(aEventName, true, true);\n            var cancel = !aTarget.dispatchEvent(event);\n            if (aTarget.hasAttribute(\"on\" + aEventName)) {\n              var fn = new Function(\"event\", aTarget.getAttribute(\"on\" + aEventName));\n              var rv = fn.call(aTarget, event);\n              if (rv == false)\n                cancel = true;\n            }\n            return !cancel;\n          } catch (e) {\n            dump(e);\n          }\n          return false;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"showPopup\">\n        <body><![CDATA[\n          this.mPicker.parentNode.openPopup(this, \"after_start\", 0, 0, false, false);\n        ]]></body>\n      </method>\n\n      <method name=\"hidePopup\">\n        <body><![CDATA[\n          this.mPicker.parentNode.hidePopup();\n        ]]></body>\n      </method>\n\n      <method name=\"onPopupShowing\">\n        <body><![CDATA[\n          if (\"resetHover\" in this.mPicker)\n            this.mPicker.resetHover();\n          document.addEventListener(\"keydown\", this.mPicker, true);\n          this.mPicker.mIsPopup = true;\n          // Initialize to current button's color\n          this.mPicker.initColor(this.color);\n        ]]></body>\n      </method>\n\n      <method name=\"onPopupHiding\">\n        <body><![CDATA[\n          // Removes the key listener\n          document.removeEventListener(\"keydown\", this.mPicker, true);\n          this.mPicker.mIsPopup = false;\n        ]]></body>\n      </method>\n\n      <method name=\"pickerChange\">\n        <body><![CDATA[\n          this.color = this.mPicker.color;\n          setTimeout(function(aPopup) { aPopup.hidePopup() }, 1, this.mPicker.parentNode);\n\n          this._fireEvent(this, \"change\");\n        ]]></body>\n      </method>\n\n      <constructor><![CDATA[\n        this.initialize();\n      ]]></constructor>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"keydown\"><![CDATA[\n        // open popup if key is space/up/left/right/down and popup is closed\n        if ( (event.keyCode == 32 || (event.keyCode > 36 && event.keyCode < 41)) && !this.open)\n          this.showPopup();\n        else if ( (event.keyCode == 27) && this.open)\n          this.hidePopup();\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"colorpickertile\" role=\"xul:colorpickertile\">\n  </binding>\n\n</bindings>\n"},{"file":"datetimebox.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings [\n<!ENTITY % datetimeboxDTD SYSTEM \"chrome://global/locale/datetimebox.dtd\">\n%datetimeboxDTD;\n]>\n\n<bindings id=\"datetimeboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"date-input\"\n           extends=\"chrome://global/content/bindings/datetimebox.xml#datetime-input-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/content/textbox.css\"/>\n      <stylesheet src=\"chrome://global/skin/textbox.css\"/>\n      <stylesheet src=\"chrome://global/content/bindings/datetimebox.css\"/>\n    </resources>\n\n    <implementation>\n      <constructor>\n      <![CDATA[\n        /* eslint-disable no-multi-spaces */\n        this.mYearPlaceHolder = ]]>\"FROM-DTD-date-year-placeholder\"<![CDATA[;\n        this.mMonthPlaceHolder = ]]>\"FROM-DTD-date-month-placeholder\"<![CDATA[;\n        this.mDayPlaceHolder = ]]>\"FROM-DTD-date-day-placeholder\"<![CDATA[;\n        /* eslint-enable no-multi-spaces */\n\n        this.mMinMonth = 1;\n        this.mMaxMonth = 12;\n        this.mMinDay = 1;\n        this.mMaxDay = 31;\n        this.mMinYear = 1;\n        // Maximum year limited by ECMAScript date object range, year <= 275760.\n        this.mMaxYear = 275760;\n        this.mMonthDayLength = 2;\n        this.mYearLength = 4;\n        this.mMonthPageUpDownInterval = 3;\n        this.mDayPageUpDownInterval = 7;\n        this.mYearPageUpDownInterval = 10;\n\n        this.buildEditFields();\n\n        if (this.mInputElement.value) {\n          this.setFieldsFromInputValue();\n        }\n      ]]>\n      </constructor>\n\n      <method name=\"buildEditFields\">\n        <body>\n        <![CDATA[\n          const HTML_NS = \"http://www.w3.org/1999/xhtml\";\n          let root =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n\n          let yearMaxLength = this.mMaxYear.toString().length\n          this.mYearField = this.createEditField(this.mYearPlaceHolder,\n            true, this.mYearLength, yearMaxLength, this.mMinYear, this.mMaxYear,\n            this.mYearPageUpDownInterval);\n          this.mMonthField = this.createEditField(this.mMonthPlaceHolder,\n            true, this.mMonthDayLength, this.mMonthDayLength, this.mMinMonth,\n            this.mMaxMonth, this.mMonthPageUpDownInterval);\n          this.mDayField = this.createEditField(this.mDayPlaceHolder,\n            true, this.mMonthDayLength, this.mMonthDayLength, this.mMinDay,\n            this.mMaxDay, this.mDayPageUpDownInterval);\n\n          let fragment = document.createDocumentFragment();\n          let formatter = Intl.DateTimeFormat(this.mLocales, {\n            year: \"numeric\",\n            month: \"numeric\",\n            day: \"numeric\"\n          });\n          formatter.formatToParts(Date.now()).map(part => {\n            switch (part.type) {\n              case \"year\":\n                fragment.appendChild(this.mYearField);\n                break;\n              case \"month\":\n                fragment.appendChild(this.mMonthField);\n                break;\n              case \"day\":\n                fragment.appendChild(this.mDayField);\n                break;\n              default:\n                let span = document.createElementNS(HTML_NS, \"span\");\n                span.textContent = part.value;\n                fragment.appendChild(span);\n                break;\n            }\n          });\n\n          root.appendChild(fragment);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"clearInputFields\">\n        <parameter name=\"aFromInputElement\"/>\n        <body>\n        <![CDATA[\n          this.log(\"clearInputFields\");\n\n          if (this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          if (this.mMonthField && !this.mMonthField.disabled &&\n              !this.mMonthField.readOnly) {\n            this.clearFieldValue(this.mMonthField);\n          }\n\n          if (this.mDayField && !this.mDayField.disabled &&\n              !this.mDayField.readOnly) {\n            this.clearFieldValue(this.mDayField);\n          }\n\n          if (this.mYearField && !this.mYearField.disabled &&\n              !this.mYearField.readOnly) {\n            this.clearFieldValue(this.mYearField);\n          }\n\n          if (!aFromInputElement) {\n            if (this.mInputElement.value) {\n              this.mInputElement.setUserInput(\"\");\n            } else {\n              this.mInputElement.updateValidityState();\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setFieldsFromInputValue\">\n        <body>\n        <![CDATA[\n          let value = this.mInputElement.value;\n          if (!value) {\n            this.clearInputFields(true);\n            return;\n          }\n\n          this.log(\"setFieldsFromInputValue: \" + value);\n          let [year, month, day] = value.split(\"-\");\n\n          this.setFieldValue(this.mYearField, year);\n          this.setFieldValue(this.mMonthField, month);\n          this.setFieldValue(this.mDayField, day);\n\n          this.notifyPicker();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setInputValueFromFields\">\n        <body>\n        <![CDATA[\n          if (this.isAnyFieldEmpty()) {\n            // Clear input element's value if any of the field has been cleared,\n            // otherwise update the validity state, since it may become \"not\"\n            // invalid if fields are not complete.\n            if (this.mInputElement.value) {\n              this.mInputElement.setUserInput(\"\");\n            } else {\n              this.mInputElement.updateValidityState();\n            }\n            // We still need to notify picker in case any of the field has\n            // changed.\n            this.notifyPicker();\n            return;\n          }\n\n          let { year, month, day } = this.getCurrentValue();\n\n          // Convert to a valid date string according to:\n          // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-date-string\n          year = year.toString().padStart(this.mYearLength, \"0\");\n          month = (month < 10) ? (\"0\" + month) : month;\n          day = (day < 10) ? (\"0\" + day) : day;\n\n          let date = [year, month, day].join(\"-\");\n\n          if (date == this.mInputElement.value) {\n            return;\n          }\n\n          this.log(\"setInputValueFromFields: \" + date);\n          this.notifyPicker();\n          this.mInputElement.setUserInput(date);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setFieldsFromPicker\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          let year = aValue.year;\n          let month = aValue.month;\n          let day = aValue.day;\n\n          if (!this.isEmpty(year)) {\n            this.setFieldValue(this.mYearField, year);\n          }\n\n          if (!this.isEmpty(month)) {\n            this.setFieldValue(this.mMonthField, month);\n          }\n\n          if (!this.isEmpty(day)) {\n            this.setFieldValue(this.mDayField, day);\n          }\n\n          // Update input element's .value if needed.\n          this.setInputValueFromFields();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"handleKeypress\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          if (this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          let targetField = aEvent.originalTarget;\n          let key = aEvent.key;\n\n          if (targetField.classList.contains(\"numeric\") && key.match(/[0-9]/)) {\n            let buffer = targetField.getAttribute(\"typeBuffer\") || \"\";\n\n            buffer = buffer.concat(key);\n            this.setFieldValue(targetField, buffer);\n\n            let n = Number(buffer);\n            let max = targetField.getAttribute(\"max\");\n            let maxLength = targetField.getAttribute(\"maxlength\");\n            if (buffer.length >= maxLength || n * 10 > max) {\n              buffer = \"\";\n              this.advanceToNextField();\n            }\n            targetField.setAttribute(\"typeBuffer\", buffer);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"incrementFieldValue\">\n        <parameter name=\"aTargetField\"/>\n        <parameter name=\"aTimes\"/>\n        <body>\n        <![CDATA[\n          let value = this.getFieldValue(aTargetField);\n\n          // Use current date if field is empty.\n          if (this.isEmpty(value)) {\n            let now = new Date();\n\n            if (aTargetField == this.mYearField) {\n              value = now.getFullYear();\n            } else if (aTargetField == this.mMonthField) {\n              value = now.getMonth() + 1;\n            } else if (aTargetField == this.mDayField) {\n              value = now.getDate();\n            } else {\n              this.log(\"Field not supported in incrementFieldValue.\");\n              return;\n            }\n          }\n\n          let min = Number(aTargetField.getAttribute(\"min\"));\n          let max = Number(aTargetField.getAttribute(\"max\"));\n\n          value += Number(aTimes);\n          if (value > max) {\n            value -= (max - min + 1);\n          } else if (value < min) {\n            value += (max - min + 1);\n          }\n\n          this.setFieldValue(aTargetField, value);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"handleKeyboardNav\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          if (this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          let targetField = aEvent.originalTarget;\n          let key = aEvent.key;\n\n          // Home/End key does nothing on year field.\n          if (targetField == this.mYearField && (key == \"Home\" ||\n                                                 key == \"End\")) {\n            return;\n          }\n\n          switch (key) {\n            case \"ArrowUp\":\n              this.incrementFieldValue(targetField, 1);\n              break;\n            case \"ArrowDown\":\n              this.incrementFieldValue(targetField, -1);\n              break;\n            case \"PageUp\": {\n              let interval = targetField.getAttribute(\"pginterval\");\n              this.incrementFieldValue(targetField, interval);\n              break;\n            }\n            case \"PageDown\": {\n              let interval = targetField.getAttribute(\"pginterval\");\n              this.incrementFieldValue(targetField, 0 - interval);\n              break;\n            }\n            case \"Home\":\n              let min = targetField.getAttribute(\"min\");\n              this.setFieldValue(targetField, min);\n              break;\n            case \"End\":\n              let max = targetField.getAttribute(\"max\");\n              this.setFieldValue(targetField, max);\n              break;\n          }\n          this.setInputValueFromFields();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getCurrentValue\">\n        <body>\n        <![CDATA[\n          let year = this.getFieldValue(this.mYearField);\n          let month = this.getFieldValue(this.mMonthField);\n          let day = this.getFieldValue(this.mDayField);\n\n          let date = { year, month, day };\n\n          this.log(\"getCurrentValue: \" + JSON.stringify(date));\n          return date;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setFieldValue\">\n       <parameter name=\"aField\"/>\n       <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          if (!aField || !aField.classList.contains(\"numeric\")) {\n            return;\n          }\n\n          let value = Number(aValue);\n          if (isNaN(value)) {\n            this.log(\"NaN on setFieldValue!\");\n            return;\n          }\n\n          let maxLength = aField.getAttribute(\"maxlength\");\n          if (aValue.length == maxLength) {\n            let min = Number(aField.getAttribute(\"min\"));\n            let max = Number(aField.getAttribute(\"max\"));\n\n            if (value < min) {\n              value = min;\n            } else if (value > max) {\n              value = max;\n            }\n          }\n\n          aField.setAttribute(\"rawValue\", value);\n\n          // Display formatted value based on locale.\n          let minDigits = aField.getAttribute(\"mindigits\");\n          let formatted = value.toLocaleString(this.mLocales, {\n            minimumIntegerDigits: minDigits,\n            useGrouping: false\n          });\n\n          aField.textContent = formatted;\n          this.updateResetButtonVisibility();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isAnyFieldAvailable\">\n        <parameter name=\"aForPicker\"/>\n        <body>\n        <![CDATA[\n          let { year, month, day } = this.getCurrentValue();\n\n          return !this.isEmpty(year) || !this.isEmpty(month) ||\n                 !this.isEmpty(day);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isAnyFieldEmpty\">\n        <body>\n        <![CDATA[\n          let { year, month, day } = this.getCurrentValue();\n\n          return (this.isEmpty(year) || this.isEmpty(month) ||\n                  this.isEmpty(day));\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n  </binding>\n\n  <binding id=\"time-input\"\n           extends=\"chrome://global/content/bindings/datetimebox.xml#datetime-input-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/content/textbox.css\"/>\n      <stylesheet src=\"chrome://global/skin/textbox.css\"/>\n      <stylesheet src=\"chrome://global/content/bindings/datetimebox.css\"/>\n    </resources>\n\n    <implementation>\n      <property name=\"kMsPerSecond\" readonly=\"true\" onget=\"return 1000;\" />\n      <property name=\"kMsPerMinute\" readonly=\"true\" onget=\"return (60 * 1000);\" />\n\n      <constructor>\n      <![CDATA[\n        const kDefaultAMString = \"AM\";\n        const kDefaultPMString = \"PM\";\n\n        let { amString, pmString } =\n          this.getStringsForLocale(this.mLocales);\n\n        this.mAMIndicator = amString || kDefaultAMString;\n        this.mPMIndicator = pmString || kDefaultPMString;\n\n        /* eslint-disable no-multi-spaces */\n        this.mHourPlaceHolder = ]]>\"FROM-DTD-time-hour-placeholder\"<![CDATA[;\n        this.mMinutePlaceHolder = ]]>\"FROM-DTD-time-minute-placeholder\"<![CDATA[;\n        this.mSecondPlaceHolder = ]]>\"FROM-DTD-time-second-placeholder\"<![CDATA[;\n        this.mMillisecPlaceHolder = ]]>\"FROM-DTD-time-millisecond-placeholder\"<![CDATA[;\n        this.mDayPeriodPlaceHolder = ]]>\"FROM-DTD-time-dayperiod-placeholder\"<![CDATA[;\n        /* eslint-enable no-multi-spaces */\n\n        this.mHour12 = this.is12HourTime(this.mLocales);\n        this.mMillisecSeparatorText = \".\";\n        this.mMaxLength = 2;\n        this.mMillisecMaxLength = 3;\n        this.mDefaultStep = 60 * 1000; // in milliseconds\n\n        this.mMinHour = this.mHour12 ? 1 : 0;\n        this.mMaxHour = this.mHour12 ? 12 : 23;\n        this.mMinMinute = 0;\n        this.mMaxMinute = 59;\n        this.mMinSecond = 0;\n        this.mMaxSecond = 59;\n        this.mMinMillisecond = 0;\n        this.mMaxMillisecond = 999;\n\n        this.mHourPageUpDownInterval = 3;\n        this.mMinSecPageUpDownInterval = 10;\n\n        this.buildEditFields();\n\n        if (this.mInputElement.value) {\n          this.setFieldsFromInputValue();\n        }\n        ]]>\n      </constructor>\n\n      <method name=\"getInputElementValues\">\n        <body>\n        <![CDATA[\n          let value = this.mInputElement.value;\n          if (value.length === 0) {\n            return {};\n          }\n\n          let hour, minute, second, millisecond;\n          [hour, minute, second] = value.split(\":\");\n          if (second) {\n            [second, millisecond] = second.split(\".\");\n\n            // Convert fraction of second to milliseconds.\n            if (millisecond && millisecond.length === 1) {\n              millisecond *= 100;\n            } else if (millisecond && millisecond.length === 2) {\n              millisecond *= 10;\n            }\n          }\n\n          return { hour, minute, second, millisecond };\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"hasSecondField\">\n        <body>\n        <![CDATA[\n          return !!this.mSecondField;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"hasMillisecField\">\n        <body>\n        <![CDATA[\n          return !!this.mMillisecField;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"hasDayPeriodField\">\n        <body>\n        <![CDATA[\n          return !!this.mDayPeriodField;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"shouldShowSecondField\">\n        <body>\n        <![CDATA[\n          let { second } = this.getInputElementValues();\n          if (second != undefined) {\n            return true;\n          }\n\n          let stepBase = this.mInputElement.getStepBase();\n          if ((stepBase % this.kMsPerMinute) != 0) {\n            return true;\n          }\n\n          let step = this.mInputElement.getStep();\n          if ((step % this.kMsPerMinute) != 0) {\n            return true;\n          }\n\n          return false;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"shouldShowMillisecField\">\n        <body>\n        <![CDATA[\n          let { millisecond } = this.getInputElementValues();\n          if (millisecond != undefined) {\n            return true;\n          }\n\n          let stepBase = this.mInputElement.getStepBase();\n          if ((stepBase % this.kMsPerSecond) != 0) {\n            return true;\n          }\n\n          let step = this.mInputElement.getStep();\n          if ((step % this.kMsPerSecond) != 0) {\n            return true;\n          }\n\n          return false;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"rebuildEditFieldsIfNeeded\">\n        <body>\n        <![CDATA[\n          if ((this.shouldShowSecondField() == this.hasSecondField()) &&\n              (this.shouldShowMillisecField() == this.hasMillisecField())) {\n            return;\n          }\n\n          let root =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n          while (root.firstChild) {\n            root.firstChild.remove();\n          }\n\n          this.mHourField = null;\n          this.mMinuteField = null;\n          this.mSecondField = null;\n          this.mMillisecField = null;\n\n          this.buildEditFields();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"buildEditFields\">\n        <body>\n        <![CDATA[\n          const HTML_NS = \"http://www.w3.org/1999/xhtml\";\n          let root =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n\n          let options = {\n            hour: \"numeric\",\n            minute: \"numeric\",\n            hour12: this.mHour12\n          };\n\n          this.mHourField = this.createEditField(this.mHourPlaceHolder,\n            true, this.mMaxLength, this.mMaxLength, this.mMinHour,\n            this.mMaxHour, this.mHourPageUpDownInterval);\n          this.mMinuteField = this.createEditField(this.mMinutePlaceHolder,\n            true, this.mMaxLength, this.mMaxLength, this.mMinMinute,\n            this.mMaxMinute, this.mMinSecPageUpDownInterval);\n\n          if (this.mHour12) {\n            this.mDayPeriodField = this.createEditField(\n              this.mDayPeriodPlaceHolder, false);\n          }\n\n          if (this.shouldShowSecondField()) {\n            options.second = \"numeric\";\n            this.mSecondField = this.createEditField(this.mSecondPlaceHolder,\n              true, this.mMaxLength, this.mMaxLength, this.mMinSecond,\n              this.mMaxSecond, this.mMinSecPageUpDownInterval);\n\n            if (this.shouldShowMillisecField()) {\n              this.mMillisecField = this.createEditField(\n                this.mMillisecPlaceHolder, true, this.mMillisecMaxLength,\n                this.mMillisecMaxLength, this.mMinMillisecond,\n                this.mMaxMillisecond, this.mMinSecPageUpDownInterval);\n            }\n          }\n\n          let fragment = document.createDocumentFragment();\n          let formatter = Intl.DateTimeFormat(this.mLocales, options);\n          formatter.formatToParts(Date.now()).map(part => {\n            switch (part.type) {\n              case \"hour\":\n                fragment.appendChild(this.mHourField);\n                break;\n              case \"minute\":\n                fragment.appendChild(this.mMinuteField);\n                break;\n              case \"second\":\n                fragment.appendChild(this.mSecondField);\n                if (this.shouldShowMillisecField()) {\n                  // Intl.DateTimeFormat does not support millisecond, so we\n                  // need to handle this on our own.\n                  let span = document.createElementNS(HTML_NS, \"span\");\n                  span.textContent = this.mMillisecSeparatorText;\n                  fragment.appendChild(span);\n                  fragment.appendChild(this.mMillisecField);\n                }\n                break;\n              case \"dayPeriod\":\n                fragment.appendChild(this.mDayPeriodField);\n                break;\n              default:\n                let span = document.createElementNS(HTML_NS, \"span\");\n                span.textContent = part.value;\n                fragment.appendChild(span);\n                break;\n            }\n          });\n\n          root.appendChild(fragment);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getStringsForLocale\">\n        <parameter name=\"aLocales\"/>\n        <body>\n        <![CDATA[\n          this.log(\"getStringsForLocale: \" + aLocales);\n\n          let intlUtils = window.intlUtils;\n          if (!intlUtils) {\n            return {};\n          }\n\n          let amString, pmString;\n          let keys = [ \"dates/gregorian/dayperiods/am\",\n                       \"dates/gregorian/dayperiods/pm\" ];\n\n          let result = intlUtils.getDisplayNames(this.mLocales, {\n            style: \"short\",\n            keys\n          });\n\n          [ amString, pmString ] = keys.map(key => result.values[key]);\n\n          return { amString, pmString };\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"is12HourTime\">\n        <parameter name=\"aLocales\"/>\n          <body>\n          <![CDATA[\n            let options = (new Intl.DateTimeFormat(aLocales, {\n              hour: \"numeric\"\n            })).resolvedOptions();\n\n            return options.hour12;\n          ]]>\n          </body>\n      </method>\n\n      <method name=\"setFieldsFromInputValue\">\n        <body>\n        <![CDATA[\n          let { hour, minute, second, millisecond } =\n            this.getInputElementValues();\n\n          if (this.isEmpty(hour) && this.isEmpty(minute)) {\n            this.clearInputFields(true);\n            return;\n          }\n\n          // Second and millisecond part are optional, rebuild edit fields if\n          // needed.\n          this.rebuildEditFieldsIfNeeded();\n\n          this.setFieldValue(this.mHourField, hour);\n          this.setFieldValue(this.mMinuteField, minute);\n          if (this.mHour12) {\n            this.setDayPeriodValue(hour >= this.mMaxHour ? this.mPMIndicator\n                                                         : this.mAMIndicator);\n          }\n\n          if (this.hasSecondField()) {\n            this.setFieldValue(this.mSecondField,\n              (second != undefined) ? second : 0);\n          }\n\n          if (this.hasMillisecField()) {\n            this.setFieldValue(this.mMillisecField,\n              (millisecond != undefined) ? millisecond : 0);\n          }\n\n          this.notifyPicker();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setInputValueFromFields\">\n        <body>\n        <![CDATA[\n          if (this.isAnyFieldEmpty()) {\n            // Clear input element's value if any of the field has been cleared,\n            // otherwise update the validity state, since it may become \"not\"\n            // invalid if fields are not complete.\n            if (this.mInputElement.value) {\n              this.mInputElement.setUserInput(\"\");\n            } else {\n              this.mInputElement.updateValidityState();\n            }\n            // We still need to notify picker in case any of the field has\n            // changed.\n            this.notifyPicker();\n            return;\n          }\n\n          let { hour, minute, second, millisecond } = this.getCurrentValue();\n          let dayPeriod = this.getDayPeriodValue();\n\n          // Convert to a valid time string according to:\n          // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-time-string\n          if (this.mHour12) {\n            if (dayPeriod == this.mPMIndicator && hour < this.mMaxHour) {\n              hour += this.mMaxHour;\n            } else if (dayPeriod == this.mAMIndicator &&\n                       hour == this.mMaxHour) {\n              hour = 0;\n            }\n          }\n\n          hour = (hour < 10) ? (\"0\" + hour) : hour;\n          minute = (minute < 10) ? (\"0\" + minute) : minute;\n\n          let time = hour + \":\" + minute;\n          if (second != undefined) {\n            second = (second < 10) ? (\"0\" + second) : second;\n            time += \":\" + second;\n          }\n\n          if (millisecond != undefined) {\n            // Convert milliseconds to fraction of second.\n            millisecond = millisecond.toString().padStart(\n              this.mMillisecMaxLength, \"0\");\n            time += \".\" + millisecond;\n          }\n\n          if (time == this.mInputElement.value) {\n            return;\n          }\n\n          this.log(\"setInputValueFromFields: \" + time);\n          this.notifyPicker();\n          this.mInputElement.setUserInput(time);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setFieldsFromPicker\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          let hour = aValue.hour;\n          let minute = aValue.minute;\n          this.log(\"setFieldsFromPicker: \" + hour + \":\" + minute);\n\n          if (!this.isEmpty(hour)) {\n            this.setFieldValue(this.mHourField, hour);\n            if (this.mHour12) {\n              this.setDayPeriodValue(hour >= this.mMaxHour ? this.mPMIndicator\n                                                           : this.mAMIndicator);\n            }\n          }\n\n          if (!this.isEmpty(minute)) {\n            this.setFieldValue(this.mMinuteField, minute);\n          }\n\n          // Update input element's .value if needed.\n          this.setInputValueFromFields();\n        ]]>\n        </body>\n       </method>\n\n      <method name=\"clearInputFields\">\n        <parameter name=\"aFromInputElement\"/>\n        <body>\n        <![CDATA[\n          this.log(\"clearInputFields\");\n\n          if (this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          if (this.mHourField && !this.mHourField.disabled &&\n              !this.mHourField.readOnly) {\n            this.clearFieldValue(this.mHourField);\n          }\n\n          if (this.mMinuteField && !this.mMinuteField.disabled &&\n              !this.mMinuteField.readOnly) {\n            this.clearFieldValue(this.mMinuteField);\n          }\n\n          if (this.hasSecondField() && !this.mSecondField.disabled &&\n              !this.mSecondField.readOnly) {\n            this.clearFieldValue(this.mSecondField);\n          }\n\n          if (this.hasMillisecField() && !this.mMillisecField.disabled &&\n              !this.mMillisecField.readOnly) {\n            this.clearFieldValue(this.mMillisecField);\n          }\n\n          if (this.hasDayPeriodField() && !this.mDayPeriodField.disabled &&\n              !this.mDayPeriodField.readOnly) {\n            this.clearFieldValue(this.mDayPeriodField);\n          }\n\n          if (!aFromInputElement) {\n            if (this.mInputElement.value) {\n              this.mInputElement.setUserInput(\"\");\n            } else {\n              this.mInputElement.updateValidityState();\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"notifyMinMaxStepAttrChanged\">\n        <body>\n        <![CDATA[\n          // Second and millisecond part are optional, rebuild edit fields if\n          // needed.\n          this.rebuildEditFieldsIfNeeded();\n          // Fill in values again.\n          this.setFieldsFromInputValue();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"incrementFieldValue\">\n        <parameter name=\"aTargetField\"/>\n        <parameter name=\"aTimes\"/>\n        <body>\n        <![CDATA[\n          let value = this.getFieldValue(aTargetField);\n\n          // Use current time if field is empty.\n          if (this.isEmpty(value)) {\n            let now = new Date();\n\n            if (aTargetField == this.mHourField) {\n              value = now.getHours();\n              if (this.mHour12) {\n                value = (value % this.mMaxHour) || this.mMaxHour;\n              }\n            } else if (aTargetField == this.mMinuteField) {\n              value = now.getMinutes();\n            } else if (aTargetField == this.mSecondField) {\n              value = now.getSeconds();\n            } else if (aTargetField == this.mMillisecField) {\n              value = now.getMilliseconds();\n            } else {\n              this.log(\"Field not supported in incrementFieldValue.\");\n              return;\n            }\n          }\n\n          let min = aTargetField.getAttribute(\"min\");\n          let max = aTargetField.getAttribute(\"max\");\n\n          value += Number(aTimes);\n          if (value > max) {\n            value -= (max - min + 1);\n          } else if (value < min) {\n            value += (max - min + 1);\n          }\n\n          this.setFieldValue(aTargetField, value);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"handleKeyboardNav\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          if (this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          let targetField = aEvent.originalTarget;\n          let key = aEvent.key;\n\n          if (this.hasDayPeriodField() &&\n              targetField == this.mDayPeriodField) {\n            // Home/End key does nothing on AM/PM field.\n            if (key == \"Home\" || key == \"End\") {\n              return;\n            }\n\n            this.setDayPeriodValue(\n              this.getDayPeriodValue() == this.mAMIndicator ? this.mPMIndicator\n                                                            : this.mAMIndicator);\n            this.setInputValueFromFields();\n            return;\n          }\n\n          switch (key) {\n            case \"ArrowUp\":\n              this.incrementFieldValue(targetField, 1);\n              break;\n            case \"ArrowDown\":\n              this.incrementFieldValue(targetField, -1);\n              break;\n            case \"PageUp\": {\n              let interval = targetField.getAttribute(\"pginterval\");\n              this.incrementFieldValue(targetField, interval);\n              break;\n            }\n            case \"PageDown\": {\n              let interval = targetField.getAttribute(\"pginterval\");\n              this.incrementFieldValue(targetField, 0 - interval);\n              break;\n            }\n            case \"Home\":\n              let min = targetField.getAttribute(\"min\");\n              this.setFieldValue(targetField, min);\n              break;\n            case \"End\":\n              let max = targetField.getAttribute(\"max\");\n              this.setFieldValue(targetField, max);\n              break;\n          }\n          this.setInputValueFromFields();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"handleKeypress\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          if (this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          let targetField = aEvent.originalTarget;\n          let key = aEvent.key;\n\n          if (this.hasDayPeriodField() &&\n              targetField == this.mDayPeriodField) {\n            if (key == \"a\" || key == \"A\") {\n              this.setDayPeriodValue(this.mAMIndicator);\n            } else if (key == \"p\" || key == \"P\") {\n              this.setDayPeriodValue(this.mPMIndicator);\n            }\n            return;\n          }\n\n          if (targetField.classList.contains(\"numeric\") && key.match(/[0-9]/)) {\n            let buffer = targetField.getAttribute(\"typeBuffer\") || \"\";\n\n            buffer = buffer.concat(key);\n            this.setFieldValue(targetField, buffer);\n\n            let n = Number(buffer);\n            let max = targetField.getAttribute(\"max\");\n            let maxLength = targetField.getAttribute(\"maxLength\");\n            if (buffer.length >= maxLength || n * 10 > max) {\n              buffer = \"\";\n              this.advanceToNextField();\n            }\n            targetField.setAttribute(\"typeBuffer\", buffer);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setFieldValue\">\n       <parameter name=\"aField\"/>\n       <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          if (!aField || !aField.classList.contains(\"numeric\")) {\n            return;\n          }\n\n          let value = Number(aValue);\n          if (isNaN(value)) {\n            this.log(\"NaN on setFieldValue!\");\n            return;\n          }\n\n          if (aField == this.mHourField) {\n            if (this.mHour12) {\n              // Try to change to 12hr format if user input is 0 or greater\n              // than 12.\n              let maxLength = aField.getAttribute(\"maxlength\");\n              if (value == 0 && aValue.length == maxLength) {\n                value = this.mMaxHour;\n              } else {\n                value = (value > this.mMaxHour) ? value % this.mMaxHour : value;\n              }\n            } else if (value > this.mMaxHour) {\n              value = this.mMaxHour;\n            }\n          }\n\n          aField.setAttribute(\"rawValue\", value);\n\n          let minDigits = aField.getAttribute(\"mindigits\");\n          let formatted = value.toLocaleString(this.mLocales, {\n            minimumIntegerDigits: minDigits,\n            useGrouping: false\n          });\n\n          aField.textContent = formatted;\n          this.updateResetButtonVisibility();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getDayPeriodValue\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          if (!this.hasDayPeriodField()) {\n            return \"\";\n          }\n\n          let placeholder = this.mDayPeriodField.placeholder;\n          let value = this.mDayPeriodField.textContent;\n\n          return (value == placeholder ? \"\" : value);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setDayPeriodValue\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          if (!this.hasDayPeriodField()) {\n            return;\n          }\n\n          this.mDayPeriodField.textContent = aValue;\n          this.updateResetButtonVisibility();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isAnyFieldAvailable\">\n        <parameter name=\"aForPicker\"/>\n        <body>\n        <![CDATA[\n          let { hour, minute, second, millisecond } = this.getCurrentValue();\n          let dayPeriod = this.getDayPeriodValue();\n\n          let available = !this.isEmpty(hour) || !this.isEmpty(minute);\n          if (available) {\n            return true;\n          }\n\n          // Picker only cares about hour:minute.\n          if (aForPicker) {\n            return false;\n          }\n\n          return (this.hasDayPeriodField() && !this.isEmpty(dayPeriod)) ||\n                 (this.hasSecondField() && !this.isEmpty(second)) ||\n                 (this.hasMillisecField() && !this.isEmpty(millisecond));\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isAnyFieldEmpty\">\n        <body>\n        <![CDATA[\n          let { hour, minute, second, millisecond } = this.getCurrentValue();\n          let dayPeriod = this.getDayPeriodValue();\n\n          return (this.isEmpty(hour) || this.isEmpty(minute) ||\n                  (this.hasDayPeriodField() && this.isEmpty(dayPeriod)) ||\n                  (this.hasSecondField() && this.isEmpty(second)) ||\n                  (this.hasMillisecField() && this.isEmpty(millisecond)));\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getCurrentValue\">\n        <body>\n        <![CDATA[\n          let hour = this.getFieldValue(this.mHourField);\n          if (!this.isEmpty(hour)) {\n            if (this.mHour12) {\n              let dayPeriod = this.getDayPeriodValue();\n              if (dayPeriod == this.mPMIndicator && hour < this.mMaxHour) {\n                hour += this.mMaxHour;\n              } else if (dayPeriod == this.mAMIndicator &&\n                         hour == this.mMaxHour) {\n                hour = 0;\n              }\n            }\n          }\n\n          let minute = this.getFieldValue(this.mMinuteField);\n          let second = this.getFieldValue(this.mSecondField);\n          let millisecond = this.getFieldValue(this.mMillisecField);\n\n          let time = { hour, minute, second, millisecond };\n\n          this.log(\"getCurrentValue: \" + JSON.stringify(time));\n          return time;\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"datetime-input-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/content/textbox.css\"/>\n      <stylesheet src=\"chrome://global/skin/textbox.css\"/>\n      <stylesheet src=\"chrome://global/content/bindings/datetimebox.css\"/>\n    </resources>\n\n    <content>\n      <html:div class=\"datetime-input-box-wrapper\" anonid=\"input-box-wrapper\"\n                xbl:inherits=\"context,disabled,readonly\">\n        <html:span class=\"datetime-input-edit-wrapper\"\n                   anonid=\"edit-wrapper\">\n          <!-- Each of the date/time input types will append their input child\n             - elements here -->\n        </html:span>\n\n        <html:button class=\"datetime-reset-button\" anonid=\"reset-button\"\n                     tabindex=\"-1\" xbl:inherits=\"disabled\"/>\n      </html:div>\n    </content>\n\n    <implementation implements=\"nsIDateTimeInputArea\">\n      <constructor>\n      <![CDATA[\n        this.DEBUG = false;\n        this.mInputElement = this.parentNode;\n        this.mLocales = window.getRegionalPrefsLocales();\n\n        this.mIsRTL = false;\n        let intlUtils = window.intlUtils;\n        if (intlUtils) {\n          this.mIsRTL =\n            intlUtils.getLocaleInfo(this.mLocales).direction === \"rtl\";\n        }\n\n        if (this.mIsRTL) {\n          let inputBoxWrapper =\n            document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                    \"input-box-wrapper\");\n          inputBoxWrapper.dir = \"rtl\";\n        }\n\n        this.mMin = this.mInputElement.min;\n        this.mMax = this.mInputElement.max;\n        this.mStep = this.mInputElement.step;\n        this.mIsPickerOpen = false;\n\n        this.mResetButton =\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"reset-button\");\n        this.mResetButton.style.visibility = \"hidden\";\n\n        this.EVENTS.forEach((eventName) => {\n          this.addEventListener(eventName, this, { mozSystemGroup: true });\n        });\n        // Handle keypress separately since we need to catch it on capturing.\n        this.addEventListener(\"keypress\", this, {\n          capture: true,\n          mozSystemGroup: true\n        });\n        // This is to open the picker when input element is clicked (this\n        // includes padding area).\n        this.mInputElement.addEventListener(\"click\", this,\n                                            { mozSystemGroup: true });\n      ]]>\n      </constructor>\n\n      <destructor>\n      <![CDATA[\n        this.mInputElement = null;\n\n        this.EVENTS.forEach((eventName) => {\n          this.removeEventListener(eventName, this, { mozSystemGroup: true });\n        });\n        this.removeEventListener(\"keypress\", this, {\n          capture: true,\n          mozSystemGroup: true\n        });\n        this.mInputElement.removeEventListener(\"click\", this,\n                                               { mozSystemGroup: true });\n      ]]>\n      </destructor>\n\n      <property name=\"EVENTS\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          return [\"focus\", \"blur\", \"copy\", \"cut\", \"paste\", \"mousedown\"];\n        ]]>\n        </getter>\n      </property>\n\n      <method name=\"log\">\n        <parameter name=\"aMsg\"/>\n        <body>\n        <![CDATA[\n          if (this.DEBUG) {\n            dump(\"[DateTimeBox] \" + aMsg + \"\\n\");\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"createEditField\">\n        <parameter name=\"aPlaceHolder\"/>\n        <parameter name=\"aIsNumeric\"/>\n        <parameter name=\"aMinDigits\"/>\n        <parameter name=\"aMaxLength\"/>\n        <parameter name=\"aMinValue\"/>\n        <parameter name=\"aMaxValue\"/>\n        <parameter name=\"aPageUpDownInterval\"/>\n        <body>\n        <![CDATA[\n          const HTML_NS = \"http://www.w3.org/1999/xhtml\";\n\n          let field = document.createElementNS(HTML_NS, \"span\");\n          field.classList.add(\"datetime-edit-field\");\n          field.textContent = aPlaceHolder;\n          field.placeholder = aPlaceHolder;\n          field.tabIndex = this.mInputElement.tabIndex;\n\n          field.setAttribute(\"readonly\", this.mInputElement.readOnly);\n          field.setAttribute(\"disabled\", this.mInputElement.disabled);\n          // Set property as well for convenience.\n          field.disabled = this.mInputElement.disabled;\n          field.readOnly = this.mInputElement.readOnly;\n\n          if (aIsNumeric) {\n            field.classList.add(\"numeric\");\n            // Maximum value allowed.\n            field.setAttribute(\"min\", aMinValue);\n            // Minumim value allowed.\n            field.setAttribute(\"max\", aMaxValue);\n            // Interval when pressing pageUp/pageDown key.\n            field.setAttribute(\"pginterval\", aPageUpDownInterval);\n            // Used to store what the user has already typed in the field,\n            // cleared when value is cleared and when field is blurred.\n            field.setAttribute(\"typeBuffer\", \"\");\n            // Used to store the non-formatted number, clered when value is\n            // cleared.\n            field.setAttribute(\"rawValue\", \"\");\n            // Minimum digits to display, padded with leading 0s.\n            field.setAttribute(\"mindigits\", aMinDigits);\n            // Maximum length for the field, will be advance to the next field\n            // automatically if exceeded.\n            field.setAttribute(\"maxlength\", aMaxLength);\n\n            if (this.mIsRTL) {\n              // Force the direction to be \"ltr\", so that the field stays in the\n              // same order even when it's empty (with placeholder). By using\n              // \"embed\", the text inside the element is still displayed based\n              // on its directionality.\n              field.style.unicodeBidi = \"embed\";\n              field.style.direction = \"ltr\";\n            }\n          }\n\n          return field;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"updateResetButtonVisibility\">\n        <body>\n          <![CDATA[\n            if (this.isAnyFieldAvailable(false)) {\n              this.mResetButton.style.visibility = \"visible\";\n            } else {\n              this.mResetButton.style.visibility = \"hidden\";\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"focusInnerTextBox\">\n        <body>\n        <![CDATA[\n          this.log(\"Focus inner editable field.\");\n\n          let editRoot =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n\n          for (let child = editRoot.firstChild; child; child = child.nextSibling) {\n            if ((child instanceof HTMLSpanElement) &&\n                child.classList.contains(\"datetime-edit-field\")) {\n              this.mLastFocusedField = child;\n              child.focus();\n              break;\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"blurInnerTextBox\">\n        <body>\n        <![CDATA[\n          this.log(\"Blur inner editable field.\");\n\n          if (this.mLastFocusedField) {\n            this.mLastFocusedField.blur();\n          } else {\n            // If .mLastFocusedField hasn't been set, blur all editable fields,\n            // so that the bound element will actually be blurred. Note that\n            // blurring on a element that has no focus won't have any effect.\n            let editRoot =\n              document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n            for (let child = editRoot.firstChild; child; child = child.nextSibling) {\n              if ((child instanceof HTMLSpanElement) &&\n                  child.classList.contains(\"datetime-edit-field\")) {\n                child.blur();\n              }\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"notifyInputElementValueChanged\">\n        <body>\n        <![CDATA[\n          this.log(\"inputElementValueChanged\");\n          this.setFieldsFromInputValue();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"notifyMinMaxStepAttrChanged\">\n        <body>\n        <!-- No operation by default -->\n        </body>\n      </method>\n\n      <method name=\"setValueFromPicker\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          this.setFieldsFromPicker(aValue);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"hasBadInput\">\n        <body>\n        <![CDATA[\n          // Incomplete field does not imply bad input.\n          if (this.isAnyFieldEmpty()) {\n            return false;\n          }\n\n          // All fields are available but input element's value is empty implies\n          // it has been sanitized.\n          if (!this.mInputElement.value) {\n            return true;\n          }\n\n          return false;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"advanceToNextField\">\n        <parameter name=\"aReverse\"/>\n        <body>\n        <![CDATA[\n          this.log(\"advanceToNextField\");\n\n          let focusedInput = this.mLastFocusedField;\n          let next = aReverse ? focusedInput.previousElementSibling\n                              : focusedInput.nextElementSibling;\n          if (!next && !aReverse) {\n            this.setInputValueFromFields();\n            return;\n          }\n\n          while (next) {\n            if ((next instanceof HTMLSpanElement) &&\n                next.classList.contains(\"datetime-edit-field\")) {\n              next.focus();\n              break;\n            }\n            next = aReverse ? next.previousElementSibling\n                            : next.nextElementSibling;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setPickerState\">\n        <parameter name=\"aIsOpen\"/>\n        <body>\n        <![CDATA[\n          this.log(\"picker is now \" + (aIsOpen ? \"opened\" : \"closed\"));\n          this.mIsPickerOpen = aIsOpen;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setEditAttribute\">\n        <parameter name=\"aName\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          this.log(\"setAttribute: \" + aName + \"=\" + aValue);\n\n          if (aName != \"tabindex\" && aName != \"disabled\" &&\n              aName != \"readonly\") {\n            return;\n          }\n\n          let editRoot =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n\n          for (let child = editRoot.firstChild; child; child = child.nextSibling) {\n            if ((child instanceof HTMLSpanElement) &&\n                child.classList.contains(\"datetime-edit-field\")) {\n\n              switch (aName) {\n                case \"tabindex\":\n                  child.setAttribute(aName, aValue);\n                  break;\n                case \"disabled\": {\n                  let value = this.mInputElement.disabled;\n                  child.setAttribute(\"disabled\", value);\n                  child.disabled = value;\n                  break;\n                }\n                case \"readonly\": {\n                  let value = this.mInputElement.readOnly;\n                  child.setAttribute(\"readonly\", value);\n                  child.readOnly = value;\n                  break;\n                }\n              }\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"removeEditAttribute\">\n        <parameter name=\"aName\"/>\n        <body>\n        <![CDATA[\n          this.log(\"removeAttribute: \" + aName);\n\n          if (aName != \"tabindex\" && aName != \"disabled\" &&\n              aName != \"readonly\") {\n            return;\n          }\n\n          let editRoot =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n\n          for (let child = editRoot.firstChild; child; child = child.nextSibling) {\n            if ((child instanceof HTMLSpanElement) &&\n                child.classList.contains(\"datetime-edit-field\")) {\n              child.removeAttribute(aName);\n              // Update property as well.\n              if (aName == \"readonly\") {\n                child.readOnly = false;\n              } else if (aName == \"disabled\") {\n                child.disabled = false;\n              }\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isEmpty\">\n        <parameter name=\"aValue\"/>\n        <body>\n          return (aValue == undefined || 0 === aValue.length);\n        </body>\n      </method>\n\n      <method name=\"getFieldValue\">\n        <parameter name=\"aField\"/>\n        <body>\n        <![CDATA[\n          if (!aField || !aField.classList.contains(\"numeric\")) {\n            return undefined;\n          }\n\n          let value = aField.getAttribute(\"rawValue\");\n          // Avoid returning 0 when field is empty.\n          return (this.isEmpty(value) ? undefined : Number(value));\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"clearFieldValue\">\n        <parameter name=\"aField\"/>\n        <body>\n        <![CDATA[\n          aField.textContent = aField.placeholder;\n          if (aField.classList.contains(\"numeric\")) {\n            aField.setAttribute(\"typeBuffer\", \"\");\n            aField.setAttribute(\"rawValue\", \"\");\n          }\n          this.updateResetButtonVisibility();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setFieldValue\">\n        <body>\n          throw Components.results.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"clearInputFields\">\n        <body>\n          throw Components.results.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"setFieldsFromInputValue\">\n        <body>\n          throw Components.results.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"setInputValueFromFields\">\n        <body>\n          throw Components.results.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"setFieldsFromPicker\">\n        <body>\n          throw Components.results.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"handleKeypress\">\n        <body>\n          throw Components.results.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"handleKeyboardNav\">\n        <body>\n          throw Components.results.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"getCurrentValue\">\n        <body>\n          throw Components.results.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"isAnyFieldAvailable\">\n        <body>\n          throw Components.results.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"notifyPicker\">\n        <body>\n        <![CDATA[\n          if (this.mIsPickerOpen && this.isAnyFieldAvailable(true)) {\n            this.mInputElement.updateDateTimePicker(this.getCurrentValue());\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isDisabled\">\n        <body>\n        <![CDATA[\n          return this.mInputElement.hasAttribute(\"disabled\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isReadonly\">\n        <body>\n        <![CDATA[\n          return this.mInputElement.hasAttribute(\"readonly\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          this.log(\"handleEvent: \" + aEvent.type);\n\n          switch (aEvent.type) {\n            case \"keypress\": {\n              this.onKeyPress(aEvent);\n              break;\n            }\n            case \"click\": {\n              this.onClick(aEvent);\n              break;\n            }\n            case \"focus\": {\n              this.onFocus(aEvent);\n              break;\n            }\n            case \"blur\": {\n              this.onBlur(aEvent);\n              break;\n            }\n            case \"mousedown\": {\n              if (aEvent.originalTarget == this.mResetButton) {\n                aEvent.preventDefault();\n              }\n              break;\n            }\n            case \"copy\":\n            case \"cut\":\n            case \"paste\": {\n              aEvent.preventDefault();\n              break;\n            }\n            default:\n              break;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"onFocus\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          this.log(\"onFocus originalTarget: \" + aEvent.originalTarget);\n\n          if (document.activeElement != this.mInputElement) {\n            return;\n          }\n\n          let target = aEvent.originalTarget;\n          if ((target instanceof HTMLSpanElement) &&\n              target.classList.contains(\"datetime-edit-field\")) {\n            if (target.disabled) {\n              return;\n            }\n            this.mLastFocusedField = target;\n            this.mInputElement.setFocusState(true);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"onBlur\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          this.log(\"onBlur originalTarget: \" + aEvent.originalTarget +\n            \" target: \" + aEvent.target);\n\n          let target = aEvent.originalTarget;\n          target.setAttribute(\"typeBuffer\", \"\");\n          this.setInputValueFromFields();\n          this.mInputElement.setFocusState(false);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"onKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          this.log(\"onKeyPress key: \" + aEvent.key);\n\n          switch (aEvent.key) {\n            // Close picker on Enter, Escape or Space key.\n            case \"Enter\":\n            case \"Escape\":\n            case \" \": {\n              if (this.mIsPickerOpen) {\n                this.mInputElement.closeDateTimePicker();\n                aEvent.preventDefault();\n              }\n              break;\n            }\n            case \"Backspace\": {\n              let targetField = aEvent.originalTarget;\n              this.clearFieldValue(targetField);\n              this.setInputValueFromFields();\n              aEvent.preventDefault();\n              break;\n            }\n            case \"ArrowRight\":\n            case \"ArrowLeft\": {\n              this.advanceToNextField(!(aEvent.key == \"ArrowRight\"));\n              aEvent.preventDefault();\n              break;\n            }\n            case \"ArrowUp\":\n            case \"ArrowDown\":\n            case \"PageUp\":\n            case \"PageDown\":\n            case \"Home\":\n            case \"End\": {\n              this.handleKeyboardNav(aEvent);\n              aEvent.preventDefault();\n              break;\n            }\n            default: {\n              // printable characters\n              if (aEvent.keyCode == 0 &&\n                  !(aEvent.ctrlKey || aEvent.altKey || aEvent.metaKey)) {\n                this.handleKeypress(aEvent);\n                aEvent.preventDefault();\n              }\n              break;\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"onClick\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          this.log(\"onClick originalTarget: \" + aEvent.originalTarget +\n                   \" target: \" + aEvent.target);\n\n          if (aEvent.defaultPrevented || this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          if (aEvent.originalTarget == this.mResetButton) {\n            this.clearInputFields(false);\n          } else if (!this.mIsPickerOpen) {\n            this.mInputElement.openDateTimePicker(this.getCurrentValue());\n          }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"datetimepicker.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings [\n  <!ENTITY % datetimepickerDTD SYSTEM \"chrome://global/locale/datetimepicker.dtd\">\n  %datetimepickerDTD;\n]>\n\n<bindings id=\"timepickerBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"datetimepicker-base\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n\n    <resources>\n      <stylesheet src=\"chrome://global/content/textbox.css\"/>\n      <stylesheet src=\"chrome://global/skin/textbox.css\"/>\n      <stylesheet src=\"chrome://global/skin/dropmarker.css\"/>\n      <stylesheet src=\"chrome://global/skin/datetimepicker.css\"/>\n    </resources>\n\n    <content align=\"center\">\n      <xul:hbox class=\"datetimepicker-input-box\" align=\"center\"\n                xbl:inherits=\"context,disabled,readonly\">\n        <xul:hbox class=\"textbox-input-box datetimepicker-input-subbox\" align=\"center\">\n          <html:input class=\"datetimepicker-input textbox-input\" anonid=\"input-one\"\n                      size=\"2\" maxlength=\"2\"\n                      xbl:inherits=\"disabled,readonly\"/>\n        </xul:hbox>\n        <xul:label anonid=\"sep-first\" class=\"datetimepicker-separator\" value=\":\"/>\n        <xul:hbox class=\"textbox-input-box datetimepicker-input-subbox\" align=\"center\">\n          <html:input class=\"datetimepicker-input textbox-input\" anonid=\"input-two\"\n                      size=\"2\" maxlength=\"2\"\n                      xbl:inherits=\"disabled,readonly\"/>\n        </xul:hbox>\n        <xul:label anonid=\"sep-second\" class=\"datetimepicker-separator\" value=\":\"/>\n        <xul:hbox class=\"textbox-input-box datetimepicker-input-subbox\" align=\"center\">\n          <html:input class=\"datetimepicker-input textbox-input\" anonid=\"input-three\"\n                      size=\"2\" maxlength=\"2\"\n                      xbl:inherits=\"disabled,readonly\"/>\n        </xul:hbox>\n        <xul:hbox class=\"textbox-input-box datetimepicker-input-subbox\" align=\"center\">\n          <html:input class=\"datetimepicker-input textbox-input\" anonid=\"input-ampm\"\n                      size=\"2\" maxlength=\"2\"\n                      xbl:inherits=\"disabled,readonly\"/>\n        </xul:hbox>\n      </xul:hbox>\n      <xul:spinbuttons anonid=\"buttons\" xbl:inherits=\"disabled\"\n                       onup=\"this.parentNode._increaseOrDecrease(1);\"\n                       ondown=\"this.parentNode._increaseOrDecrease(-1);\"/>\n    </content>\n\n    <implementation>\n      <field name=\"_dateValue\">null</field>\n      <field name=\"_fieldOne\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"input-one\");\n      </field>\n      <field name=\"_fieldTwo\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"input-two\");\n      </field>\n      <field name=\"_fieldThree\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"input-three\");\n      </field>\n      <field name=\"_fieldAMPM\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"input-ampm\");\n      </field>\n      <field name=\"_separatorFirst\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"sep-first\");\n      </field>\n      <field name=\"_separatorSecond\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"sep-second\");\n      </field>\n      <field name=\"_lastFocusedField\">null</field>\n      <field name=\"_hasEntry\">true</field>\n      <field name=\"_valueEntered\">false</field>\n      <field name=\"attachedControl\">null</field>\n\n      <property name=\"_currentField\" readonly=\"true\">\n        <getter>\n          var focusedInput = document.activeElement;\n          if (focusedInput == this._fieldOne ||\n              focusedInput == this._fieldTwo ||\n              focusedInput == this._fieldThree ||\n              focusedInput == this._fieldAMPM)\n            return focusedInput;\n          return this._lastFocusedField || this._fieldOne;\n        </getter>\n      </property>\n\n      <property name=\"dateValue\" onget=\"return new Date(this._dateValue);\">\n        <setter>\n          <![CDATA[\n            if (!(val instanceof Date))\n              throw \"Invalid Date\";\n\n            this._setValueNoSync(val);\n            if (this.attachedControl)\n              this.attachedControl._setValueNoSync(val);\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"readOnly\" onset=\"if (val) this.setAttribute('readonly', 'true');\n                                       else this.removeAttribute('readonly'); return val;\"\n                                onget=\"return this.getAttribute('readonly') == 'true';\"/>\n\n      <method name=\"_fireEvent\">\n        <parameter name=\"aEventName\"/>\n        <parameter name=\"aTarget\"/>\n        <body>\n          var event = document.createEvent(\"Events\");\n          event.initEvent(aEventName, true, true);\n          return !aTarget.dispatchEvent(event);\n        </body>\n      </method>\n\n      <method name=\"_setValueOnChange\">\n        <parameter name=\"aField\"/>\n        <body>\n          <![CDATA[\n            if (!this._hasEntry)\n              return;\n\n            if (aField == this._fieldOne ||\n                aField == this._fieldTwo ||\n                aField == this._fieldThree) {\n              var value = Number(aField.value);\n              if (isNaN(value))\n                value = 0;\n\n              value = this._constrainValue(aField, value, true);\n              this._setFieldValue(aField, value);\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_init\">\n        <body/>\n      </method>\n\n      <constructor>\n        this._init();\n\n        var cval = this.getAttribute(\"value\");\n        if (cval) {\n          try {\n            this.value = cval;\n            return;\n          } catch (ex) { }\n        }\n        this.dateValue = new Date();\n      </constructor>\n\n      <destructor>\n        if (this.attachedControl) {\n          this.attachedControl.attachedControl = null;\n          this.attachedControl = null;\n        }\n      </destructor>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"focus\" phase=\"capturing\">\n        <![CDATA[\n          var target = event.originalTarget;\n          if (target == this._fieldOne ||\n              target == this._fieldTwo ||\n              target == this._fieldThree ||\n              target == this._fieldAMPM)\n            this._lastFocusedField = target;\n        ]]>\n      </handler>\n\n      <handler event=\"keypress\">\n        <![CDATA[\n          if (this._hasEntry && event.charCode &&\n              this._currentField != this._fieldAMPM &&\n                !(event.altKey || event.ctrlKey || event.metaKey) &&\n              (event.charCode < 48 || event.charCode > 57))\n            event.preventDefault();\n        ]]>\n      </handler>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\">\n        if (this._hasEntry)\n          this._increaseOrDecrease(1);\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\">\n        if (this._hasEntry)\n          this._increaseOrDecrease(-1);\n      </handler>\n\n      <handler event=\"input\">\n        this._valueEntered = true;\n      </handler>\n\n      <handler event=\"change\">\n        this._setValueOnChange(event.originalTarget);\n      </handler>\n    </handlers>\n\n  </binding>\n\n  <binding id=\"timepicker\"\n           extends=\"chrome://global/content/bindings/datetimepicker.xml#datetimepicker-base\">\n\n    <implementation>\n      <field name=\"is24HourClock\">false</field>\n      <field name=\"hourLeadingZero\">false</field>\n      <field name=\"minuteLeadingZero\">true</field>\n      <field name=\"secondLeadingZero\">true</field>\n      <field name=\"amIndicator\">\"AM\"</field>\n      <field name=\"pmIndicator\">\"PM\"</field>\n\n      <field name=\"hourField\">null</field>\n      <field name=\"minuteField\">null</field>\n      <field name=\"secondField\">null</field>\n\n      <property name=\"value\">\n        <getter>\n          <![CDATA[\n            var minute = this._dateValue.getMinutes();\n            if (minute < 10)\n              minute = \"0\" + minute;\n\n            var second = this._dateValue.getSeconds();\n            if (second < 10)\n              second = \"0\" + second;\n            return this._dateValue.getHours() + \":\" + minute + \":\" + second;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            var items = val.match(/^([0-9]{1,2})\\:([0-9]{1,2})\\:?([0-9]{1,2})?$/);\n            if (!items)\n              throw \"Invalid Time\";\n\n            var dt = this.dateValue;\n            dt.setHours(items[1]);\n            dt.setMinutes(items[2]);\n            dt.setSeconds(items[3] ? items[3] : 0);\n            this.dateValue = dt;\n            return val;\n          ]]>\n        </setter>\n      </property>\n      <property name=\"hour\" onget=\"return this._dateValue.getHours();\">\n        <setter>\n          <![CDATA[\n            var valnum = Number(val);\n            if (isNaN(valnum) || valnum < 0 || valnum > 23)\n              throw \"Invalid Hour\";\n            this._setFieldValue(this.hourField, valnum);\n            return val;\n          ]]>\n        </setter>\n      </property>\n      <property name=\"minute\" onget=\"return this._dateValue.getMinutes();\">\n        <setter>\n          <![CDATA[\n            var valnum = Number(val);\n            if (isNaN(valnum) || valnum < 0 || valnum > 59)\n              throw \"Invalid Minute\";\n            this._setFieldValue(this.minuteField, valnum);\n            return val;\n          ]]>\n        </setter>\n      </property>\n      <property name=\"second\" onget=\"return this._dateValue.getSeconds();\">\n        <setter>\n          <![CDATA[\n            var valnum = Number(val);\n            if (isNaN(valnum) || valnum < 0 || valnum > 59)\n              throw \"Invalid Second\";\n            this._setFieldValue(this.secondField, valnum);\n            return val;\n          ]]>\n        </setter>\n      </property>\n      <property name=\"isPM\">\n        <getter>\n          <![CDATA[\n            return (this.hour >= 12);\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            if (val) {\n              if (this.hour < 12)\n                this.hour += 12;\n            } else if (this.hour >= 12)\n              this.hour -= 12;\n            return val;\n          ]]>\n        </setter>\n      </property>\n      <property name=\"hideSeconds\">\n        <getter>\n          return (this.getAttribute(\"hideseconds\") == \"true\");\n        </getter>\n        <setter>\n          if (val)\n            this.setAttribute(\"hideseconds\", \"true\");\n          else\n            this.removeAttribute(\"hideseconds\");\n          if (this.secondField)\n            this.secondField.parentNode.collapsed = val;\n          this._separatorSecond.collapsed = val;\n          return val;\n        </setter>\n      </property>\n      <property name=\"increment\">\n        <getter>\n          <![CDATA[\n            var increment = this.getAttribute(\"increment\");\n            increment = Number(increment);\n            if (isNaN(increment) || increment <= 0 || increment >= 60)\n              return 1;\n            return increment;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            if (typeof val == \"number\")\n              this.setAttribute(\"increment\", val);\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"_setValueNoSync\">\n        <parameter name=\"aValue\"/>\n        <body>\n          <![CDATA[\n            var dt = new Date(aValue);\n            if (!isNaN(dt)) {\n              this._dateValue = dt;\n              this.setAttribute(\"value\", this.value);\n              this._updateUI(this.hourField, this.hour);\n              this._updateUI(this.minuteField, this.minute);\n              this._updateUI(this.secondField, this.second);\n            }\n          ]]>\n        </body>\n      </method>\n      <method name=\"_increaseOrDecrease\">\n        <parameter name=\"aDir\"/>\n        <body>\n          <![CDATA[\n            if (this.disabled || this.readOnly)\n              return;\n\n            var field = this._currentField;\n            if (this._valueEntered)\n              this._setValueOnChange(field);\n\n            if (field == this._fieldAMPM) {\n              this.isPM = !this.isPM;\n              this._fireEvent(\"change\", this);\n            } else {\n              var oldval;\n              var change = aDir;\n              if (field == this.hourField) {\n                oldval = this.hour;\n              } else if (field == this.minuteField) {\n                oldval = this.minute;\n                change *= this.increment;\n              } else if (field == this.secondField) {\n                oldval = this.second;\n              }\n\n              var newval = this._constrainValue(field, oldval + change, false);\n\n              if (field == this.hourField)\n                this.hour = newval;\n              else if (field == this.minuteField)\n                this.minute = newval;\n              else if (field == this.secondField)\n                this.second = newval;\n\n              if (oldval != newval)\n                this._fireEvent(\"change\", this);\n            }\n            field.select();\n          ]]>\n        </body>\n      </method>\n      <method name=\"_setFieldValue\">\n        <parameter name=\"aField\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n          <![CDATA[\n            if (aField == this.hourField)\n              this._dateValue.setHours(aValue);\n            else if (aField == this.minuteField)\n              this._dateValue.setMinutes(aValue);\n            else if (aField == this.secondField)\n              this._dateValue.setSeconds(aValue);\n\n            this.setAttribute(\"value\", this.value);\n            this._updateUI(aField, aValue);\n\n            if (this.attachedControl)\n              this.attachedControl._setValueNoSync(this._dateValue);\n          ]]>\n        </body>\n      </method>\n      <method name=\"_updateUI\">\n        <parameter name=\"aField\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n          <![CDATA[\n            this._valueEntered = false;\n\n            var prependZero = false;\n            if (aField == this.hourField) {\n              prependZero = this.hourLeadingZero;\n              if (!this.is24HourClock) {\n                if (aValue >= 12) {\n                  if (aValue > 12)\n                    aValue -= 12;\n                  this._fieldAMPM.value = this.pmIndicator;\n                } else {\n                  if (aValue == 0)\n                    aValue = 12;\n                  this._fieldAMPM.value = this.amIndicator;\n                }\n              }\n            } else if (aField == this.minuteField) {\n              prependZero = this.minuteLeadingZero;\n            } else if (aField == this.secondField) {\n              prependZero = this.secondLeadingZero;\n            }\n\n            if (prependZero && aValue < 10)\n              aField.value = \"0\" + aValue;\n            else\n              aField.value = aValue;\n          ]]>\n        </body>\n      </method>\n      <method name=\"_constrainValue\">\n        <parameter name=\"aField\"/>\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aNoWrap\"/>\n        <body>\n          <![CDATA[\n            // aNoWrap is true when the user entered a value, so just\n            // constrain within limits. If false, the value is being\n            // incremented or decremented, so wrap around values\n            var max = (aField == this.hourField) ? 24 : 60;\n            if (aValue < 0)\n              return aNoWrap ? 0 : max + aValue;\n            if (aValue >= max)\n              return aNoWrap ? max - 1 : aValue - max;\n            return aValue;\n          ]]>\n        </body>\n      </method>\n      <method name=\"_init\">\n        <body>\n          <![CDATA[\n            this.hourField = this._fieldOne;\n            this.minuteField = this._fieldTwo;\n            this.secondField = this._fieldThree;\n\n            var numberOrder = /^(\\D*)\\s*(\\d+)(\\D*)(\\d+)(\\D*)(\\d+)\\s*(\\D*)$/;\n\n            var locale = Intl.DateTimeFormat().resolvedOptions().locale + \"-u-ca-gregory-nu-latn\";\n\n            var pmTime = new Date(2000, 0, 1, 16, 7, 9).toLocaleTimeString(locale);\n            var numberFields = pmTime.match(numberOrder);\n            if (numberFields) {\n              this._separatorFirst.value = numberFields[3];\n              this._separatorSecond.value = numberFields[5];\n              if (Number(numberFields[2]) > 12)\n                this.is24HourClock = true;\n              else\n                this.pmIndicator = numberFields[1] || numberFields[7];\n            }\n\n            var amTime = new Date(2000, 0, 1, 1, 7, 9).toLocaleTimeString(locale);\n            numberFields = amTime.match(numberOrder);\n            if (numberFields) {\n              this.hourLeadingZero = (numberFields[2].length > 1);\n              this.minuteLeadingZero = (numberFields[4].length > 1);\n              this.secondLeadingZero = (numberFields[6].length > 1);\n\n              if (!this.is24HourClock) {\n                this.amIndicator = numberFields[1] || numberFields[7];\n                if (numberFields[1]) {\n                  var mfield = this._fieldAMPM.parentNode;\n                  var mcontainer = mfield.parentNode;\n                  mcontainer.insertBefore(mfield, mcontainer.firstChild);\n                }\n                var size = (numberFields[1] || numberFields[7]).length;\n                if (this.pmIndicator.length > size)\n                  size = this.pmIndicator.length;\n                this._fieldAMPM.size = size;\n                this._fieldAMPM.maxLength = size;\n              } else {\n                this._fieldAMPM.parentNode.collapsed = true;\n              }\n            }\n\n            this.hideSeconds = this.hideSeconds;\n          ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\">\n        <![CDATA[\n          // just allow any printable character to switch the AM/PM state\n          if (event.charCode && !this.disabled && !this.readOnly &&\n              this._currentField == this._fieldAMPM) {\n            this.isPM = !this.isPM;\n            this._fieldAMPM.select();\n            this._fireEvent(\"change\", this);\n            event.preventDefault();\n          }\n        ]]>\n      </handler>\n    </handlers>\n\n  </binding>\n\n  <binding id=\"datepicker\"\n           extends=\"chrome://global/content/bindings/datetimepicker.xml#datetimepicker-base\">\n\n    <implementation>\n      <field name=\"yearLeadingZero\">false</field>\n      <field name=\"monthLeadingZero\">true</field>\n      <field name=\"dateLeadingZero\">true</field>\n\n      <field name=\"yearField\"/>\n      <field name=\"monthField\"/>\n      <field name=\"dateField\"/>\n\n      <property name=\"value\">\n        <getter>\n          <![CDATA[\n            var month = this._dateValue.getMonth();\n            month = (month < 9) ? month = \"0\" + ++month : month + 1;\n\n            var date = this._dateValue.getDate();\n            if (date < 10)\n              date = \"0\" + date;\n            return this._dateValue.getFullYear() + \"-\" + month + \"-\" + date;\n          ]]>\n\n        </getter>\n        <setter>\n          <![CDATA[\n            var results = val.match(/^([0-9]{1,4})\\-([0-9]{1,2})\\-([0-9]{1,2})$/);\n            if (!results)\n              throw \"Invalid Date\";\n\n            this.dateValue = new Date(results[1] + \"/\" + results[2] + \"/\" + results[3]);\n            this.setAttribute(\"value\", this.value);\n            return val;\n          ]]>\n        </setter>\n      </property>\n      <property name=\"year\" onget=\"return this._dateValue.getFullYear();\">\n        <setter>\n          <![CDATA[\n            var valnum = Number(val);\n            if (isNaN(valnum) || valnum < 1 || valnum > 9999)\n              throw \"Invalid Year\";\n            this._setFieldValue(this.yearField, valnum);\n            return val;\n          ]]>\n        </setter>\n      </property>\n      <property name=\"month\" onget=\"return this._dateValue.getMonth();\">\n        <setter>\n          <![CDATA[\n            var valnum = Number(val);\n            if (isNaN(valnum) || valnum < 0 || valnum > 11)\n              throw \"Invalid Month\";\n            this._setFieldValue(this.monthField, valnum);\n            return val;\n          ]]>\n        </setter>\n      </property>\n      <property name=\"date\" onget=\"return this._dateValue.getDate();\">\n        <setter>\n          <![CDATA[\n            var valnum = Number(val);\n            if (isNaN(valnum) || valnum < 1 || valnum > 31)\n              throw \"Invalid Date\";\n            this._setFieldValue(this.dateField, valnum);\n            return val;\n          ]]>\n        </setter>\n      </property>\n      <property name=\"open\" onget=\"return false;\" onset=\"return val;\"/>\n\n      <property name=\"displayedMonth\" onget=\"return this.month;\"\n                onset=\"this.month = val; return val;\"/>\n      <property name=\"displayedYear\" onget=\"return this.year;\"\n                onset=\"this.year = val; return val;\"/>\n\n      <method name=\"_setValueNoSync\">\n        <parameter name=\"aValue\"/>\n        <body>\n          <![CDATA[\n            var dt = new Date(aValue);\n            if (!isNaN(dt)) {\n              this._dateValue = dt;\n              this.setAttribute(\"value\", this.value);\n              this._updateUI(this.yearField, this.year);\n              this._updateUI(this.monthField, this.month);\n              this._updateUI(this.dateField, this.date);\n            }\n          ]]>\n        </body>\n      </method>\n      <method name=\"_increaseOrDecrease\">\n        <parameter name=\"aDir\"/>\n        <body>\n          <![CDATA[\n            if (this.disabled || this.readOnly)\n              return;\n\n            var field = this._currentField;\n            if (this._valueEntered)\n              this._setValueOnChange(field);\n\n            var oldval;\n            if (field == this.yearField)\n              oldval = this.year;\n            else if (field == this.monthField)\n              oldval = this.month;\n            else if (field == this.dateField)\n              oldval = this.date;\n\n            var newval = this._constrainValue(field, oldval + aDir, false);\n\n            if (field == this.yearField)\n              this.year = newval;\n            else if (field == this.monthField)\n              this.month = newval;\n            else if (field == this.dateField)\n              this.date = newval;\n\n            if (oldval != newval)\n              this._fireEvent(\"change\", this);\n            field.select();\n          ]]>\n        </body>\n      </method>\n      <method name=\"_setFieldValue\">\n        <parameter name=\"aField\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n          <![CDATA[\n            if (aField == this.yearField) {\n              let oldDate = this.date;\n              this._dateValue.setFullYear(aValue);\n              if (oldDate != this.date) {\n                this._dateValue.setDate(0);\n                this._updateUI(this.dateField, this.date);\n              }\n            } else if (aField == this.monthField) {\n              let oldDate = this.date;\n              this._dateValue.setMonth(aValue);\n              if (oldDate != this.date) {\n                this._dateValue.setDate(0);\n                this._updateUI(this.dateField, this.date);\n              }\n            } else if (aField == this.dateField) {\n              this._dateValue.setDate(aValue);\n            }\n\n            this.setAttribute(\"value\", this.value);\n            this._updateUI(aField, aValue);\n\n            if (this.attachedControl)\n              this.attachedControl._setValueNoSync(this._dateValue);\n          ]]>\n        </body>\n      </method>\n      <method name=\"_updateUI\">\n        <parameter name=\"aField\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n          <![CDATA[\n            this._valueEntered = false;\n\n            var prependZero = false;\n            if (aField == this.yearField) {\n              if (this.yearLeadingZero) {\n                aField.value = (\"000\" + aValue).slice(-4);\n                return;\n              }\n            } else if (aField == this.monthField) {\n              aValue++;\n              prependZero = this.monthLeadingZero;\n            } else if (aField == this.dateField) {\n              prependZero = this.dateLeadingZero;\n            }\n            if (prependZero && aValue < 10)\n              aField.value = \"0\" + aValue;\n            else\n              aField.value = aValue;\n          ]]>\n        </body>\n      </method>\n      <method name=\"_constrainValue\">\n        <parameter name=\"aField\"/>\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aNoWrap\"/>\n        <body>\n          <![CDATA[\n            // the month will be 1 to 12 if entered by the user, so subtract 1\n            if (aNoWrap && aField == this.monthField)\n              aValue--;\n\n            if (aField == this.dateField) {\n              if (aValue < 1)\n                return new Date(this.year, this.month + 1, 0).getDate();\n\n              var currentMonth = this.month;\n              var dt = new Date(this.year, currentMonth, aValue);\n              return (dt.getMonth() != currentMonth ? 1 : aValue);\n            }\n            var min = (aField == this.monthField) ? 0 : 1;\n            var max = (aField == this.monthField) ? 11 : 9999;\n            if (aValue < min)\n              return aNoWrap ? min : max;\n            if (aValue > max)\n              return aNoWrap ? max : min;\n            return aValue;\n          ]]>\n        </body>\n      </method>\n      <method name=\"_init\">\n        <body>\n          <![CDATA[\n            // We'll default to YYYY/MM/DD to start.\n            var yfield = \"input-one\";\n            var mfield = \"input-two\";\n            var dfield = \"input-three\";\n            var twoDigitYear = false;\n            this.yearLeadingZero = true;\n            this.monthLeadingZero = true;\n            this.dateLeadingZero = true;\n\n            var numberOrder = /^(\\D*)\\s*(\\d+)(\\D*)(\\d+)(\\D*)(\\d+)\\s*(\\D*)$/;\n\n            var locale = Intl.DateTimeFormat().resolvedOptions().locale + \"-u-ca-gregory-nu-latn\";\n\n            var dt = new Date(2002, 9, 4).toLocaleDateString(locale);\n            var numberFields = dt.match(numberOrder);\n            if (numberFields) {\n              this._separatorFirst.value = numberFields[3];\n              this._separatorSecond.value = numberFields[5];\n\n              var yi = 2, mi = 4, di = 6;\n\n              function fieldForNumber(i) {\n                if (i == 2)\n                  return \"input-one\";\n                if (i == 4)\n                  return \"input-two\";\n                return \"input-three\";\n              }\n\n              for (var i = 1; i < numberFields.length; i++) {\n                switch (Number(numberFields[i])) {\n                  case 2:\n                    twoDigitYear = true; // fall through\n                  case 2002:\n                    yi = i;\n                    yfield = fieldForNumber(i);\n                    break;\n                  case 9, 10:\n                    mi = i;\n                    mfield = fieldForNumber(i);\n                    break;\n                  case 4:\n                    di = i;\n                    dfield = fieldForNumber(i);\n                    break;\n                }\n              }\n\n              this.yearLeadingZero = (numberFields[yi].length > 1);\n              this.monthLeadingZero = (numberFields[mi].length > 1);\n              this.dateLeadingZero = (numberFields[di].length > 1);\n            }\n\n            this.yearField = document.getAnonymousElementByAttribute(this, \"anonid\", yfield);\n            if (!twoDigitYear)\n              this.yearField.parentNode.classList.add(\"datetimepicker-input-subbox\", \"datetimepicker-year\");\n            this.monthField = document.getAnonymousElementByAttribute(this, \"anonid\", mfield);\n            this.dateField = document.getAnonymousElementByAttribute(this, \"anonid\", dfield);\n\n            this._fieldAMPM.parentNode.collapsed = true;\n            this.yearField.size = twoDigitYear ? 2 : 4;\n            this.yearField.maxLength = twoDigitYear ? 2 : 4;\n          ]]>\n        </body>\n      </method>\n    </implementation>\n\n  </binding>\n\n  <binding id=\"datepicker-grid\"\n           extends=\"chrome://global/content/bindings/datetimepicker.xml#datepicker\">\n\n    <content>\n      <vbox class=\"datepicker-mainbox\"\n            xmlns=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n        <hbox class=\"datepicker-monthbox\" align=\"center\">\n          <button class=\"datepicker-previous datepicker-button\" type=\"repeat\"\n                  xbl:inherits=\"disabled\"\n                  oncommand=\"document.getBindingParent(this)._increaseOrDecreaseMonth(-1);\"/>\n          <spacer flex=\"1\"/>\n          <deck anonid=\"monthlabeldeck\">\n            <label class=\"datepicker-gridlabel\" value=\"\"/>\n            <label class=\"datepicker-gridlabel\" value=\"\"/>\n            <label class=\"datepicker-gridlabel\" value=\"\"/>\n            <label class=\"datepicker-gridlabel\" value=\"\"/>\n            <label class=\"datepicker-gridlabel\" value=\"\"/>\n            <label class=\"datepicker-gridlabel\" value=\"\"/>\n            <label class=\"datepicker-gridlabel\" value=\"\"/>\n            <label class=\"datepicker-gridlabel\" value=\"\"/>\n            <label class=\"datepicker-gridlabel\" value=\"\"/>\n            <label class=\"datepicker-gridlabel\" value=\"\"/>\n            <label class=\"datepicker-gridlabel\" value=\"\"/>\n            <label class=\"datepicker-gridlabel\" value=\"\"/>\n          </deck>\n          <label anonid=\"yearlabel\" class=\"datepicker-gridlabel\"/>\n          <spacer flex=\"1\"/>\n          <button class=\"datepicker-next datepicker-button\" type=\"repeat\"\n                  xbl:inherits=\"disabled\"\n                  oncommand=\"document.getBindingParent(this)._increaseOrDecreaseMonth(1);\"/>\n        </hbox>\n        <grid class=\"datepicker-grid\" role=\"grid\">\n          <columns>\n            <column class=\"datepicker-gridrow\" flex=\"1\"/>\n            <column class=\"datepicker-gridrow\" flex=\"1\"/>\n            <column class=\"datepicker-gridrow\" flex=\"1\"/>\n            <column class=\"datepicker-gridrow\" flex=\"1\"/>\n            <column class=\"datepicker-gridrow\" flex=\"1\"/>\n            <column class=\"datepicker-gridrow\" flex=\"1\"/>\n            <column class=\"datepicker-gridrow\" flex=\"1\"/>\n          </columns>\n          <rows anonid=\"datebox\">\n            <row anonid=\"dayofweekbox\">\n              <label class=\"datepicker-weeklabel\" role=\"columnheader\"/>\n              <label class=\"datepicker-weeklabel\" role=\"columnheader\"/>\n              <label class=\"datepicker-weeklabel\" role=\"columnheader\"/>\n              <label class=\"datepicker-weeklabel\" role=\"columnheader\"/>\n              <label class=\"datepicker-weeklabel\" role=\"columnheader\"/>\n              <label class=\"datepicker-weeklabel\" role=\"columnheader\"/>\n              <label class=\"datepicker-weeklabel\" role=\"columnheader\"/>\n            </row>\n            <row>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n            </row>\n            <row>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n            </row>\n            <row>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n            </row>\n            <row>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n            </row>\n            <row>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n            </row>\n            <row>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n              <label class=\"datepicker-gridlabel\" role=\"gridcell\"/>\n            </row>\n          </rows>\n        </grid>\n      </vbox>\n    </content>\n\n    <implementation>\n      <field name=\"_hasEntry\">false</field>\n      <field name=\"_weekStart\">FROM-DTD-firstdayofweek-default</field>\n      <field name=\"_displayedDate\">null</field>\n      <field name=\"_todayItem\">null</field>\n\n      <field name=\"yearField\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"yearlabel\");\n      </field>\n      <field name=\"monthField\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"monthlabeldeck\");\n      </field>\n      <field name=\"dateField\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"datebox\");\n      </field>\n\n      <field name=\"_selectedItem\">null</field>\n\n      <property name=\"selectedItem\" onget=\"return this._selectedItem\">\n        <setter>\n          <![CDATA[\n            if (!val.value)\n              return val;\n            if (val.parentNode.parentNode != this.dateField)\n              return val;\n\n            if (this._selectedItem)\n              this._selectedItem.removeAttribute(\"selected\");\n            this._selectedItem = val;\n            val.setAttribute(\"selected\", \"true\");\n            this._displayedDate.setDate(val.value);\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"displayedMonth\">\n        <getter>\n          return this._displayedDate.getMonth();\n        </getter>\n        <setter>\n          this._updateUI(this.monthField, val, true);\n          return val;\n        </setter>\n      </property>\n      <property name=\"displayedYear\">\n        <getter>\n          return this._displayedDate.getFullYear();\n        </getter>\n        <setter>\n          this._updateUI(this.yearField, val, true);\n          return val;\n        </setter>\n      </property>\n\n      <method name=\"_init\">\n        <body>\n          <![CDATA[\n            var locale = Intl.DateTimeFormat().resolvedOptions().locale + \"-u-ca-gregory\";\n            var dtfMonth = Intl.DateTimeFormat(locale, {month: \"long\", timeZone: \"UTC\"});\n            var dtfWeekday = Intl.DateTimeFormat(locale, {weekday: \"narrow\"});\n\n            var monthLabel = this.monthField.firstChild;\n            var tempDate = new Date(Date.UTC(2005, 0, 1));\n            for (var month = 0; month < 12; month++) {\n              tempDate.setUTCMonth(month);\n              monthLabel.setAttribute(\"value\", dtfMonth.format(tempDate));\n              monthLabel = monthLabel.nextSibling;\n            }\n\n            var fdow = Number(this.getAttribute(\"firstdayofweek\"));\n            if (!isNaN(fdow) && fdow >= 0 && fdow <= 6)\n              this._weekStart = fdow;\n\n            var weekbox = document.getAnonymousElementByAttribute(this, \"anonid\", \"dayofweekbox\").childNodes;\n            var date = new Date();\n            date.setDate(date.getDate() - (date.getDay() - this._weekStart));\n            for (var i = 0; i < weekbox.length; i++) {\n              weekbox[i].value = dtfWeekday.format(date);\n              date.setDate(date.getDate() + 1);\n            }\n          ]]>\n        </body>\n      </method>\n      <method name=\"_setValueNoSync\">\n        <parameter name=\"aValue\"/>\n        <body>\n          <![CDATA[\n            var dt = new Date(aValue);\n            if (!isNaN(dt)) {\n              this._dateValue = dt;\n              this.setAttribute(\"value\", this.value);\n              this._updateUI();\n            }\n          ]]>\n        </body>\n      </method>\n      <method name=\"_updateUI\">\n        <parameter name=\"aField\"/>\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aCheckMonth\"/>\n        <body>\n          <![CDATA[\n            var date;\n            var currentMonth;\n            if (aCheckMonth) {\n              if (!this._displayedDate)\n                this._displayedDate = this.dateValue;\n\n              var expectedMonth = aValue;\n              if (aField == this.monthField) {\n                this._displayedDate.setMonth(aValue);\n              } else {\n                expectedMonth = this._displayedDate.getMonth();\n                this._displayedDate.setFullYear(aValue);\n              }\n\n              if (expectedMonth != -1 && expectedMonth != 12 &&\n                  expectedMonth != this._displayedDate.getMonth()) {\n                // If the month isn't what was expected, then the month overflowed.\n                // Setting the date to 0 will go back to the last day of the right month.\n                this._displayedDate.setDate(0);\n              }\n\n              date = new Date(this._displayedDate);\n              currentMonth = this._displayedDate.getMonth();\n            } else {\n              var samemonth = (this._displayedDate &&\n                               this._displayedDate.getMonth() == this.month &&\n                               this._displayedDate.getFullYear() == this.year);\n              if (samemonth) {\n                var items = this.dateField.getElementsByAttribute(\"value\", this.date);\n                if (items.length)\n                  this.selectedItem = items[0];\n                return;\n              }\n\n              date = this.dateValue;\n              this._displayedDate = new Date(date);\n              currentMonth = this.month;\n            }\n\n            if (this._todayItem) {\n              this._todayItem.removeAttribute(\"today\");\n              this._todayItem = null;\n            }\n\n            if (this._selectedItem) {\n              this._selectedItem.removeAttribute(\"selected\");\n              this._selectedItem = null;\n            }\n\n            // Update the month and year title\n            this.monthField.selectedIndex = currentMonth;\n            this.yearField.setAttribute(\"value\", date.getFullYear());\n\n            date.setDate(1);\n            var firstWeekday = (7 + date.getDay() - this._weekStart) % 7;\n            date.setDate(date.getDate() - firstWeekday);\n\n            var today = new Date();\n            var datebox = this.dateField;\n            for (var k = 1; k < datebox.childNodes.length; k++) {\n              var row = datebox.childNodes[k];\n              for (var i = 0; i < 7; i++) {\n                var item = row.childNodes[i];\n\n                if (currentMonth == date.getMonth()) {\n                  item.value = date.getDate();\n\n                  // highlight today\n                  if (this._isSameDay(today, date)) {\n                    this._todayItem = item;\n                    item.setAttribute(\"today\", \"true\");\n                  }\n\n                  // highlight the selected date\n                  if (this._isSameDay(this._dateValue, date)) {\n                    this._selectedItem = item;\n                    item.setAttribute(\"selected\", \"true\");\n                  }\n                } else {\n                  item.value = \"\";\n                }\n\n                date.setDate(date.getDate() + 1);\n              }\n            }\n\n            this._fireEvent(\"monthchange\", this);\n          ]]>\n        </body>\n      </method>\n      <method name=\"_increaseOrDecreaseDateFromEvent\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aDiff\"/>\n        <body>\n          <![CDATA[\n            if (aEvent.originalTarget == this && !this.disabled && !this.readOnly) {\n              var newdate = this.dateValue;\n              newdate.setDate(newdate.getDate() + aDiff);\n              this.dateValue = newdate;\n              this._fireEvent(\"change\", this);\n            }\n            aEvent.stopPropagation();\n            aEvent.preventDefault();\n          ]]>\n        </body>\n      </method>\n      <method name=\"_increaseOrDecreaseMonth\">\n        <parameter name=\"aDir\"/>\n        <body>\n          <![CDATA[\n            if (!this.disabled) {\n              var month = this._displayedDate ? this._displayedDate.getMonth() :\n                                                this.month;\n              this._updateUI(this.monthField, month + aDir, true);\n            }\n          ]]>\n        </body>\n      </method>\n      <method name=\"_isSameDay\">\n        <parameter name=\"aDate1\"/>\n        <parameter name=\"aDate2\"/>\n        <body>\n          <![CDATA[\n            return (aDate1 && aDate2 &&\n                    aDate1.getDate() == aDate2.getDate() &&\n                    aDate1.getMonth() == aDate2.getMonth() &&\n                    aDate1.getFullYear() == aDate2.getFullYear());\n          ]]>\n        </body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"click\">\n        <![CDATA[\n          if (event.button != 0 || this.disabled || this.readOnly)\n            return;\n\n          var target = event.originalTarget;\n          if (target.classList.contains(\"datepicker-gridlabel\") &&\n              target != this.selectedItem) {\n            this.selectedItem = target;\n            this._dateValue = new Date(this._displayedDate);\n            if (this.attachedControl)\n              this.attachedControl._setValueNoSync(this._dateValue);\n            this._fireEvent(\"change\", this);\n\n            if (this.attachedControl && \"open\" in this.attachedControl)\n              this.attachedControl.open = false; // close the popup\n          }\n        ]]>\n      </handler>\n      <handler event=\"MozMousePixelScroll\" preventdefault=\"true\"/>\n      <handler event=\"DOMMouseScroll\" preventdefault=\"true\">\n        <![CDATA[\n          this._increaseOrDecreaseMonth(event.detail < 0 ? -1 : 1);\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\"\n               action=\"this._increaseOrDecreaseDateFromEvent(event, -1);\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\"\n               action=\"this._increaseOrDecreaseDateFromEvent(event, 1);\"/>\n      <handler event=\"keypress\" keycode=\"VK_UP\"\n               action=\"this._increaseOrDecreaseDateFromEvent(event, -7);\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\"\n               action=\"this._increaseOrDecreaseDateFromEvent(event, 7);\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" preventdefault=\"true\"\n               action=\"this._increaseOrDecreaseMonth(-1);\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" preventdefault=\"true\"\n               action=\"this._increaseOrDecreaseMonth(1);\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"datepicker-popup\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/datetimepicker.xml#datepicker\">\n    <content align=\"center\">\n      <xul:hbox class=\"textbox-input-box datetimepicker-input-box\" align=\"center\"\n                allowevents=\"true\" xbl:inherits=\"context,disabled,readonly\">\n        <xul:hbox class=\"datetimepicker-input-subbox\" align=\"baseline\">\n          <html:input class=\"datetimepicker-input textbox-input\" anonid=\"input-one\"\n                      size=\"2\" maxlength=\"2\"\n                      xbl:inherits=\"disabled,readonly\"/>\n        </xul:hbox>\n        <xul:label anonid=\"sep-first\" class=\"datetimepicker-separator\" value=\":\"/>\n        <xul:hbox class=\"datetimepicker-input-subbox\" align=\"baseline\">\n          <html:input class=\"datetimepicker-input textbox-input\" anonid=\"input-two\"\n                      size=\"2\" maxlength=\"2\"\n                      xbl:inherits=\"disabled,readonly\"/>\n        </xul:hbox>\n        <xul:label anonid=\"sep-second\" class=\"datetimepicker-separator\" value=\":\"/>\n        <xul:hbox class=\"datetimepicker-input-subbox\" align=\"center\">\n          <html:input class=\"datetimepicker-input textbox-input\" anonid=\"input-three\"\n                      size=\"2\" maxlength=\"2\"\n                      xbl:inherits=\"disabled,readonly\"/>\n        </xul:hbox>\n        <xul:hbox class=\"datetimepicker-input-subbox\" align=\"center\">\n          <html:input class=\"datetimepicker-input textbox-input\" anonid=\"input-ampm\"\n                      size=\"2\" maxlength=\"2\"\n                      xbl:inherits=\"disabled,readonly\"/>\n        </xul:hbox>\n      </xul:hbox>\n      <xul:spinbuttons anonid=\"buttons\" xbl:inherits=\"disabled\" allowevents=\"true\"\n                       onup=\"this.parentNode._increaseOrDecrease(1);\"\n                       ondown=\"this.parentNode._increaseOrDecrease(-1);\"/>\n      <xul:dropmarker class=\"datepicker-dropmarker\" xbl:inherits=\"disabled\"/>\n      <xul:panel onpopupshown=\"this.firstChild.focus();\" level=\"top\">\n        <xul:datepicker anonid=\"grid\" type=\"grid\" class=\"datepicker-popupgrid\"\n                        xbl:inherits=\"disabled,readonly,firstdayofweek\"/>\n      </xul:panel>\n    </content>\n    <implementation>\n      <constructor>\n        var grid = document.getAnonymousElementByAttribute(this, \"anonid\", \"grid\");\n        this.attachedControl = grid;\n        grid.attachedControl = this;\n        grid._setValueNoSync(this._dateValue);\n      </constructor>\n      <property name=\"open\" onget=\"return this.hasAttribute('open');\">\n        <setter>\n          <![CDATA[\n            if (this.boxObject instanceof MenuBoxObject)\n              this.boxObject.openMenu(val);\n            return val;\n          ]]>\n        </setter>\n      </property>\n      <property name=\"displayedMonth\">\n        <getter>\n          return document.getAnonymousElementByAttribute(this, \"anonid\", \"grid\").displayedMonth;\n        </getter>\n        <setter>\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"grid\").displayedMonth = val;\n          return val;\n        </setter>\n      </property>\n      <property name=\"displayedYear\">\n        <getter>\n          return document.getAnonymousElementByAttribute(this, \"anonid\", \"grid\").displayedYear;\n        </getter>\n        <setter>\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"grid\").displayedYear = val;\n          return val;\n        </setter>\n      </property>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"datetimepopup.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"dateTimePopupBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n  <binding id=\"datetime-popup\"\n           extends=\"chrome://global/content/bindings/popup.xml#arrowpanel\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/datetimepopup.css\"/>\n    </resources>\n    <implementation>\n      <property name=\"dateTimePopupFrame\">\n        <getter>\n          let frame = this.querySelector(\"#dateTimePopupFrame\");\n          if (!frame) {\n            frame = this.ownerDocument.createElement(\"iframe\");\n            frame.id = \"dateTimePopupFrame\";\n            this.appendChild(frame);\n          }\n          return frame;\n        </getter>\n      </property>\n      <field name=\"TIME_PICKER_WIDTH\" readonly=\"true\">\"12em\"</field>\n      <field name=\"TIME_PICKER_HEIGHT\" readonly=\"true\">\"21em\"</field>\n      <field name=\"DATE_PICKER_WIDTH\" readonly=\"true\">\"23.1em\"</field>\n      <field name=\"DATE_PICKER_HEIGHT\" readonly=\"true\">\"20.7em\"</field>\n      <constructor><![CDATA[\n        this.mozIntl = Components.classes[\"@mozilla.org/mozintl;1\"]\n                                 .getService(Components.interfaces.mozIMozIntl);\n        // Notify DateTimePickerHelper.jsm that binding is ready.\n        this.dispatchEvent(new CustomEvent(\"DateTimePickerBindingReady\"));\n      ]]></constructor>\n      <method name=\"openPicker\">\n        <parameter name=\"type\"/>\n        <parameter name=\"anchor\"/>\n        <parameter name=\"detail\"/>\n        <body><![CDATA[\n          this.type = type;\n          this.pickerState = {};\n          // TODO: Resize picker according to content zoom level\n          this.style.fontSize = \"10px\";\n          switch (type) {\n            case \"time\": {\n              this.detail = detail;\n              this.dateTimePopupFrame.addEventListener(\"load\", this, true);\n              this.dateTimePopupFrame.setAttribute(\"src\", \"chrome://global/content/timepicker.xhtml\");\n              this.dateTimePopupFrame.style.width = this.TIME_PICKER_WIDTH;\n              this.dateTimePopupFrame.style.height = this.TIME_PICKER_HEIGHT;\n              break;\n            }\n            case \"date\": {\n              this.detail = detail;\n              this.dateTimePopupFrame.addEventListener(\"load\", this, true);\n              this.dateTimePopupFrame.setAttribute(\"src\", \"chrome://global/content/datepicker.xhtml\");\n              this.dateTimePopupFrame.style.width = this.DATE_PICKER_WIDTH;\n              this.dateTimePopupFrame.style.height = this.DATE_PICKER_HEIGHT;\n              break;\n            }\n          }\n          this.hidden = false;\n          this.openPopup(anchor, \"after_start\", 0, 0);\n        ]]></body>\n      </method>\n      <method name=\"closePicker\">\n        <body><![CDATA[\n          this.setInputBoxValue(true);\n          this.pickerState = {};\n          this.type = undefined;\n          this.dateTimePopupFrame.removeEventListener(\"load\", this, true);\n          this.dateTimePopupFrame.contentDocument.removeEventListener(\"message\", this);\n          this.dateTimePopupFrame.setAttribute(\"src\", \"\");\n          this.hidden = true;\n        ]]></body>\n      </method>\n      <method name=\"setPopupValue\">\n        <parameter name=\"data\"/>\n        <body><![CDATA[\n          switch (this.type) {\n            case \"time\": {\n              this.postMessageToPicker({\n                name: \"PickerSetValue\",\n                detail: data.value\n              });\n              break;\n            }\n            case \"date\": {\n              const { year, month, day } = data.value;\n              this.postMessageToPicker({\n                name: \"PickerSetValue\",\n                detail: {\n                  year,\n                  // Month value from input box starts from 1 instead of 0\n                  month: month == undefined ? undefined : month - 1,\n                  day\n                }\n              });\n              break;\n            }\n          }\n        ]]></body>\n      </method>\n      <method name=\"initPicker\">\n        <parameter name=\"detail\"/>\n        <body><![CDATA[\n          // TODO: When bug 1376616 lands, replace this.setGregorian with\n          //       mozIntl.Locale for setting calendar to Gregorian\n          const locale = this.setGregorian(Services.locale.getAppLocaleAsBCP47());\n          const dir = this.mozIntl.getLocaleInfo(locale).direction;\n\n          switch (this.type) {\n            case \"time\": {\n              const { hour, minute } = detail.value;\n              const format = detail.format || \"12\";\n\n              this.postMessageToPicker({\n                name: \"PickerInit\",\n                detail: {\n                  hour,\n                  minute,\n                  format,\n                  locale,\n                  min: detail.min,\n                  max: detail.max,\n                  step: detail.step,\n                }\n              });\n              break;\n            }\n            case \"date\": {\n              const { year, month, day } = detail.value;\n              const { firstDayOfWeek, weekends } =\n                this.getCalendarInfo(locale);\n              const monthStrings = this.getDisplayNames(\n                locale, [\n                  \"dates/gregorian/months/january\",\n                  \"dates/gregorian/months/february\",\n                  \"dates/gregorian/months/march\",\n                  \"dates/gregorian/months/april\",\n                  \"dates/gregorian/months/may\",\n                  \"dates/gregorian/months/june\",\n                  \"dates/gregorian/months/july\",\n                  \"dates/gregorian/months/august\",\n                  \"dates/gregorian/months/september\",\n                  \"dates/gregorian/months/october\",\n                  \"dates/gregorian/months/november\",\n                  \"dates/gregorian/months/december\",\n                ], \"short\");\n              const weekdayStrings = this.getDisplayNames(\n                locale, [\n                  \"dates/gregorian/weekdays/sunday\",\n                  \"dates/gregorian/weekdays/monday\",\n                  \"dates/gregorian/weekdays/tuesday\",\n                  \"dates/gregorian/weekdays/wednesday\",\n                  \"dates/gregorian/weekdays/thursday\",\n                  \"dates/gregorian/weekdays/friday\",\n                  \"dates/gregorian/weekdays/saturday\",\n                ], \"short\");\n\n              this.postMessageToPicker({\n                name: \"PickerInit\",\n                detail: {\n                  year,\n                  // Month value from input box starts from 1 instead of 0\n                  month: month == undefined ? undefined : month - 1,\n                  day,\n                  firstDayOfWeek,\n                  weekends,\n                  monthStrings,\n                  weekdayStrings,\n                  locale,\n                  dir,\n                  min: detail.min,\n                  max: detail.max,\n                  step: detail.step,\n                  stepBase: detail.stepBase,\n                }\n              });\n              break;\n            }\n          }\n        ]]></body>\n      </method>\n      <method name=\"setInputBoxValue\">\n        <parameter name=\"passAllValues\"/>\n        <body><![CDATA[\n          /**\n           * @param {Boolean} passAllValues: Pass spinner values regardless if they've been set/changed or not\n           */\n          switch (this.type) {\n            case \"time\": {\n              const { hour, minute, isHourSet, isMinuteSet, isDayPeriodSet } = this.pickerState;\n              const isAnyValueSet = isHourSet || isMinuteSet || isDayPeriodSet;\n              if (passAllValues && isAnyValueSet) {\n                this.sendPickerValueChanged({ hour, minute });\n              } else {\n                this.sendPickerValueChanged({\n                  hour: isHourSet || isDayPeriodSet ? hour : undefined,\n                  minute: isMinuteSet ? minute : undefined\n                });\n              }\n              break;\n            }\n            case \"date\": {\n              this.sendPickerValueChanged(this.pickerState);\n              break;\n            }\n          }\n        ]]></body>\n      </method>\n      <method name=\"sendPickerValueChanged\">\n        <parameter name=\"value\"/>\n        <body><![CDATA[\n          switch (this.type) {\n            case \"time\": {\n              this.dispatchEvent(new CustomEvent(\"DateTimePickerValueChanged\", {\n                detail: {\n                  hour: value.hour,\n                  minute: value.minute\n                }\n              }));\n              break;\n            }\n            case \"date\": {\n              this.dispatchEvent(new CustomEvent(\"DateTimePickerValueChanged\", {\n                detail: {\n                  year: value.year,\n                  // Month value from input box starts from 1 instead of 0\n                  month: value.month == undefined ? undefined : value.month + 1,\n                  day: value.day\n                }\n              }));\n              break;\n            }\n          }\n        ]]></body>\n      </method>\n      <method name=\"getCalendarInfo\">\n        <parameter name=\"locale\"/>\n        <body><![CDATA[\n          const calendarInfo = this.mozIntl.getCalendarInfo(locale);\n\n          // Day of week from calendarInfo starts from 1 as Sunday to 7 as Saturday,\n          // so they need to be mapped to JavaScript convention with 0 as Sunday\n          // and 6 as Saturday\n          let firstDayOfWeek = calendarInfo.firstDayOfWeek - 1,\n              weekendStart = calendarInfo.weekendStart - 1,\n              weekendEnd = calendarInfo.weekendEnd - 1;\n\n          let weekends = [];\n\n          // Make sure weekendEnd is greater than weekendStart\n          if (weekendEnd < weekendStart) {\n            weekendEnd += 7;\n          }\n\n          // We get the weekends by incrementing weekendStart up to weekendEnd.\n          // If the start and end is the same day, then weekends only has one day.\n          for (let day = weekendStart; day <= weekendEnd; day++) {\n            weekends.push(day % 7);\n          }\n\n          return {\n            firstDayOfWeek,\n            weekends\n          }\n        ]]></body>\n      </method>\n      <method name=\"getDisplayNames\">\n        <parameter name=\"locale\"/>\n        <parameter name=\"keys\"/>\n        <parameter name=\"style\"/>\n        <body><![CDATA[\n          const displayNames = this.mozIntl.getDisplayNames(locale, {keys, style});\n          return keys.map(key => displayNames.values[key]);\n        ]]></body>\n      </method>\n      <method name=\"setGregorian\">\n        <parameter name=\"locale\"/>\n        <body><![CDATA[\n          if (locale.match(/u-ca-/)) {\n            return locale.replace(/u-ca-[^-]+/, \"u-ca-gregory\");\n          }\n          return locale + \"-u-ca-gregory\";\n        ]]></body>\n      </method>\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.type) {\n            case \"load\": {\n              this.initPicker(this.detail);\n              this.dateTimePopupFrame.contentWindow.addEventListener(\"message\", this);\n              break;\n            }\n            case \"message\": {\n              this.handleMessage(aEvent);\n              break;\n            }\n          }\n        ]]></body>\n      </method>\n      <method name=\"handleMessage\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this.dateTimePopupFrame.contentDocument.nodePrincipal.isSystemPrincipal) {\n            return;\n          }\n\n          switch (aEvent.data.name) {\n            case \"PickerPopupChanged\": {\n              this.pickerState = aEvent.data.detail;\n              this.setInputBoxValue();\n              break;\n            }\n            case \"ClosePopup\": {\n              this.hidePopup();\n              this.closePicker();\n              break;\n            }\n          }\n        ]]></body>\n      </method>\n      <method name=\"postMessageToPicker\">\n        <parameter name=\"data\"/>\n        <body><![CDATA[\n          if (this.dateTimePopupFrame.contentDocument.nodePrincipal.isSystemPrincipal) {\n            this.dateTimePopupFrame.contentWindow.postMessage(data, \"*\");\n          }\n        ]]></body>\n      </method>\n\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"dialog.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"dialogBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"dialog\" extends=\"chrome://global/content/bindings/general.xml#root-element\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/dialog.css\"/>\n    </resources>\n    <content>\n      <xul:vbox class=\"box-inherit dialog-content-box\" flex=\"1\">\n        <children/>\n      </xul:vbox>\n\n      <xul:hbox class=\"dialog-button-box\" anonid=\"buttons\"\n                xbl:inherits=\"pack=buttonpack,align=buttonalign,dir=buttondir,orient=buttonorient\"\n\n                pack=\"end\">\n        <xul:button dlgtype=\"extra2\" class=\"dialog-button\" hidden=\"true\"/>\n        <xul:spacer anonid=\"spacer\" flex=\"1\" hidden=\"true\"/>\n        <xul:button dlgtype=\"accept\" class=\"dialog-button\" xbl:inherits=\"disabled=buttondisabledaccept\"/>\n        <xul:button dlgtype=\"extra1\" class=\"dialog-button\" hidden=\"true\"/>\n        <xul:button dlgtype=\"cancel\" class=\"dialog-button\"/>\n        <xul:button dlgtype=\"help\" class=\"dialog-button\" hidden=\"true\"/>\n        <xul:button dlgtype=\"disclosure\" class=\"dialog-button\" hidden=\"true\"/>\n\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <field name=\"_mStrBundle\">null</field>\n      <field name=\"_closeHandler\">(function(event) {\n        if (!document.documentElement.cancelDialog())\n          event.preventDefault();\n      })</field>\n\n      <property name=\"buttons\"\n                onget=\"return this.getAttribute('buttons');\"\n                onset=\"this._configureButtons(val); return val;\"/>\n\n      <property name=\"defaultButton\">\n        <getter>\n        <![CDATA[\n          if (this.hasAttribute(\"defaultButton\"))\n            return this.getAttribute(\"defaultButton\");\n          return \"accept\";  // default to the accept button\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          this._setDefaultButton(val);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"acceptDialog\">\n        <body>\n        <![CDATA[\n          return this._doButtonCommand(\"accept\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"cancelDialog\">\n        <body>\n        <![CDATA[\n          return this._doButtonCommand(\"cancel\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getButton\">\n        <parameter name=\"aDlgType\"/>\n        <body>\n        <![CDATA[\n          return this._buttons[aDlgType];\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"moveToAlertPosition\">\n        <body>\n        <![CDATA[\n          // hack. we need this so the window has something like its final size\n          if (window.outerWidth == 1) {\n            dump(\"Trying to position a sizeless window; caller should have called sizeToContent() or sizeTo(). See bug 75649.\\n\");\n            sizeToContent();\n          }\n\n          if (opener) {\n            var xOffset = (opener.outerWidth - window.outerWidth) / 2;\n            var yOffset = opener.outerHeight / 5;\n\n            var newX = opener.screenX + xOffset;\n            var newY = opener.screenY + yOffset;\n          } else {\n            newX = (screen.availWidth - window.outerWidth) / 2;\n            newY = (screen.availHeight - window.outerHeight) / 2;\n          }\n\n          // ensure the window is fully onscreen (if smaller than the screen)\n          if (newX < screen.availLeft)\n            newX = screen.availLeft + 20;\n          if ((newX + window.outerWidth) > (screen.availLeft + screen.availWidth))\n            newX = (screen.availLeft + screen.availWidth) - window.outerWidth - 20;\n\n          if (newY < screen.availTop)\n            newY = screen.availTop + 20;\n          if ((newY + window.outerHeight) > (screen.availTop + screen.availHeight))\n            newY = (screen.availTop + screen.availHeight) - window.outerHeight - 60;\n\n          window.moveTo( newX, newY );\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"centerWindowOnScreen\">\n        <body>\n        <![CDATA[\n          var xOffset = screen.availWidth / 2 - window.outerWidth / 2;\n          var yOffset = screen.availHeight / 2 - window.outerHeight / 2;\n\n          xOffset = xOffset > 0 ? xOffset : 0;\n          yOffset = yOffset > 0 ? yOffset : 0;\n          window.moveTo(xOffset, yOffset);\n        ]]>\n        </body>\n      </method>\n\n      <constructor>\n      <![CDATA[\n        this._configureButtons(this.buttons);\n\n        // listen for when window is closed via native close buttons\n        window.addEventListener(\"close\", this._closeHandler);\n\n        // for things that we need to initialize after onload fires\n        window.addEventListener(\"load\", this.postLoadInit);\n\n        window.moveToAlertPosition = this.moveToAlertPosition;\n        window.centerWindowOnScreen = this.centerWindowOnScreen;\n      ]]>\n      </constructor>\n\n      <method name=\"postLoadInit\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          function focusInit() {\n            const dialog = document.documentElement;\n            const defaultButton = dialog.getButton(dialog.defaultButton);\n            // give focus to the first focusable element in the dialog\n            if (!document.commandDispatcher.focusedElement) {\n              document.commandDispatcher.advanceFocusIntoSubtree(dialog);\n\n              var focusedElt = document.commandDispatcher.focusedElement;\n              if (focusedElt) {\n                var initialFocusedElt = focusedElt;\n                while (focusedElt.localName == \"tab\" ||\n                       focusedElt.getAttribute(\"noinitialfocus\") == \"true\") {\n                  document.commandDispatcher.advanceFocusIntoSubtree(focusedElt);\n                  focusedElt = document.commandDispatcher.focusedElement;\n                  if (focusedElt == initialFocusedElt) {\n                    if (focusedElt.getAttribute(\"noinitialfocus\") == \"true\") {\n                      focusedElt.blur();\n                    }\n                    break;\n                  }\n                }\n\n                if (initialFocusedElt.localName == \"tab\") {\n                  if (focusedElt.hasAttribute(\"dlgtype\")) {\n                    // We don't want to focus on anonymous OK, Cancel, etc. buttons,\n                    // so return focus to the tab itself\n                    initialFocusedElt.focus();\n                  }\n                } else if (!/Mac/.test(navigator.platform) &&\n                           focusedElt.hasAttribute(\"dlgtype\") && focusedElt != defaultButton) {\n                  defaultButton.focus();\n                }\n              }\n            }\n\n            try {\n              if (defaultButton)\n                window.notifyDefaultButtonLoaded(defaultButton);\n            } catch (e) { }\n          }\n\n          // Give focus after onload completes, see bug 103197.\n          setTimeout(focusInit, 0);\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"mStrBundle\">\n        <getter>\n        <![CDATA[\n          if (!this._mStrBundle) {\n            // need to create string bundle manually instead of using <xul:stringbundle/>\n            // see bug 63370 for details\n            this._mStrBundle = Components.classes[\"@mozilla.org/intl/stringbundle;1\"]\n                                         .getService(Components.interfaces.nsIStringBundleService)\n                                         .createBundle(\"chrome://global/locale/dialog.properties\");\n          }\n          return this._mStrBundle;\n        ]]></getter>\n      </property>\n\n      <method name=\"_configureButtons\">\n        <parameter name=\"aButtons\"/>\n        <body>\n        <![CDATA[\n          // by default, get all the anonymous button elements\n          var buttons = {};\n          this._buttons = buttons;\n          buttons.accept = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"accept\");\n          buttons.cancel = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"cancel\");\n          buttons.extra1 = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"extra1\");\n          buttons.extra2 = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"extra2\");\n          buttons.help = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"help\");\n          buttons.disclosure = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"disclosure\");\n\n          // look for any overriding explicit button elements\n          var exBtns = this.getElementsByAttribute(\"dlgtype\", \"*\");\n          var dlgtype;\n          var i;\n          for (i = 0; i < exBtns.length; ++i) {\n            dlgtype = exBtns[i].getAttribute(\"dlgtype\");\n            buttons[dlgtype].hidden = true; // hide the anonymous button\n            buttons[dlgtype] = exBtns[i];\n          }\n\n          // add the label and oncommand handler to each button\n          for (dlgtype in buttons) {\n            var button = buttons[dlgtype];\n            button.addEventListener(\"command\", this._handleButtonCommand, true);\n\n            // don't override custom labels with pre-defined labels on explicit buttons\n            if (!button.hasAttribute(\"label\")) {\n              // dialog attributes override the default labels in dialog.properties\n              if (this.hasAttribute(\"buttonlabel\" + dlgtype)) {\n                button.setAttribute(\"label\", this.getAttribute(\"buttonlabel\" + dlgtype));\n                if (this.hasAttribute(\"buttonaccesskey\" + dlgtype))\n                  button.setAttribute(\"accesskey\", this.getAttribute(\"buttonaccesskey\" + dlgtype));\n              } else if (dlgtype != \"extra1\" && dlgtype != \"extra2\") {\n                button.setAttribute(\"label\", this.mStrBundle.GetStringFromName(\"button-\" + dlgtype));\n                var accessKey = this.mStrBundle.GetStringFromName(\"accesskey-\" + dlgtype);\n                if (accessKey)\n                  button.setAttribute(\"accesskey\", accessKey);\n              }\n            }\n            // allow specifying alternate icons in the dialog header\n            if (!button.hasAttribute(\"icon\")) {\n              // if there's an icon specified, use that\n              if (this.hasAttribute(\"buttonicon\" + dlgtype))\n                button.setAttribute(\"icon\", this.getAttribute(\"buttonicon\" + dlgtype));\n              // otherwise set defaults\n              else\n                switch (dlgtype) {\n                  case \"accept\":\n                    button.setAttribute(\"icon\", \"accept\");\n                    break;\n                  case \"cancel\":\n                    button.setAttribute(\"icon\", \"cancel\");\n                    break;\n                  case \"disclosure\":\n                    button.setAttribute(\"icon\", \"properties\");\n                    break;\n                  case \"help\":\n                    button.setAttribute(\"icon\", \"help\");\n                    break;\n                  default:\n                    break;\n                }\n            }\n          }\n\n          // ensure that hitting enter triggers the default button command\n          this.defaultButton = this.defaultButton;\n\n          // if there is a special button configuration, use it\n          if (aButtons) {\n            // expect a comma delimited list of dlgtype values\n            var list = aButtons.split(\",\");\n\n            // mark shown dlgtypes as true\n            var shown = { accept: false, cancel: false, help: false,\n                          disclosure: false, extra1: false, extra2: false };\n            for (i = 0; i < list.length; ++i)\n              shown[list[i].replace(/ /g, \"\")] = true;\n\n            // hide/show the buttons we want\n            for (dlgtype in buttons)\n              buttons[dlgtype].hidden = !shown[dlgtype];\n\n            // show the spacer on Windows only when the extra2 button is present\n            if (/Win/.test(navigator.platform)) {\n              var spacer = document.getAnonymousElementByAttribute(this, \"anonid\", \"spacer\");\n              spacer.removeAttribute(\"hidden\");\n              spacer.setAttribute(\"flex\", shown.extra2 ? \"1\" : \"0\");\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_setDefaultButton\">\n        <parameter name=\"aNewDefault\"/>\n        <body>\n        <![CDATA[\n          // remove the default attribute from the previous default button, if any\n          var oldDefaultButton = this.getButton(this.defaultButton);\n          if (oldDefaultButton)\n            oldDefaultButton.removeAttribute(\"default\");\n\n          var newDefaultButton = this.getButton(aNewDefault);\n          if (newDefaultButton) {\n            this.setAttribute(\"defaultButton\", aNewDefault);\n            newDefaultButton.setAttribute(\"default\", \"true\");\n          } else {\n            this.setAttribute(\"defaultButton\", \"none\");\n            if (aNewDefault != \"none\")\n              dump(\"invalid new default button: \" + aNewDefault + \", assuming: none\\n\");\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_handleButtonCommand\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          return document.documentElement._doButtonCommand(\n                                        aEvent.target.getAttribute(\"dlgtype\"));\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_doButtonCommand\">\n        <parameter name=\"aDlgType\"/>\n        <body>\n        <![CDATA[\n          var button = this.getButton(aDlgType);\n          if (!button.disabled) {\n            var noCancel = this._fireButtonEvent(aDlgType);\n            if (noCancel) {\n              if (aDlgType == \"accept\" || aDlgType == \"cancel\") {\n                var closingEvent = new CustomEvent(\"dialogclosing\", {\n                  bubbles: true,\n                  detail: { button: aDlgType },\n                });\n                this.dispatchEvent(closingEvent);\n                window.close();\n              }\n            }\n            return noCancel;\n          }\n          return true;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_fireButtonEvent\">\n        <parameter name=\"aDlgType\"/>\n        <body>\n        <![CDATA[\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"dialog\" + aDlgType, true, true);\n\n          // handle dom event handlers\n          var noCancel = this.dispatchEvent(event);\n\n          // handle any xml attribute event handlers\n          var handler = this.getAttribute(\"ondialog\" + aDlgType);\n          if (handler != \"\") {\n            var fn = new Function(\"event\", handler);\n            var returned = fn(event);\n            if (returned == false)\n              noCancel = false;\n          }\n\n          return noCancel;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_hitEnter\">\n        <parameter name=\"evt\"/>\n        <body>\n        <![CDATA[\n          if (evt.defaultPrevented)\n            return;\n\n          var btn = this.getButton(this.defaultButton);\n          if (btn)\n            this._doButtonCommand(this.defaultButton);\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\"\n               group=\"system\" action=\"this._hitEnter(event);\"/>\n      <handler event=\"keypress\" keycode=\"VK_ESCAPE\" group=\"system\">\n        if (!event.defaultPrevented)\n          this.cancelDialog();\n      </handler>\n\n      <handler event=\"focus\" phase=\"capturing\">\n        var btn = this.getButton(this.defaultButton);\n        if (btn)\n          btn.setAttribute(\"default\", event.originalTarget == btn || !(event.originalTarget instanceof Components.interfaces.nsIDOMXULButtonElement));\n      </handler>\n\n    </handlers>\n\n  </binding>\n\n  <binding id=\"dialogheader\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/dialog.css\"/>\n    </resources>\n    <content>\n      <xul:label class=\"dialogheader-title\" xbl:inherits=\"value=title,crop\" crop=\"right\" flex=\"1\"/>\n      <xul:label class=\"dialogheader-description\" xbl:inherits=\"value=description\"/>\n    </content>\n  </binding>\n\n</bindings>\n"},{"file":"editor.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"editorBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"editor\" role=\"outerdoc\">\n    <implementation type=\"application/javascript\">\n      <constructor>\n        <![CDATA[\n          // Make window editable immediately only\n          //   if the \"editortype\" attribute is supplied\n          // This allows using same contentWindow for different editortypes,\n          //   where the type is determined during the apps's window.onload handler.\n          if (this.editortype)\n            this.makeEditable(this.editortype, true);\n        ]]>\n      </constructor>\n      <destructor/>\n\n      <field name=\"_editorContentListener\">\n        <![CDATA[\n          ({\n            QueryInterface(iid) {\n              if (iid.equals(Components.interfaces.nsIURIContentListener) ||\n                  iid.equals(Components.interfaces.nsISupportsWeakReference) ||\n                  iid.equals(Components.interfaces.nsISupports))\n              return this;\n\n              throw Components.results.NS_ERROR_NO_INTERFACE;\n            },\n            onStartURIOpen(uri) {\n              return false;\n            },\n            doContent(contentType, isContentPreferred, request, contentHandler) {\n              return false;\n            },\n            isPreferred(contentType, desiredContentType) {\n              return false;\n            },\n            canHandleContent(contentType, isContentPreferred, desiredContentType) {\n              return false;\n            },\n            loadCookie: null,\n            parentContentListener: null\n          })\n        ]]>\n      </field>\n      <method name=\"makeEditable\">\n        <parameter name=\"editortype\"/>\n        <parameter name=\"waitForUrlLoad\"/>\n        <body>\n        <![CDATA[\n          this.editingSession.makeWindowEditable(this.contentWindow, editortype, waitForUrlLoad, true, false);\n          this.setAttribute(\"editortype\", editortype);\n\n          this.docShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor)\n              .getInterface(Components.interfaces.nsIURIContentListener)\n              .parentContentListener = this._editorContentListener;\n        ]]>\n        </body>\n      </method>\n      <method name=\"getEditor\">\n        <parameter name=\"containingWindow\"/>\n        <body>\n        <![CDATA[\n          return this.editingSession.getEditorForWindow(containingWindow);\n        ]]>\n        </body>\n      </method>\n      <method name=\"getHTMLEditor\">\n        <parameter name=\"containingWindow\"/>\n        <body>\n        <![CDATA[\n          var editor = this.editingSession.getEditorForWindow(containingWindow);\n          return editor.QueryInterface(Components.interfaces.nsIHTMLEditor);\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"_finder\">null</field>\n      <property name=\"finder\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._finder) {\n            if (!this.docShell)\n              return null;\n\n            let Finder = Components.utils.import(\"resource://gre/modules/Finder.jsm\", {}).Finder;\n            this._finder = new Finder(this.docShell);\n          }\n          return this._finder;\n        ]]></getter>\n      </property>\n\n      <field name=\"_fastFind\">null</field>\n      <property name=\"fastFind\"\n                readonly=\"true\">\n        <getter>\n        <![CDATA[\n          if (!this._fastFind) {\n            if (!(\"@mozilla.org/typeaheadfind;1\" in Components.classes))\n              return null;\n\n            if (!this.docShell)\n              return null;\n\n            this._fastFind = Components.classes[\"@mozilla.org/typeaheadfind;1\"]\n                                       .createInstance(Components.interfaces.nsITypeAheadFind);\n            this._fastFind.init(this.docShell);\n          }\n          return this._fastFind;\n        ]]>\n        </getter>\n      </property>\n\n      <field name=\"_lastSearchString\">null</field>\n\n      <property name=\"editortype\"\n                onget=\"return this.getAttribute('editortype');\"\n                onset=\"this.setAttribute('editortype', val); return val;\"/>\n      <property name=\"webNavigation\"\n                onget=\"return this.docShell.QueryInterface(Components.interfaces.nsIWebNavigation);\"\n                readonly=\"true\"/>\n      <property name=\"contentDocument\" readonly=\"true\"\n                onget=\"return this.webNavigation.document;\"/>\n      <property name=\"docShell\" readonly=\"true\">\n        <getter><![CDATA[\n          let {frameLoader} = this;\n          return frameLoader ? frameLoader.docShell : null;\n        ]]></getter>\n      </property>\n      <property name=\"currentURI\"\n                readonly=\"true\"\n                onget=\"return this.webNavigation.currentURI;\"/>\n      <property name=\"contentWindow\"\n                readonly=\"true\"\n                onget=\"return this.docShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindow);\"/>\n      <property name=\"contentWindowAsCPOW\"\n                readonly=\"true\"\n                onget=\"return this.contentWindow;\"/>\n      <property name=\"webBrowserFind\"\n                readonly=\"true\"\n                onget=\"return this.docShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIWebBrowserFind);\"/>\n      <property name=\"markupDocumentViewer\"\n                readonly=\"true\"\n                onget=\"return this.docShell.contentViewer;\"/>\n      <property name=\"editingSession\"\n                readonly=\"true\"\n                onget=\"return this.webNavigation.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIEditingSession);\"/>\n      <property name=\"commandManager\"\n                readonly=\"true\"\n                onget=\"return this.webNavigation.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsICommandManager);\"/>\n      <property name=\"fullZoom\"\n                onget=\"return this.markupDocumentViewer.fullZoom;\"\n                onset=\"this.markupDocumentViewer.fullZoom = val;\"/>\n      <property name=\"textZoom\"\n                onget=\"return this.markupDocumentViewer.textZoom;\"\n                onset=\"this.markupDocumentViewer.textZoom = val;\"/>\n      <property name=\"isSyntheticDocument\"\n                onget=\"return this.contentDocument.isSyntheticDocument;\"\n                readonly=\"true\"/>\n      <property name=\"messageManager\"\n                readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (this.frameLoader) {\n              return this.frameLoader.messageManager;\n            }\n            return null;\n          ]]>\n        </getter>\n      </property>\n      <property name=\"outerWindowID\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.contentWindow\n                     .QueryInterface(Components.interfaces.nsIInterfaceRequestor)\n                     .getInterface(Components.interfaces.nsIDOMWindowUtils)\n                     .outerWindowID;\n        ]]></getter>\n      </property>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"expander.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"expanderBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"expander\" display=\"xul:vbox\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/expander.css\"/>\n    </resources>\n    <content>\n      <xul:hbox align=\"center\">\n        <xul:button type=\"disclosure\" class=\"expanderButton\" anonid=\"disclosure\" xbl:inherits=\"disabled\" mousethrough=\"always\"/>\n        <xul:label class=\"header expanderButton\" anonid=\"label\" xbl:inherits=\"value=label,disabled\" mousethrough=\"always\" flex=\"1\"/>\n        <xul:button anonid=\"clear-button\" xbl:inherits=\"label=clearlabel,disabled=cleardisabled,hidden=clearhidden\" mousethrough=\"always\" icon=\"clear\"/>\n      </xul:hbox>\n      <xul:vbox flex=\"1\" anonid=\"settings\" class=\"settingsContainer\" collapsed=\"true\" xbl:inherits=\"align\">\n        <children/>\n      </xul:vbox>\n    </content>\n    <implementation>\n      <constructor><![CDATA[\n        var settings = document.getAnonymousElementByAttribute(this, \"anonid\", \"settings\");\n        var expander = document.getAnonymousElementByAttribute(this, \"anonid\", \"disclosure\");\n        var open = this.getAttribute(\"open\") == \"true\";\n        settings.collapsed = !open;\n        expander.open = open;\n      ]]></constructor>\n      <property name=\"open\">\n        <setter>\n          <![CDATA[\n            var settings = document.getAnonymousElementByAttribute(this, \"anonid\", \"settings\");\n            var expander = document.getAnonymousElementByAttribute(this, \"anonid\", \"disclosure\");\n            settings.collapsed = !val;\n            expander.open = val;\n            if (val)\n              this.setAttribute(\"open\", \"true\");\n            else\n              this.setAttribute(\"open\", \"false\");\n            return val;\n          ]]>\n        </setter>\n        <getter>\n          return this.getAttribute(\"open\");\n        </getter>\n      </property>        \n      <method name=\"onCommand\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          var element = aEvent.originalTarget;\n          var button = element.getAttribute(\"anonid\");\n          switch (button) {\n          case \"disclosure\":\n          case \"label\":\n            if (this.open == \"true\")\n              this.open = false;\n            else\n              this.open = true;\n            break;\n          case \"clear-button\":\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"clear\", true, true);\n            this.dispatchEvent(event);\n            break;\n          }\n        ]]></body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"command\"><![CDATA[\n        this.onCommand(event);\n      ]]></handler>\n      <handler event=\"click\"><![CDATA[\n        if (event.originalTarget.localName == \"label\")\n          this.onCommand(event);\n      ]]></handler>\n    </handlers>\n  </binding>\n          \n</bindings>\n\n          \n"},{"file":"filefield.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"filefieldBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"filefield\" extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/filefield.css\"/>\n    </resources>\n    <content>\n      <xul:stringbundle anonid=\"bundle\" src=\"chrome://global/locale/filefield.properties\"/>\n      <xul:hbox class=\"fileFieldContentBox\" align=\"center\" flex=\"1\" xbl:inherits=\"disabled\">\n        <xul:image class=\"fileFieldIcon\" xbl:inherits=\"src=image,disabled\"/>\n        <xul:textbox class=\"fileFieldLabel\" xbl:inherits=\"value=label,disabled,accesskey,tabindex,aria-labelledby\" flex=\"1\" readonly=\"true\"/>\n      </xul:hbox>\n    </content>\n    <implementation implements=\"nsIDOMXULLabeledControlElement\">\n      <property name=\"label\" onget=\"return this.getAttribute('label');\">\n        <setter>\n          this.setAttribute(\"label\", val);\n          var elt = document.getAnonymousElementByAttribute(this, \"class\", \"fileFieldLabel\");\n          return (elt.value = val);\n        </setter>\n      </property>\n\n      <field name=\"_file\">null</field>\n      <property name=\"file\"  onget=\"return this._file\">\n        <setter>\n        <![CDATA[\n          this._file = val;\n          if (val) {\n            this.image = this._getIconURLForFile(val);\n            this.label = this._getDisplayNameForFile(val);\n          } else {\n            this.removeAttribute(\"image\");\n            var bundle = document.getAnonymousElementByAttribute(this, \"anonid\", \"bundle\");\n            this.label = bundle.getString(\"downloadHelperNoneSelected\");\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n      <method name=\"_getDisplayNameForFile\">\n        <parameter name=\"aFile\"/>\n        <body>\n        <![CDATA[\n          if (/Win/.test(navigator.platform)) {\n            var lfw = aFile.QueryInterface(Components.interfaces.nsILocalFileWin);\n            try {\n              return lfw.getVersionInfoField(\"FileDescription\");\n            } catch (e) {\n              // fall through to the filename\n            }\n          } else if (/Mac/.test(navigator.platform)) {\n            var lfm = aFile.QueryInterface(Components.interfaces.nsILocalFileMac);\n            try {\n              return lfm.bundleDisplayName;\n            } catch (e) {\n              // fall through to the file name\n            }\n          }\n          var ios = Components.classes[\"@mozilla.org/network/io-service;1\"]\n                              .getService(Components.interfaces.nsIIOService);\n          var url = ios.newFileURI(aFile).QueryInterface(Components.interfaces.nsIURL);\n          return url.fileName;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_getIconURLForFile\">\n        <parameter name=\"aFile\"/>\n        <body>\n        <![CDATA[\n          if (!aFile)\n            return \"\";\n          var ios = Components.classes[\"@mozilla.org/network/io-service;1\"]\n                              .getService(Components.interfaces.nsIIOService);\n          var fph = ios.getProtocolHandler(\"file\")\n                       .QueryInterface(Components.interfaces.nsIFileProtocolHandler);\n          var urlspec = fph.getURLSpecFromFile(aFile);\n          return \"moz-icon://\" + urlspec + \"?size=16\";\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"findbar.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings [\n<!ENTITY % findBarDTD SYSTEM \"chrome://global/locale/findbar.dtd\" >\n%findBarDTD;\n]>\n\n<bindings id=\"findbarBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <!-- Private binding -->\n  <binding id=\"findbar-textbox\"\n           extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <implementation>\n\n      <field name=\"_findbar\">null</field>\n      <property name=\"findbar\" readonly=\"true\">\n        <getter>\n          return this._findbar ?\n                 this._findbar : this._findbar = document.getBindingParent(this);\n        </getter>\n      </property>\n\n      <method name=\"_handleEnter\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (this.findbar._findMode == this.findbar.FIND_NORMAL) {\n            let findString = this.findbar._findField;\n            if (!findString.value)\n              return;\n            if (aEvent.getModifierState(\"Accel\")) {\n              this.findbar.getElement(\"highlight\").click();\n              return;\n            }\n\n            this.findbar.onFindAgainCommand(aEvent.shiftKey);\n          } else {\n            this.findbar._finishFAYT(aEvent);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_handleTab\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let shouldHandle = !aEvent.altKey && !aEvent.ctrlKey &&\n                             !aEvent.metaKey;\n          if (shouldHandle &&\n              this.findbar._findMode != this.findbar.FIND_NORMAL) {\n\n            this.findbar._finishFAYT(aEvent);\n          }\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"input\"><![CDATA[\n        // We should do nothing during composition.  E.g., composing string\n        // before converting may matches a forward word of expected word.\n        // After that, even if user converts the composition string to the\n        // expected word, it may find second or later searching word in the\n        // document.\n        if (this.findbar._isIMEComposing) {\n          return;\n        }\n\n        if (this._hadValue && !this.value) {\n          this._willfullyDeleted = true;\n          this._hadValue = false;\n        } else if (this.value.trim()) {\n          this._hadValue = true;\n          this._willfullyDeleted = false;\n        }\n        this.findbar._find(this.value);\n      ]]></handler>\n\n      <handler event=\"keypress\"><![CDATA[\n        let shouldHandle = !event.altKey && !event.ctrlKey &&\n                           !event.metaKey && !event.shiftKey;\n\n        switch (event.keyCode) {\n          case KeyEvent.DOM_VK_RETURN:\n            this._handleEnter(event);\n            break;\n          case KeyEvent.DOM_VK_TAB:\n            this._handleTab(event);\n            break;\n          case KeyEvent.DOM_VK_PAGE_UP:\n          case KeyEvent.DOM_VK_PAGE_DOWN:\n            if (shouldHandle) {\n              this.findbar.browser.finder.keyPress(event);\n              event.preventDefault();\n            }\n            break;\n          case KeyEvent.DOM_VK_UP:\n          case KeyEvent.DOM_VK_DOWN:\n            this.findbar.browser.finder.keyPress(event);\n            event.preventDefault();\n            break;\n        }\n      ]]></handler>\n\n      <handler event=\"blur\"><![CDATA[\n        let findbar = this.findbar;\n        // Note: This code used to remove the selection\n        // if it matched an editable.\n        findbar.browser.finder.enableSelection();\n      ]]></handler>\n\n      <handler event=\"focus\"><![CDATA[\n        if (/Mac/.test(navigator.platform)) {\n          let findbar = this.findbar;\n          findbar._onFindFieldFocus();\n        }\n      ]]></handler>\n\n      <handler event=\"compositionstart\"><![CDATA[\n        // Don't close the find toolbar while IME is composing.\n        let findbar = this.findbar;\n        findbar._isIMEComposing = true;\n        if (findbar._quickFindTimeout) {\n          clearTimeout(findbar._quickFindTimeout);\n          findbar._quickFindTimeout = null;\n        }\n      ]]></handler>\n\n      <handler event=\"compositionend\"><![CDATA[\n        let findbar = this.findbar;\n        findbar._isIMEComposing = false;\n        if (findbar._findMode != findbar.FIND_NORMAL)\n          findbar._setFindCloseTimeout();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        if (event.dataTransfer.types.includes(\"text/plain\"))\n          event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"drop\"><![CDATA[\n        let value = event.dataTransfer.getData(\"text/plain\");\n        this.value = value;\n        this.findbar._find(value);\n        event.stopPropagation();\n        event.preventDefault();\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"findbar\"\n           extends=\"chrome://global/content/bindings/toolbar.xml#toolbar\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/findBar.css\"/>\n    </resources>\n\n    <content hidden=\"true\">\n    <xul:hbox anonid=\"findbar-container\" class=\"findbar-container\" flex=\"1\" align=\"center\">\n      <xul:hbox anonid=\"findbar-textbox-wrapper\" align=\"stretch\">\n        <xul:textbox anonid=\"findbar-textbox\"\n                     class=\"findbar-textbox findbar-find-fast\"\n                     xbl:inherits=\"flash\"/>\n        <xul:toolbarbutton anonid=\"find-previous\"\n                           class=\"findbar-find-previous tabbable\"\n                           tooltiptext=\"FROM-DTD-previous-tooltip\"\n                           oncommand=\"onFindAgainCommand(true);\"\n                           disabled=\"true\"\n                           xbl:inherits=\"accesskey=findpreviousaccesskey\"/>\n        <xul:toolbarbutton anonid=\"find-next\"\n                           class=\"findbar-find-next tabbable\"\n                           tooltiptext=\"FROM-DTD-next-tooltip\"\n                           oncommand=\"onFindAgainCommand(false);\"\n                           disabled=\"true\"\n                           xbl:inherits=\"accesskey=findnextaccesskey\"/>\n      </xul:hbox>\n      <xul:toolbarbutton anonid=\"highlight\"\n                         class=\"findbar-highlight findbar-button tabbable\"\n                         label=\"FROM-DTD-highlightAll-label\"\n                         accesskey=\"FROM-DTD-highlightAll-accesskey\"\n                         tooltiptext=\"FROM-DTD-highlightAll-tooltiptext\"\n                         oncommand=\"toggleHighlight(this.checked);\"\n                         type=\"checkbox\"\n                         xbl:inherits=\"accesskey=highlightaccesskey\"/>\n      <xul:toolbarbutton anonid=\"find-case-sensitive\"\n                         class=\"findbar-case-sensitive findbar-button tabbable\"\n                         label=\"FROM-DTD-caseSensitive-label\"\n                         accesskey=\"FROM-DTD-caseSensitive-accesskey\"\n                         tooltiptext=\"FROM-DTD-caseSensitive-tooltiptext\"\n                         oncommand=\"_setCaseSensitivity(this.checked ? 1 : 0);\"\n                         type=\"checkbox\"\n                         xbl:inherits=\"accesskey=matchcaseaccesskey\"/>\n      <xul:toolbarbutton anonid=\"find-entire-word\"\n                         class=\"findbar-entire-word findbar-button tabbable\"\n                         label=\"FROM-DTD-entireWord-label\"\n                         accesskey=\"FROM-DTD-entireWord-accesskey\"\n                         tooltiptext=\"FROM-DTD-entireWord-tooltiptext\"\n                         oncommand=\"toggleEntireWord(this.checked);\"\n                         type=\"checkbox\"\n                         xbl:inherits=\"accesskey=entirewordaccesskey\"/>\n      <xul:label anonid=\"match-case-status\" class=\"findbar-find-fast\"/>\n      <xul:label anonid=\"entire-word-status\" class=\"findbar-find-fast\"/>\n      <xul:label anonid=\"found-matches\" class=\"findbar-find-fast found-matches\" hidden=\"true\"/>\n      <xul:image anonid=\"find-status-icon\" class=\"findbar-find-fast find-status-icon\"/>\n      <xul:description anonid=\"find-status\"\n                       control=\"findbar-textbox\"\n                       class=\"findbar-find-fast findbar-find-status\">\n      <!-- Do not use value, first child is used because it provides a11y with text change events -->\n      </xul:description>\n    </xul:hbox>\n    <xul:toolbarbutton anonid=\"find-closebutton\"\n                       class=\"findbar-closebutton close-icon\"\n                       tooltiptext=\"FROM-DTD-findCloseButton-tooltip\"\n                       oncommand=\"close();\"/>\n    </content>\n\n    <implementation implements=\"nsIMessageListener, nsIEditActionListener\">\n      <!-- Please keep in sync with toolkit/content/browser-content.js -->\n      <field name=\"FIND_NORMAL\">0</field>\n      <field name=\"FIND_TYPEAHEAD\">1</field>\n      <field name=\"FIND_LINKS\">2</field>\n\n      <field name=\"__findMode\">0</field>\n      <property name=\"_findMode\" onget=\"return this.__findMode;\"\n                onset=\"this.__findMode = val; this._updateBrowserWithState(); return val;\"/>\n\n      <field name=\"_flashFindBar\">0</field>\n      <field name=\"_initialFlashFindBarCount\">6</field>\n\n      <!--\n        - For tests that need to know when the find bar is finished\n        - initializing, we store a promise to notify on.\n        -->\n      <field name=\"_startFindDeferred\">null</field>\n\n      <property name=\"prefillWithSelection\"\n                onget=\"return this.getAttribute('prefillwithselection') != 'false'\"\n                onset=\"this.setAttribute('prefillwithselection', val); return val;\"/>\n\n      <method name=\"getElement\">\n        <parameter name=\"aAnonymousID\"/>\n        <body><![CDATA[\n          return document.getAnonymousElementByAttribute(this,\n                                                         \"anonid\",\n                                                         aAnonymousID)\n        ]]></body>\n      </method>\n\n      <property name=\"findMode\"\n                readonly=\"true\"\n                onget=\"return this._findMode;\"/>\n\n      <property name=\"hasTransactions\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._findField.value)\n            return true;\n\n          // Watch out for lazy editor init\n          if (this._findField.editor) {\n            let tm = this._findField.editor.transactionManager;\n            return !!(tm.numberOfUndoItems || tm.numberOfRedoItems);\n          }\n          return false;\n        ]]></getter>\n      </property>\n\n      <field name=\"_browser\">null</field>\n      <property name=\"browser\">\n        <getter><![CDATA[\n          if (!this._browser) {\n            this._browser =\n              document.getElementById(this.getAttribute(\"browserid\"));\n          }\n          return this._browser;\n        ]]></getter>\n        <setter><![CDATA[\n          if (this._browser) {\n            if (this._browser.messageManager) {\n              this._browser.messageManager.removeMessageListener(\"Findbar:Keypress\", this);\n              this._browser.messageManager.removeMessageListener(\"Findbar:Mouseup\", this);\n            }\n            let finder = this._browser.finder;\n            if (finder)\n              finder.removeResultListener(this);\n          }\n\n          this._browser = val;\n          if (this._browser) {\n            // Need to do this to ensure the correct initial state.\n            this._updateBrowserWithState();\n            this._browser.messageManager.addMessageListener(\"Findbar:Keypress\", this);\n            this._browser.messageManager.addMessageListener(\"Findbar:Mouseup\", this);\n            this._browser.finder.addResultListener(this);\n\n            this._findField.value = this._browser._lastSearchString;\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <field name=\"__prefsvc\">null</field>\n      <property name=\"_prefsvc\">\n        <getter><![CDATA[\n          if (!this.__prefsvc) {\n            this.__prefsvc = Components.classes[\"@mozilla.org/preferences-service;1\"]\n              .getService(Components.interfaces.nsIPrefBranch);\n          }\n          return this.__prefsvc;\n        ]]></getter>\n      </property>\n\n      <field name=\"_observer\"><![CDATA[({\n        _self: this,\n\n        QueryInterface(aIID) {\n          if (aIID.equals(Components.interfaces.nsIObserver) ||\n              aIID.equals(Components.interfaces.nsISupportsWeakReference) ||\n              aIID.equals(Components.interfaces.nsISupports))\n            return this;\n\n          throw Components.results.NS_ERROR_NO_INTERFACE;\n        },\n\n        observe(aSubject, aTopic, aPrefName) {\n          if (aTopic != \"nsPref:changed\")\n            return;\n\n          let prefsvc = this._self._prefsvc;\n\n          switch (aPrefName) {\n            case \"accessibility.typeaheadfind\":\n              this._self._findAsYouType = prefsvc.getBoolPref(aPrefName);\n              break;\n            case \"accessibility.typeaheadfind.linksonly\":\n              this._self._typeAheadLinksOnly = prefsvc.getBoolPref(aPrefName);\n              break;\n            case \"accessibility.typeaheadfind.casesensitive\":\n              this._self._setCaseSensitivity(prefsvc.getIntPref(aPrefName));\n              break;\n            case \"findbar.entireword\":\n              this._self._entireWord = prefsvc.getBoolPref(aPrefName);\n              this._self.toggleEntireWord(this._self._entireWord, true);\n              break;\n            case \"findbar.highlightAll\":\n              this._self.toggleHighlight(prefsvc.getBoolPref(aPrefName), true);\n              break;\n            case \"findbar.modalHighlight\":\n              this._self._useModalHighlight = prefsvc.getBoolPref(aPrefName);\n              if (this._self.browser.finder)\n                this._self.browser.finder.onModalHighlightChange(this._self._useModalHighlight);\n              break;\n          }\n        }\n      })]]></field>\n\n      <field name=\"_destroyed\">false</field>\n\n      <constructor><![CDATA[\n        // These elements are accessed frequently and are therefore cached\n        this._findField = this.getElement(\"findbar-textbox\");\n        this._foundMatches = this.getElement(\"found-matches\");\n        this._findStatusIcon = this.getElement(\"find-status-icon\");\n        this._findStatusDesc = this.getElement(\"find-status\");\n\n        this._foundURL = null;\n\n        let prefsvc = this._prefsvc;\n\n        this._quickFindTimeoutLength =\n          prefsvc.getIntPref(\"accessibility.typeaheadfind.timeout\");\n        this._flashFindBar =\n          prefsvc.getIntPref(\"accessibility.typeaheadfind.flashBar\");\n        this._useModalHighlight = prefsvc.getBoolPref(\"findbar.modalHighlight\");\n\n        prefsvc.addObserver(\"accessibility.typeaheadfind\",\n                            this._observer);\n        prefsvc.addObserver(\"accessibility.typeaheadfind.linksonly\",\n                            this._observer);\n        prefsvc.addObserver(\"accessibility.typeaheadfind.casesensitive\",\n                            this._observer);\n        prefsvc.addObserver(\"findbar.entireword\", this._observer);\n        prefsvc.addObserver(\"findbar.highlightAll\", this._observer);\n        prefsvc.addObserver(\"findbar.modalHighlight\", this._observer);\n\n        this._findAsYouType =\n          prefsvc.getBoolPref(\"accessibility.typeaheadfind\");\n        this._typeAheadLinksOnly =\n          prefsvc.getBoolPref(\"accessibility.typeaheadfind.linksonly\");\n        this._typeAheadCaseSensitive =\n          prefsvc.getIntPref(\"accessibility.typeaheadfind.casesensitive\");\n        this._entireWord = prefsvc.getBoolPref(\"findbar.entireword\");\n        this._highlightAll = prefsvc.getBoolPref(\"findbar.highlightAll\");\n\n        // Convenience\n        this.nsITypeAheadFind = Components.interfaces.nsITypeAheadFind;\n        this.nsISelectionController = Components.interfaces.nsISelectionController;\n        this._findSelection = this.nsISelectionController.SELECTION_FIND;\n\n        this._findResetTimeout = -1;\n\n        // Make sure the FAYT keypress listener is attached by initializing the\n        // browser property\n        if (this.getAttribute(\"browserid\"))\n          setTimeout(function(aSelf) { aSelf.browser = aSelf.browser; }, 0, this);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        this.destroy();\n      ]]></destructor>\n\n      <!-- This is necessary because the destructor isn't called when\n           we are removed from a document that is not destroyed. This\n           needs to be explicitly called in this case -->\n      <method name=\"destroy\">\n        <body><![CDATA[\n          if (this._destroyed)\n            return;\n          this._destroyed = true;\n\n          if (this.browser.finder)\n            this.browser.finder.destroy();\n\n          this.browser = null;\n\n          let prefsvc = this._prefsvc;\n          prefsvc.removeObserver(\"accessibility.typeaheadfind\",\n                                 this._observer);\n          prefsvc.removeObserver(\"accessibility.typeaheadfind.linksonly\",\n                                 this._observer);\n          prefsvc.removeObserver(\"accessibility.typeaheadfind.casesensitive\",\n                                 this._observer);\n          prefsvc.removeObserver(\"findbar.entireword\", this._observer);\n          prefsvc.removeObserver(\"findbar.highlightAll\", this._observer);\n          prefsvc.removeObserver(\"findbar.modalHighlight\", this._observer);\n\n          // Clear all timers that might still be running.\n          this._cancelTimers();\n        ]]></body>\n      </method>\n\n      <method name=\"_cancelTimers\">\n        <body><![CDATA[\n          if (this._flashFindBarTimeout) {\n            clearInterval(this._flashFindBarTimeout);\n            this._flashFindBarTimeout = null;\n          }\n          if (this._quickFindTimeout) {\n            clearTimeout(this._quickFindTimeout);\n            this._quickFindTimeout = null;\n          }\n          if (this._findResetTimeout) {\n            clearTimeout(this._findResetTimeout);\n            this._findResetTimeout = null;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_setFindCloseTimeout\">\n        <body><![CDATA[\n          if (this._quickFindTimeout)\n            clearTimeout(this._quickFindTimeout);\n\n          // Don't close the find toolbar while IME is composing OR when the\n          // findbar is already hidden.\n          if (this._isIMEComposing || this.hidden) {\n            this._quickFindTimeout = null;\n            return;\n          }\n\n          this._quickFindTimeout = setTimeout(() => {\n             if (this._findMode != this.FIND_NORMAL)\n               this.close();\n             this._quickFindTimeout = null;\n           }, this._quickFindTimeoutLength);\n        ]]></body>\n      </method>\n\n      <field name=\"_pluralForm\">null</field>\n      <property name=\"pluralForm\">\n        <getter><![CDATA[\n          if (!this._pluralForm) {\n            this._pluralForm = Components.utils.import(\n                               \"resource://gre/modules/PluralForm.jsm\", {}).PluralForm;\n          }\n          return this._pluralForm;\n        ]]></getter>\n      </property>\n\n      <!--\n        - Updates the search match count after each find operation on a new string.\n        - @param aRes\n        -        the result of the find operation\n        -->\n      <method name=\"_updateMatchesCount\">\n        <body><![CDATA[\n          if (!this._dispatchFindEvent(\"matchescount\"))\n            return;\n\n          this.browser.finder.requestMatchesCount(this._findField.value,\n            this._findMode == this.FIND_LINKS);\n        ]]></body>\n      </method>\n\n      <!--\n        - Turns highlight on or off.\n        - @param aHighlight (boolean)\n        -        Whether to turn the highlight on or off\n        - @param aFromPrefObserver (boolean)\n        -        Whether the callee is the pref observer, which means we should\n        -        not set the same pref again.\n        -->\n      <method name=\"toggleHighlight\">\n        <parameter name=\"aHighlight\"/>\n        <parameter name=\"aFromPrefObserver\"/>\n        <body><![CDATA[\n          if (aHighlight === this._highlightAll) {\n            return;\n          }\n\n          this.browser.finder.onHighlightAllChange(aHighlight);\n\n          this._setHighlightAll(aHighlight, aFromPrefObserver);\n\n          if (!this._dispatchFindEvent(\"highlightallchange\")) {\n            return;\n          }\n\n          let word = this._findField.value;\n          // Bug 429723. Don't attempt to highlight \"\"\n          if (aHighlight && !word)\n            return;\n\n          this.browser.finder.highlight(aHighlight, word,\n            this._findMode == this.FIND_LINKS);\n\n          // Update the matches count\n          this._updateMatchesCount(this.nsITypeAheadFind.FIND_FOUND);\n        ]]></body>\n      </method>\n\n      <!--\n        - Updates the highlight-all mode of the findbar and its UI.\n        - @param aHighlight (boolean)\n        -        Whether to turn the highlight on or off.\n        - @param aFromPrefObserver (boolean)\n        -        Whether the callee is the pref observer, which means we should\n        -        not set the same pref again.\n        -->\n      <method name=\"_setHighlightAll\">\n        <parameter name=\"aHighlight\"/>\n        <parameter name=\"aFromPrefObserver\"/>\n        <body><![CDATA[\n          if (typeof aHighlight != \"boolean\") {\n            aHighlight = this._highlightAll;\n          }\n          if (aHighlight !== this._highlightAll && !aFromPrefObserver) {\n            this._prefsvc.setBoolPref(\"findbar.highlightAll\", aHighlight);\n          }\n          this._highlightAll = aHighlight;\n          let checkbox = this.getElement(\"highlight\");\n          checkbox.checked = this._highlightAll;\n        ]]></body>\n      </method>\n\n      <!--\n        - Updates the case-sensitivity mode of the findbar and its UI.\n        - @param [optional] aString\n        -        The string for which case sensitivity might be turned on.\n        -        This only used when case-sensitivity is in auto mode,\n        -        @see _shouldBeCaseSensitive. The default value for this\n        -        parameter is the find-field value.\n        -->\n      <method name=\"_updateCaseSensitivity\">\n        <parameter name=\"aString\"/>\n        <body><![CDATA[\n          let val = aString || this._findField.value;\n\n          let caseSensitive = this._shouldBeCaseSensitive(val);\n          let checkbox = this.getElement(\"find-case-sensitive\");\n          let statusLabel = this.getElement(\"match-case-status\");\n          checkbox.checked = caseSensitive;\n\n          statusLabel.value = caseSensitive ? this._caseSensitiveStr : \"\";\n\n          // Show the checkbox on the full Find bar in non-auto mode.\n          // Show the label in all other cases.\n          let hideCheckbox = this._findMode != this.FIND_NORMAL ||\n            (this._typeAheadCaseSensitive != 0 &&\n             this._typeAheadCaseSensitive != 1);\n          checkbox.hidden = hideCheckbox;\n          statusLabel.hidden = !hideCheckbox;\n\n          this.browser.finder.caseSensitive = caseSensitive;\n        ]]></body>\n      </method>\n\n      <!--\n        - Sets the findbar case-sensitivity mode\n        - @param aCaseSensitivity (int)\n        -   0 - case insensitive\n        -   1 - case sensitive\n        -   2 - auto = case sensitive iff match string contains upper case letters\n        -   @see _shouldBeCaseSensitive\n        -->\n      <method name=\"_setCaseSensitivity\">\n        <parameter name=\"aCaseSensitivity\"/>\n        <body><![CDATA[\n          this._typeAheadCaseSensitive = aCaseSensitivity;\n          this._updateCaseSensitivity();\n          this._findFailedString = null;\n          this._find();\n\n          this._dispatchFindEvent(\"casesensitivitychange\");\n        ]]></body>\n      </method>\n\n      <!--\n        - Updates the entire-word mode of the findbar and its UI.\n        -->\n      <method name=\"_setEntireWord\">\n        <body><![CDATA[\n          let entireWord = this._entireWord;\n          let checkbox = this.getElement(\"find-entire-word\");\n          let statusLabel = this.getElement(\"entire-word-status\");\n          checkbox.checked = entireWord;\n\n          statusLabel.value = entireWord ? this._entireWordStr : \"\";\n\n          // Show the checkbox on the full Find bar in non-auto mode.\n          // Show the label in all other cases.\n          let hideCheckbox = this._findMode != this.FIND_NORMAL;\n          checkbox.hidden = hideCheckbox;\n          statusLabel.hidden = !hideCheckbox;\n\n          this.browser.finder.entireWord = entireWord;\n        ]]></body>\n      </method>\n\n      <!--\n        - Sets the findbar entire-word mode\n        - @param aEntireWord (boolean)\n        - Whether or not entire-word mode should be turned on.\n        -->\n      <method name=\"toggleEntireWord\">\n        <parameter name=\"aEntireWord\"/>\n        <parameter name=\"aFromPrefObserver\"/>\n        <body><![CDATA[\n          if (!aFromPrefObserver) {\n            // Just set the pref; our observer will change the find bar behavior.\n            this._prefsvc.setBoolPref(\"findbar.entireword\", aEntireWord);\n            return;\n          }\n\n          this._findFailedString = null;\n          this._find();\n        ]]></body>\n      </method>\n\n      <field name=\"_strBundle\">null</field>\n      <property name=\"strBundle\">\n        <getter><![CDATA[\n          if (!this._strBundle) {\n            this._strBundle =\n              Components.classes[\"@mozilla.org/intl/stringbundle;1\"]\n                        .getService(Components.interfaces.nsIStringBundleService)\n                        .createBundle(\"chrome://global/locale/findbar.properties\");\n          }\n          return this._strBundle;\n        ]]></getter>\n      </property>\n\n      <!--\n        - Opens and displays the find bar.\n        -\n        - @param aMode\n        -        the find mode to be used, which is either FIND_NORMAL,\n        -        FIND_TYPEAHEAD or FIND_LINKS. If not passed, the last\n        -        find mode if any or FIND_NORMAL.\n        - @returns true if the find bar wasn't previously open, false otherwise.\n        -->\n      <method name=\"open\">\n        <parameter name=\"aMode\"/>\n        <body><![CDATA[\n          if (aMode != undefined)\n            this._findMode = aMode;\n\n          if (!this._notFoundStr) {\n            var stringsBundle = this.strBundle;\n            this._notFoundStr = stringsBundle.GetStringFromName(\"NotFound\");\n            this._wrappedToTopStr =\n              stringsBundle.GetStringFromName(\"WrappedToTop\");\n            this._wrappedToBottomStr =\n              stringsBundle.GetStringFromName(\"WrappedToBottom\");\n            this._normalFindStr =\n              stringsBundle.GetStringFromName(\"NormalFind\");\n            this._fastFindStr =\n              stringsBundle.GetStringFromName(\"FastFind\");\n            this._fastFindLinksStr =\n              stringsBundle.GetStringFromName(\"FastFindLinks\");\n            this._caseSensitiveStr =\n              stringsBundle.GetStringFromName(\"CaseSensitive\");\n            this._entireWordStr =\n              stringsBundle.GetStringFromName(\"EntireWord\");\n          }\n\n          this._findFailedString = null;\n\n          this._updateFindUI();\n          if (this.hidden) {\n            this.removeAttribute(\"noanim\");\n            this.hidden = false;\n\n            this._updateStatusUI(this.nsITypeAheadFind.FIND_FOUND);\n\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"findbaropen\", true, false);\n            this.dispatchEvent(event);\n\n            this.browser.finder.onFindbarOpen();\n\n            return true;\n          }\n          return false;\n        ]]></body>\n      </method>\n\n      <!--\n        - Closes the findbar.\n        -->\n      <method name=\"close\">\n        <parameter name=\"aNoAnim\"/>\n        <body><![CDATA[\n          if (this.hidden)\n            return;\n\n          if (aNoAnim)\n            this.setAttribute(\"noanim\", true);\n          this.hidden = true;\n\n          // 'focusContent()' iterates over all listeners in the chrome\n          // process, so we need to call it from here.\n          this.browser.finder.focusContent();\n          this.browser.finder.onFindbarClose();\n\n          this._cancelTimers();\n\n          this._findFailedString = null;\n        ]]></body>\n      </method>\n\n      <method name=\"clear\">\n        <body><![CDATA[\n          this.browser.finder.removeSelection();\n          this._findField.reset();\n          this.toggleHighlight(false);\n          this._updateStatusUI();\n          this._enableFindButtons(false);\n        ]]></body>\n      </method>\n\n      <method name=\"_dispatchKeypressEvent\">\n        <parameter name=\"aTarget\"/>\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!aTarget)\n            return;\n\n          let event = document.createEvent(\"KeyboardEvent\");\n          event.initKeyEvent(aEvent.type, aEvent.bubbles, aEvent.cancelable,\n                             aEvent.view, aEvent.ctrlKey, aEvent.altKey,\n                             aEvent.shiftKey, aEvent.metaKey, aEvent.keyCode,\n                             aEvent.charCode);\n          aTarget.dispatchEvent(event);\n        ]]></body>\n      </method>\n\n      <field name=\"_xulBrowserWindow\">null</field>\n      <method name=\"_updateStatusUIBar\">\n        <parameter name=\"aFoundURL\"/>\n        <body><![CDATA[\n          if (!this._xulBrowserWindow) {\n            try {\n              this._xulBrowserWindow =\n                window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)\n                      .getInterface(Components.interfaces.nsIWebNavigation)\n                      .QueryInterface(Components.interfaces.nsIDocShellTreeItem)\n                      .treeOwner\n                      .QueryInterface(Components.interfaces.nsIInterfaceRequestor)\n                      .getInterface(Components.interfaces.nsIXULWindow)\n                      .XULBrowserWindow;\n            } catch (ex) { }\n            if (!this._xulBrowserWindow)\n              return false;\n          }\n\n          // Call this has the same effect like hovering over link,\n          // the browser shows the URL as a tooltip.\n          this._xulBrowserWindow.setOverLink(aFoundURL || \"\", null);\n          return true;\n        ]]></body>\n      </method>\n\n      <method name=\"_finishFAYT\">\n        <parameter name=\"aKeypressEvent\"/>\n        <body><![CDATA[\n          this.browser.finder.focusContent();\n\n          if (aKeypressEvent)\n            aKeypressEvent.preventDefault();\n\n          this.browser.finder.keyPress(aKeypressEvent);\n\n          this.close();\n          return true;\n        ]]></body>\n      </method>\n\n      <method name=\"_shouldBeCaseSensitive\">\n        <parameter name=\"aString\"/>\n        <body><![CDATA[\n          if (this._typeAheadCaseSensitive == 0)\n            return false;\n          if (this._typeAheadCaseSensitive == 1)\n            return true;\n\n          return aString != aString.toLowerCase();\n        ]]></body>\n      </method>\n\n      <!-- We get a fake event object through an IPC message which contains the\n           data we need to make a decision. We then return |true| if and only if\n           the page gets to deal with the event itself. Everywhere we return\n           false, the message sender will take care of calling event.preventDefault\n           on the real event. -->\n      <method name=\"_onBrowserKeypress\">\n        <parameter name=\"aFakeEvent\"/>\n        <parameter name=\"aShouldFastFind\"/>\n        <body><![CDATA[\n          const FAYT_LINKS_KEY = \"'\";\n          const FAYT_TEXT_KEY = \"/\";\n\n          // Fast keypresses can stack up when the content process is slow or\n          // hangs when in e10s mode. We make sure the findbar isn't 'opened'\n          // several times in a row, because then the find query is selected\n          // each time, losing characters typed initially.\n          let inputField = this._findField.inputField;\n          if (!this.hidden && document.activeElement == inputField) {\n            this._dispatchKeypressEvent(inputField, aFakeEvent);\n            return false;\n          }\n\n          if (this._findMode != this.FIND_NORMAL && this._quickFindTimeout) {\n            if (!aFakeEvent.charCode)\n              return true;\n\n            this._findField.select();\n            this._findField.focus();\n            this._dispatchKeypressEvent(this._findField.inputField, aFakeEvent);\n            return false;\n          }\n\n          if (!aShouldFastFind)\n            return true;\n\n          let key = aFakeEvent.charCode ? String.fromCharCode(aFakeEvent.charCode) : null;\n          let manualstartFAYT = (key == FAYT_LINKS_KEY || key == FAYT_TEXT_KEY);\n          let autostartFAYT = !manualstartFAYT && this._findAsYouType &&\n                              key && key != \" \";\n          if (manualstartFAYT || autostartFAYT) {\n            let mode = (key == FAYT_LINKS_KEY ||\n                        (autostartFAYT && this._typeAheadLinksOnly)) ?\n              this.FIND_LINKS : this.FIND_TYPEAHEAD;\n\n            // Clear bar first, so that when openFindBar() calls setCaseSensitivity()\n            // it doesn't get confused by a lingering value\n            this._findField.value = \"\";\n\n            this.open(mode);\n            this._setFindCloseTimeout();\n            this._findField.select();\n            this._findField.focus();\n\n            if (autostartFAYT)\n              this._dispatchKeypressEvent(this._findField.inputField, aFakeEvent);\n            else\n              this._updateStatusUI(this.nsITypeAheadFind.FIND_FOUND);\n\n            return false;\n          }\n          return undefined;\n        ]]></body>\n      </method>\n\n      <!-- See nsIMessageListener -->\n      <method name=\"receiveMessage\">\n        <parameter name=\"aMessage\"/>\n        <body><![CDATA[\n          if (aMessage.target != this._browser) {\n            return undefined;\n          }\n          switch (aMessage.name) {\n            case \"Findbar:Mouseup\":\n              if (!this.hidden && this._findMode != this.FIND_NORMAL)\n                this.close();\n              break;\n\n            case \"Findbar:Keypress\":\n              return this._onBrowserKeypress(aMessage.data.fakeEvent,\n                                             aMessage.data.shouldFastFind);\n          }\n          return undefined;\n        ]]></body>\n      </method>\n\n      <method name=\"_updateBrowserWithState\">\n        <body><![CDATA[\n          if (this._browser && this._browser.messageManager) {\n            this._browser.messageManager.sendAsyncMessage(\"Findbar:UpdateState\", {\n              findMode: this._findMode\n            });\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_enableFindButtons\">\n        <parameter name=\"aEnable\"/>\n        <body><![CDATA[\n          this.getElement(\"find-next\").disabled =\n            this.getElement(\"find-previous\").disabled = !aEnable;\n        ]]></body>\n      </method>\n\n      <!--\n        - Determines whether minimalist or general-purpose search UI is to be\n        - displayed when the find bar is activated.\n        -->\n      <method name=\"_updateFindUI\">\n        <body><![CDATA[\n          let showMinimalUI = this._findMode != this.FIND_NORMAL;\n\n          let nodes = this.getElement(\"findbar-container\").childNodes;\n          let wrapper = this.getElement(\"findbar-textbox-wrapper\");\n          let foundMatches = this._foundMatches;\n          for (let node of nodes) {\n            if (node == wrapper || node == foundMatches)\n               continue;\n            node.hidden = showMinimalUI;\n          }\n          this.getElement(\"find-next\").hidden =\n            this.getElement(\"find-previous\").hidden = showMinimalUI;\n          foundMatches.hidden = showMinimalUI || !foundMatches.value;\n          this._updateCaseSensitivity();\n          this._setEntireWord();\n          this._setHighlightAll();\n\n          if (showMinimalUI)\n            this._findField.classList.add(\"minimal\");\n          else\n            this._findField.classList.remove(\"minimal\");\n\n          if (this._findMode == this.FIND_TYPEAHEAD)\n            this._findField.placeholder = this._fastFindStr;\n          else if (this._findMode == this.FIND_LINKS)\n            this._findField.placeholder = this._fastFindLinksStr;\n          else\n            this._findField.placeholder = this._normalFindStr;\n        ]]></body>\n      </method>\n\n      <method name=\"_find\">\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          if (!this._dispatchFindEvent(\"\"))\n            return;\n\n          let val = aValue || this._findField.value;\n\n          // We have to carry around an explicit version of this,\n          // because finder.searchString doesn't update on failed\n          // searches.\n          this.browser._lastSearchString = val;\n\n          // Only search on input if we don't have a last-failed string,\n          // or if the current search string doesn't start with it.\n          // In entire-word mode we always attemp a find; since sequential matching\n          // is not guaranteed, the first character typed may not be a word (no\n          // match), but the with the second character it may well be a word,\n          // thus a match.\n          if (!this._findFailedString ||\n              !val.startsWith(this._findFailedString) ||\n              this._entireWord) {\n            // Getting here means the user commanded a find op. Make sure any\n            // initial prefilling is ignored if it hasn't happened yet.\n            if (this._startFindDeferred) {\n              this._startFindDeferred.resolve();\n              this._startFindDeferred = null;\n            }\n\n            this._enableFindButtons(val);\n            this._updateCaseSensitivity(val);\n            this._setEntireWord();\n\n            this.browser.finder.fastFind(val, this._findMode == this.FIND_LINKS,\n                                         this._findMode != this.FIND_NORMAL);\n          }\n\n          if (this._findMode != this.FIND_NORMAL)\n            this._setFindCloseTimeout();\n\n          if (this._findResetTimeout != -1)\n            clearTimeout(this._findResetTimeout);\n\n          // allow a search to happen on input again after a second has\n          // expired since the previous input, to allow for dynamic\n          // content and/or page loading\n          this._findResetTimeout = setTimeout(() => {\n            this._findFailedString = null;\n            this._findResetTimeout = -1;\n          }, 1000);\n        ]]></body>\n      </method>\n\n      <method name=\"_flash\">\n        <body><![CDATA[\n          if (this._flashFindBarCount === undefined)\n            this._flashFindBarCount = this._initialFlashFindBarCount;\n\n          if (this._flashFindBarCount-- == 0) {\n            clearInterval(this._flashFindBarTimeout);\n            this.removeAttribute(\"flash\");\n            this._flashFindBarCount = 6;\n            return;\n          }\n\n          this.setAttribute(\"flash\",\n                            (this._flashFindBarCount % 2 == 0) ?\n                            \"false\" : \"true\");\n        ]]></body>\n      </method>\n\n      <method name=\"_findAgain\">\n        <parameter name=\"aFindPrevious\"/>\n        <body><![CDATA[\n          this.browser.finder.findAgain(aFindPrevious,\n                                        this._findMode == this.FIND_LINKS,\n                                        this._findMode != this.FIND_NORMAL);\n        ]]></body>\n      </method>\n\n      <method name=\"_updateStatusUI\">\n        <parameter name=\"res\"/>\n        <parameter name=\"aFindPrevious\"/>\n        <body><![CDATA[\n          switch (res) {\n            case this.nsITypeAheadFind.FIND_WRAPPED:\n              this._findStatusIcon.setAttribute(\"status\", \"wrapped\");\n              this._findStatusDesc.textContent =\n                aFindPrevious ? this._wrappedToBottomStr : this._wrappedToTopStr;\n              this._findField.removeAttribute(\"status\");\n              break;\n            case this.nsITypeAheadFind.FIND_NOTFOUND:\n              this._findStatusIcon.setAttribute(\"status\", \"notfound\");\n              this._findStatusDesc.textContent = this._notFoundStr;\n              this._findField.setAttribute(\"status\", \"notfound\");\n              break;\n            case this.nsITypeAheadFind.FIND_PENDING:\n              this._findStatusIcon.setAttribute(\"status\", \"pending\");\n              this._findStatusDesc.textContent = \"\";\n              this._findField.removeAttribute(\"status\");\n              break;\n            case this.nsITypeAheadFind.FIND_FOUND:\n            default:\n              this._findStatusIcon.removeAttribute(\"status\");\n              this._findStatusDesc.textContent = \"\";\n              this._findField.removeAttribute(\"status\");\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"updateControlState\">\n        <parameter name=\"aResult\"/>\n        <parameter name=\"aFindPrevious\"/>\n        <body><![CDATA[\n          this._updateStatusUI(aResult, aFindPrevious);\n          this._enableFindButtons(aResult !== this.nsITypeAheadFind.FIND_NOTFOUND &&\n            !!this._findField.value);\n        ]]></body>\n      </method>\n\n      <method name=\"_dispatchFindEvent\">\n        <parameter name=\"aType\"/>\n        <parameter name=\"aFindPrevious\"/>\n        <body><![CDATA[\n          let event = document.createEvent(\"CustomEvent\");\n          event.initCustomEvent(\"find\" + aType, true, true, {\n            query: this._findField.value,\n            caseSensitive: !!this._typeAheadCaseSensitive,\n            entireWord: this._entireWord,\n            highlightAll: this._highlightAll,\n            findPrevious: aFindPrevious\n          });\n          return this.dispatchEvent(event);\n        ]]></body>\n      </method>\n\n\n      <!--\n        - Opens the findbar, focuses the findfield and selects its contents.\n        - Also flashes the findbar the first time it's used.\n        - @param aMode\n        -        the find mode to be used, which is either FIND_NORMAL,\n        -        FIND_TYPEAHEAD or FIND_LINKS. If not passed, the last\n        -        find mode if any or FIND_NORMAL.\n        -->\n      <method name=\"startFind\">\n        <parameter name=\"aMode\"/>\n        <body><![CDATA[\n          let prefsvc = this._prefsvc;\n          let userWantsPrefill = true;\n          this.open(aMode);\n\n          if (this._flashFindBar) {\n            this._flashFindBarTimeout = setInterval(() => this._flash(), 500);\n            prefsvc.setIntPref(\"accessibility.typeaheadfind.flashBar\",\n                               --this._flashFindBar);\n          }\n\n          let {PromiseUtils} =\n            Components.utils.import(\"resource://gre/modules/PromiseUtils.jsm\", {});\n          this._startFindDeferred = PromiseUtils.defer();\n          let startFindPromise = this._startFindDeferred.promise;\n\n          if (this.prefillWithSelection)\n            userWantsPrefill =\n              prefsvc.getBoolPref(\"accessibility.typeaheadfind.prefillwithselection\");\n\n          if (this.prefillWithSelection && userWantsPrefill) {\n            // NB: We have to focus this._findField here so tests that send\n            // key events can open and close the find bar synchronously.\n            this._findField.focus();\n\n            // (e10s) since we focus lets also select it, otherwise that would\n            // only happen in this.onCurrentSelection and, because it is async,\n            // there's a chance keypresses could come inbetween, leading to\n            // jumbled up queries.\n            this._findField.select();\n\n            this.browser.finder.getInitialSelection();\n            return startFindPromise;\n          }\n\n          // If userWantsPrefill is false but prefillWithSelection is true,\n          // then we might need to check the selection clipboard. Call\n          // onCurrentSelection to do so.\n          // Note: this.onCurrentSelection clears this._startFindDeferred.\n          this.onCurrentSelection(\"\", true);\n          return startFindPromise;\n        ]]></body>\n      </method>\n\n      <!--\n        - Convenient alias to startFind(gFindBar.FIND_NORMAL);\n        -\n        - You should generally map the window's find command to this method.\n        -   e.g. <command name=\"cmd_find\" oncommand=\"gFindBar.onFindCommand();\"/>\n        -->\n      <method name=\"onFindCommand\">\n        <body><![CDATA[\n          return this.startFind(this.FIND_NORMAL);\n        ]]></body>\n      </method>\n\n      <!--\n        - Stub for find-next and find-previous commands\n        - @param aFindPrevious\n        -        true for find-previous, false otherwise.\n        -->\n      <method name=\"onFindAgainCommand\">\n        <parameter name=\"aFindPrevious\"/>\n        <body><![CDATA[\n          let findString = this._browser.finder.searchString || this._findField.value;\n          if (!findString)\n            return this.startFind();\n\n          // We dispatch the findAgain event here instead of in _findAgain since\n          // if there is a find event handler that prevents the default then\n          // finder.searchString will never get updated which in turn means\n          // there would never be findAgain events because of the logic below.\n          if (!this._dispatchFindEvent(\"again\", aFindPrevious))\n            return undefined;\n\n          // user explicitly requested another search, so do it even if we think it'll fail\n          this._findFailedString = null;\n\n          // Ensure the stored SearchString is in sync with what we want to find\n          if (this._findField.value != this._browser.finder.searchString) {\n            this._find(this._findField.value);\n          } else {\n            this._findAgain(aFindPrevious);\n            if (this._useModalHighlight) {\n              this.open();\n              this._findField.focus();\n            }\n          }\n\n          return undefined;\n        ]]></body>\n      </method>\n\n\n\n      <!--\n        - This handles all the result changes for both\n        - type-ahead-find and highlighting.\n        - @param aResult\n        -   One of the nsITypeAheadFind.FIND_* constants\n        -   indicating the result of a search operation.\n        - @param aFindBackwards\n        -   If the search was done from the bottom to\n        -   the top. This is used for right error messages\n        -   when reaching \"the end of the page\".\n        - @param aLinkURL\n        -   When a link matched then its URK. Always null\n        -   when not in FIND_LINKS mode.\n        -->\n      <method name=\"onFindResult\">\n        <parameter name=\"aData\"/>\n        <body><![CDATA[\n          if (aData.result == this.nsITypeAheadFind.FIND_NOTFOUND) {\n            // If an explicit Find Again command fails, re-open the toolbar.\n            if (aData.storeResult && this.open()) {\n              this._findField.select();\n              this._findField.focus();\n            }\n            this._findFailedString = aData.searchString;\n          } else {\n            this._findFailedString = null;\n          }\n\n          this._updateStatusUI(aData.result, aData.findBackwards);\n          this._updateStatusUIBar(aData.linkURL);\n\n          if (this._findMode != this.FIND_NORMAL)\n            this._setFindCloseTimeout();\n        ]]></body>\n      </method>\n\n      <!--\n        - This handles all the result changes for matches counts.\n        - @param aResult\n        -   Result Object, containing the total amount of matches and a vector\n        -   of the current result.\n        -->\n      <method name=\"onMatchesCountResult\">\n        <parameter name=\"aResult\"/>\n        <body><![CDATA[\n          if (aResult.total !== 0) {\n            if (aResult.total == -1) {\n              this._foundMatches.value = this.pluralForm.get(\n                aResult.limit,\n                this.strBundle.GetStringFromName(\"FoundMatchesCountLimit\")\n              ).replace(\"#1\", aResult.limit);\n            } else {\n              this._foundMatches.value = this.pluralForm.get(\n                aResult.total,\n                this.strBundle.GetStringFromName(\"FoundMatches\")\n              ).replace(\"#1\", aResult.current)\n               .replace(\"#2\", aResult.total);\n            }\n            this._foundMatches.hidden = false;\n          } else {\n            this._foundMatches.hidden = true;\n            this._foundMatches.value = \"\";\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onHighlightFinished\">\n        <parameter name=\"result\"/>\n        <body><![CDATA[\n          // Noop.\n        ]]></body>\n      </method>\n\n      <method name=\"onCurrentSelection\">\n        <parameter name=\"aSelectionString\" />\n        <parameter name=\"aIsInitialSelection\" />\n        <body><![CDATA[\n          // Ignore the prefill if the user has already typed in the findbar,\n          // it would have been overwritten anyway. See bug 1198465.\n          if (aIsInitialSelection && !this._startFindDeferred)\n            return;\n\n          if (/Mac/.test(navigator.platform) && aIsInitialSelection && !aSelectionString) {\n            let clipboardSearchString = this.browser.finder.clipboardSearchString;\n            if (clipboardSearchString)\n              aSelectionString = clipboardSearchString;\n          }\n\n          if (aSelectionString)\n            this._findField.value = aSelectionString;\n\n          if (aIsInitialSelection) {\n            this._enableFindButtons(!!this._findField.value);\n            this._findField.select();\n            this._findField.focus();\n\n            this._startFindDeferred.resolve();\n            this._startFindDeferred = null;\n          }\n        ]]></body>\n      </method>\n\n      <!--\n        - This handler may cancel a request to focus content by returning |false|\n        - explicitly.\n        -->\n      <method name=\"shouldFocusContent\">\n        <body><![CDATA[\n          const fm = Components.classes[\"@mozilla.org/focus-manager;1\"]\n                               .getService(Components.interfaces.nsIFocusManager);\n          if (fm.focusedWindow != window)\n            return false;\n\n          let focusedElement = fm.focusedElement;\n          if (!focusedElement)\n            return false;\n\n          let bindingParent = document.getBindingParent(focusedElement);\n          if (bindingParent != this && bindingParent != this._findField)\n            return false;\n\n          return true;\n        ]]></body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <!--\n        - We have to guard against `this.close` being |null| due to an unknown\n        - issue, which is tracked in bug 957999.\n        -->\n      <handler event=\"keypress\" keycode=\"VK_ESCAPE\" phase=\"capturing\"\n               action=\"if (this.close) this.close();\" preventdefault=\"true\"/>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"general.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"generalBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"basecontrol\">\n    <implementation implements=\"nsIDOMXULControlElement\">\n      <!-- public implementation -->\n      <property name=\"disabled\" onset=\"if (val) this.setAttribute('disabled', 'true');\n                                       else this.removeAttribute('disabled');\n                                       return val;\"\n                                onget=\"return this.getAttribute('disabled') == 'true';\"/>\n      <property name=\"tabIndex\" onget=\"return parseInt(this.getAttribute('tabindex')) || 0\"\n                                onset=\"if (val) this.setAttribute('tabindex', val);\n                                       else this.removeAttribute('tabindex'); return val;\"/>\n    </implementation>\n  </binding>\n\n  <binding id=\"basetext\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <implementation implements=\"nsIDOMXULLabeledControlElement\">\n      <!-- public implementation -->\n      <property name=\"label\"      onset=\"this.setAttribute('label',val); return val;\"\n                                  onget=\"return this.getAttribute('label');\"/>\n      <property name=\"crop\"       onset=\"this.setAttribute('crop',val); return val;\"\n                                  onget=\"return this.getAttribute('crop');\"/>\n      <property name=\"image\"      onset=\"this.setAttribute('image',val); return val;\"\n                                  onget=\"return this.getAttribute('image');\"/>\n      <property name=\"command\"    onset=\"this.setAttribute('command',val); return val;\"\n                                  onget=\"return this.getAttribute('command');\"/>\n      <property name=\"accessKey\">\n        <getter>\n          <![CDATA[\n            return this.labelElement ? this.labelElement.accessKey : this.getAttribute(\"accesskey\");\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            // Always store on the control\n            this.setAttribute(\"accesskey\", val);\n            // If there is a label, change the accesskey on the labelElement\n            // if it's also set there\n            if (this.labelElement) {\n              this.labelElement.accessKey = val;\n            }\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <field name=\"labelElement\"/>\n    </implementation>      \n  </binding>\n\n  <binding id=\"control-item\" extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <implementation>\n      <property name=\"value\"      onset=\"this.setAttribute('value', val); return val;\"\n                                  onget=\"return this.getAttribute('value');\"/>\n    </implementation>\n  </binding>\n\n  <binding id=\"root-element\">\n    <implementation>\n      <field name=\"_lightweightTheme\">null</field>\n      <constructor><![CDATA[\n        if (this.hasAttribute(\"lightweightthemes\")) {\n          let temp = {};\n          Components.utils.import(\"resource://gre/modules/LightweightThemeConsumer.jsm\", temp);\n          this._lightweightTheme = new temp.LightweightThemeConsumer(this.ownerDocument);\n        }\n      ]]></constructor>\n      <destructor><![CDATA[\n        if (this._lightweightTheme) {\n          this._lightweightTheme.destroy();\n          this._lightweightTheme = null;\n        }\n      ]]></destructor>\n    </implementation>\n  </binding>\n\n  <binding id=\"iframe\" role=\"outerdoc\">\n    <implementation>\n      <property name=\"docShell\" readonly=\"true\">\n        <getter><![CDATA[\n          let {frameLoader} = this;\n          return frameLoader ? frameLoader.docShell : null;\n        ]]></getter>\n      </property>\n      <property name=\"contentWindow\"\n                readonly=\"true\"\n                onget=\"return this.docShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindow);\"/>\n      <property name=\"webNavigation\"\n                onget=\"return this.docShell.QueryInterface(Components.interfaces.nsIWebNavigation);\"\n                readonly=\"true\"/>\n      <property name=\"contentDocument\" readonly=\"true\"\n                onget=\"return this.webNavigation.document;\"/>\n    </implementation>\n  </binding>\n\n  <binding id=\"statusbarpanel\" display=\"xul:button\">\n    <content>\n      <children>\n        <xul:label class=\"statusbarpanel-text\" xbl:inherits=\"value=label,crop\" crop=\"right\" flex=\"1\"/>\n      </children>\n    </content>\n\n    <implementation>\n      <property name=\"label\"\n                onget=\"return this.getAttribute('label');\"\n                onset=\"this.setAttribute('label',val); return val;\"/>\n      <property name=\"image\"\n                onget=\"return this.getAttribute('image');\"\n                onset=\"this.setAttribute('image',val); return val;\"/>\n      <property name=\"src\"\n                onget=\"return this.getAttribute('src');\"\n                onset=\"this.setAttribute('src',val); return val;\"/>\n    </implementation>\n  </binding>\n\n  <binding id=\"statusbarpanel-menu-iconic\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/general.xml#statusbarpanel\">\n    <content>\n      <xul:image class=\"statusbarpanel-icon\" xbl:inherits=\"src,src=image\"/>\n      <children/>\n    </content>\n  </binding>\n\n  <binding id=\"statusbar\" role=\"xul:statusbar\">\n    <content>\n      <children/>\n      <xul:statusbarpanel class=\"statusbar-resizerpanel\">\n        <xul:resizer dir=\"bottomend\"/>\n      </xul:statusbarpanel>\n    </content>\n  </binding>\n\n  <binding id=\"statusbarpanel-iconic\" display=\"xul:button\" role=\"xul:button\"\n           extends=\"chrome://global/content/bindings/general.xml#statusbarpanel\">\n    <content>\n      <xul:image class=\"statusbarpanel-icon\" xbl:inherits=\"src,src=image\"/>\n    </content>\n  </binding>\n\n  <binding id=\"statusbarpanel-iconic-text\" display=\"xul:button\" role=\"xul:button\"\n           extends=\"chrome://global/content/bindings/general.xml#statusbarpanel\">\n    <content>\n      <xul:image class=\"statusbarpanel-icon\" xbl:inherits=\"src,src=image\"/>\n      <xul:label class=\"statusbarpanel-text\" xbl:inherits=\"value=label,crop\"/>\n    </content>\n  </binding>\n\n  <binding id=\"image\" role=\"xul:image\">\n    <implementation implements=\"nsIDOMXULImageElement\">\n      <property name=\"src\"\n                onget=\"return this.getAttribute('src');\"\n                onset=\"this.setAttribute('src',val); return val;\"/>\n    </implementation>\n  </binding>\n\n  <binding id=\"deck\">\n    <implementation>\n      <property name=\"selectedIndex\"\n                onget=\"return this.getAttribute('selectedIndex') || '0'\">\n        <setter>\n        <![CDATA[\n          if (this.selectedIndex == val)\n            return val;\n          this.setAttribute(\"selectedIndex\", val);\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"select\", true, true);\n          this.dispatchEvent(event);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedPanel\">\n        <getter>\n          <![CDATA[\n            return this.childNodes[this.selectedIndex];\n          ]]>\n        </getter>\n\n        <setter>\n          <![CDATA[\n            var selectedIndex = -1;\n            for (var panel = val; panel != null; panel = panel.previousSibling)\n              ++selectedIndex;\n            this.selectedIndex = selectedIndex;\n            return val;\n          ]]>\n        </setter>\n      </property>\n    </implementation>\n  </binding>\n\n  <binding id=\"dropmarker\" extends=\"xul:button\" role=\"xul:dropmarker\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/dropmarker.css\"/>\n    </resources>\n\n    <content>\n      <xul:image class=\"dropmarker-icon\"/>\n    </content>\n  </binding>\n\n  <binding id=\"windowdragbox\">\n    <implementation>\n      <field name=\"_dragBindingAlive\">true</field>\n      <constructor>\n        if (!this._draggableStarted) {\n          this._draggableStarted = true;\n          try {\n            let tmp = {};\n            Components.utils.import(\"resource://gre/modules/WindowDraggingUtils.jsm\", tmp);\n            let draghandle = new tmp.WindowDraggingElement(this);\n            draghandle.mouseDownCheck = function() {\n              return this._dragBindingAlive;\n            };\n          } catch (e) {}\n        }\n      </constructor>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"groupbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"groupboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"groupbox-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/groupbox.css\"/>\n    </resources>\n  </binding>\n\n  <binding id=\"groupbox\" role=\"xul:groupbox\"\n    extends=\"chrome://global/content/bindings/groupbox.xml#groupbox-base\">\n    <content>\n      <xul:hbox class=\"groupbox-title\" align=\"center\" pack=\"start\">\n        <children includes=\"caption\"/>\n      </xul:hbox>\n      <xul:box flex=\"1\" class=\"groupbox-body\" xbl:inherits=\"orient,align,pack\">\n        <children/>\n      </xul:box>\n    </content>\n  </binding>\n\n  <binding id=\"caption\" extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/groupbox.css\"/>\n    </resources>\n    \n    <content>\n      <children>\n        <xul:image class=\"caption-icon\" xbl:inherits=\"src=image\"/>\n        <xul:label class=\"caption-text\" flex=\"1\"\n                   xbl:inherits=\"default,value=label,crop,accesskey\"/>\n      </children>\n    </content>\n  </binding>\n\n</bindings>\n"},{"file":"listbox.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This files relies on these specific Chrome/XBL globals -->\n<!-- globals ChromeNodeList -->\n\n<bindings id=\"listboxBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <!--\n    Interface binding that is base for bindings of xul:listbox and\n    xul:richlistbox elements. This binding assumes that successors bindings\n    will implement the following properties and methods:\n\n    /** Return the number of items */\n    readonly itemCount\n\n    /** Return index of given item\n    * @param aItem - given item element */\n    getIndexOfItem(aItem)\n\n    /** Return item at given index\n    * @param aIndex - index of item element */\n    getItemAtIndex(aIndex)\n\n    /** Return count of item elements */\n    getRowCount()\n\n    /** Return count of visible item elements */\n    getNumberOfVisibleRows()\n\n    /** Return index of first visible item element */\n    getIndexOfFirstVisibleRow()\n\n    /** Return true if item of given index is visible\n     * @param aIndex - index of item element\n     *\n     * @note XXX: this method should be removed after bug 364612 is fixed\n     */\n    ensureIndexIsVisible(aIndex)\n\n    /** Return true if item element is visible\n     * @param aElement - given item element */\n    ensureElementIsVisible(aElement)\n\n    /** Scroll list control to make visible item of given index\n     * @param aIndex - index of item element\n     *\n     * @note XXX: this method should be removed after bug 364612 is fixed\n     */\n    scrollToIndex(aIndex)\n\n    /** Create item element and append it to the end of listbox\n     * @param aLabel - label of new item element\n     * @param aValue - value of new item element */\n    appendItem(aLabel, aValue)\n\n    /** Create item element and insert it to given position\n     * @param aIndex - insertion position\n     * @param aLabel - label of new item element\n     * @param aValue - value of new item element */\n    insertItemAt(aIndex, aLabel, aValue)\n\n    /** Scroll up/down one page\n     * @param aDirection - specifies scrolling direction, should be either -1 or 1\n     * @return the number of elements the selection scrolled\n     */\n    scrollOnePage(aDirection)\n\n    /** Fire \"select\" event */\n    _fireOnSelect()\n   -->\n   <binding id=\"listbox-base\" role=\"xul:listbox\"\n            extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n\n    <implementation implements=\"nsIDOMXULMultiSelectControlElement\">\n      <field name=\"_lastKeyTime\">0</field>\n      <field name=\"_incrementalString\">\"\"</field>\n\n    <!-- nsIDOMXULSelectControlElement -->\n      <property name=\"selectedItem\"\n                onset=\"this.selectItem(val);\">\n        <getter>\n        <![CDATA[\n          return this.selectedItems.length > 0 ? this.selectedItems[0] : null;\n        ]]>\n        </getter>\n      </property>\n\n      <property name=\"selectedIndex\">\n        <getter>\n        <![CDATA[\n          if (this.selectedItems.length > 0)\n            return this.getIndexOfItem(this.selectedItems[0]);\n          return -1;\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          if (val >= 0) {\n            // This is a micro-optimization so that a call to getIndexOfItem or\n            // getItemAtIndex caused by _fireOnSelect (especially for derived\n            // widgets) won't loop the children.\n            this._selecting = {\n              item: this.getItemAtIndex(val),\n              index: val\n            };\n            this.selectItem(this._selecting.item);\n            delete this._selecting;\n          } else {\n            this.clearSelection();\n            this.currentItem = null;\n          }\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"value\">\n        <getter>\n        <![CDATA[\n          if (this.selectedItems.length > 0)\n            return this.selectedItem.value;\n          return null;\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          var kids = this.getElementsByAttribute(\"value\", val);\n          if (kids && kids.item(0))\n            this.selectItem(kids[0]);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"removeItemAt\">\n        <parameter name=\"index\"/>\n        <body>\n        <![CDATA[\n          var remove = this.getItemAtIndex(index);\n          if (remove)\n            this.removeChild(remove);\n          return remove;\n        ]]>\n        </body>\n      </method>\n\n    <!-- nsIDOMXULMultiSelectControlElement -->\n      <property name=\"selType\"\n                onget=\"return this.getAttribute('seltype');\"\n                onset=\"this.setAttribute('seltype', val); return val;\"/>\n\n      <property name=\"currentItem\" onget=\"return this._currentItem;\">\n        <setter>\n          if (this._currentItem == val)\n            return val;\n\n          if (this._currentItem)\n            this._currentItem.current = false;\n          this._currentItem = val;\n\n          if (val)\n            val.current = true;\n\n          return val;\n        </setter>\n      </property>\n\n      <property name=\"currentIndex\">\n        <getter>\n          return this.currentItem ? this.getIndexOfItem(this.currentItem) : -1;\n        </getter>\n        <setter>\n        <![CDATA[\n          if (val >= 0)\n            this.currentItem = this.getItemAtIndex(val);\n          else\n            this.currentItem = null;\n        ]]>\n        </setter>\n      </property>\n\n      <field name=\"selectedItems\">new ChromeNodeList()</field>\n\n      <method name=\"addItemToSelection\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          if (this.selType != \"multiple\" && this.selectedCount)\n            return;\n\n          if (aItem.selected)\n            return;\n\n          this.selectedItems.append(aItem);\n          aItem.selected = true;\n\n          this._fireOnSelect();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"removeItemFromSelection\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          if (!aItem.selected)\n            return;\n\n          this.selectedItems.remove(aItem);\n          aItem.selected = false;\n          this._fireOnSelect();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"toggleItemSelection\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          if (aItem.selected)\n            this.removeItemFromSelection(aItem);\n          else\n            this.addItemToSelection(aItem);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"selectItem\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          if (!aItem)\n            return;\n\n          if (this.selectedItems.length == 1 && this.selectedItems[0] == aItem)\n            return;\n\n          this._selectionStart = null;\n\n          var suppress = this._suppressOnSelect;\n          this._suppressOnSelect = true;\n\n          this.clearSelection();\n          this.addItemToSelection(aItem);\n          this.currentItem = aItem;\n\n          this._suppressOnSelect = suppress;\n          this._fireOnSelect();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"selectItemRange\">\n        <parameter name=\"aStartItem\"/>\n        <parameter name=\"aEndItem\"/>\n        <body>\n        <![CDATA[\n          if (this.selType != \"multiple\")\n            return;\n\n          if (!aStartItem)\n            aStartItem = this._selectionStart ?\n              this._selectionStart : this.currentItem;\n\n          if (!aStartItem)\n            aStartItem = aEndItem;\n\n          var suppressSelect = this._suppressOnSelect;\n          this._suppressOnSelect = true;\n\n          this._selectionStart = aStartItem;\n\n          var currentItem;\n          var startIndex = this.getIndexOfItem(aStartItem);\n          var endIndex = this.getIndexOfItem(aEndItem);\n          if (endIndex < startIndex) {\n            currentItem = aEndItem;\n            aEndItem = aStartItem;\n            aStartItem = currentItem;\n          } else {\n            currentItem = aStartItem;\n          }\n\n          while (currentItem) {\n            this.addItemToSelection(currentItem);\n            if (currentItem == aEndItem) {\n              currentItem = this.getNextItem(currentItem, 1);\n              break;\n            }\n            currentItem = this.getNextItem(currentItem, 1);\n          }\n\n          // Clear around new selection\n          // Don't use clearSelection() because it causes a lot of noise\n          // with respect to selection removed notifications used by the\n          // accessibility API support.\n          var userSelecting = this._userSelecting;\n          this._userSelecting = false; // that's US automatically unselecting\n          for (; currentItem; currentItem = this.getNextItem(currentItem, 1))\n            this.removeItemFromSelection(currentItem);\n\n          for (currentItem = this.getItemAtIndex(0); currentItem != aStartItem;\n               currentItem = this.getNextItem(currentItem, 1))\n            this.removeItemFromSelection(currentItem);\n          this._userSelecting = userSelecting;\n\n          this._suppressOnSelect = suppressSelect;\n\n          this._fireOnSelect();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"selectAll\">\n        <body>\n          this._selectionStart = null;\n\n          var suppress = this._suppressOnSelect;\n          this._suppressOnSelect = true;\n\n          var item = this.getItemAtIndex(0);\n          while (item) {\n            this.addItemToSelection(item);\n            item = this.getNextItem(item, 1);\n          }\n\n          this._suppressOnSelect = suppress;\n          this._fireOnSelect();\n        </body>\n      </method>\n\n      <method name=\"invertSelection\">\n        <body>\n          this._selectionStart = null;\n\n          var suppress = this._suppressOnSelect;\n          this._suppressOnSelect = true;\n\n          var item = this.getItemAtIndex(0);\n          while (item) {\n            if (item.selected)\n              this.removeItemFromSelection(item);\n            else\n              this.addItemToSelection(item);\n            item = this.getNextItem(item, 1);\n          }\n\n          this._suppressOnSelect = suppress;\n          this._fireOnSelect();\n        </body>\n      </method>\n\n      <method name=\"clearSelection\">\n        <body>\n        <![CDATA[\n          if (this.selectedItems) {\n            while (this.selectedItems.length > 0) {\n              let item = this.selectedItems[0];\n              item.selected = false;\n              this.selectedItems.remove(item);\n            }\n          }\n\n          this._selectionStart = null;\n          this._fireOnSelect();\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"selectedCount\" readonly=\"true\"\n                onget=\"return this.selectedItems.length;\"/>\n\n      <method name=\"getSelectedItem\">\n        <parameter name=\"aIndex\"/>\n        <body>\n        <![CDATA[\n          return aIndex < this.selectedItems.length ?\n            this.selectedItems[aIndex] : null;\n        ]]>\n        </body>\n      </method>\n\n    <!-- Other public members -->\n      <property name=\"disableKeyNavigation\"\n                onget=\"return this.hasAttribute('disableKeyNavigation');\">\n        <setter>\n          if (val)\n            this.setAttribute(\"disableKeyNavigation\", \"true\");\n          else\n            this.removeAttribute(\"disableKeyNavigation\");\n          return val;\n        </setter>\n      </property>\n\n      <property name=\"suppressOnSelect\"\n                onget=\"return this.getAttribute('suppressonselect') == 'true';\"\n                onset=\"this.setAttribute('suppressonselect', val);\"/>\n\n      <property name=\"_selectDelay\"\n                onset=\"this.setAttribute('_selectDelay', val);\"\n                onget=\"return this.getAttribute('_selectDelay') || 50;\"/>\n\n      <method name=\"timedSelect\">\n        <parameter name=\"aItem\"/>\n        <parameter name=\"aTimeout\"/>\n        <body>\n        <![CDATA[\n          var suppress = this._suppressOnSelect;\n          if (aTimeout != -1)\n            this._suppressOnSelect = true;\n\n          this.selectItem(aItem);\n\n          this._suppressOnSelect = suppress;\n\n          if (aTimeout != -1) {\n            if (this._selectTimeout)\n              window.clearTimeout(this._selectTimeout);\n            this._selectTimeout =\n              window.setTimeout(this._selectTimeoutHandler, aTimeout, this);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"moveByOffset\">\n        <parameter name=\"aOffset\"/>\n        <parameter name=\"aIsSelecting\"/>\n        <parameter name=\"aIsSelectingRange\"/>\n        <body>\n        <![CDATA[\n          if ((aIsSelectingRange || !aIsSelecting) &&\n              this.selType != \"multiple\")\n            return;\n\n          var newIndex = this.currentIndex + aOffset;\n          if (newIndex < 0)\n            newIndex = 0;\n\n          var numItems = this.getRowCount();\n          if (newIndex > numItems - 1)\n            newIndex = numItems - 1;\n\n          var newItem = this.getItemAtIndex(newIndex);\n          // make sure that the item is actually visible/selectable\n          if (this._userSelecting && newItem && !this._canUserSelect(newItem))\n            newItem =\n              aOffset > 0 ? this.getNextItem(newItem, 1) || this.getPreviousItem(newItem, 1) :\n                            this.getPreviousItem(newItem, 1) || this.getNextItem(newItem, 1);\n          if (newItem) {\n            this.ensureIndexIsVisible(this.getIndexOfItem(newItem));\n            if (aIsSelectingRange)\n              this.selectItemRange(null, newItem);\n            else if (aIsSelecting)\n              this.selectItem(newItem);\n\n            this.currentItem = newItem;\n          }\n        ]]>\n        </body>\n      </method>\n\n    <!-- Private -->\n      <method name=\"getNextItem\">\n        <parameter name=\"aStartItem\"/>\n        <parameter name=\"aDelta\"/>\n        <body>\n        <![CDATA[\n          while (aStartItem) {\n            aStartItem = aStartItem.nextSibling;\n            if (aStartItem && aStartItem instanceof\n                Components.interfaces.nsIDOMXULSelectControlItemElement &&\n                (!this._userSelecting || this._canUserSelect(aStartItem))) {\n              --aDelta;\n              if (aDelta == 0)\n                return aStartItem;\n            }\n          }\n          return null;\n        ]]></body>\n      </method>\n\n      <method name=\"getPreviousItem\">\n        <parameter name=\"aStartItem\"/>\n        <parameter name=\"aDelta\"/>\n        <body>\n        <![CDATA[\n          while (aStartItem) {\n            aStartItem = aStartItem.previousSibling;\n            if (aStartItem && aStartItem instanceof\n                Components.interfaces.nsIDOMXULSelectControlItemElement &&\n                (!this._userSelecting || this._canUserSelect(aStartItem))) {\n              --aDelta;\n              if (aDelta == 0)\n                return aStartItem;\n            }\n          }\n          return null;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByOffsetFromUserEvent\">\n        <parameter name=\"aOffset\"/>\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          if (!aEvent.defaultPrevented) {\n            this._userSelecting = true;\n            this._mayReverse = true;\n            this.moveByOffset(aOffset, !aEvent.ctrlKey, aEvent.shiftKey);\n            this._userSelecting = false;\n            this._mayReverse = false;\n            aEvent.preventDefault();\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_canUserSelect\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          var style = document.defaultView.getComputedStyle(aItem);\n          return style.display != \"none\" && style.visibility == \"visible\";\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_selectTimeoutHandler\">\n        <parameter name=\"aMe\"/>\n        <body>\n          aMe._fireOnSelect();\n          aMe._selectTimeout = null;\n        </body>\n      </method>\n\n      <field name=\"_suppressOnSelect\">false</field>\n      <field name=\"_userSelecting\">false</field>\n      <field name=\"_mayReverse\">false</field>\n      <field name=\"_selectTimeout\">null</field>\n      <field name=\"_currentItem\">null</field>\n      <field name=\"_selectionStart\">null</field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"control shift any\"\n               action=\"this._moveByOffsetFromUserEvent(-1, event);\"\n               group=\"system\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"control shift any\"\n               action=\"this._moveByOffsetFromUserEvent(1, event);\"\n               group=\"system\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control shift any\"\n               group=\"system\">\n        <![CDATA[\n          this._mayReverse = true;\n          this._moveByOffsetFromUserEvent(-this.currentIndex, event);\n          this._mayReverse = false;\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control shift any\"\n               group=\"system\">\n        <![CDATA[\n          this._mayReverse = true;\n          this._moveByOffsetFromUserEvent(this.getRowCount() - this.currentIndex - 1, event);\n          this._mayReverse = false;\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"control shift any\"\n               group=\"system\">\n        <![CDATA[\n          this._mayReverse = true;\n          this._moveByOffsetFromUserEvent(this.scrollOnePage(-1), event);\n          this._mayReverse = false;\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"control shift any\"\n               group=\"system\">\n        <![CDATA[\n          this._mayReverse = true;\n          this._moveByOffsetFromUserEvent(this.scrollOnePage(1), event);\n          this._mayReverse = false;\n        ]]>\n      </handler>\n      <handler event=\"keypress\" key=\" \" modifiers=\"control\" phase=\"target\">\n      <![CDATA[\n        if (this.currentItem && this.selType == \"multiple\")\n          this.toggleItemSelection(this.currentItem);\n      ]]>\n      </handler>\n      <handler event=\"focus\">\n      <![CDATA[\n        if (this.getRowCount() > 0) {\n          if (this.currentIndex == -1) {\n            this.currentIndex = this.getIndexOfFirstVisibleRow();\n          } else {\n            this.currentItem._fireEvent(\"DOMMenuItemActive\");\n          }\n        }\n        this._lastKeyTime = 0;\n      ]]>\n      </handler>\n      <handler event=\"keypress\" phase=\"target\">\n      <![CDATA[\n        if (this.disableKeyNavigation || !event.charCode ||\n            event.altKey || event.ctrlKey || event.metaKey)\n          return;\n\n        if (event.timeStamp - this._lastKeyTime > 1000)\n          this._incrementalString = \"\";\n\n        var key = String.fromCharCode(event.charCode).toLowerCase();\n        this._incrementalString += key;\n        this._lastKeyTime = event.timeStamp;\n\n        // If all letters in the incremental string are the same, just\n        // try to match the first one\n        var incrementalString = /^(.)\\1+$/.test(this._incrementalString) ?\n                                RegExp.$1 : this._incrementalString;\n        var length = incrementalString.length;\n\n        var rowCount = this.getRowCount();\n        var l = this.selectedItems.length;\n        var start = l > 0 ? this.getIndexOfItem(this.selectedItems[l - 1]) : -1;\n        // start from the first element if none was selected or from the one\n        // following the selected one if it's a new or a repeated-letter search\n        if (start == -1 || length == 1)\n          start++;\n\n        for (var i = 0; i < rowCount; i++) {\n          var k = (start + i) % rowCount;\n          var listitem = this.getItemAtIndex(k);\n          if (!this._canUserSelect(listitem))\n            continue;\n          // allow richlistitems to specify the string being searched for\n          var searchText = \"searchLabel\" in listitem ? listitem.searchLabel :\n                           listitem.getAttribute(\"label\"); // (see also bug 250123)\n          searchText = searchText.substring(0, length).toLowerCase();\n          if (searchText == incrementalString) {\n            this.ensureIndexIsVisible(k);\n            this.timedSelect(listitem, this._selectDelay);\n            break;\n          }\n        }\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n\n  <!-- Binding for xul:listbox element.\n  -->\n  <binding id=\"listbox\"\n           extends=\"#listbox-base\">\n\n    <resources>\n      <stylesheet src=\"chrome://global/skin/listbox.css\"/>\n    </resources>\n\n    <content>\n      <children includes=\"listcols\">\n        <xul:listcols>\n          <xul:listcol flex=\"1\"/>\n        </xul:listcols>\n      </children>\n      <xul:listrows>\n        <children includes=\"listhead\"/>\n        <xul:listboxbody xbl:inherits=\"rows,size,minheight\">\n          <children includes=\"listitem\"/>\n        </xul:listboxbody>\n      </xul:listrows>\n    </content>\n\n    <implementation>\n\n      <!-- ///////////////// public listbox members ///////////////// -->\n\n      <property name=\"listBoxObject\"\n                onget=\"return this.boxObject;\"\n                readonly=\"true\"/>\n\n      <!-- ///////////////// private listbox members ///////////////// -->\n\n      <field name=\"_touchY\">-1</field>\n\n      <method name=\"_fireOnSelect\">\n        <body>\n        <![CDATA[\n          if (!this._suppressOnSelect && !this.suppressOnSelect) {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"select\", true, true);\n            this.dispatchEvent(event);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <constructor>\n      <![CDATA[\n        var count = this.itemCount;\n        for (var index = 0; index < count; index++) {\n          var item = this.getItemAtIndex(index);\n          if (item.getAttribute(\"selected\") == \"true\")\n            this.selectedItems.append(item);\n        }\n      ]]>\n      </constructor>\n\n      <!-- ///////////////// nsIDOMXULSelectControlElement ///////////////// -->\n\n      <method name=\"appendItem\">\n        <parameter name=\"aLabel\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n          const XULNS =\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\n          var item = this.ownerDocument.createElementNS(XULNS, \"listitem\");\n          item.setAttribute(\"label\", aLabel);\n          item.setAttribute(\"value\", aValue);\n          this.appendChild(item);\n          return item;\n        </body>\n      </method>\n\n      <method name=\"insertItemAt\">\n        <parameter name=\"aIndex\"/>\n        <parameter name=\"aLabel\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n          const XULNS =\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\n          var item = this.ownerDocument.createElementNS(XULNS, \"listitem\");\n          item.setAttribute(\"label\", aLabel);\n          item.setAttribute(\"value\", aValue);\n          var before = this.getItemAtIndex(aIndex);\n          if (before)\n            this.insertBefore(item, before);\n          else\n            this.appendChild(item);\n          return item;\n        </body>\n      </method>\n\n      <property name=\"itemCount\" readonly=\"true\"\n                onget=\"return this.listBoxObject.getRowCount()\"/>\n\n      <!-- ///////////////// nsIListBoxObject ///////////////// -->\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"item\"/>\n        <body>\n          <![CDATA[\n            if (this._selecting && this._selecting.item == item)\n              return this._selecting.index;\n            return this.listBoxObject.getIndexOfItem(item);\n          ]]>\n        </body>\n      </method>\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"index\"/>\n        <body>\n          <![CDATA[\n            if (this._selecting && this._selecting.index == index)\n              return this._selecting.item;\n            return this.listBoxObject.getItemAtIndex(index);\n          ]]>\n        </body>\n      </method>\n      <method name=\"ensureIndexIsVisible\">\n        <parameter name=\"index\"/>\n        <body>\n          return this.listBoxObject.ensureIndexIsVisible(index);\n        </body>\n      </method>\n      <method name=\"ensureElementIsVisible\">\n        <parameter name=\"element\"/>\n        <body>\n          return this.ensureIndexIsVisible(this.listBoxObject.getIndexOfItem(element));\n        </body>\n      </method>\n      <method name=\"scrollToIndex\">\n        <parameter name=\"index\"/>\n        <body>\n          return this.listBoxObject.scrollToIndex(index);\n        </body>\n      </method>\n      <method name=\"getNumberOfVisibleRows\">\n        <body>\n          return this.listBoxObject.getNumberOfVisibleRows();\n        </body>\n      </method>\n      <method name=\"getIndexOfFirstVisibleRow\">\n        <body>\n          return this.listBoxObject.getIndexOfFirstVisibleRow();\n        </body>\n      </method>\n      <method name=\"getRowCount\">\n        <body>\n          return this.listBoxObject.getRowCount();\n        </body>\n      </method>\n\n      <method name=\"scrollOnePage\">\n        <parameter name=\"direction\"/>  <!-- Must be -1 or 1 -->\n        <body>\n          <![CDATA[\n            var pageOffset = this.getNumberOfVisibleRows() * direction;\n            // skip over invisible elements - the user won't care about them\n            for (var i = 0; i != pageOffset; i += direction) {\n              var item = this.getItemAtIndex(this.currentIndex + i);\n              if (item && !this._canUserSelect(item))\n                pageOffset += direction;\n            }\n            var newTop = this.getIndexOfFirstVisibleRow() + pageOffset;\n            if (direction == 1) {\n              var maxTop = this.getRowCount() - this.getNumberOfVisibleRows();\n              for (i = this.getRowCount(); i >= 0 && i > maxTop; i--) {\n                item = this.getItemAtIndex(i);\n                if (item && !this._canUserSelect(item))\n                  maxTop--;\n              }\n              if (newTop >= maxTop)\n                newTop = maxTop;\n            }\n            if (newTop < 0)\n              newTop = 0;\n            this.scrollToIndex(newTop);\n            return pageOffset;\n          ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" key=\" \" phase=\"target\">\n        <![CDATA[\n          if (this.currentItem) {\n            if (this.currentItem.getAttribute(\"type\") != \"checkbox\") {\n              this.addItemToSelection(this.currentItem);\n              // Prevent page from scrolling on the space key.\n              event.preventDefault();\n            } else if (!this.currentItem.disabled) {\n              this.currentItem.checked = !this.currentItem.checked;\n              this.currentItem.doCommand();\n              // Prevent page from scrolling on the space key.\n              event.preventDefault();\n            }\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"MozSwipeGesture\">\n        <![CDATA[\n          // Figure out which index to show\n          let targetIndex = 0;\n\n          // Only handle swipe gestures up and down\n          switch (event.direction) {\n            case event.DIRECTION_DOWN:\n              targetIndex = this.itemCount - 1;\n              // Fall through for actual action\n            case event.DIRECTION_UP:\n              this.ensureIndexIsVisible(targetIndex);\n              break;\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"touchstart\">\n        <![CDATA[\n          if (event.touches.length > 1) {\n            // Multiple touch points detected, abort. In particular this aborts\n            // the panning gesture when the user puts a second finger down after\n            // already panning with one finger. Aborting at this point prevents\n            // the pan gesture from being resumed until all fingers are lifted\n            // (as opposed to when the user is back down to one finger).\n            this._touchY = -1;\n          } else {\n            this._touchY = event.touches[0].screenY;\n          }\n        ]]>\n      </handler>\n      <handler event=\"touchmove\">\n        <![CDATA[\n          if (event.touches.length == 1 &&\n              this._touchY >= 0) {\n            let deltaY = this._touchY - event.touches[0].screenY;\n            let lines = Math.trunc(deltaY / this.listBoxObject.getRowHeight());\n            if (Math.abs(lines) > 0) {\n              this.listBoxObject.scrollByLines(lines);\n              deltaY -= lines * this.listBoxObject.getRowHeight();\n              this._touchY = event.touches[0].screenY + deltaY;\n            }\n            event.preventDefault();\n          }\n        ]]>\n      </handler>\n      <handler event=\"touchend\">\n        <![CDATA[\n          this._touchY = -1;\n        ]]>\n      </handler>\n\n    </handlers>\n  </binding>\n\n  <binding id=\"listrows\">\n\n    <resources>\n      <stylesheet src=\"chrome://global/skin/listbox.css\"/>\n    </resources>\n\n    <handlers>\n      <handler event=\"DOMMouseScroll\" phase=\"capturing\">\n      <![CDATA[\n        if (event.axis == event.HORIZONTAL_AXIS)\n          return;\n\n        var listBox = this.parentNode.listBoxObject;\n        var rows = event.detail;\n        if (rows == UIEvent.SCROLL_PAGE_UP)\n          rows = -listBox.getNumberOfVisibleRows();\n        else if (rows == UIEvent.SCROLL_PAGE_DOWN)\n          rows = listBox.getNumberOfVisibleRows();\n\n        listBox.scrollByLines(rows);\n        event.preventDefault();\n      ]]>\n      </handler>\n\n      <handler event=\"MozMousePixelScroll\" phase=\"capturing\">\n      <![CDATA[\n        if (event.axis == event.HORIZONTAL_AXIS)\n          return;\n\n        // shouldn't be scrolled by pixel scrolling events before a line/page\n        // scrolling event.\n        event.preventDefault();\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"listitem\" role=\"xul:listitem\"\n           extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/listbox.css\"/>\n    </resources>\n\n    <content>\n      <children>\n        <xul:listcell xbl:inherits=\"label,crop,disabled,flexlabel\"/>\n      </children>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <property name=\"current\" onget=\"return this.getAttribute('current') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.setAttribute(\"current\", \"true\");\n          else\n            this.removeAttribute(\"current\");\n\n          let control = this.control;\n          if (!control || !control.suppressMenuItemEvent) {\n            this._fireEvent(val ? \"DOMMenuItemActive\" : \"DOMMenuItemInactive\");\n          }\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <!-- ///////////////// nsIDOMXULSelectControlItemElement ///////////////// -->\n\n      <property name=\"value\" onget=\"return this.getAttribute('value');\"\n                             onset=\"this.setAttribute('value', val); return val;\"/>\n      <property name=\"label\" onget=\"return this.getAttribute('label');\"\n                             onset=\"this.setAttribute('label', val); return val;\"/>\n\n      <property name=\"selected\" onget=\"return this.getAttribute('selected') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.setAttribute(\"selected\", \"true\");\n          else\n            this.removeAttribute(\"selected\");\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"control\">\n        <getter><![CDATA[\n          var parent = this.parentNode;\n          while (parent) {\n            if (parent instanceof Components.interfaces.nsIDOMXULSelectControlElement)\n              return parent;\n            parent = parent.parentNode;\n          }\n          return null;\n        ]]></getter>\n      </property>\n\n      <method name=\"_fireEvent\">\n        <parameter name=\"name\"/>\n        <body>\n        <![CDATA[\n          var event = document.createEvent(\"Events\");\n          event.initEvent(name, true, true);\n          this.dispatchEvent(event);\n        ]]>\n        </body>\n      </method>\n    </implementation>\n    <handlers>\n      <!-- If there is no modifier key, we select on mousedown, not\n           click, so that drags work correctly. -->\n      <handler event=\"mousedown\">\n      <![CDATA[\n        var control = this.control;\n        if (!control || control.disabled)\n          return;\n        if ((!event.ctrlKey || (/Mac/.test(navigator.platform) && event.button == 2)) &&\n            !event.shiftKey && !event.metaKey) {\n          if (!this.selected) {\n            control.selectItem(this);\n          }\n          control.currentItem = this;\n        }\n      ]]>\n      </handler>\n\n      <!-- On a click (up+down on the same item), deselect everything\n           except this item. -->\n      <handler event=\"click\" button=\"0\">\n      <![CDATA[\n        var control = this.control;\n        if (!control || control.disabled)\n          return;\n        control._userSelecting = true;\n        if (control.selType != \"multiple\") {\n          control.selectItem(this);\n        } else if (event.ctrlKey || event.metaKey) {\n          control.toggleItemSelection(this);\n          control.currentItem = this;\n        } else if (event.shiftKey) {\n          control.selectItemRange(null, this);\n          control.currentItem = this;\n        } else {\n          /* We want to deselect all the selected items except what was\n            clicked, UNLESS it was a right-click.  We have to do this\n            in click rather than mousedown so that you can drag a\n            selected group of items */\n\n          // use selectItemRange instead of selectItem, because this\n          // doesn't de- and reselect this item if it is selected\n          control.selectItemRange(this, this);\n        }\n        control._userSelecting = false;\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"listitem-iconic\"\n           extends=\"chrome://global/content/bindings/listbox.xml#listitem\">\n    <content>\n      <children>\n        <xul:listcell class=\"listcell-iconic\" xbl:inherits=\"label,image,crop,disabled,flexlabel\"/>\n      </children>\n    </content>\n  </binding>\n\n  <binding id=\"listitem-checkbox\"\n           extends=\"chrome://global/content/bindings/listbox.xml#listitem\">\n    <content>\n      <children>\n        <xul:listcell type=\"checkbox\" xbl:inherits=\"label,crop,checked,disabled,flexlabel\"/>\n      </children>\n    </content>\n\n    <implementation>\n      <property name=\"checked\"\n                onget=\"return this.getAttribute('checked') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.setAttribute(\"checked\", \"true\");\n          else\n            this.removeAttribute(\"checked\");\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"CheckboxStateChange\", true, true);\n          this.dispatchEvent(event);\n          return val;\n        ]]></setter>\n      </property>\n    </implementation>\n\n    <handlers>\n      <handler event=\"mousedown\" button=\"0\">\n      <![CDATA[\n        if (!this.disabled && !this.control.disabled) {\n          this.checked = !this.checked;\n          this.doCommand();\n        }\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"listitem-checkbox-iconic\"\n           extends=\"chrome://global/content/bindings/listbox.xml#listitem-checkbox\">\n    <content>\n      <children>\n        <xul:listcell type=\"checkbox\" class=\"listcell-iconic\" xbl:inherits=\"label,image,crop,checked,disabled,flexlabel\"/>\n      </children>\n    </content>\n  </binding>\n\n  <binding id=\"listcell\" role=\"xul:listcell\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n\n    <resources>\n      <stylesheet src=\"chrome://global/skin/listbox.css\"/>\n    </resources>\n\n    <content>\n      <children>\n        <xul:label class=\"listcell-label\" xbl:inherits=\"value=label,flex=flexlabel,crop,disabled\" flex=\"1\" crop=\"right\"/>\n      </children>\n    </content>\n  </binding>\n\n  <binding id=\"listcell-iconic\"\n           extends=\"chrome://global/content/bindings/listbox.xml#listcell\">\n    <content>\n      <children>\n        <xul:image class=\"listcell-icon\" xbl:inherits=\"src=image\"/>\n        <xul:label class=\"listcell-label\" xbl:inherits=\"value=label,flex=flexlabel,crop,disabled\" flex=\"1\" crop=\"right\"/>\n      </children>\n    </content>\n  </binding>\n\n  <binding id=\"listcell-checkbox\"\n           extends=\"chrome://global/content/bindings/listbox.xml#listcell\">\n    <content>\n      <children>\n        <xul:image class=\"listcell-check\" xbl:inherits=\"checked,disabled\"/>\n        <xul:label class=\"listcell-label\" xbl:inherits=\"value=label,flex=flexlabel,crop,disabled\" flex=\"1\" crop=\"right\"/>\n      </children>\n    </content>\n  </binding>\n\n  <binding id=\"listcell-checkbox-iconic\"\n           extends=\"chrome://global/content/bindings/listbox.xml#listcell-checkbox\">\n    <content>\n      <children>\n        <xul:image class=\"listcell-check\" xbl:inherits=\"checked,disabled\"/>\n        <xul:image class=\"listcell-icon\" xbl:inherits=\"src=image\"/>\n        <xul:label class=\"listcell-label\" xbl:inherits=\"value=label,flex=flexlabel,crop,disabled\" flex=\"1\" crop=\"right\"/>\n      </children>\n    </content>\n  </binding>\n\n  <binding id=\"listhead\" role=\"xul:listhead\">\n\n    <resources>\n      <stylesheet src=\"chrome://global/skin/listbox.css\"/>\n    </resources>\n\n    <content>\n      <xul:listheaditem>\n        <children includes=\"listheader\"/>\n      </xul:listheaditem>\n    </content>\n  </binding>\n\n  <binding id=\"listheader\" display=\"xul:button\" role=\"xul:listheader\">\n\n    <resources>\n      <stylesheet src=\"chrome://global/skin/listbox.css\"/>\n    </resources>\n\n    <content>\n      <xul:image class=\"listheader-icon\"/>\n      <xul:label class=\"listheader-label\" xbl:inherits=\"value=label,crop\" flex=\"1\" crop=\"right\"/>\n      <xul:image class=\"listheader-sortdirection\" xbl:inherits=\"sortDirection\"/>\n    </content>\n  </binding>\n\n</bindings>\n"},{"file":"menu.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"menuitemBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"menuitem-base\" role=\"xul:menuitem\"\n           extends=\"chrome://global/content/bindings/general.xml#control-item\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/menu.css\"/>\n    </resources>\n    <implementation implements=\"nsIDOMXULSelectControlItemElement, nsIDOMXULContainerItemElement\">\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"selected\" readonly=\"true\"\n                onget=\"return this.getAttribute('selected') == 'true';\"/>\n      <property name=\"control\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var parent = this.parentNode;\n            if (parent &&\n                parent.parentNode instanceof Components.interfaces.nsIDOMXULSelectControlElement)\n              return parent.parentNode;\n            return null;\n          ]]>\n        </getter>\n      </property>\n\n      <!-- nsIDOMXULContainerItemElement -->\n      <property name=\"parentContainer\" readonly=\"true\">\n        <getter>\n          for (var parent = this.parentNode; parent; parent = parent.parentNode) {\n            if (parent instanceof Components.interfaces.nsIDOMXULContainerElement)\n              return parent;\n          }\n          return null;\n        </getter>\n      </property>\n    </implementation>\n  </binding>\n\n  <binding id=\"menu-base\"\n           extends=\"chrome://global/content/bindings/menu.xml#menuitem-base\">\n\n    <implementation implements=\"nsIDOMXULContainerElement\">\n      <property name=\"open\" onget=\"return this.hasAttribute('open');\">\n        <setter><![CDATA[\n          this.boxObject.openMenu(val);\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"openedWithKey\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.boxObject.openedWithKey;\n        ]]></getter>\n      </property>\n\n      <!-- nsIDOMXULContainerElement interface -->\n      <method name=\"appendItem\">\n        <parameter name=\"aLabel\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n          return this.insertItemAt(-1, aLabel, aValue);\n        </body>\n      </method>\n\n      <method name=\"insertItemAt\">\n        <parameter name=\"aIndex\"/>\n        <parameter name=\"aLabel\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n          const XUL_NS =\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\n          var menupopup = this.menupopup;\n          if (!menupopup) {\n            menupopup = this.ownerDocument.createElementNS(XUL_NS, \"menupopup\");\n            this.appendChild(menupopup);\n          }\n\n          var menuitem = this.ownerDocument.createElementNS(XUL_NS, \"menuitem\");\n          menuitem.setAttribute(\"label\", aLabel);\n          menuitem.setAttribute(\"value\", aValue);\n\n          var before = this.getItemAtIndex(aIndex);\n          if (before)\n            return menupopup.insertBefore(menuitem, before);\n          return menupopup.appendChild(menuitem);\n        </body>\n      </method>\n\n      <method name=\"removeItemAt\">\n        <parameter name=\"aIndex\"/>\n        <body>\n        <![CDATA[\n          var menupopup = this.menupopup;\n          if (menupopup) {\n            var item = this.getItemAtIndex(aIndex);\n            if (item)\n              return menupopup.removeChild(item);\n          }\n          return null;\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"itemCount\" readonly=\"true\">\n        <getter>\n          var menupopup = this.menupopup;\n          return menupopup ? menupopup.childNodes.length : 0;\n        </getter>\n      </property>\n\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          var menupopup = this.menupopup;\n          if (menupopup) {\n            var items = menupopup.childNodes;\n            var length = items.length;\n            for (var index = 0; index < length; ++index) {\n              if (items[index] == aItem)\n                return index;\n            }\n          }\n          return -1;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"aIndex\"/>\n        <body>\n        <![CDATA[\n          var menupopup = this.menupopup;\n          if (!menupopup || aIndex < 0 || aIndex >= menupopup.childNodes.length)\n            return null;\n\n          return menupopup.childNodes[aIndex];\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"menupopup\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          const XUL_NS =\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\n          for (var child = this.firstChild; child; child = child.nextSibling) {\n            if (child.namespaceURI == XUL_NS && child.localName == \"menupopup\")\n              return child;\n          }\n          return null;\n        ]]>\n        </getter>\n      </property>\n    </implementation>\n  </binding>\n\n  <binding id=\"menu\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:label class=\"menu-text\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\"/>\n      <xul:hbox class=\"menu-accel-container\" anonid=\"accel\">\n        <xul:label class=\"menu-accel\" xbl:inherits=\"value=acceltext\"/>\n      </xul:hbox>\n      <xul:hbox align=\"center\" class=\"menu-right\" xbl:inherits=\"_moz-menuactive,disabled\">\n        <xul:image/>\n      </xul:hbox>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menuitem\" extends=\"chrome://global/content/bindings/menu.xml#menuitem-base\">\n    <content>\n      <xul:label class=\"menu-text\" xbl:inherits=\"value=label,accesskey,crop,highlightable\" crop=\"right\"/>\n      <xul:hbox class=\"menu-accel-container\" anonid=\"accel\">\n        <xul:label class=\"menu-accel\" xbl:inherits=\"value=acceltext\"/>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"menucaption\" extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:label class=\"menu-text\" xbl:inherits=\"value=label,crop\" crop=\"right\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menu-menubar\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:label class=\"menubar-text\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menu-menubar-iconic\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:image class=\"menubar-left\" xbl:inherits=\"src=image\"/>\n      <xul:label class=\"menubar-text\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menuitem-iconic\" extends=\"chrome://global/content/bindings/menu.xml#menuitem\">\n    <content>\n      <xul:hbox class=\"menu-iconic-left\" align=\"center\" pack=\"center\"\n                xbl:inherits=\"selected,_moz-menuactive,disabled,checked\">\n        <xul:image class=\"menu-iconic-icon\" xbl:inherits=\"src=image,triggeringprincipal=iconloadingprincipal,validate,src\"/>\n      </xul:hbox>\n      <xul:label class=\"menu-iconic-text\" flex=\"1\" xbl:inherits=\"value=label,accesskey,crop,highlightable\" crop=\"right\"/>\n      <xul:label class=\"menu-iconic-highlightable-text\" xbl:inherits=\"xbl:text=label,crop,accesskey,highlightable\" crop=\"right\"/>\n      <children/>\n      <xul:hbox class=\"menu-accel-container\" anonid=\"accel\">\n        <xul:label class=\"menu-iconic-accel\" xbl:inherits=\"value=acceltext\"/>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"menuitem-iconic-noaccel\" extends=\"chrome://global/content/bindings/menu.xml#menuitem\">\n    <content>\n      <xul:hbox class=\"menu-iconic-left\" align=\"center\" pack=\"center\"\n                xbl:inherits=\"selected,disabled,checked\">\n        <xul:image class=\"menu-iconic-icon\" xbl:inherits=\"src=image,validate,src\"/>\n      </xul:hbox>\n      <xul:label class=\"menu-iconic-text\" flex=\"1\" xbl:inherits=\"value=label,accesskey,crop,highlightable\" crop=\"right\"/>\n      <xul:label class=\"menu-iconic-highlightable-text\" xbl:inherits=\"xbl:text=label,crop,accesskey,highlightable\" crop=\"right\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menucaption-inmenulist\" extends=\"chrome://global/content/bindings/menu.xml#menucaption\">\n    <content>\n      <xul:hbox class=\"menu-iconic-left\" align=\"center\" pack=\"center\"\n                xbl:inherits=\"selected,disabled,checked\">\n        <xul:image class=\"menu-iconic-icon\" xbl:inherits=\"src=image,validate,src\"/>\n      </xul:hbox>\n      <xul:label class=\"menu-iconic-text\" flex=\"1\" xbl:inherits=\"value=label,crop,highlightable\" crop=\"right\"/>\n      <xul:label class=\"menu-iconic-highlightable-text\" xbl:inherits=\"xbl:text=label,crop,highlightable\" crop=\"right\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menuitem-iconic-desc-noaccel\" extends=\"chrome://global/content/bindings/menu.xml#menuitem\">\n    <content>\n      <xul:hbox class=\"menu-iconic-left\" align=\"center\" pack=\"center\"\n                xbl:inherits=\"selected,disabled,checked\">\n        <xul:image class=\"menu-iconic-icon\" xbl:inherits=\"src=image,validate,src\"/>\n      </xul:hbox>\n      <xul:label class=\"menu-iconic-text\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\" flex=\"1\"/>\n      <xul:label class=\"menu-iconic-text menu-description\" xbl:inherits=\"value=description\" crop=\"right\" flex=\"10000\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menu-iconic\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:hbox class=\"menu-iconic-left\" align=\"center\" pack=\"center\">\n        <xul:image class=\"menu-iconic-icon\" xbl:inherits=\"src=image\"/>\n      </xul:hbox>\n      <xul:label class=\"menu-iconic-text\" flex=\"1\" xbl:inherits=\"value=label,accesskey,crop,highlightable\" crop=\"right\"/>\n      <xul:label class=\"menu-iconic-highlightable-text\" xbl:inherits=\"xbl:text=label,crop,accesskey,highlightable\" crop=\"right\"/>\n      <xul:hbox class=\"menu-accel-container\" anonid=\"accel\">\n        <xul:label class=\"menu-iconic-accel\" xbl:inherits=\"value=acceltext\"/>\n      </xul:hbox>\n      <xul:hbox align=\"center\" class=\"menu-right\" xbl:inherits=\"_moz-menuactive,disabled\">\n        <xul:image/>\n      </xul:hbox>\n      <children includes=\"menupopup|template\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menubutton-item\" extends=\"chrome://global/content/bindings/menu.xml#menuitem-base\">\n    <content>\n      <xul:label class=\"menubutton-text\" flex=\"1\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menuseparator\" role=\"xul:menuseparator\"\n           extends=\"chrome://global/content/bindings/menu.xml#menuitem-base\">\n  </binding>\n\n</bindings>\n"},{"file":"menulist.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"menulistBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"menulist-base\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <resources>\n      <stylesheet src=\"chrome://global/content/menulist.css\"/>\n      <stylesheet src=\"chrome://global/skin/menulist.css\"/>\n    </resources>\n  </binding>\n\n  <binding id=\"menulist\" display=\"xul:menu\" role=\"xul:menulist\"\n           extends=\"chrome://global/content/bindings/menulist.xml#menulist-base\">\n    <content sizetopopup=\"pref\">\n      <xul:hbox class=\"menulist-label-box\" flex=\"1\">\n        <xul:image class=\"menulist-icon\" xbl:inherits=\"src=image,src\"/>\n        <xul:label class=\"menulist-label\" xbl:inherits=\"value=label,crop,accesskey,highlightable\" crop=\"right\" flex=\"1\"/>\n        <xul:label class=\"menulist-highlightable-label\" xbl:inherits=\"xbl:text=label,crop,accesskey,highlightable\" crop=\"right\" flex=\"1\"/>\n      </xul:hbox>\n      <xul:dropmarker class=\"menulist-dropmarker\" type=\"menu\" xbl:inherits=\"disabled,open\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n\n    <handlers>\n      <handler event=\"command\" phase=\"capturing\"\n        action=\"if (event.target.parentNode.parentNode == this) this.selectedItem = event.target;\"/>\n\n      <handler event=\"popupshowing\">\n        <![CDATA[\n          if (event.target.parentNode == this) {\n            this.menuBoxObject.activeChild = null;\n            if (this.selectedItem)\n              // Not ready for auto-setting the active child in hierarchies yet.\n              // For now, only do this when the outermost menupopup opens.\n              this.menuBoxObject.activeChild = this.mSelectedInternal;\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"keypress\" modifiers=\"shift any\" group=\"system\">\n        <![CDATA[\n          if (!event.defaultPrevented &&\n              (event.keyCode == KeyEvent.DOM_VK_UP ||\n               event.keyCode == KeyEvent.DOM_VK_DOWN ||\n               event.keyCode == KeyEvent.DOM_VK_PAGE_UP ||\n               event.keyCode == KeyEvent.DOM_VK_PAGE_DOWN ||\n               event.keyCode == KeyEvent.DOM_VK_HOME ||\n               event.keyCode == KeyEvent.DOM_VK_END ||\n               event.keyCode == KeyEvent.DOM_VK_BACK_SPACE ||\n               event.charCode > 0)) {\n            // Moving relative to an item: start from the currently selected item\n            this.menuBoxObject.activeChild = this.mSelectedInternal;\n            if (this.menuBoxObject.handleKeyPress(event)) {\n              this.menuBoxObject.activeChild.doCommand();\n              event.preventDefault();\n            }\n          }\n        ]]>\n      </handler>\n    </handlers>\n\n    <implementation implements=\"nsIDOMXULMenuListElement\">\n      <constructor>\n        this.mInputField = null;\n        this.mSelectedInternal = null;\n        this.mAttributeObserver = null;\n        this.menuBoxObject = this.boxObject;\n        this.setInitialSelection();\n      </constructor>\n\n      <method name=\"setInitialSelection\">\n        <body>\n          <![CDATA[\n            var popup = this.menupopup;\n            if (popup) {\n              var arr = popup.getElementsByAttribute(\"selected\", \"true\");\n\n              var editable = this.editable;\n              var value = this.value;\n              if (!arr.item(0) && value)\n                arr = popup.getElementsByAttribute(editable ? \"label\" : \"value\", value);\n\n              if (arr.item(0))\n                this.selectedItem = arr[0];\n              else if (!editable)\n                this.selectedIndex = 0;\n            }\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"value\" onget=\"return this.getAttribute('value');\">\n        <setter>\n          <![CDATA[\n            // if the new value is null, we still need to remove the old value\n            if (val == null)\n              return this.selectedItem = val;\n\n            var arr = null;\n            var popup = this.menupopup;\n            if (popup)\n              arr = popup.getElementsByAttribute(\"value\", val);\n\n            if (arr && arr.item(0))\n              this.selectedItem = arr[0];\n            else {\n              this.selectedItem = null;\n              this.setAttribute(\"value\", val);\n            }\n\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"inputField\" readonly=\"true\" onget=\"return null;\"/>\n\n      <property name=\"crop\" onset=\"this.setAttribute('crop',val); return val;\"\n                            onget=\"return this.getAttribute('crop');\"/>\n      <property name=\"image\"  onset=\"this.setAttribute('image',val); return val;\"\n                              onget=\"return this.getAttribute('image');\"/>\n      <property name=\"label\" readonly=\"true\" onget=\"return this.getAttribute('label');\"/>\n      <property name=\"description\" onset=\"this.setAttribute('description',val); return val;\"\n                                   onget=\"return this.getAttribute('description');\"/>\n\n      <property name=\"editable\" onget=\"return this.getAttribute('editable') == 'true';\">\n        <setter>\n          <![CDATA[\n            if (!val && this.editable) {\n              // If we were focused and transition from editable to not editable,\n              // focus the parent menulist so that the focus does not get stuck.\n              if (this.inputField == document.activeElement)\n                window.setTimeout(() => this.focus(), 0);\n            }\n\n            this.setAttribute(\"editable\", val);\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"open\" onset=\"this.menuBoxObject.openMenu(val);\n                                   return val;\"\n                            onget=\"return this.hasAttribute('open');\"/>\n\n      <property name=\"itemCount\" readonly=\"true\"\n                onget=\"return this.menupopup ? this.menupopup.childNodes.length : 0\"/>\n\n      <property name=\"menupopup\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var popup = this.firstChild;\n            while (popup && popup.localName != \"menupopup\")\n              popup = popup.nextSibling;\n            return popup;\n          ]]>\n        </getter>\n      </property>\n\n      <method name=\"contains\">\n        <parameter name=\"item\"/>\n        <body>\n          <![CDATA[\n            if (!item)\n              return false;\n\n            var parent = item.parentNode;\n            return (parent && parent.parentNode == this);\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"selectedIndex\">\n        <getter>\n          <![CDATA[\n            // Quick and dirty. We won't deal with hierarchical menulists yet.\n            if (!this.selectedItem ||\n                !this.mSelectedInternal.parentNode ||\n                this.mSelectedInternal.parentNode.parentNode != this)\n              return -1;\n\n            var children = this.mSelectedInternal.parentNode.childNodes;\n            var i = children.length;\n            while (i--)\n              if (children[i] == this.mSelectedInternal)\n                break;\n\n            return i;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            var popup = this.menupopup;\n            if (popup && 0 <= val) {\n              if (val < popup.childNodes.length)\n                this.selectedItem = popup.childNodes[val];\n            } else\n              this.selectedItem = null;\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedItem\">\n        <getter>\n          <![CDATA[\n            return this.mSelectedInternal;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            var oldval = this.mSelectedInternal;\n            if (oldval == val)\n              return val;\n\n            if (val && !this.contains(val))\n              return val;\n\n            if (oldval) {\n              oldval.removeAttribute(\"selected\");\n              this.mAttributeObserver.disconnect();\n            }\n\n            this.mSelectedInternal = val;\n            let attributeFilter = [\"value\", \"label\", \"image\", \"description\"];\n            if (val) {\n              val.setAttribute(\"selected\", \"true\");\n              for (let attr of attributeFilter) {\n                if (val.hasAttribute(attr)) {\n                  this.setAttribute(attr, val.getAttribute(attr));\n                } else {\n                  this.removeAttribute(attr);\n                }\n              }\n\n              this.mAttributeObserver = new MutationObserver(this.handleMutation.bind(this));\n              this.mAttributeObserver.observe(val, { attributeFilter });\n            } else {\n              for (let attr of attributeFilter) {\n                this.removeAttribute(attr);\n              }\n            }\n\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"select\", true, true);\n            this.dispatchEvent(event);\n\n            event = document.createEvent(\"Events\");\n            event.initEvent(\"ValueChange\", true, true);\n            this.dispatchEvent(event);\n\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"handleMutation\">\n        <parameter name=\"aRecords\"/>\n        <body>\n          <![CDATA[\n            for (let record of aRecords) {\n              let t = record.target;\n              if (t == this.mSelectedInternal) {\n                let attrName = record.attributeName;\n                switch (attrName) {\n                  case \"value\":\n                  case \"label\":\n                  case \"image\":\n                  case \"description\":\n                    if (t.hasAttribute(attrName)) {\n                      this.setAttribute(attrName, t.getAttribute(attrName));\n                    } else {\n                      this.removeAttribute(attrName);\n                    }\n                }\n              }\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"item\"/>\n        <body>\n        <![CDATA[\n          var popup = this.menupopup;\n          if (popup) {\n            var children = popup.childNodes;\n            var i = children.length;\n            while (i--)\n              if (children[i] == item)\n                return i;\n          }\n          return -1;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"index\"/>\n        <body>\n        <![CDATA[\n          var popup = this.menupopup;\n          if (popup) {\n            var children = popup.childNodes;\n            if (index >= 0 && index < children.length)\n              return children[index];\n          }\n          return null;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"appendItem\">\n        <parameter name=\"label\"/>\n        <parameter name=\"value\"/>\n        <parameter name=\"description\"/>\n        <body>\n        <![CDATA[\n          const XULNS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          var popup = this.menupopup ||\n                      this.appendChild(document.createElementNS(XULNS, \"menupopup\"));\n          var item = document.createElementNS(XULNS, \"menuitem\");\n          item.setAttribute(\"label\", label);\n          item.setAttribute(\"value\", value);\n          if (description)\n            item.setAttribute(\"description\", description);\n\n          popup.appendChild(item);\n          return item;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"insertItemAt\">\n        <parameter name=\"index\"/>\n        <parameter name=\"label\"/>\n        <parameter name=\"value\"/>\n        <parameter name=\"description\"/>\n        <body>\n        <![CDATA[\n          const XULNS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          var popup = this.menupopup ||\n                      this.appendChild(document.createElementNS(XULNS, \"menupopup\"));\n          var item = document.createElementNS(XULNS, \"menuitem\");\n          item.setAttribute(\"label\", label);\n          item.setAttribute(\"value\", value);\n          if (description)\n            item.setAttribute(\"description\", description);\n\n          if (index >= 0 && index < popup.childNodes.length)\n            popup.insertBefore(item, popup.childNodes[index]);\n          else\n            popup.appendChild(item);\n          return item;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"removeItemAt\">\n        <parameter name=\"index\"/>\n        <body>\n        <![CDATA[\n          var popup = this.menupopup;\n          if (popup && 0 <= index && index < popup.childNodes.length) {\n            var remove = popup.childNodes[index];\n            popup.removeChild(remove);\n            return remove;\n          }\n          return null;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"removeAllItems\">\n        <body>\n        <![CDATA[\n          this.selectedItem = null;\n          var popup = this.menupopup;\n          if (popup)\n            this.removeChild(popup);\n        ]]>\n        </body>\n      </method>\n\n      <destructor>\n        <![CDATA[\n          if (this.mAttributeObserver) {\n            this.mAttributeObserver.disconnect();\n          }\n        ]]>\n      </destructor>\n    </implementation>\n  </binding>\n\n  <binding id=\"menulist-editable\" extends=\"chrome://global/content/bindings/menulist.xml#menulist\">\n    <content sizetopopup=\"pref\">\n      <xul:hbox class=\"menulist-editable-box textbox-input-box\" xbl:inherits=\"context,disabled,readonly,focused\" flex=\"1\">\n        <html:input class=\"menulist-editable-input\" anonid=\"input\" allowevents=\"true\"\n                    xbl:inherits=\"value=label,value,disabled,tabindex,readonly,placeholder\"/>\n      </xul:hbox>\n      <xul:dropmarker class=\"menulist-dropmarker\" type=\"menu\"\n                      xbl:inherits=\"open,disabled,parentfocused=focused\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n\n    <implementation>\n      <method name=\"_selectInputFieldValueInList\">\n        <body>\n        <![CDATA[\n          if (this.hasAttribute(\"disableautoselect\"))\n            return;\n\n          // Find and select the menuitem that matches inputField's \"value\"\n          var arr = null;\n          var popup = this.menupopup;\n\n          if (popup)\n            arr = popup.getElementsByAttribute(\"label\", this.inputField.value);\n\n          this.setSelectionInternal(arr ? arr.item(0) : null);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setSelectionInternal\">\n        <parameter name=\"val\"/>\n        <body>\n          <![CDATA[\n            // This is called internally to set selected item\n            //  without triggering infinite loop\n            //  when using selectedItem's setter\n            if (this.mSelectedInternal == val)\n              return val;\n\n            if (this.mSelectedInternal)\n              this.mSelectedInternal.removeAttribute(\"selected\");\n\n            this.mSelectedInternal = val;\n\n            if (val)\n              val.setAttribute(\"selected\", \"true\");\n\n            // Do NOT change the \"value\", which is owned by inputField\n            return val;\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"inputField\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.mInputField)\n            this.mInputField = document.getAnonymousElementByAttribute(this, \"anonid\", \"input\");\n          return this.mInputField;\n        ]]></getter>\n      </property>\n\n      <property name=\"label\"      onset=\"this.inputField.value = val; return val;\"\n                                  onget=\"return this.inputField.value;\"/>\n\n      <property name=\"value\"      onget=\"return this.inputField.value;\">\n        <setter>\n        <![CDATA[\n          // Override menulist's value setter to refer to the inputField's value\n          // (Allows using \"menulist.value\" instead of \"menulist.inputField.value\")\n          this.inputField.value = val;\n          this.setAttribute(\"value\", val);\n          this.setAttribute(\"label\", val);\n          this._selectInputFieldValueInList();\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedItem\">\n        <getter>\n          <![CDATA[\n            // Make sure internally-selected item\n            //  is in sync with inputField.value\n            this._selectInputFieldValueInList();\n            return this.mSelectedInternal;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            var oldval = this.mSelectedInternal;\n            if (oldval == val)\n              return val;\n\n            if (val && !this.contains(val))\n              return val;\n\n            // This doesn't touch inputField.value or \"value\" and \"label\" attributes\n            this.setSelectionInternal(val);\n            if (val) {\n              // Editable menulist uses \"label\" as its \"value\"\n              var label = val.getAttribute(\"label\");\n              this.inputField.value = label;\n              this.setAttribute(\"value\", label);\n              this.setAttribute(\"label\", label);\n            } else {\n              this.inputField.value = \"\";\n              this.removeAttribute(\"value\");\n              this.removeAttribute(\"label\");\n            }\n\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"select\", true, true);\n            this.dispatchEvent(event);\n\n            event = document.createEvent(\"Events\");\n            event.initEvent(\"ValueChange\", true, true);\n            this.dispatchEvent(event);\n\n            return val;\n          ]]>\n        </setter>\n      </property>\n      <property name=\"disableautoselect\"\n                onset=\"if (val) this.setAttribute('disableautoselect','true');\n                       else this.removeAttribute('disableautoselect'); return val;\"\n                onget=\"return this.hasAttribute('disableautoselect');\"/>\n\n      <property name=\"editor\" readonly=\"true\">\n        <getter><![CDATA[\n          const nsIDOMNSEditableElement = Components.interfaces.nsIDOMNSEditableElement;\n          return this.inputField.QueryInterface(nsIDOMNSEditableElement).editor;\n        ]]></getter>\n      </property>\n\n      <property name=\"readOnly\"   onset=\"this.inputField.readOnly = val;\n                                         if (val) this.setAttribute('readonly', 'true');\n                                         else this.removeAttribute('readonly'); return val;\"\n                                  onget=\"return this.inputField.readOnly;\"/>\n\n      <method name=\"select\">\n        <body>\n          this.inputField.select();\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"focus\" phase=\"capturing\">\n        <![CDATA[\n          this.setAttribute(\"focused\", \"true\");\n        ]]>\n      </handler>\n\n      <handler event=\"blur\" phase=\"capturing\">\n        <![CDATA[\n          this.removeAttribute(\"focused\");\n        ]]>\n      </handler>\n\n      <handler event=\"popupshowing\">\n        <![CDATA[\n          // editable menulists elements aren't in the focus order,\n          // so when the popup opens we need to force the focus to the inputField\n          if (event.target.parentNode == this) {\n            if (document.commandDispatcher.focusedElement != this.inputField)\n              this.inputField.focus();\n\n            this.menuBoxObject.activeChild = null;\n            if (this.selectedItem)\n              // Not ready for auto-setting the active child in hierarchies yet.\n              // For now, only do this when the outermost menupopup opens.\n              this.menuBoxObject.activeChild = this.mSelectedInternal;\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"keypress\">\n        <![CDATA[\n          // open popup if key is up arrow, down arrow, or F4\n          if (!event.ctrlKey && !event.shiftKey) {\n            if (event.keyCode == KeyEvent.DOM_VK_UP ||\n                event.keyCode == KeyEvent.DOM_VK_DOWN ||\n                (event.keyCode == KeyEvent.DOM_VK_F4 && !event.altKey)) {\n              event.preventDefault();\n              this.open = true;\n            }\n          }\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"menulist-description\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/menulist.xml#menulist\">\n    <content sizetopopup=\"pref\">\n      <xul:hbox class=\"menulist-label-box\" flex=\"1\">\n        <xul:image class=\"menulist-icon\" xbl:inherits=\"src=image,src\"/>\n        <xul:label class=\"menulist-label\" xbl:inherits=\"value=label,crop,accesskey\" crop=\"right\" flex=\"1\"/>\n        <xul:label class=\"menulist-label menulist-description\" xbl:inherits=\"value=description\" crop=\"right\" flex=\"10000\"/>\n      </xul:hbox>\n      <xul:dropmarker class=\"menulist-dropmarker\" type=\"menu\" xbl:inherits=\"disabled,open\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menulist-popuponly\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/menulist.xml#menulist\">\n    <content sizetopopup=\"pref\">\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"notification.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE bindings [\n<!ENTITY % notificationDTD SYSTEM \"chrome://global/locale/notification.dtd\">\n%notificationDTD;\n]>\n\n<bindings id=\"notificationBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"notificationbox\">\n    <content>\n      <xul:stack xbl:inherits=\"hidden=notificationshidden\"\n                 class=\"notificationbox-stack\">\n        <xul:spacer/>\n        <children includes=\"notification\"/>\n      </xul:stack>\n      <children/>\n    </content>\n\n    <implementation>\n      <field name=\"PRIORITY_INFO_LOW\" readonly=\"true\">1</field>\n      <field name=\"PRIORITY_INFO_MEDIUM\" readonly=\"true\">2</field>\n      <field name=\"PRIORITY_INFO_HIGH\" readonly=\"true\">3</field>\n      <field name=\"PRIORITY_WARNING_LOW\" readonly=\"true\">4</field>\n      <field name=\"PRIORITY_WARNING_MEDIUM\" readonly=\"true\">5</field>\n      <field name=\"PRIORITY_WARNING_HIGH\" readonly=\"true\">6</field>\n      <field name=\"PRIORITY_CRITICAL_LOW\" readonly=\"true\">7</field>\n      <field name=\"PRIORITY_CRITICAL_MEDIUM\" readonly=\"true\">8</field>\n      <field name=\"PRIORITY_CRITICAL_HIGH\" readonly=\"true\">9</field>\n      <field name=\"PRIORITY_CRITICAL_BLOCK\" readonly=\"true\">10</field>\n\n      <field name=\"currentNotification\">null</field>\n\n      <field name=\"_closedNotification\">null</field>\n      <field name=\"_blockingCanvas\">null</field>\n      <field name=\"_animating\">false</field>\n\n      <property name=\"_allowAnimation\">\n        <getter>\n          <![CDATA[\n            var prefs = Components.classes[\"@mozilla.org/preferences-service;1\"]\n                                  .getService(Components.interfaces.nsIPrefBranch);\n            return prefs.getBoolPref(\"toolkit.cosmeticAnimations.enabled\");\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"notificationsHidden\"\n                onget=\"return this.getAttribute('notificationshidden') == 'true';\">\n        <setter>\n          <![CDATA[\n            if (val)\n              this.setAttribute(\"notificationshidden\", true);\n            else this.removeAttribute(\"notificationshidden\");\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"allNotifications\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var closedNotification = this._closedNotification;\n            var notifications = this.getElementsByTagName(\"notification\");\n            return Array.filter(notifications, n => n != closedNotification);\n          ]]>\n        </getter>\n      </property>\n\n      <method name=\"getNotificationWithValue\">\n        <parameter name=\"aValue\"/>\n        <body>\n          <![CDATA[\n            var notifications = this.allNotifications;\n            for (var n = notifications.length - 1; n >= 0; n--) {\n              if (aValue == notifications[n].getAttribute(\"value\"))\n                return notifications[n];\n            }\n            return null;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"appendNotification\">\n        <parameter name=\"aLabel\"/>\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aImage\"/>\n        <parameter name=\"aPriority\"/>\n        <parameter name=\"aButtons\"/>\n        <parameter name=\"aEventCallback\"/>\n        <body>\n          <![CDATA[\n            if (aPriority < this.PRIORITY_INFO_LOW ||\n                aPriority > this.PRIORITY_CRITICAL_BLOCK)\n              throw \"Invalid notification priority \" + aPriority;\n\n            // check for where the notification should be inserted according to\n            // priority. If two are equal, the existing one appears on top.\n            var notifications = this.allNotifications;\n            var insertPos = null;\n            for (var n = notifications.length - 1; n >= 0; n--) {\n              if (notifications[n].priority < aPriority)\n                break;\n              insertPos = notifications[n];\n            }\n\n            const XULNS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n            var newitem = document.createElementNS(XULNS, \"notification\");\n            // Can't use instanceof in case this was created from a different document:\n            let labelIsDocFragment = aLabel && typeof aLabel == \"object\" && aLabel.nodeType &&\n                                     aLabel.nodeType == aLabel.DOCUMENT_FRAGMENT_NODE;\n            if (!labelIsDocFragment)\n              newitem.setAttribute(\"label\", aLabel);\n            newitem.setAttribute(\"value\", aValue);\n            if (aImage)\n              newitem.setAttribute(\"image\", aImage);\n            newitem.eventCallback = aEventCallback;\n\n            if (aButtons) {\n              // The notification-button-default class is added to the button\n              // with isDefault set to true. If there is no such button, it is\n              // added to the first button (unless that button has isDefault\n              // set to false). There cannot be multiple default buttons.\n              var defaultElem;\n\n              for (var b = 0; b < aButtons.length; b++) {\n                var button = aButtons[b];\n                var buttonElem = document.createElementNS(XULNS, \"button\");\n                buttonElem.setAttribute(\"label\", button.label);\n                if (typeof button.accessKey == \"string\")\n                  buttonElem.setAttribute(\"accesskey\", button.accessKey);\n                if (typeof button.type == \"string\") {\n                  buttonElem.setAttribute(\"type\", button.type);\n                  if ((button.type == \"menu-button\" || button.type == \"menu\") &&\n                      \"popup\" in button) {\n                    buttonElem.appendChild(button.popup);\n                    delete button.popup;\n                  }\n                  if (typeof button.anchor == \"string\")\n                    buttonElem.setAttribute(\"anchor\", button.anchor);\n                }\n                buttonElem.classList.add(\"notification-button\");\n\n                if (button.isDefault ||\n                    b == 0 && !(\"isDefault\" in button))\n                  defaultElem = buttonElem;\n\n                newitem.appendChild(buttonElem);\n                buttonElem.buttonInfo = button;\n              }\n\n              if (defaultElem)\n                defaultElem.classList.add(\"notification-button-default\");\n            }\n\n            newitem.setAttribute(\"priority\", aPriority);\n            if (aPriority >= this.PRIORITY_CRITICAL_LOW)\n              newitem.setAttribute(\"type\", \"critical\");\n            else if (aPriority <= this.PRIORITY_INFO_HIGH)\n              newitem.setAttribute(\"type\", \"info\");\n            else\n              newitem.setAttribute(\"type\", \"warning\");\n\n            if (!insertPos) {\n              newitem.style.position = \"fixed\";\n              newitem.style.top = \"100%\";\n              newitem.style.marginTop = \"-15px\";\n              newitem.style.opacity = \"0\";\n            }\n            this.insertBefore(newitem, insertPos);\n            // Can only insert the document fragment after the item has been created because\n            // otherwise the XBL structure isn't there yet:\n            if (labelIsDocFragment) {\n              document.getAnonymousElementByAttribute(newitem, \"anonid\", \"messageText\")\n                .appendChild(aLabel);\n            }\n\n            if (!insertPos)\n              this._showNotification(newitem, true);\n\n            // Fire event for accessibility APIs\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"AlertActive\", true, true);\n            newitem.dispatchEvent(event);\n\n            return newitem;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeNotification\">\n        <parameter name=\"aItem\"/>\n        <parameter name=\"aSkipAnimation\"/>\n        <body>\n          <![CDATA[\n            if (aItem == this.currentNotification)\n              this.removeCurrentNotification(aSkipAnimation);\n            else if (aItem != this._closedNotification)\n              this._removeNotificationElement(aItem);\n            return aItem;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_removeNotificationElement\">\n        <parameter name=\"aChild\"/>\n        <body>\n          <![CDATA[\n            if (aChild.eventCallback)\n              aChild.eventCallback(\"removed\");\n            this.removeChild(aChild);\n\n            // make sure focus doesn't get lost (workaround for bug 570835)\n            let fm = Components.classes[\"@mozilla.org/focus-manager;1\"]\n                               .getService(Components.interfaces.nsIFocusManager);\n            if (!fm.getFocusedElementForWindow(window, false, {}))\n              fm.moveFocus(window, this, fm.MOVEFOCUS_FORWARD, 0);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeCurrentNotification\">\n        <parameter name=\"aSkipAnimation\"/>\n        <body>\n          <![CDATA[\n            this._showNotification(this.currentNotification, false, aSkipAnimation);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeAllNotifications\">\n        <parameter name=\"aImmediate\"/>\n        <body>\n          <![CDATA[\n            var notifications = this.allNotifications;\n            for (var n = notifications.length - 1; n >= 0; n--) {\n              if (aImmediate)\n                this._removeNotificationElement(notifications[n]);\n              else\n                this.removeNotification(notifications[n]);\n            }\n            this.currentNotification = null;\n\n            // Clean up any currently-animating notification; this is necessary\n            // if a notification was just opened and is still animating, but we\n            // want to close it *without* animating.  This can even happen if\n            // the user toggled `toolkit.cosmeticAnimations.enabled` to false\n            // and called this method immediately after an animated notification\n            // displayed (although this case isn't very likely).\n            if (aImmediate || !this._allowAnimation)\n              this._finishAnimation();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeTransientNotifications\">\n        <body>\n          <![CDATA[\n            var notifications = this.allNotifications;\n            for (var n = notifications.length - 1; n >= 0; n--) {\n              var notification = notifications[n];\n              if (notification.persistence)\n                notification.persistence--;\n              else if (Date.now() > notification.timeout)\n                this.removeNotification(notification);\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_showNotification\">\n        <parameter name=\"aNotification\"/>\n        <parameter name=\"aSlideIn\"/>\n        <parameter name=\"aSkipAnimation\"/>\n        <body>\n          <![CDATA[\n            this._finishAnimation();\n\n            var height = aNotification.boxObject.height;\n            var skipAnimation = aSkipAnimation || height == 0 ||\n                                !this._allowAnimation;\n            aNotification.classList.toggle(\"animated\", !skipAnimation);\n\n            if (aSlideIn) {\n              this.currentNotification = aNotification;\n              aNotification.style.removeProperty(\"position\");\n              aNotification.style.removeProperty(\"top\");\n              aNotification.style.removeProperty(\"margin-top\");\n              aNotification.style.removeProperty(\"opacity\");\n\n              if (skipAnimation) {\n                this._setBlockingState(this.currentNotification);\n                return;\n              }\n            } else {\n              this._closedNotification = aNotification;\n              var notifications = this.allNotifications;\n              var idx = notifications.length - 1;\n              this.currentNotification = (idx >= 0) ? notifications[idx] : null;\n\n              if (skipAnimation) {\n                this._removeNotificationElement(this._closedNotification);\n                this._closedNotification = null;\n                this._setBlockingState(this.currentNotification);\n                return;\n              }\n\n              aNotification.style.marginTop = -height + \"px\";\n              aNotification.style.opacity = 0;\n            }\n\n            this._animating = true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_finishAnimation\">\n        <body><![CDATA[\n          if (this._animating) {\n            this._animating = false;\n            if (this._closedNotification) {\n              this._removeNotificationElement(this._closedNotification);\n              this._closedNotification = null;\n            }\n            this._setBlockingState(this.currentNotification);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_setBlockingState\">\n        <parameter name=\"aNotification\"/>\n        <body>\n          <![CDATA[\n            var isblock = aNotification &&\n                          aNotification.priority == this.PRIORITY_CRITICAL_BLOCK;\n            var canvas = this._blockingCanvas;\n            if (isblock) {\n              if (!canvas)\n                canvas = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n              const XULNS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n              let content = this.firstChild;\n              if (!content ||\n                   content.namespaceURI != XULNS ||\n                   content.localName != \"browser\")\n                return;\n\n              var width = content.boxObject.width;\n              var height = content.boxObject.height;\n              content.collapsed = true;\n\n              canvas.setAttribute(\"width\", width);\n              canvas.setAttribute(\"height\", height);\n              canvas.setAttribute(\"flex\", \"1\");\n\n              this.appendChild(canvas);\n              this._blockingCanvas = canvas;\n\n              var bgcolor = \"white\";\n              try {\n                var prefService = Components.classes[\"@mozilla.org/preferences-service;1\"].\n                                    getService(Components.interfaces.nsIPrefBranch);\n                bgcolor = prefService.getCharPref(\"browser.display.background_color\");\n\n                var win = content.contentWindow;\n                var context = canvas.getContext(\"2d\");\n                context.globalAlpha = 0.5;\n                context.drawWindow(win, win.scrollX, win.scrollY,\n                                   width, height, bgcolor);\n              } catch (ex) { }\n            } else if (canvas) {\n              canvas.remove();\n              this._blockingCanvas = null;\n              let content = this.firstChild;\n              if (content)\n                content.collapsed = false;\n            }\n          ]]>\n        </body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"transitionend\"><![CDATA[\n        if (event.target.localName == \"notification\" &&\n            event.propertyName == \"margin-top\")\n          this._finishAnimation();\n      ]]></handler>\n    </handlers>\n\n  </binding>\n\n  <binding id=\"notification\" role=\"xul:alert\">\n    <content>\n      <xul:hbox class=\"notification-inner\" flex=\"1\" xbl:inherits=\"type\">\n        <xul:hbox anonid=\"details\" align=\"center\" flex=\"1\"\n                  oncommand=\"this.parentNode.parentNode._doButtonCommand(event);\">\n          <xul:image anonid=\"messageImage\" class=\"messageImage\" xbl:inherits=\"src=image,type,value\"/>\n          <xul:description anonid=\"messageText\" class=\"messageText\" flex=\"1\" xbl:inherits=\"xbl:text=label\"/>\n          <xul:spacer flex=\"1\"/>\n          <children/>\n        </xul:hbox>\n        <xul:toolbarbutton ondblclick=\"event.stopPropagation();\"\n                           class=\"messageCloseButton close-icon tabbable\"\n                           xbl:inherits=\"hidden=hideclose\"\n                           tooltiptext=\"FROM-DTD-closeNotification-tooltip\"\n                           oncommand=\"document.getBindingParent(this).dismiss();\"/>\n      </xul:hbox>\n    </content>\n    <resources>\n      <stylesheet src=\"chrome://global/skin/notification.css\"/>\n    </resources>\n    <implementation>\n      <property name=\"label\" onset=\"this.setAttribute('label', val); return val;\"\n                             onget=\"return this.getAttribute('label');\"/>\n      <property name=\"value\" onset=\"this.setAttribute('value', val); return val;\"\n                             onget=\"return this.getAttribute('value');\"/>\n      <property name=\"image\" onset=\"this.setAttribute('image', val); return val;\"\n                             onget=\"return this.getAttribute('image');\"/>\n      <property name=\"type\" onset=\"this.setAttribute('type', val); return val;\"\n                            onget=\"return this.getAttribute('type');\"/>\n      <property name=\"priority\" onget=\"return parseInt(this.getAttribute('priority')) || 0;\"\n                                onset=\"this.setAttribute('priority', val); return val;\"/>\n      <property name=\"persistence\" onget=\"return parseInt(this.getAttribute('persistence')) || 0;\"\n                                   onset=\"this.setAttribute('persistence', val); return val;\"/>\n      <field name=\"timeout\">0</field>\n\n      <property name=\"control\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var parent = this.parentNode;\n            while (parent) {\n              if (parent.localName == \"notificationbox\")\n                return parent;\n              parent = parent.parentNode;\n            }\n            return null;\n          ]]>\n        </getter>\n      </property>\n\n      <!-- This method should only be called when the user has\n           manually closed the notification. If you want to\n           programmatically close the notification, you should\n           call close() instead. -->\n      <method name=\"dismiss\">\n        <body>\n          <![CDATA[\n            if (this.eventCallback) {\n              this.eventCallback(\"dismissed\");\n            }\n            this.close();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"close\">\n        <body>\n          <![CDATA[\n            var control = this.control;\n            if (control)\n              control.removeNotification(this);\n            else\n              this.hidden = true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_doButtonCommand\">\n        <parameter name=\"aEvent\"/>\n        <body>\n          <![CDATA[\n            if (!(\"buttonInfo\" in aEvent.target))\n              return;\n\n            var button = aEvent.target.buttonInfo;\n            if (button.popup) {\n              document.getElementById(button.popup).\n                openPopup(aEvent.originalTarget, \"after_start\", 0, 0, false, false, aEvent);\n              aEvent.stopPropagation();\n            } else {\n              var callback = button.callback;\n              if (callback) {\n                var result = callback(this, button, aEvent.target);\n                if (!result)\n                  this.close();\n                aEvent.stopPropagation();\n              }\n            }\n          ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"popup-notification\">\n    <content orient=\"vertical\">\n      <xul:hbox align=\"start\" class=\"popup-notification-body-container\">\n        <xul:image class=\"popup-notification-icon\"\n                   xbl:inherits=\"popupid,src=icon,class=iconclass\"/>\n        <xul:vbox flex=\"1\" pack=\"start\"\n                  class=\"popup-notification-body\" xbl:inherits=\"popupid\">\n          <xul:hbox align=\"start\">\n            <xul:vbox flex=\"1\">\n              <xul:label class=\"popup-notification-origin header\"\n                         xbl:inherits=\"value=origin,tooltiptext=origin\"\n                         crop=\"center\"/>\n              <xul:description class=\"popup-notification-description\"\n                               xbl:inherits=\"xbl:text=label,popupid\"/>\n            </xul:vbox>\n            <xul:toolbarbutton anonid=\"closebutton\"\n                               class=\"messageCloseButton close-icon popup-notification-closebutton tabbable\"\n                               xbl:inherits=\"oncommand=closebuttoncommand,hidden=closebuttonhidden\"\n                               tooltiptext=\"FROM-DTD-closeNotification-tooltip\"/>\n          </xul:hbox>\n          <children includes=\"popupnotificationcontent\"/>\n          <xul:label class=\"text-link popup-notification-learnmore-link\"\n                     xbl:inherits=\"onclick=learnmoreclick,href=learnmoreurl\">FROM-DTD-learnMore</xul:label>\n          <xul:checkbox anonid=\"checkbox\"\n                        xbl:inherits=\"hidden=checkboxhidden,checked=checkboxchecked,label=checkboxlabel,oncommand=checkboxcommand\" />\n          <xul:description class=\"popup-notification-warning\" xbl:inherits=\"hidden=warninghidden,xbl:text=warninglabel\"/>\n        </xul:vbox>\n      </xul:hbox>\n      <xul:hbox class=\"popup-notification-button-container\">\n        <children includes=\"button\"/>\n        <xul:button anonid=\"secondarybutton\"\n                    class=\"popup-notification-button\"\n                    xbl:inherits=\"oncommand=secondarybuttoncommand,label=secondarybuttonlabel,accesskey=secondarybuttonaccesskey,hidden=secondarybuttonhidden\"/>\n        <xul:toolbarseparator xbl:inherits=\"hidden=dropmarkerhidden\"/>\n        <xul:button anonid=\"menubutton\"\n                    type=\"menu\"\n                    class=\"popup-notification-button popup-notification-dropmarker\"\n                    xbl:inherits=\"onpopupshown=dropmarkerpopupshown,hidden=dropmarkerhidden\">\n          <xul:menupopup anonid=\"menupopup\"\n                         position=\"after_end\"\n                         xbl:inherits=\"oncommand=menucommand\">\n            <children/>\n          </xul:menupopup>\n        </xul:button>\n        <xul:button anonid=\"button\"\n                    class=\"popup-notification-button\"\n                    default=\"true\"\n                    label=\"FROM-DTD-defaultButton-label\"\n                    accesskey=\"FROM-DTD-defaultButton-accesskey\"\n                    xbl:inherits=\"oncommand=buttoncommand,label=buttonlabel,accesskey=buttonaccesskey,highlight=buttonhighlight,disabled=mainactiondisabled\"/>\n      </xul:hbox>\n    </content>\n    <resources>\n      <stylesheet src=\"chrome://global/skin/notification.css\"/>\n    </resources>\n    <implementation>\n      <field name=\"checkbox\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"checkbox\");\n      </field>\n      <field name=\"closebutton\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"closebutton\");\n      </field>\n      <field name=\"button\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"button\");\n      </field>\n      <field name=\"secondaryButton\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"secondarybutton\");\n      </field>\n      <field name=\"menubutton\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"menubutton\");\n      </field>\n      <field name=\"menupopup\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"menupopup\");\n      </field>\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"numberbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"numberboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"numberbox\"\n           extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n\n    <resources>\n      <stylesheet src=\"chrome://global/skin/numberbox.css\"/>\n    </resources>\n\n    <content>\n      <xul:hbox class=\"textbox-input-box numberbox-input-box\" flex=\"1\" xbl:inherits=\"context,disabled,focused\">\n        <html:input class=\"numberbox-input textbox-input\" anonid=\"input\"\n                    xbl:inherits=\"value,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey\"/>\n      </xul:hbox>\n      <xul:spinbuttons anonid=\"buttons\" xbl:inherits=\"disabled,hidden=hidespinbuttons\"/>\n    </content>\n\n    <implementation>\n      <field name=\"_valueEntered\">false</field>\n      <field name=\"_spinButtons\">null</field>\n      <field name=\"_value\">0</field>\n      <field name=\"decimalSymbol\">\".\"</field>\n\n      <property name=\"spinButtons\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (!this._spinButtons)\n              this._spinButtons = document.getAnonymousElementByAttribute(this, \"anonid\", \"buttons\");\n            return this._spinButtons;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"value\" onget=\"return '' + this.valueNumber\"\n                             onset=\"return this.valueNumber = val;\"/>\n\n      <property name=\"valueNumber\">\n        <getter>\n          if (this._valueEntered) {\n            var newval = this.inputField.value;\n            newval = newval.replace(this.decimalSymbol, \".\");\n            this._validateValue(newval, false);\n          }\n          return this._value;\n        </getter>\n        <setter>\n          this._validateValue(val, false);\n          return val;\n        </setter>\n      </property>\n\n      <property name=\"wrapAround\">\n        <getter>\n        <![CDATA[\n          return (this.getAttribute(\"wraparound\") == \"true\")\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          if (val)\n            this.setAttribute(\"wraparound\", \"true\");\n          else\n            this.removeAttribute(\"wraparound\");\n          this._enableDisableButtons();\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"min\">\n        <getter>\n          var min = this.getAttribute(\"min\");\n          return min ? Number(min) : 0;\n        </getter>\n        <setter>\n        <![CDATA[\n          if (typeof val == \"number\") {\n            this.setAttribute(\"min\", val);\n            if (this.valueNumber < val)\n              this._validateValue(val, false);\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"max\">\n        <getter>\n          var max = this.getAttribute(\"max\");\n          return max ? Number(max) : Infinity;\n        </getter>\n        <setter>\n        <![CDATA[\n          if (typeof val != \"number\")\n            return val;\n          var min = this.min;\n          if (val < min)\n            val = min;\n          this.setAttribute(\"max\", val);\n          if (this.valueNumber > val)\n            this._validateValue(val, false);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"decimalPlaces\">\n        <getter>\n          var places = this.getAttribute(\"decimalplaces\");\n          return places ? Number(places) : 0;\n        </getter>\n        <setter>\n          if (typeof val == \"number\") {\n            this.setAttribute(\"decimalplaces\", val);\n            this._validateValue(this.valueNumber, false);\n          }\n          return val;\n        </setter>\n      </property>\n\n      <property name=\"increment\">\n        <getter>\n          var increment = this.getAttribute(\"increment\");\n          return increment ? Number(increment) : 1;\n        </getter>\n        <setter>\n        <![CDATA[\n          if (typeof val == \"number\")\n            this.setAttribute(\"increment\", val);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"decrease\">\n        <body>\n          return this._validateValue(this.valueNumber - this.increment, true);\n        </body>\n      </method>\n\n      <method name=\"increase\">\n        <body>\n          return this._validateValue(this.valueNumber + this.increment, true);\n        </body>\n      </method>\n\n      <method name=\"_modifyUp\">\n        <body>\n          <![CDATA[\n            if (this.disabled || this.readOnly)\n              return;\n            var oldval = this.valueNumber;\n            var newval = this.increase();\n            this.inputField.select();\n            if (oldval != newval)\n              this._fireChange();\n          ]]>\n        </body>\n      </method>\n      <method name=\"_modifyDown\">\n        <body>\n          <![CDATA[\n            if (this.disabled || this.readOnly)\n              return;\n            var oldval = this.valueNumber;\n            var newval = this.decrease();\n            this.inputField.select();\n            if (oldval != newval)\n              this._fireChange();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_enableDisableButtons\">\n        <body>\n          <![CDATA[\n            var buttons = this.spinButtons;\n            if (this.wrapAround) {\n              buttons.decreaseDisabled = buttons.increaseDisabled = false;\n            } else if (this.disabled || this.readOnly) {\n              buttons.decreaseDisabled = buttons.increaseDisabled = true;\n            } else {\n              buttons.decreaseDisabled = (this.valueNumber <= this.min);\n              buttons.increaseDisabled = (this.valueNumber >= this.max);\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_validateValue\">\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aIsIncDec\"/>\n        <body>\n          <![CDATA[\n            aValue = Number(aValue) || 0;\n\n            var min = this.min;\n            var max = this.max;\n            var wrapAround = this.wrapAround &&\n                             min != -Infinity && max != Infinity;\n            if (aValue < min)\n              aValue = (aIsIncDec && wrapAround ? max : min);\n            else if (aValue > max)\n              aValue = (aIsIncDec && wrapAround ? min : max);\n\n            var places = this.decimalPlaces;\n            aValue = (places == Infinity) ? \"\" + aValue : aValue.toFixed(places);\n\n            this._valueEntered = false;\n            this._value = Number(aValue);\n            this.inputField.value = aValue.replace(/\\./, this.decimalSymbol);\n\n            if (!wrapAround)\n              this._enableDisableButtons();\n\n            return aValue;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_fireChange\">\n        <body>\n          var evt = document.createEvent(\"Events\");\n          evt.initEvent(\"change\", true, true);\n          this.dispatchEvent(evt);\n        </body>\n      </method>\n\n      <constructor><![CDATA[\n        if (this.max < this.min)\n          this.max = this.min;\n\n        var dsymbol = (Number(5.4)).toLocaleString().match(/\\D/);\n        if (dsymbol != null)\n          this.decimalSymbol = dsymbol[0];\n\n        var value = this.inputField.value || 0;\n        this._validateValue(value, false);\n      ]]></constructor>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"input\" phase=\"capturing\">\n        this._valueEntered = true;\n      </handler>\n\n      <handler event=\"keypress\">\n        <![CDATA[\n          if (!event.ctrlKey && !event.metaKey && !event.altKey && event.charCode) {\n            if (event.charCode == this.decimalSymbol.charCodeAt(0) &&\n                this.decimalPlaces &&\n                String(this.inputField.value).indexOf(this.decimalSymbol) == -1)\n              return;\n\n            if (event.charCode == 45 && this.min < 0)\n              return;\n\n            if (event.charCode < 48 || event.charCode > 57)\n              event.preventDefault();\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\">\n        this._modifyUp();\n      </handler>\n\n      <handler event=\"keypress\" keycode=\"VK_DOWN\">\n        this._modifyDown();\n      </handler>\n\n      <handler event=\"up\" preventdefault=\"true\">\n        this._modifyUp();\n      </handler>\n\n      <handler event=\"down\" preventdefault=\"true\">\n        this._modifyDown();\n      </handler>\n\n      <handler event=\"change\">\n        if (event.originalTarget == this.inputField) {\n          var newval = this.inputField.value;\n          newval = newval.replace(this.decimalSymbol, \".\");\n          this._validateValue(newval, false);\n        }\n      </handler>\n    </handlers>\n\n  </binding>\n\n</bindings>\n"},{"file":"optionsDialog.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"optionsDialogBindings\" \n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n          \n  <binding id=\"optionsDialog\" \n           extends=\"chrome://global/content/bindings/dialog.xml#dialog\">\n     <content>\n\n       <xul:hbox flex=\"1\">\n         <xul:categoryBox anonid=\"prefsCategories\">\n           <children/>\n         </xul:categoryBox>\n         <xul:vbox flex=\"1\">\n           <xul:dialogheader id=\"panelHeader\"/>\n           <xul:iframe anonid=\"panelFrame\" name=\"panelFrame\" style=\"width: 0px;\" flex=\"1\"/>\n         </xul:vbox>\n       </xul:hbox>\n\n     </content>\n     \n     <implementation>\n     \n     \n     </implementation>\n                     \n  </binding>\n          \n</bindings>"},{"file":"popup.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This files relies on these specific Chrome/XBL globals -->\n<!-- globals PopupBoxObject -->\n\n<bindings id=\"popupBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"popup-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/popup.css\"/>\n    </resources>\n\n    <implementation implements=\"nsIDOMXULPopupElement\">\n      <property name=\"label\" onget=\"return this.getAttribute('label');\"\n                             onset=\"this.setAttribute('label', val); return val;\"/>\n      <property name=\"position\" onget=\"return this.getAttribute('position');\"\n                                onset=\"this.setAttribute('position', val); return val;\"/>\n      <property name=\"popupBoxObject\">\n        <getter>\n          return this.boxObject;\n        </getter>\n      </property>\n\n      <property name=\"state\" readonly=\"true\"\n                onget=\"return this.popupBoxObject.popupState\"/>\n\n      <property name=\"triggerNode\" readonly=\"true\"\n                onget=\"return this.popupBoxObject.triggerNode\"/>\n\n      <property name=\"anchorNode\" readonly=\"true\"\n                onget=\"return this.popupBoxObject.anchorNode\"/>\n\n      <method name=\"openPopup\">\n        <parameter name=\"aAnchorElement\"/>\n        <parameter name=\"aPosition\"/>\n        <parameter name=\"aX\"/>\n        <parameter name=\"aY\"/>\n        <parameter name=\"aIsContextMenu\"/>\n        <parameter name=\"aAttributesOverride\"/>\n        <parameter name=\"aTriggerEvent\"/>\n        <body>\n        <![CDATA[\n          // Allow for passing an options object as the second argument.\n          if (arguments.length == 2 &&\n              arguments[1] != null &&\n              typeof arguments[1] == \"object\") {\n            let params = arguments[1];\n            aPosition = params.position;\n            aX = params.x;\n            aY = params.y;\n            aIsContextMenu = params.isContextMenu;\n            aAttributesOverride = params.attributesOverride;\n            aTriggerEvent = params.triggerEvent;\n          }\n\n          try {\n            var popupBox = this.popupBoxObject;\n            if (popupBox)\n              popupBox.openPopup(aAnchorElement, aPosition, aX, aY,\n                                 aIsContextMenu, aAttributesOverride, aTriggerEvent);\n          } catch (e) {}\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"openPopupAtScreen\">\n        <parameter name=\"aX\"/>\n        <parameter name=\"aY\"/>\n        <parameter name=\"aIsContextMenu\"/>\n        <parameter name=\"aTriggerEvent\"/>\n        <body>\n        <![CDATA[\n          try {\n            var popupBox = this.popupBoxObject;\n            if (popupBox)\n              popupBox.openPopupAtScreen(aX, aY, aIsContextMenu, aTriggerEvent);\n          } catch (e) {}\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"openPopupAtScreenRect\">\n        <parameter name=\"aPosition\"/>\n        <parameter name=\"aX\"/>\n        <parameter name=\"aY\"/>\n        <parameter name=\"aWidth\"/>\n        <parameter name=\"aHeight\"/>\n        <parameter name=\"aIsContextMenu\"/>\n        <parameter name=\"aAttributesOverride\"/>\n        <parameter name=\"aTriggerEvent\"/>\n        <body>\n        <![CDATA[\n          try {\n            var popupBox = this.popupBoxObject;\n            if (popupBox)\n              popupBox.openPopupAtScreenRect(aPosition, aX, aY, aWidth, aHeight,\n                                             aIsContextMenu, aAttributesOverride, aTriggerEvent);\n          } catch (e) {}\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"showPopup\">\n        <parameter name=\"element\"/>\n        <parameter name=\"xpos\"/>\n        <parameter name=\"ypos\"/>\n        <parameter name=\"popuptype\"/>\n        <parameter name=\"anchoralignment\"/>\n        <parameter name=\"popupalignment\"/>\n        <body>\n        <![CDATA[\n          var popupBox = null;\n          var menuBox = null;\n          try {\n            popupBox = this.popupBoxObject;\n          } catch (e) {}\n          try {\n            menuBox = this.parentNode.boxObject;\n          } catch (e) {}\n          if (menuBox instanceof MenuBoxObject)\n            menuBox.openMenu(true);\n          else if (popupBox)\n            popupBox.showPopup(element, this, xpos, ypos, popuptype, anchoralignment, popupalignment);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"hidePopup\">\n        <parameter name=\"cancel\"/>\n        <body>\n        <![CDATA[\n          var popupBox = null;\n          var menuBox = null;\n          try {\n            popupBox = this.popupBoxObject;\n          } catch (e) {}\n          try {\n            menuBox = this.parentNode.boxObject;\n          } catch (e) {}\n          if (menuBox instanceof MenuBoxObject)\n            menuBox.openMenu(false);\n          else if (popupBox instanceof PopupBoxObject)\n            popupBox.hidePopup(cancel);\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"autoPosition\">\n        <getter>\n        <![CDATA[\n          return this.popupBoxObject.autoPosition;\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          return this.popupBoxObject.autoPosition = val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"alignmentPosition\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          return this.popupBoxObject.alignmentPosition;\n        ]]>\n        </getter>\n      </property>\n\n      <property name=\"alignmentOffset\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          return this.popupBoxObject.alignmentOffset;\n        ]]>\n        </getter>\n      </property>\n\n      <method name=\"enableKeyboardNavigator\">\n        <parameter name=\"aEnableKeyboardNavigator\"/>\n        <body>\n        <![CDATA[\n          this.popupBoxObject.enableKeyboardNavigator(aEnableKeyboardNavigator);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"enableRollup\">\n        <parameter name=\"aEnableRollup\"/>\n        <body>\n        <![CDATA[\n          this.popupBoxObject.enableRollup(aEnableRollup);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"sizeTo\">\n        <parameter name=\"aWidth\"/>\n        <parameter name=\"aHeight\"/>\n        <body>\n        <![CDATA[\n          this.popupBoxObject.sizeTo(aWidth, aHeight);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"moveTo\">\n        <parameter name=\"aLeft\"/>\n        <parameter name=\"aTop\"/>\n        <body>\n        <![CDATA[\n          this.popupBoxObject.moveTo(aLeft, aTop);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"moveToAnchor\">\n        <parameter name=\"aAnchorElement\"/>\n        <parameter name=\"aPosition\"/>\n        <parameter name=\"aX\"/>\n        <parameter name=\"aY\"/>\n        <parameter name=\"aAttributesOverride\"/>\n        <body>\n        <![CDATA[\n          this.popupBoxObject.moveToAnchor(aAnchorElement, aPosition, aX, aY, aAttributesOverride);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getOuterScreenRect\">\n        <body>\n        <![CDATA[\n          return this.popupBoxObject.getOuterScreenRect();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setConstraintRect\">\n        <parameter name=\"aRect\"/>\n        <body>\n        <![CDATA[\n          this.popupBoxObject.setConstraintRect(aRect);\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n  </binding>\n\n  <binding id=\"popup\" role=\"xul:menupopup\"\n           extends=\"chrome://global/content/bindings/popup.xml#popup-base\">\n\n    <content>\n      <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                          smoothscroll=\"false\">\n        <children/>\n      </xul:arrowscrollbox>\n    </content>\n\n    <implementation>\n      <field name=\"scrollBox\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"class\", \"popup-internal-box\");\n      </field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\">\n        <![CDATA[\n          var array = [];\n          var width = 0;\n          for (var menuitem = this.firstChild; menuitem; menuitem = menuitem.nextSibling) {\n            if (menuitem.localName == \"menuitem\" && menuitem.hasAttribute(\"acceltext\")) {\n              var accel = document.getAnonymousElementByAttribute(menuitem, \"anonid\", \"accel\");\n              if (accel && accel.boxObject) {\n                array.push(accel);\n                if (accel.boxObject.width > width)\n                  width = accel.boxObject.width;\n              }\n            }\n          }\n          for (var i = 0; i < array.length; i++)\n            array[i].width = width;\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"panel\" role=\"xul:panel\"\n           extends=\"chrome://global/content/bindings/popup.xml#popup-base\">\n    <implementation implements=\"nsIDOMXULPopupElement\">\n      <field name=\"_prevFocus\">0</field>\n      <field name=\"_dragBindingAlive\">true</field>\n      <constructor>\n      <![CDATA[\n        if (this.getAttribute(\"backdrag\") == \"true\" && !this._draggableStarted) {\n          this._draggableStarted = true;\n          try {\n            let tmp = {};\n            Components.utils.import(\"resource://gre/modules/WindowDraggingUtils.jsm\", tmp);\n            let draghandle = new tmp.WindowDraggingElement(this);\n            draghandle.mouseDownCheck = function() {\n              return this._dragBindingAlive;\n            }\n          } catch (e) {}\n        }\n      ]]>\n      </constructor>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // Capture the previous focus before has a chance to get set inside the panel\n        try {\n          this._prevFocus = Components.utils\n                            .getWeakReference(document.commandDispatcher.focusedElement);\n          if (this._prevFocus.get())\n            return;\n        } catch (ex) { }\n\n        this._prevFocus = Components.utils.getWeakReference(document.activeElement);\n      ]]></handler>\n      <handler event=\"popupshown\"><![CDATA[\n        // Fire event for accessibility APIs\n        var alertEvent = document.createEvent(\"Events\");\n        alertEvent.initEvent(\"AlertActive\", true, true);\n        this.dispatchEvent(alertEvent);\n       ]]></handler>\n      <handler event=\"popuphiding\"><![CDATA[\n        try {\n          this._currentFocus = document.commandDispatcher.focusedElement;\n        } catch (e) {\n          this._currentFocus = document.activeElement;\n        }\n      ]]></handler>\n      <handler event=\"popuphidden\"><![CDATA[\n        function doFocus() {\n          // Focus was set on an element inside this panel,\n          // so we need to move it back to where it was previously\n          try {\n            let fm = Components.classes[\"@mozilla.org/focus-manager;1\"]\n                               .getService(Components.interfaces.nsIFocusManager);\n            fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);\n          } catch (e) {\n            prevFocus.focus();\n          }\n        }\n        var currentFocus = this._currentFocus;\n        var prevFocus = this._prevFocus ? this._prevFocus.get() : null;\n        this._currentFocus = null;\n        this._prevFocus = null;\n\n        // Avoid changing focus if focus changed while we hide the popup\n        // (This can happen e.g. if the popup is hiding as a result of a\n        // click/keypress that focused something)\n        let nowFocus;\n        try {\n          nowFocus = document.commandDispatcher.focusedElement;\n        } catch (e) {\n          nowFocus = document.activeElement;\n        }\n        if (nowFocus && nowFocus != currentFocus)\n          return;\n\n        if (prevFocus && this.getAttribute(\"norestorefocus\") != \"true\") {\n          // Try to restore focus\n          try {\n            if (document.commandDispatcher.focusedWindow != window)\n              return; // Focus has already been set to a window outside of this panel\n          } catch (ex) {}\n\n          if (!currentFocus) {\n            doFocus();\n            return;\n          }\n          while (currentFocus) {\n            if (currentFocus == this) {\n              doFocus();\n              return;\n            }\n            currentFocus = currentFocus.parentNode;\n          }\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"arrowpanel\" extends=\"chrome://global/content/bindings/popup.xml#panel\">\n    <content flip=\"both\" side=\"top\" position=\"bottomcenter topleft\" consumeoutsideclicks=\"false\">\n      <xul:vbox anonid=\"container\" class=\"panel-arrowcontainer\" flex=\"1\"\n               xbl:inherits=\"side,panelopen\">\n        <xul:box anonid=\"arrowbox\" class=\"panel-arrowbox\">\n          <xul:image anonid=\"arrow\" class=\"panel-arrow\" xbl:inherits=\"side\"/>\n        </xul:box>\n        <xul:box class=\"panel-arrowcontent\" xbl:inherits=\"side,align,dir,orient,pack\" flex=\"1\">\n          <children/>\n        </xul:box>\n      </xul:vbox>\n    </content>\n    <implementation>\n      <field name=\"_fadeTimer\">null</field>\n      <method name=\"sizeTo\">\n        <parameter name=\"aWidth\"/>\n        <parameter name=\"aHeight\"/>\n        <body>\n        <![CDATA[\n          this.popupBoxObject.sizeTo(aWidth, aHeight);\n          if (this.state == \"open\") {\n            this.adjustArrowPosition();\n          }\n        ]]>\n        </body>\n      </method>\n      <method name=\"moveToAnchor\">\n        <parameter name=\"aAnchorElement\"/>\n        <parameter name=\"aPosition\"/>\n        <parameter name=\"aX\"/>\n        <parameter name=\"aY\"/>\n        <parameter name=\"aAttributesOverride\"/>\n        <body>\n        <![CDATA[\n          this.popupBoxObject.moveToAnchor(aAnchorElement, aPosition, aX, aY, aAttributesOverride);\n        ]]>\n        </body>\n      </method>\n      <method name=\"adjustArrowPosition\">\n        <body>\n        <![CDATA[\n        var anchor = this.anchorNode;\n        if (!anchor) {\n          return;\n        }\n\n        var container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n        var arrowbox = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\");\n\n        var position = this.alignmentPosition;\n        var offset = this.alignmentOffset;\n\n        this.setAttribute(\"arrowposition\", position);\n\n        if (position.indexOf(\"start_\") == 0 || position.indexOf(\"end_\") == 0) {\n          container.orient = \"horizontal\";\n          arrowbox.orient = \"vertical\";\n          if (position.indexOf(\"_after\") > 0) {\n            arrowbox.pack = \"end\";\n          } else {\n            arrowbox.pack = \"start\";\n          }\n          arrowbox.style.transform = \"translate(0, \" + -offset + \"px)\";\n\n          // The assigned side stays the same regardless of direction.\n          var isRTL = (window.getComputedStyle(this).direction == \"rtl\");\n\n          if (position.indexOf(\"start_\") == 0) {\n            container.dir = \"reverse\";\n            this.setAttribute(\"side\", isRTL ? \"left\" : \"right\");\n          } else {\n            container.dir = \"\";\n            this.setAttribute(\"side\", isRTL ? \"right\" : \"left\");\n          }\n        } else if (position.indexOf(\"before_\") == 0 || position.indexOf(\"after_\") == 0) {\n          container.orient = \"\";\n          arrowbox.orient = \"\";\n          if (position.indexOf(\"_end\") > 0) {\n            arrowbox.pack = \"end\";\n          } else {\n            arrowbox.pack = \"start\";\n          }\n          arrowbox.style.transform = \"translate(\" + -offset + \"px, 0)\";\n\n          if (position.indexOf(\"before_\") == 0) {\n            container.dir = \"reverse\";\n            this.setAttribute(\"side\", \"bottom\");\n          } else {\n            container.dir = \"\";\n            this.setAttribute(\"side\", \"top\");\n          }\n        }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\">\n      <![CDATA[\n        var arrow = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrow\");\n        arrow.hidden = this.anchorNode == null;\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\")\n                .style.removeProperty(\"transform\");\n\n        if (this.getAttribute(\"animate\") != \"false\") {\n          this.setAttribute(\"animate\", \"open\");\n          // the animating attribute prevents user interaction during transition\n          // it is removed when popupshown fires\n          this.setAttribute(\"animating\", \"true\");\n        }\n\n        // set fading\n        var fade = this.getAttribute(\"fade\");\n        var fadeDelay = 0;\n        if (fade == \"fast\") {\n          fadeDelay = 1;\n        } else if (fade == \"slow\") {\n          fadeDelay = 4000;\n        } else {\n          return;\n        }\n\n        this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);\n      ]]>\n      </handler>\n      <handler event=\"popuphiding\" phase=\"target\">\n        let animate = (this.getAttribute(\"animate\") != \"false\");\n\n        if (this._fadeTimer) {\n          clearTimeout(this._fadeTimer);\n          if (animate) {\n            this.setAttribute(\"animate\", \"fade\");\n          }\n        } else if (animate) {\n          this.setAttribute(\"animate\", \"cancel\");\n        }\n      </handler>\n      <handler event=\"popupshown\" phase=\"target\">\n        this.removeAttribute(\"animating\");\n        this.setAttribute(\"panelopen\", \"true\");\n      </handler>\n      <handler event=\"popuphidden\" phase=\"target\">\n        this.removeAttribute(\"panelopen\");\n        if (this.getAttribute(\"animate\") != \"false\") {\n          this.removeAttribute(\"animate\");\n        }\n      </handler>\n      <handler event=\"popuppositioned\" phase=\"target\">\n        this.adjustArrowPosition();\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"tooltip\" role=\"xul:tooltip\"\n           extends=\"chrome://global/content/bindings/popup.xml#popup-base\">\n    <content>\n      <children>\n        <xul:label class=\"tooltip-label\" xbl:inherits=\"xbl:text=label\" flex=\"1\"/>\n      </children>\n    </content>\n\n    <implementation>\n      <field name=\"_mouseOutCount\">0</field>\n      <field name=\"_isMouseOver\">false</field>\n\n      <property name=\"label\"\n                onget=\"return this.getAttribute('label');\"\n                onset=\"this.setAttribute('label', val); return val;\"/>\n\n      <property name=\"page\" onset=\"if (val) this.setAttribute('page', 'true');\n                                   else this.removeAttribute('page');\n                                   return val;\"\n                            onget=\"return this.getAttribute('page') == 'true';\"/>\n      <property name=\"textProvider\"\n                readonly=\"true\">\n        <getter>\n        <![CDATA[\n          if (!this._textProvider) {\n            this._textProvider = Components.classes[\"@mozilla.org/embedcomp/default-tooltiptextprovider;1\"]\n                                 .getService(Components.interfaces.nsITooltipTextProvider);\n          }\n          return this._textProvider;\n        ]]>\n        </getter>\n      </property>\n\n      <!-- Given the supplied element within a page, set the tooltip's text to the text\n           for that element. Returns true if text was assigned, and false if the no text\n           is set, which normally would be used to cancel tooltip display.\n        -->\n      <method name=\"fillInPageTooltip\">\n        <parameter name=\"tipElement\"/>\n        <body>\n        <![CDATA[\n          let tttp = this.textProvider;\n          let textObj = {}, dirObj = {};\n          let shouldChangeText = tttp.getNodeText(tipElement, textObj, dirObj);\n          if (shouldChangeText) {\n            this.style.direction = dirObj.value;\n            this.label = textObj.value;\n          }\n          return shouldChangeText;\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"mouseover\"><![CDATA[\n        var rel = event.relatedTarget;\n        if (!rel)\n          return;\n\n        // find out if the node we entered from is one of our anonymous children\n        while (rel) {\n          if (rel == this)\n            break;\n          rel = rel.parentNode;\n        }\n\n        // if the exited node is not a descendant of ours, we are entering for the first time\n        if (rel != this)\n          this._isMouseOver = true;\n      ]]></handler>\n\n      <handler event=\"mouseout\"><![CDATA[\n        var rel = event.relatedTarget;\n\n        // relatedTarget is null when the titletip is first shown: a mouseout event fires\n        // because the mouse is exiting the main window and entering the titletip \"window\".\n        // relatedTarget is also null when the mouse exits the main window completely,\n        // so count how many times relatedTarget was null after titletip is first shown\n        // and hide popup the 2nd time\n        if (!rel) {\n          ++this._mouseOutCount;\n          if (this._mouseOutCount > 1)\n            this.hidePopup();\n          return;\n        }\n\n        // find out if the node we are entering is one of our anonymous children\n        while (rel) {\n          if (rel == this)\n            break;\n          rel = rel.parentNode;\n        }\n\n        // if the entered node is not a descendant of ours, hide the tooltip\n        if (rel != this && this._isMouseOver) {\n          this.hidePopup();\n        }\n      ]]></handler>\n\n      <handler event=\"popupshowing\"><![CDATA[\n        if (this.page && !this.fillInPageTooltip(this.triggerNode)) {\n          event.preventDefault();\n        }\n      ]]></handler>\n\n      <handler event=\"popuphiding\"><![CDATA[\n        this._isMouseOver = false;\n        this._mouseOutCount = 0;\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"popup-scrollbars\" extends=\"chrome://global/content/bindings/popup.xml#popup\">\n    <content>\n      <xul:scrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\" style=\"overflow: auto;\">\n        <children/>\n      </xul:scrollbox>\n    </content>\n    <implementation>\n      <field name=\"AUTOSCROLL_INTERVAL\">25</field>\n      <field name=\"NOT_DRAGGING\">0</field>\n      <field name=\"DRAG_OVER_BUTTON\">-1</field>\n      <field name=\"DRAG_OVER_POPUP\">1</field>\n\n      <field name=\"_draggingState\">this.NOT_DRAGGING</field>\n      <field name=\"_scrollTimer\">0</field>\n\n      <method name=\"enableDragScrolling\">\n        <!-- when overItem is true, drag started over menuitem; when false, drag\n             started while the popup was opening.\n          -->\n        <parameter name=\"overItem\"/>\n        <body>\n        <![CDATA[\n          if (!this._draggingState) {\n            this.setCaptureAlways();\n            this._draggingState = overItem ? this.DRAG_OVER_POPUP : this.DRAG_OVER_BUTTON;\n          }\n        ]]>\n        </body>\n      </method>\n      <method name=\"_clearScrollTimer\">\n        <body>\n        <![CDATA[\n          if (this._scrollTimer) {\n            this.ownerGlobal.clearInterval(this._scrollTimer);\n            this._scrollTimer = 0;\n          }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"popupshown\">\n        // Enable drag scrolling even when the mouse wasn't used. The mousemove\n        // handler will remove it if the mouse isn't down.\n        this.enableDragScrolling(false);\n      </handler>\n\n      <handler event=\"popuphidden\">\n      <![CDATA[\n        this._draggingState = this.NOT_DRAGGING;\n        this._clearScrollTimer();\n        this.releaseCapture();\n      ]]>\n      </handler>\n\n      <handler event=\"mousedown\" button=\"0\">\n      <![CDATA[\n        if (this.state == \"open\" &&\n            (event.target.localName == \"menuitem\" ||\n             event.target.localName == \"menu\" ||\n             event.target.localName == \"menucaption\")) {\n          this.enableDragScrolling(true);\n        }\n      ]]>\n      </handler>\n      <handler event=\"mouseup\" button=\"0\">\n      <![CDATA[\n        this._draggingState = this.NOT_DRAGGING;\n        this._clearScrollTimer();\n      ]]>\n      </handler>\n      <handler event=\"mousemove\">\n      <![CDATA[\n        if (!this._draggingState) {\n          return;\n        }\n\n        this._clearScrollTimer();\n\n        // If the user released the mouse before the popup opens, we will\n        // still be capturing, so check that the button is still pressed. If\n        // not, release the capture and do nothing else. This also handles if\n        // the dropdown was opened via the keyboard.\n        if (!(event.buttons & 1)) {\n          this._draggingState = this.NOT_DRAGGING;\n          this.releaseCapture();\n          return;\n        }\n\n        // If dragging outside the top or bottom edge of the popup, but within\n        // the popup area horizontally, scroll the list in that direction. The\n        // _draggingState flag is used to ensure that scrolling does not start\n        // until the mouse has moved over the popup first, preventing scrolling\n        // while over the dropdown button.\n        let popupRect = this.getOuterScreenRect();\n        if (event.screenX >= popupRect.left && event.screenX <= popupRect.right) {\n          if (this._draggingState == this.DRAG_OVER_BUTTON) {\n            if (event.screenY > popupRect.top && event.screenY < popupRect.bottom) {\n              this._draggingState = this.DRAG_OVER_POPUP;\n            }\n          }\n\n          if (this._draggingState == this.DRAG_OVER_POPUP &&\n              (event.screenY <= popupRect.top || event.screenY >= popupRect.bottom)) {\n            let scrollAmount = event.screenY <= popupRect.top ? -1 : 1;\n            this.scrollBox.scrollByIndex(scrollAmount);\n\n            let win = this.ownerGlobal;\n            this._scrollTimer = win.setInterval(() => {\n              this.scrollBox.scrollByIndex(scrollAmount);\n            }, this.AUTOSCROLL_INTERVAL);\n          }\n        }\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"preferences.xml","body":"<?xml version=\"1.0\"?>\n\n<!DOCTYPE bindings [\n  <!ENTITY % preferencesDTD SYSTEM \"chrome://global/locale/preferences.dtd\">\n  %preferencesDTD;\n  <!ENTITY % globalKeysDTD SYSTEM \"chrome://global/locale/globalKeys.dtd\">\n  %globalKeysDTD;\n]>\n\n<bindings id=\"preferencesBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  <binding id=\"preferences\">\n    <implementation implements=\"nsIObserver\">\n      <method name=\"_constructAfterChildren\">\n      <body>\n      <![CDATA[\n      // This method will be called after the last of the child\n      // <preference> elements is constructed. Its purpose is to propagate\n      // the values to the associated form elements. Sometimes the code for\n      // some <preference> initializers depend on other <preference> elements\n      // being initialized so we wait and call updateElements on all of them\n      // once the last one has been constructed. See bugs 997570 and 992185.\n\n      var elements = this.getElementsByTagName(\"preference\");\n      for (let element of elements) {\n        element.updateElements();\n      }\n\n      this._constructAfterChildrenCalled = true;\n      ]]>\n      </body>\n      </method>\n      <method name=\"observe\">\n        <parameter name=\"aSubject\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aData\"/>\n        <body>\n        <![CDATA[\n          for (var i = 0; i < this.childNodes.length; ++i) {\n            var preference = this.childNodes[i];\n            if (preference.name == aData) {\n              preference.value = preference.valueFromPreferences;\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"fireChangedEvent\">\n        <parameter name=\"aPreference\"/>\n        <body>\n        <![CDATA[\n          // Value changed, synthesize an event\n          try {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"change\", true, true);\n            aPreference.dispatchEvent(event);\n          } catch (e) {\n            Components.utils.reportError(e);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"service\">\n        Components.classes[\"@mozilla.org/preferences-service;1\"]\n                  .getService(Components.interfaces.nsIPrefService);\n      </field>\n      <field name=\"rootBranch\">\n        Components.classes[\"@mozilla.org/preferences-service;1\"]\n                  .getService(Components.interfaces.nsIPrefBranch);\n      </field>\n      <field name=\"defaultBranch\">\n        this.service.getDefaultBranch(\"\");\n      </field>\n      <field name=\"rootBranchInternal\">\n        Components.classes[\"@mozilla.org/preferences-service;1\"]\n                  .getService(Components.interfaces.nsIPrefBranch);\n      </field>\n      <property name=\"type\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            return document.documentElement.type || \"\";\n          ]]>\n        </getter>\n      </property>\n      <property name=\"instantApply\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var doc = document.documentElement;\n            return this.type == \"child\" ? doc.instantApply\n                                        : doc.instantApply || this.rootBranch.getBoolPref(\"browser.preferences.instantApply\");\n          ]]>\n        </getter>\n      </property>\n\n      <!-- We want to call _constructAfterChildren after all child\n           <preference> elements have been constructed. To do this, we get\n           and store the node list of all child <preference> elements in the\n           constructor, and maintain a count which is incremented in the\n           constructor of <preference>. _constructAfterChildren is called\n           when the count matches the length of the list. -->\n      <field name=\"_constructedChildrenCount\">0</field>\n      <field name=\"_preferenceChildren\">null</field>\n      <!-- Some <preference> elements are added dynamically after\n           _constructAfterChildren has already been called - we want to\n           avoid looping over all of them again in this case so we remember\n           if we already called it. -->\n      <field name=\"_constructAfterChildrenCalled\">false</field>\n      <constructor>\n      <![CDATA[\n        this._preferenceChildren = this.getElementsByTagName(\"preference\");\n      ]]>\n      </constructor>\n    </implementation>\n  </binding>\n\n  <binding id=\"preference\">\n    <implementation>\n      <constructor>\n      <![CDATA[\n        // if the element has been inserted without the name attribute set,\n        // we have nothing to do here\n        if (!this.name)\n          return;\n\n        this.preferences.rootBranchInternal\n            .addObserver(this.name, this.preferences);\n        // In non-instant apply mode, we must try and use the last saved state\n        // from any previous opens of a child dialog instead of the value from\n        // preferences, to pick up any edits a user may have made.\n\n        var secMan = Components.classes[\"@mozilla.org/scriptsecuritymanager;1\"]\n                    .getService(Components.interfaces.nsIScriptSecurityManager);\n        if (this.preferences.type == \"child\" &&\n            !this.instantApply && window.opener &&\n            secMan.isSystemPrincipal(window.opener.document.nodePrincipal)) {\n          var pdoc = window.opener.document;\n\n          // Try to find a preference element for the same preference.\n          var preference = null;\n          var parentPreferences = pdoc.getElementsByTagName(\"preferences\");\n          for (var k = 0; (k < parentPreferences.length && !preference); ++k) {\n            var parentPrefs = parentPreferences[k]\n                                    .getElementsByAttribute(\"name\", this.name);\n            for (var l = 0; (l < parentPrefs.length && !preference); ++l) {\n              if (parentPrefs[l].localName == \"preference\")\n                preference = parentPrefs[l];\n            }\n          }\n\n          // Don't use the value setter here, we don't want updateElements to be prematurely fired.\n          this._value = preference ? preference.value : this.valueFromPreferences;\n        } else {\n          this._value = this.valueFromPreferences;\n        }\n        if (this.preferences._constructAfterChildrenCalled) {\n          // This <preference> was added after _constructAfterChildren() was already called.\n          // We can directly call updateElements().\n          this.updateElements();\n          return;\n        }\n        this.preferences._constructedChildrenCount++;\n        if (this.preferences._constructedChildrenCount ==\n            this.preferences._preferenceChildren.length) {\n          // This is the last <preference>, time to updateElements() on all of them.\n          this.preferences._constructAfterChildren();\n        }\n      ]]>\n      </constructor>\n      <destructor>\n        this.preferences.rootBranchInternal\n            .removeObserver(this.name, this.preferences);\n      </destructor>\n      <field name=\"_constructed\">false</field>\n      <property name=\"instantApply\">\n        <getter>\n          if (this.getAttribute(\"instantApply\") == \"false\")\n            return false;\n          return this.getAttribute(\"instantApply\") == \"true\" || this.preferences.instantApply;\n        </getter>\n      </property>\n\n      <property name=\"preferences\" onget=\"return this.parentNode\"/>\n      <property name=\"name\" onget=\"return this.getAttribute('name');\">\n        <setter>\n          if (val == this.name)\n            return val;\n\n          this.preferences.rootBranchInternal\n              .removeObserver(this.name, this.preferences);\n          this.setAttribute(\"name\", val);\n          this.preferences.rootBranchInternal\n              .addObserver(val, this.preferences);\n\n          return val;\n        </setter>\n      </property>\n      <property name=\"type\" onget=\"return this.getAttribute('type');\"\n                            onset=\"this.setAttribute('type', val); return val;\"/>\n      <property name=\"inverted\" onget=\"return this.getAttribute('inverted') == 'true';\"\n                                onset=\"this.setAttribute('inverted', val); return val;\"/>\n      <property name=\"readonly\" onget=\"return this.getAttribute('readonly') == 'true';\"\n                                onset=\"this.setAttribute('readonly', val); return val;\"/>\n\n      <field name=\"_value\">null</field>\n      <method name=\"_setValue\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          if (this.value !== aValue) {\n            this._value = aValue;\n            if (this.instantApply)\n              this.valueFromPreferences = aValue;\n            this.preferences.fireChangedEvent(this);\n          }\n          return aValue;\n        ]]>\n        </body>\n      </method>\n      <property name=\"value\" onget=\"return this._value\" onset=\"return this._setValue(val);\"/>\n\n      <property name=\"locked\">\n        <getter>\n          return this.preferences.rootBranch.prefIsLocked(this.name);\n        </getter>\n      </property>\n\n      <property name=\"disabled\">\n        <getter>\n          return this.getAttribute(\"disabled\") == \"true\";\n        </getter>\n        <setter>\n        <![CDATA[\n          if (val)\n            this.setAttribute(\"disabled\", \"true\");\n          else\n            this.removeAttribute(\"disabled\");\n\n          if (!this.id)\n            return val;\n\n          var elements = document.getElementsByAttribute(\"preference\", this.id);\n          for (var i = 0; i < elements.length; ++i) {\n            elements[i].disabled = val;\n\n            var labels = document.getElementsByAttribute(\"control\", elements[i].id);\n            for (var j = 0; j < labels.length; ++j)\n              labels[j].disabled = val;\n          }\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"tabIndex\">\n        <getter>\n          return parseInt(this.getAttribute(\"tabindex\"));\n        </getter>\n        <setter>\n        <![CDATA[\n          if (val)\n            this.setAttribute(\"tabindex\", val);\n          else\n            this.removeAttribute(\"tabindex\");\n\n          if (!this.id)\n            return val;\n\n          var elements = document.getElementsByAttribute(\"preference\", this.id);\n          for (var i = 0; i < elements.length; ++i) {\n            elements[i].tabIndex = val;\n\n            var labels = document.getElementsByAttribute(\"control\", elements[i].id);\n            for (var j = 0; j < labels.length; ++j)\n              labels[j].tabIndex = val;\n          }\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"hasUserValue\">\n        <getter>\n        <![CDATA[\n          return this.preferences.rootBranch.prefHasUserValue(this.name) &&\n                 this.value !== undefined;\n        ]]>\n        </getter>\n      </property>\n\n      <method name=\"reset\">\n        <body>\n          // defer reset until preference update\n          this.value = undefined;\n        </body>\n      </method>\n\n      <field name=\"_useDefault\">false</field>\n      <property name=\"defaultValue\">\n        <getter>\n        <![CDATA[\n          this._useDefault = true;\n          var val = this.valueFromPreferences;\n          this._useDefault = false;\n          return val;\n        ]]>\n        </getter>\n      </property>\n\n      <property name=\"_branch\">\n        <getter>\n          return this._useDefault ? this.preferences.defaultBranch : this.preferences.rootBranch;\n        </getter>\n      </property>\n\n      <field name=\"batching\">false</field>\n\n      <method name=\"_reportUnknownType\">\n        <body>\n        <![CDATA[\n          var consoleService = Components.classes[\"@mozilla.org/consoleservice;1\"]\n                                         .getService(Components.interfaces.nsIConsoleService);\n          var msg = \"<preference> with id='\" + this.id + \"' and name='\" +\n                    this.name + \"' has unknown type '\" + this.type + \"'.\";\n          consoleService.logStringMessage(msg);\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"valueFromPreferences\">\n        <getter>\n        <![CDATA[\n          try {\n            // Force a resync of value with preferences.\n            switch (this.type) {\n            case \"int\":\n              return this._branch.getIntPref(this.name);\n            case \"bool\":\n              var val = this._branch.getBoolPref(this.name);\n              return this.inverted ? !val : val;\n            case \"wstring\":\n              return this._branch\n                         .getComplexValue(this.name, Components.interfaces.nsIPrefLocalizedString)\n                         .data;\n            case \"string\":\n            case \"unichar\":\n              return this._branch.getStringPref(this.name);\n            case \"fontname\":\n              var family = this._branch.getStringPref(this.name);\n              var fontEnumerator = Components.classes[\"@mozilla.org/gfx/fontenumerator;1\"]\n                                             .createInstance(Components.interfaces.nsIFontEnumerator);\n              return fontEnumerator.getStandardFamilyName(family);\n            case \"file\":\n              var f = this._branch\n                          .getComplexValue(this.name, Components.interfaces.nsIFile);\n              return f;\n            default:\n              this._reportUnknownType();\n            }\n          } catch (e) { }\n          return null;\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          // Exit early if nothing to do.\n          if (this.readonly || this.valueFromPreferences == val)\n            return val;\n\n          // The special value undefined means 'reset preference to default'.\n          if (val === undefined) {\n            this.preferences.rootBranch.clearUserPref(this.name);\n            return val;\n          }\n\n          // Force a resync of preferences with value.\n          switch (this.type) {\n          case \"int\":\n            this.preferences.rootBranch.setIntPref(this.name, val);\n            break;\n          case \"bool\":\n            this.preferences.rootBranch.setBoolPref(this.name, this.inverted ? !val : val);\n            break;\n          case \"wstring\":\n            var pls = Components.classes[\"@mozilla.org/pref-localizedstring;1\"]\n                                .createInstance(Components.interfaces.nsIPrefLocalizedString);\n            pls.data = val;\n            this.preferences.rootBranch\n                .setComplexValue(this.name, Components.interfaces.nsIPrefLocalizedString, pls);\n            break;\n          case \"string\":\n          case \"unichar\":\n          case \"fontname\":\n            this.preferences.rootBranch.setStringPref(this.name, val);\n            break;\n          case \"file\":\n            var lf;\n            if (typeof(val) == \"string\") {\n              lf = Components.classes[\"@mozilla.org/file/local;1\"]\n                             .createInstance(Components.interfaces.nsIFile);\n              lf.persistentDescriptor = val;\n              if (!lf.exists())\n                lf.initWithPath(val);\n            } else\n              lf = val.QueryInterface(Components.interfaces.nsIFile);\n            this.preferences.rootBranch\n                .setComplexValue(this.name, Components.interfaces.nsIFile, lf);\n            break;\n          default:\n            this._reportUnknownType();\n          }\n          if (!this.batching)\n            this.preferences.service.savePrefFile(null);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"setElementValue\">\n        <parameter name=\"aElement\"/>\n        <body>\n        <![CDATA[\n          if (this.locked)\n            aElement.disabled = true;\n\n          if (!this.isElementEditable(aElement))\n            return;\n\n          var rv = undefined;\n          if (aElement.hasAttribute(\"onsyncfrompreference\")) {\n            // Value changed, synthesize an event\n            try {\n              var event = document.createEvent(\"Events\");\n              event.initEvent(\"syncfrompreference\", true, true);\n              var f = new Function(\"event\",\n                                   aElement.getAttribute(\"onsyncfrompreference\"));\n              rv = f.call(aElement, event);\n            } catch (e) {\n              Components.utils.reportError(e);\n            }\n          }\n          var val = rv;\n          if (val === undefined)\n            val = this.instantApply ? this.valueFromPreferences : this.value;\n          // if the preference is marked for reset, show default value in UI\n          if (val === undefined)\n            val = this.defaultValue;\n\n          /**\n           * Initialize a UI element property with a value. Handles the case\n           * where an element has not yet had a XBL binding attached for it and\n           * the property setter does not yet exist by setting the same attribute\n           * on the XUL element using DOM apis and assuming the element's\n           * constructor or property getters appropriately handle this state.\n           */\n          function setValue(element, attribute, value) {\n            if (attribute in element)\n              element[attribute] = value;\n            else\n              element.setAttribute(attribute, value);\n          }\n          if (aElement.localName == \"checkbox\" ||\n              aElement.localName == \"listitem\")\n            setValue(aElement, \"checked\", val);\n          else if (aElement.localName == \"colorpicker\")\n            setValue(aElement, \"color\", val);\n          else if (aElement.localName == \"textbox\") {\n            // XXXmano Bug 303998: Avoid a caret placement issue if either the\n            // preference observer or its setter calls updateElements as a result\n            // of the input event handler.\n            if (aElement.value !== val)\n              setValue(aElement, \"value\", val);\n          } else\n            setValue(aElement, \"value\", val);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getElementValue\">\n        <parameter name=\"aElement\"/>\n        <body>\n        <![CDATA[\n          if (aElement.hasAttribute(\"onsynctopreference\")) {\n            // Value changed, synthesize an event\n            try {\n              var event = document.createEvent(\"Events\");\n              event.initEvent(\"synctopreference\", true, true);\n              var f = new Function(\"event\",\n                                   aElement.getAttribute(\"onsynctopreference\"));\n              var rv = f.call(aElement, event);\n              if (rv !== undefined)\n                return rv;\n            } catch (e) {\n              Components.utils.reportError(e);\n            }\n          }\n\n          /**\n           * Read the value of an attribute from an element, assuming the\n           * attribute is a property on the element's node API. If the property\n           * is not present in the API, then assume its value is contained in\n           * an attribute, as is the case before a binding has been attached.\n           */\n          function getValue(element, attribute) {\n            if (attribute in element)\n              return element[attribute];\n            return element.getAttribute(attribute);\n          }\n          if (aElement.localName == \"checkbox\" ||\n              aElement.localName == \"listitem\")\n            var value = getValue(aElement, \"checked\");\n          else if (aElement.localName == \"colorpicker\")\n            value = getValue(aElement, \"color\");\n          else\n            value = getValue(aElement, \"value\");\n\n          switch (this.type) {\n          case \"int\":\n            return parseInt(value, 10) || 0;\n          case \"bool\":\n            return typeof(value) == \"boolean\" ? value : value == \"true\";\n          }\n          return value;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isElementEditable\">\n        <parameter name=\"aElement\"/>\n        <body>\n        <![CDATA[\n          switch (aElement.localName) {\n          case \"checkbox\":\n          case \"colorpicker\":\n          case \"radiogroup\":\n          case \"textbox\":\n          case \"listitem\":\n          case \"listbox\":\n          case \"menulist\":\n            return true;\n          }\n          return aElement.getAttribute(\"preference-editable\") == \"true\";\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"updateElements\">\n        <body>\n        <![CDATA[\n          if (!this.id)\n            return;\n\n          // This \"change\" event handler tracks changes made to preferences by\n          // sources other than the user in this window.\n          var elements = document.getElementsByAttribute(\"preference\", this.id);\n          for (var i = 0; i < elements.length; ++i)\n            this.setElementValue(elements[i]);\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"change\">\n        this.updateElements();\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"prefwindow\"\n           extends=\"chrome://global/content/bindings/dialog.xml#dialog\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/preferences.css\"/>\n    </resources>\n    <content dlgbuttons=\"accept,cancel\" persist=\"lastSelected screenX screenY\"\n             closebuttonlabel=\"FROM-DTD-preferencesCloseButton-label\"\n             closebuttonaccesskey=\"FROM-DTD-preferencesCloseButton-accesskey\"\n             role=\"dialog\"\n\n             title=\"FROM-DTD-preferencesDefaultTitleWin-title\">\n\n      <xul:windowdragbox orient=\"vertical\">\n        <xul:radiogroup anonid=\"selector\" orient=\"horizontal\" class=\"paneSelector chromeclass-toolbar\"\n                        role=\"listbox\"/> <!-- Expose to accessibility APIs as a listbox -->\n      </xul:windowdragbox>\n      <xul:hbox flex=\"1\" class=\"paneDeckContainer\">\n        <xul:deck anonid=\"paneDeck\" flex=\"1\">\n          <children includes=\"prefpane\"/>\n        </xul:deck>\n      </xul:hbox>\n      <xul:hbox anonid=\"dlg-buttons\" class=\"prefWindow-dlgbuttons\" pack=\"end\">\n\n        <xul:button dlgtype=\"extra2\" class=\"dialog-button\" hidden=\"true\"/>\n        <xul:spacer anonid=\"spacer\" flex=\"1\"/>\n        <xul:button dlgtype=\"accept\" class=\"dialog-button\" icon=\"accept\"/>\n        <xul:button dlgtype=\"extra1\" class=\"dialog-button\" hidden=\"true\"/>\n        <xul:button dlgtype=\"cancel\" class=\"dialog-button\" icon=\"cancel\"/>\n        <xul:button dlgtype=\"help\" class=\"dialog-button\" hidden=\"true\" icon=\"help\"/>\n        <xul:button dlgtype=\"disclosure\" class=\"dialog-button\" hidden=\"true\"/>\n\n      </xul:hbox>\n      <xul:hbox>\n        <children/>\n      </xul:hbox>\n    </content>\n    <implementation implements=\"nsITimerCallback\">\n      <constructor>\n      <![CDATA[\n        if (this.type != \"child\") {\n          if (!this._instantApplyInitialized) {\n            let psvc = Components.classes[\"@mozilla.org/preferences-service;1\"]\n                                 .getService(Components.interfaces.nsIPrefBranch);\n            this.instantApply = psvc.getBoolPref(\"browser.preferences.instantApply\");\n          }\n          if (this.instantApply) {\n            var docElt = document.documentElement;\n            var acceptButton = docElt.getButton(\"accept\");\n            acceptButton.hidden = true;\n            var cancelButton  = docElt.getButton(\"cancel\");\n            if (/Mac/.test(navigator.platform)) {\n              // no buttons on Mac except Help\n              cancelButton.hidden = true;\n              // Move Help button to the end\n              document.getAnonymousElementByAttribute(this, \"anonid\", \"spacer\").hidden = true;\n              // Also, don't fire onDialogAccept on enter\n              acceptButton.disabled = true;\n            } else {\n              // morph the Cancel button into the Close button\n              cancelButton.setAttribute(\"icon\", \"close\");\n              cancelButton.label = docElt.getAttribute(\"closebuttonlabel\");\n              cancelButton.accesskey = docElt.getAttribute(\"closebuttonaccesskey\");\n            }\n          }\n        }\n        this.setAttribute(\"animated\", this._shouldAnimate ? \"true\" : \"false\");\n        var panes = this.preferencePanes;\n\n        var lastPane = null;\n        if (this.lastSelected) {\n          lastPane = document.getElementById(this.lastSelected);\n          if (!lastPane) {\n            this.lastSelected = \"\";\n          }\n        }\n\n        var paneToLoad;\n        if (\"arguments\" in window && window.arguments[0] && document.getElementById(window.arguments[0]) && document.getElementById(window.arguments[0]).nodeName == \"prefpane\") {\n          paneToLoad = document.getElementById(window.arguments[0]);\n          this.lastSelected = paneToLoad.id;\n        } else if (lastPane)\n          paneToLoad = lastPane;\n        else\n          paneToLoad = panes[0];\n\n        for (var i = 0; i < panes.length; ++i) {\n          this._makePaneButton(panes[i]);\n          if (panes[i].loaded) {\n            // Inline pane content, fire load event to force initialization.\n            this._fireEvent(\"paneload\", panes[i]);\n          }\n        }\n        this.showPane(paneToLoad);\n\n        if (panes.length == 1)\n          this._selector.setAttribute(\"collapsed\", \"true\");\n      ]]>\n      </constructor>\n\n      <destructor>\n      <![CDATA[\n        // Release timers to avoid reference cycles.\n        if (this._animateTimer) {\n          this._animateTimer.cancel();\n          this._animateTimer = null;\n        }\n        if (this._fadeTimer) {\n          this._fadeTimer.cancel();\n          this._fadeTimer = null;\n        }\n      ]]>\n      </destructor>\n\n      <!-- Derived bindings can set this to true to cause us to skip\n           reading the browser.preferences.instantApply pref in the constructor.\n           Then they can set instantApply to their wished value. -->\n      <field name=\"_instantApplyInitialized\">false</field>\n      <!-- Controls whether changed pref values take effect immediately. -->\n      <field name=\"instantApply\">false</field>\n\n      <property name=\"preferencePanes\"\n                onget=\"return this.getElementsByTagName('prefpane');\"/>\n\n      <property name=\"type\" onget=\"return this.getAttribute('type');\"/>\n      <property name=\"_paneDeck\"\n                onget=\"return document.getAnonymousElementByAttribute(this, 'anonid', 'paneDeck');\"/>\n      <property name=\"_paneDeckContainer\"\n                onget=\"return document.getAnonymousElementByAttribute(this, 'class', 'paneDeckContainer');\"/>\n      <property name=\"_selector\"\n                onget=\"return document.getAnonymousElementByAttribute(this, 'anonid', 'selector');\"/>\n      <property name=\"lastSelected\"\n                onget=\"return this.getAttribute('lastSelected');\">\n        <setter>\n          this.setAttribute(\"lastSelected\", val);\n          document.persist(this.id, \"lastSelected\");\n          return val;\n        </setter>\n      </property>\n      <property name=\"currentPane\"\n                onset=\"return this._currentPane = val;\">\n        <getter>\n          if (!this._currentPane)\n            this._currentPane = this.preferencePanes[0];\n\n          return this._currentPane;\n        </getter>\n      </property>\n      <field name=\"_currentPane\">null</field>\n\n\n      <method name=\"_makePaneButton\">\n        <parameter name=\"aPaneElement\"/>\n        <body>\n        <![CDATA[\n          var radio = document.createElement(\"radio\");\n          radio.setAttribute(\"pane\", aPaneElement.id);\n          radio.setAttribute(\"label\", aPaneElement.label);\n          // Expose preference group choice to accessibility APIs as an unchecked list item\n          // The parent group is exposed to accessibility APIs as a list\n          if (aPaneElement.image)\n            radio.setAttribute(\"src\", aPaneElement.image);\n          radio.style.listStyleImage = aPaneElement.style.listStyleImage;\n          this._selector.appendChild(radio);\n          return radio;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"showPane\">\n        <parameter name=\"aPaneElement\"/>\n        <body>\n        <![CDATA[\n          if (!aPaneElement)\n            return;\n\n          this._selector.selectedItem = document.getAnonymousElementByAttribute(this, \"pane\", aPaneElement.id);\n          if (!aPaneElement.loaded) {\n            let OverlayLoadObserver = function(aPane) {\n              this._pane = aPane;\n            }\n            OverlayLoadObserver.prototype = {\n              _outer: this,\n              observe(aSubject, aTopic, aData) {\n                this._pane.loaded = true;\n                this._outer._fireEvent(\"paneload\", this._pane);\n                this._outer._selectPane(this._pane);\n              }\n            };\n\n            var obs = new OverlayLoadObserver(aPaneElement);\n            document.loadOverlay(aPaneElement.src, obs);\n          } else\n            this._selectPane(aPaneElement);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_fireEvent\">\n        <parameter name=\"aEventName\"/>\n        <parameter name=\"aTarget\"/>\n        <body>\n        <![CDATA[\n          // Panel loaded, synthesize a load event.\n          try {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(aEventName, true, true);\n            var cancel = !aTarget.dispatchEvent(event);\n            if (aTarget.hasAttribute(\"on\" + aEventName)) {\n              var fn = new Function(\"event\", aTarget.getAttribute(\"on\" + aEventName));\n              var rv = fn.call(aTarget, event);\n              if (rv == false)\n                cancel = true;\n            }\n            return !cancel;\n          } catch (e) {\n            Components.utils.reportError(e);\n          }\n          return false;\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"_initialized\">false</field>\n      <method name=\"_selectPane\">\n        <parameter name=\"aPaneElement\"/>\n        <body>\n        <![CDATA[\n          if (/Mac/.test(navigator.platform)) {\n            var paneTitle = aPaneElement.label;\n            if (paneTitle != \"\")\n              document.title = paneTitle;\n          }\n          var helpButton = document.documentElement.getButton(\"help\");\n          if (aPaneElement.helpTopic)\n            helpButton.hidden = false;\n          else\n            helpButton.hidden = true;\n\n          // Find this pane's index in the deck and set the deck's\n          // selectedIndex to that value to switch to it.\n          var prefpanes = this.preferencePanes;\n          for (var i = 0; i < prefpanes.length; ++i) {\n            if (prefpanes[i] == aPaneElement) {\n              this._paneDeck.selectedIndex = i;\n\n              if (this.type != \"child\") {\n                if (aPaneElement.hasAttribute(\"flex\") && this._shouldAnimate &&\n                    prefpanes.length > 1)\n                  aPaneElement.removeAttribute(\"flex\");\n                // Calling sizeToContent after the first prefpane is loaded\n                // will size the windows contents so style information is\n                // available to calculate correct sizing.\n                if (!this._initialized && prefpanes.length > 1) {\n                  if (this._shouldAnimate)\n                    this.style.minHeight = 0;\n                  window.sizeToContent();\n                }\n\n                var oldPane = this.lastSelected ? document.getElementById(this.lastSelected) : this.preferencePanes[0];\n                oldPane.selected = !(aPaneElement.selected = true);\n                this.lastSelected = aPaneElement.id;\n                this.currentPane = aPaneElement;\n                this._initialized = true;\n\n                // Only animate if we've switched between prefpanes\n                if (this._shouldAnimate && oldPane.id != aPaneElement.id) {\n                  aPaneElement.style.opacity = 0.0;\n                  this.animate(oldPane, aPaneElement);\n                } else if (!this._shouldAnimate && prefpanes.length > 1) {\n                  var targetHeight = parseInt(window.getComputedStyle(this._paneDeckContainer).height);\n                  var verticalPadding = parseInt(window.getComputedStyle(aPaneElement).paddingTop);\n                  verticalPadding += parseInt(window.getComputedStyle(aPaneElement).paddingBottom);\n                  if (aPaneElement.contentHeight > targetHeight - verticalPadding) {\n                    // To workaround the bottom border of a groupbox from being\n                    // cutoff an hbox with a class of bottomBox may enclose it.\n                    // This needs to include its padding to resize properly.\n                    // See bug 394433\n                    var bottomPadding = 0;\n                    var bottomBox = aPaneElement.getElementsByAttribute(\"class\", \"bottomBox\")[0];\n                    if (bottomBox)\n                      bottomPadding = parseInt(window.getComputedStyle(bottomBox).paddingBottom);\n                    window.innerHeight += bottomPadding + verticalPadding + aPaneElement.contentHeight - targetHeight;\n                  }\n\n                  // XXX rstrong - extend the contents of the prefpane to\n                  // prevent elements from being cutoff (see bug 349098).\n                  if (aPaneElement.contentHeight + verticalPadding < targetHeight)\n                    aPaneElement._content.style.height = targetHeight - verticalPadding + \"px\";\n                }\n              }\n              break;\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"_shouldAnimate\">\n        <getter>\n        <![CDATA[\n          var psvc = Components.classes[\"@mozilla.org/preferences-service;1\"]\n                               .getService(Components.interfaces.nsIPrefBranch);\n          return psvc.getBoolPref(\"browser.preferences.animateFadeIn\",\n                                  /Mac/.test(navigator.platform));\n        ]]>\n        </getter>\n      </property>\n\n      <method name=\"animate\">\n        <parameter name=\"aOldPane\"/>\n        <parameter name=\"aNewPane\"/>\n        <body>\n        <![CDATA[\n          // if we are already resizing, use currentHeight\n          var oldHeight = this._currentHeight ? this._currentHeight : aOldPane.contentHeight;\n\n          this._multiplier = aNewPane.contentHeight > oldHeight ? 1 : -1;\n          var sizeDelta = Math.abs(oldHeight - aNewPane.contentHeight);\n          this._animateRemainder = sizeDelta % this._animateIncrement;\n\n          this._setUpAnimationTimer(oldHeight);\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"_sizeIncrement\">\n        <getter>\n        <![CDATA[\n          var lastSelectedPane = document.getElementById(this.lastSelected);\n          var increment = this._animateIncrement * this._multiplier;\n          var newHeight = this._currentHeight + increment;\n          if ((this._multiplier > 0 && this._currentHeight >= lastSelectedPane.contentHeight) ||\n              (this._multiplier < 0 && this._currentHeight <= lastSelectedPane.contentHeight))\n            return 0;\n\n          if ((this._multiplier > 0 && newHeight > lastSelectedPane.contentHeight) ||\n              (this._multiplier < 0 && newHeight < lastSelectedPane.contentHeight))\n            increment = this._animateRemainder * this._multiplier;\n          return increment;\n        ]]>\n        </getter>\n      </property>\n\n      <method name=\"notify\">\n        <parameter name=\"aTimer\"/>\n        <body>\n        <![CDATA[\n          if (!document)\n            aTimer.cancel();\n\n          if (aTimer == this._animateTimer) {\n            var increment = this._sizeIncrement;\n            if (increment != 0) {\n              window.innerHeight += increment;\n              this._currentHeight += increment;\n            } else {\n              aTimer.cancel();\n              this._setUpFadeTimer();\n            }\n          } else if (aTimer == this._fadeTimer) {\n            var elt = document.getElementById(this.lastSelected);\n            var newOpacity = parseFloat(window.getComputedStyle(elt).opacity) + this._fadeIncrement;\n            if (newOpacity < 1.0)\n              elt.style.opacity = newOpacity;\n            else {\n              aTimer.cancel();\n              elt.style.opacity = 1.0;\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_setUpAnimationTimer\">\n        <parameter name=\"aStartHeight\"/>\n        <body>\n        <![CDATA[\n          if (!this._animateTimer)\n            this._animateTimer = Components.classes[\"@mozilla.org/timer;1\"]\n                                           .createInstance(Components.interfaces.nsITimer);\n          else\n            this._animateTimer.cancel();\n          this._currentHeight = aStartHeight;\n\n          this._animateTimer.initWithCallback(this, this._animateDelay,\n                                              Components.interfaces.nsITimer.TYPE_REPEATING_SLACK);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_setUpFadeTimer\">\n        <body>\n        <![CDATA[\n          if (!this._fadeTimer)\n            this._fadeTimer = Components.classes[\"@mozilla.org/timer;1\"]\n                                        .createInstance(Components.interfaces.nsITimer);\n          else\n            this._fadeTimer.cancel();\n\n          this._fadeTimer.initWithCallback(this, this._fadeDelay,\n                                           Components.interfaces.nsITimer.TYPE_REPEATING_SLACK);\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"_animateTimer\">null</field>\n      <field name=\"_fadeTimer\">null</field>\n      <field name=\"_animateDelay\">15</field>\n      <field name=\"_animateIncrement\">40</field>\n      <field name=\"_fadeDelay\">5</field>\n      <field name=\"_fadeIncrement\">0.40</field>\n      <field name=\"_animateRemainder\">0</field>\n      <field name=\"_currentHeight\">0</field>\n      <field name=\"_multiplier\">0</field>\n\n      <method name=\"addPane\">\n        <parameter name=\"aPaneElement\"/>\n        <body>\n        <![CDATA[\n          this.appendChild(aPaneElement);\n\n          // Set up pane button\n          this._makePaneButton(aPaneElement);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"openSubDialog\">\n        <parameter name=\"aURL\"/>\n        <parameter name=\"aFeatures\"/>\n        <parameter name=\"aParams\"/>\n        <body>\n          return openDialog(aURL, \"\", \"modal,centerscreen,resizable=no\" + (aFeatures != \"\" ? (\",\" + aFeatures) : \"\"), aParams);\n        </body>\n      </method>\n\n      <method name=\"openWindow\">\n        <parameter name=\"aWindowType\"/>\n        <parameter name=\"aURL\"/>\n        <parameter name=\"aFeatures\"/>\n        <parameter name=\"aParams\"/>\n        <body>\n        <![CDATA[\n          var wm = Components.classes[\"@mozilla.org/appshell/window-mediator;1\"]\n                             .getService(Components.interfaces.nsIWindowMediator);\n          var win = aWindowType ? wm.getMostRecentWindow(aWindowType) : null;\n          if (win) {\n            if (\"initWithParams\" in win)\n              win.initWithParams(aParams);\n            win.focus();\n          } else {\n            var features = \"resizable,dialog=no,centerscreen\" + (aFeatures != \"\" ? (\",\" + aFeatures) : \"\");\n            var parentWindow = (this.instantApply || !window.opener || window.opener.closed) ? window : window.opener;\n            win = parentWindow.openDialog(aURL, \"_blank\", features, aParams);\n          }\n          return win;\n        ]]>\n        </body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"dialogaccept\">\n      <![CDATA[\n        if (!this._fireEvent(\"beforeaccept\", this)) {\n          return false;\n        }\n\n        var secMan = Components.classes[\"@mozilla.org/scriptsecuritymanager;1\"]\n                    .getService(Components.interfaces.nsIScriptSecurityManager);\n        if (this.type == \"child\" && window.opener &&\n            secMan.isSystemPrincipal(window.opener.document.nodePrincipal)) {\n          var pdocEl = window.opener.document.documentElement;\n          if (pdocEl.instantApply) {\n            let panes = this.preferencePanes;\n            for (let i = 0; i < panes.length; ++i)\n              panes[i].writePreferences(true);\n          } else {\n            // Clone all the preferences elements from the child document and\n            // insert them into the pane collection of the parent.\n            var pdoc = window.opener.document;\n            if (pdoc.documentElement.localName == \"prefwindow\") {\n              var currentPane = pdoc.documentElement.currentPane;\n              var id = window.location.href + \"#childprefs\";\n              var childPrefs = pdoc.getElementById(id);\n              if (!childPrefs) {\n                childPrefs = pdoc.createElement(\"preferences\");\n                currentPane.appendChild(childPrefs);\n                childPrefs.id = id;\n              }\n              let panes = this.preferencePanes;\n              for (let i = 0; i < panes.length; ++i) {\n                var preferences = panes[i].preferences;\n                for (var j = 0; j < preferences.length; ++j) {\n                  // Try to find a preference element for the same preference.\n                  var preference = null;\n                  var parentPreferences = pdoc.getElementsByTagName(\"preferences\");\n                  for (var k = 0; (k < parentPreferences.length && !preference); ++k) {\n                    var parentPrefs = parentPreferences[k]\n                                         .getElementsByAttribute(\"name\", preferences[j].name);\n                    for (var l = 0; (l < parentPrefs.length && !preference); ++l) {\n                      if (parentPrefs[l].localName == \"preference\")\n                        preference = parentPrefs[l];\n                    }\n                  }\n                  if (!preference) {\n                    // No matching preference in the parent window.\n                    preference = pdoc.createElement(\"preference\");\n                    childPrefs.appendChild(preference);\n                    preference.name     = preferences[j].name;\n                    preference.type     = preferences[j].type;\n                    preference.inverted = preferences[j].inverted;\n                    preference.readonly = preferences[j].readonly;\n                    preference.disabled = preferences[j].disabled;\n                  }\n                  preference.value = preferences[j].value;\n                }\n              }\n            }\n          }\n        } else {\n          let panes = this.preferencePanes;\n          for (var i = 0; i < panes.length; ++i)\n            panes[i].writePreferences(false);\n\n          let psvc = Components.classes[\"@mozilla.org/preferences-service;1\"]\n                               .getService(Components.interfaces.nsIPrefService);\n          psvc.savePrefFile(null);\n        }\n\n        return true;\n      ]]>\n      </handler>\n      <handler event=\"command\">\n        if (event.originalTarget.hasAttribute(\"pane\")) {\n          var pane = document.getElementById(event.originalTarget.getAttribute(\"pane\"));\n          this.showPane(pane);\n        }\n      </handler>\n\n      <handler event=\"keypress\" key=\"FROM-DTD-windowClose-key\" modifiers=\"accel\" phase=\"capturing\">\n      <![CDATA[\n        if (this.instantApply)\n          window.close();\n        event.stopPropagation();\n        event.preventDefault();\n      ]]>\n      </handler>\n\n      <handler event=\"keypress\"\n\n               keycode=\"FROM-DTD-openHelp-commandkey\"\n\n               phase=\"capturing\">\n      <![CDATA[\n        var helpButton = this.getButton(\"help\");\n        if (helpButton.disabled || helpButton.hidden)\n          return;\n        this._fireEvent(\"dialoghelp\", this);\n        event.stopPropagation();\n        event.preventDefault();\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"prefpane\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/preferences.css\"/>\n    </resources>\n    <content>\n      <xul:vbox class=\"content-box\" xbl:inherits=\"flex\">\n        <children/>\n      </xul:vbox>\n    </content>\n    <implementation>\n      <method name=\"writePreferences\">\n        <parameter name=\"aFlushToDisk\"/>\n        <body>\n        <![CDATA[\n          // Write all values to preferences.\n          if (this._deferredValueUpdateElements.size) {\n            this._finalizeDeferredElements();\n          }\n\n          var preferences = this.preferences;\n          for (var i = 0; i < preferences.length; ++i) {\n            var preference = preferences[i];\n            preference.batching = true;\n            preference.valueFromPreferences = preference.value;\n            preference.batching = false;\n          }\n          if (aFlushToDisk) {\n            var psvc = Components.classes[\"@mozilla.org/preferences-service;1\"]\n                                 .getService(Components.interfaces.nsIPrefService);\n            psvc.savePrefFile(null);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"src\"\n                onget=\"return this.getAttribute('src');\"\n                onset=\"this.setAttribute('src', val); return val;\"/>\n      <property name=\"selected\"\n                onget=\"return this.getAttribute('selected') == 'true';\"\n                onset=\"this.setAttribute('selected', val); return val;\"/>\n      <property name=\"image\"\n                onget=\"return this.getAttribute('image');\"\n                onset=\"this.setAttribute('image', val); return val;\"/>\n      <property name=\"label\"\n                onget=\"return this.getAttribute('label');\"\n                onset=\"this.setAttribute('label', val); return val;\"/>\n\n      <property name=\"preferenceElements\"\n                onget=\"return this.getElementsByAttribute('preference', '*');\"/>\n      <property name=\"preferences\"\n                onget=\"return this.getElementsByTagName('preference');\"/>\n\n      <property name=\"helpTopic\">\n        <getter>\n        <![CDATA[\n          // if there are tabs, and the selected tab provides a helpTopic, return that\n          var box = this.getElementsByTagName(\"tabbox\");\n          if (box[0]) {\n            var tab = box[0].selectedTab;\n            if (tab && tab.hasAttribute(\"helpTopic\"))\n              return tab.getAttribute(\"helpTopic\");\n          }\n\n          // otherwise, return the helpTopic of the current panel\n          return this.getAttribute(\"helpTopic\");\n        ]]>\n        </getter>\n      </property>\n\n      <field name=\"_loaded\">false</field>\n      <property name=\"loaded\"\n                onget=\"return !this.src ? true : this._loaded;\"\n                onset=\"this._loaded = val; return val;\"/>\n\n      <method name=\"preferenceForElement\">\n        <parameter name=\"aElement\"/>\n        <body>\n          return document.getElementById(aElement.getAttribute(\"preference\"));\n        </body>\n      </method>\n\n      <method name=\"getPreferenceElement\">\n        <parameter name=\"aStartElement\"/>\n        <body>\n        <![CDATA[\n          var temp = aStartElement;\n          while (temp && temp.nodeType == Node.ELEMENT_NODE &&\n                 !temp.hasAttribute(\"preference\"))\n            temp = temp.parentNode;\n          return temp && temp.nodeType == Node.ELEMENT_NODE ?\n                 temp : aStartElement;\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"DeferredTask\" readonly=\"true\">\n        <getter><![CDATA[\n          let module = {};\n          Components.utils.import(\"resource://gre/modules/DeferredTask.jsm\", module);\n          Object.defineProperty(this, \"DeferredTask\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: module.DeferredTask\n          });\n          return module.DeferredTask;\n        ]]></getter>\n      </property>\n      <method name=\"_deferredValueUpdate\">\n        <parameter name=\"aElement\"/>\n        <body>\n        <![CDATA[\n          delete aElement._deferredValueUpdateTask;\n          let preference = document.getElementById(aElement.getAttribute(\"preference\"));\n          let prefVal = preference.getElementValue(aElement);\n          preference.value = prefVal;\n          this._deferredValueUpdateElements.delete(aElement);\n        ]]>\n        </body>\n      </method>\n      <field name=\"_deferredValueUpdateElements\">\n        new Set();\n      </field>\n      <method name=\"_finalizeDeferredElements\">\n        <body>\n        <![CDATA[\n          for (let el of this._deferredValueUpdateElements) {\n            if (el._deferredValueUpdateTask) {\n              el._deferredValueUpdateTask.finalize();\n            }\n          }\n        ]]>\n        </body>\n      </method>\n      <method name=\"userChangedValue\">\n        <parameter name=\"aElement\"/>\n        <body>\n        <![CDATA[\n          let element = this.getPreferenceElement(aElement);\n          if (element.hasAttribute(\"preference\")) {\n            if (element.getAttribute(\"delayprefsave\") != \"true\") {\n              var preference = document.getElementById(element.getAttribute(\"preference\"));\n              var prefVal = preference.getElementValue(element);\n              preference.value = prefVal;\n            } else {\n              if (!element._deferredValueUpdateTask) {\n                element._deferredValueUpdateTask = new this.DeferredTask(this._deferredValueUpdate.bind(this, element), 1000);\n                this._deferredValueUpdateElements.add(element);\n              } else {\n                // Each time the preference is changed, restart the delay.\n                element._deferredValueUpdateTask.disarm();\n              }\n              element._deferredValueUpdateTask.arm();\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"contentHeight\">\n        <getter>\n          var targetHeight = parseInt(window.getComputedStyle(this._content).height);\n          targetHeight += parseInt(window.getComputedStyle(this._content).marginTop);\n          targetHeight += parseInt(window.getComputedStyle(this._content).marginBottom);\n          return targetHeight;\n        </getter>\n      </property>\n      <field name=\"_content\">\n        document.getAnonymousElementByAttribute(this, \"class\", \"content-box\");\n      </field>\n    </implementation>\n    <handlers>\n      <handler event=\"command\">\n        // This \"command\" event handler tracks changes made to preferences by\n        // the user in this window.\n        if (event.sourceEvent)\n          event = event.sourceEvent;\n        this.userChangedValue(event.target);\n      </handler>\n      <handler event=\"select\">\n        // This \"select\" event handler tracks changes made to colorpicker\n        // preferences by the user in this window.\n        if (event.target.localName == \"colorpicker\")\n          this.userChangedValue(event.target);\n      </handler>\n      <handler event=\"change\">\n        // This \"change\" event handler tracks changes made to preferences by\n        // the user in this window.\n        this.userChangedValue(event.target);\n      </handler>\n      <handler event=\"input\">\n        // This \"input\" event handler tracks changes made to preferences by\n        // the user in this window.\n        this.userChangedValue(event.target);\n      </handler>\n      <handler event=\"paneload\">\n      <![CDATA[\n        // Initialize all values from preferences.\n        var elements = this.preferenceElements;\n        for (var i = 0; i < elements.length; ++i) {\n          try {\n            var preference = this.preferenceForElement(elements[i]);\n            preference.setElementValue(elements[i]);\n          } catch (e) {\n            dump(\"*** No preference found for \" + elements[i].getAttribute(\"preference\") + \"\\n\");\n          }\n        }\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"panebutton\" role=\"xul:listitem\"\n           extends=\"chrome://global/content/bindings/radio.xml#radio\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/preferences.css\"/>\n    </resources>\n    <content>\n      <xul:image class=\"paneButtonIcon\" xbl:inherits=\"src\"/>\n      <xul:label class=\"paneButtonLabel\" xbl:inherits=\"value=label\"/>\n    </content>\n  </binding>\n\n</bindings>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"file":"progressmeter.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"progressmeterBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"progressmeter\" role=\"xul:progressmeter\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/progressmeter.css\"/>\n    </resources>\n\n    <content>\n      <xul:spacer class=\"progress-bar\" xbl:inherits=\"mode\"/>\n      <xul:spacer class=\"progress-remainder\" xbl:inherits=\"mode\"/>\n    </content>\n\n    <implementation>\n      <property name=\"mode\" onset=\"if (this.mode != val) this.setAttribute('mode', val); return val;\"\n                            onget=\"return this.getAttribute('mode');\"/>\n\n      <property name=\"value\" onget=\"return this.getAttribute('value') || '0';\">\n        <setter><![CDATA[\n          var p = Math.round(val);\n          var max = Math.round(this.max);\n          if (p < 0)\n            p = 0;\n          else if (p > max)\n            p = max;\n          var c = this.value;\n          if (p != c) {\n            var delta = p - c;\n            if (delta < 0)\n              delta = -delta;\n            if (delta > 3 || p == 0 || p == max) {\n              this.setAttribute(\"value\", p);\n              // Fire DOM event so that accessible value change events occur\n              var event = document.createEvent(\"Events\");\n              event.initEvent(\"ValueChange\", true, true);\n              this.dispatchEvent(event);\n            }\n          }\n\n          return val;\n        ]]></setter>\n      </property>\n      <property name=\"max\"\n                onget=\"return this.getAttribute('max') || '100';\"\n                onset=\"this.setAttribute('max', isNaN(val) ? 100 : Math.max(val, 1));\n                       this.value = this.value;\n                       return val;\" />\n    </implementation>\n  </binding>\n\n  <binding id=\"progressmeter-undetermined\"\n           extends=\"chrome://global/content/bindings/progressmeter.xml#progressmeter\">\n    <content>\n      <xul:stack class=\"progress-remainder\" flex=\"1\" anonid=\"stack\" style=\"overflow: -moz-hidden-unscrollable;\">\n        <xul:spacer class=\"progress-bar\" anonid=\"spacer\" top=\"0\" style=\"margin-right: -1000px;\"/>\n      </xul:stack>\n    </content>\n\n    <implementation>\n      <field name=\"_alive\">true</field>\n      <method name=\"_init\">\n        <body><![CDATA[\n          var stack =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"stack\");\n          var spacer =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"spacer\");\n          var isLTR =\n           document.defaultView.getComputedStyle(this).direction == \"ltr\";\n          var startTime = performance.now();\n          var self = this;\n\n          function nextStep(t) {\n            try {\n              var width = stack.boxObject.width;\n              if (!width) {\n                // Maybe we've been removed from the document.\n                if (self._alive)\n                  requestAnimationFrame(nextStep);\n                return;\n              }\n\n              var elapsedTime = t - startTime;\n\n              // Width of chunk is 1/5 (determined by the ratio 2000:400) of the\n              // total width of the progress bar. The left edge of the chunk\n              // starts at -1 and moves all the way to 4. It covers the distance\n              // in 2 seconds.\n              var position = isLTR ? ((elapsedTime % 2000) / 400) - 1 :\n                                     ((elapsedTime % 2000) / -400) + 4;\n\n              width = width >> 2;\n              spacer.height = stack.boxObject.height;\n              spacer.width = width;\n              spacer.left = width * position;\n\n              requestAnimationFrame(nextStep);\n            } catch (e) {\n            }\n          }\n          requestAnimationFrame(nextStep);\n        ]]></body>\n      </method>\n\n      <constructor>this._init();</constructor>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"radio.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"radioBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"radiogroup\" role=\"xul:radiogroup\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/radio.css\"/>\n    </resources>\n\n    <implementation implements=\"nsIDOMXULSelectControlElement\">\n      <constructor>\n        <![CDATA[\n          if (this.getAttribute(\"disabled\") == \"true\")\n            this.disabled = true;\n\n          var children = this._getRadioChildren();\n          var length = children.length;\n          for (var i = 0; i < length; i++) {\n            if (children[i].getAttribute(\"selected\") == \"true\") {\n              this.selectedIndex = i;\n              return;\n            }\n          }\n\n          var value = this.value;\n          if (value)\n            this.value = value;\n          else\n            this.selectedIndex = 0;\n        ]]>\n      </constructor>\n\n      <property name=\"value\" onget=\"return this.getAttribute('value');\">\n        <setter>\n          <![CDATA[\n            this.setAttribute(\"value\", val);\n            var children = this._getRadioChildren();\n            for (var i = 0; i < children.length; i++) {\n              if (String(children[i].value) == String(val)) {\n                this.selectedItem = children[i];\n                break;\n              }\n            }\n            return val;\n          ]]>\n        </setter>\n      </property>\n      <property name=\"disabled\">\n        <getter>\n        <![CDATA[\n          if (this.getAttribute(\"disabled\") == \"true\")\n            return true;\n          var children = this._getRadioChildren();\n          for (var i = 0; i < children.length; ++i) {\n            if (!children[i].hidden && !children[i].collapsed && !children[i].disabled)\n              return false;\n          }\n          return true;\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          if (val)\n            this.setAttribute(\"disabled\", \"true\");\n          else\n            this.removeAttribute(\"disabled\");\n          var children = this._getRadioChildren();\n          for (var i = 0; i < children.length; ++i) {\n            children[i].disabled = val;\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"itemCount\" readonly=\"true\"\n                onget=\"return this._getRadioChildren().length\"/>\n\n      <property name=\"selectedIndex\">\n        <getter>\n        <![CDATA[\n          var children = this._getRadioChildren();\n          for (var i = 0; i < children.length; ++i) {\n            if (children[i].selected)\n              return i;\n          }\n          return -1;\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          this.selectedItem = this._getRadioChildren()[val];\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedItem\">\n        <getter>\n        <![CDATA[\n          var children = this._getRadioChildren();\n          for (var i = 0; i < children.length; ++i) {\n            if (children[i].selected)\n              return children[i];\n          }\n          return null;\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          var focused = this.getAttribute(\"focused\") == \"true\";\n          var alreadySelected = false;\n\n          if (val) {\n            alreadySelected = val.getAttribute(\"selected\") == \"true\";\n            val.setAttribute(\"focused\", focused);\n            val.setAttribute(\"selected\", \"true\");\n            this.setAttribute(\"value\", val.value);\n          } else {\n            this.removeAttribute(\"value\");\n          }\n\n          // uncheck all other group nodes\n          var children = this._getRadioChildren();\n          var previousItem = null;\n          for (var i = 0; i < children.length; ++i) {\n            if (children[i] != val) {\n              if (children[i].getAttribute(\"selected\") == \"true\")\n                previousItem = children[i];\n\n              children[i].removeAttribute(\"selected\");\n              children[i].removeAttribute(\"focused\");\n            }\n          }\n\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"select\", false, true);\n          this.dispatchEvent(event);\n\n          if (!alreadySelected && focused) {\n            // Only report if actual change\n            var myEvent;\n            if (val) {\n              myEvent = document.createEvent(\"Events\");\n              myEvent.initEvent(\"RadioStateChange\", true, true);\n              val.dispatchEvent(myEvent);\n            }\n\n            if (previousItem) {\n              myEvent = document.createEvent(\"Events\");\n              myEvent.initEvent(\"RadioStateChange\", true, true);\n              previousItem.dispatchEvent(myEvent);\n            }\n          }\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"focusedItem\">\n        <getter>\n        <![CDATA[\n          var children = this._getRadioChildren();\n          for (var i = 0; i < children.length; ++i) {\n            if (children[i].getAttribute(\"focused\") == \"true\")\n              return children[i];\n          }\n          return null;\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          if (val) val.setAttribute(\"focused\", \"true\");\n\n          // unfocus all other group nodes\n          var children = this._getRadioChildren();\n          for (var i = 0; i < children.length; ++i) {\n            if (children[i] != val)\n              children[i].removeAttribute(\"focused\");\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"checkAdjacentElement\">\n        <parameter name=\"aNextFlag\"/>\n        <body>\n        <![CDATA[\n          var currentElement = this.focusedItem || this.selectedItem;\n          var i;\n          var children = this._getRadioChildren();\n          for (i = 0; i < children.length; ++i ) {\n            if (children[i] == currentElement)\n              break;\n          }\n          var index = i;\n\n          if (aNextFlag) {\n            do {\n              if (++i == children.length)\n                i = 0;\n              if (i == index)\n                break;\n            }\n            while (children[i].hidden || children[i].collapsed || children[i].disabled);\n            // XXX check for display/visibility props too\n\n            this.selectedItem = children[i];\n            children[i].doCommand();\n          } else {\n            do {\n              if (i == 0)\n                i = children.length;\n              if (--i == index)\n                break;\n            }\n            while (children[i].hidden || children[i].collapsed || children[i].disabled);\n            // XXX check for display/visibility props too\n\n            this.selectedItem = children[i];\n            children[i].doCommand();\n          }\n        ]]>\n        </body>\n      </method>\n      <field name=\"_radioChildren\">null</field>\n      <method name=\"_getRadioChildren\">\n        <body>\n        <![CDATA[\n          if (this._radioChildren)\n            return this._radioChildren;\n\n          var radioChildren = [];\n          var doc = this.ownerDocument;\n\n          if (this.hasChildNodes()) {\n            // Don't store the collected child nodes immediately,\n            // collecting the child nodes could trigger constructors\n            // which would blow away our list.\n\n            const nsIDOMNodeFilter = Components.interfaces.nsIDOMNodeFilter;\n            var iterator = doc.createTreeWalker(this,\n                                                nsIDOMNodeFilter.SHOW_ELEMENT,\n                                                this._filterRadioGroup);\n            while (iterator.nextNode())\n              radioChildren.push(iterator.currentNode);\n            return this._radioChildren = radioChildren;\n          }\n\n          // We don't have child nodes.\n          const XUL_NS = \"http://www.mozilla.org/keymaster/\"\n                       + \"gatekeeper/there.is.only.xul\";\n          var elems = doc.getElementsByAttribute(\"group\", this.id);\n          for (var i = 0; i < elems.length; i++) {\n            if ((elems[i].namespaceURI == XUL_NS) &&\n                (elems[i].localName == \"radio\")) {\n              radioChildren.push(elems[i]);\n            }\n          }\n          return this._radioChildren = radioChildren;\n        ]]>\n        </body>\n      </method>\n      <method name=\"_filterRadioGroup\">\n        <parameter name=\"node\"/>\n        <body>\n        <![CDATA[\n          switch (node.localName) {\n            case \"radio\": return NodeFilter.FILTER_ACCEPT;\n            case \"template\":\n            case \"radiogroup\": return NodeFilter.FILTER_REJECT;\n            default: return NodeFilter.FILTER_SKIP;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"item\"/>\n        <body>\n          return this._getRadioChildren().indexOf(item);\n        </body>\n      </method>\n\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"index\"/>\n        <body>\n        <![CDATA[\n          var children = this._getRadioChildren();\n          return (index >= 0 && index < children.length) ? children[index] : null;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"appendItem\">\n        <parameter name=\"label\"/>\n        <parameter name=\"value\"/>\n        <body>\n        <![CDATA[\n          var XULNS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          var radio = document.createElementNS(XULNS, \"radio\");\n          radio.setAttribute(\"label\", label);\n          radio.setAttribute(\"value\", value);\n          this.appendChild(radio);\n          this._radioChildren = null;\n          return radio;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"insertItemAt\">\n        <parameter name=\"index\"/>\n        <parameter name=\"label\"/>\n        <parameter name=\"value\"/>\n        <body>\n        <![CDATA[\n          var XULNS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          var radio = document.createElementNS(XULNS, \"radio\");\n          radio.setAttribute(\"label\", label);\n          radio.setAttribute(\"value\", value);\n          var before = this.getItemAtIndex(index);\n          if (before)\n            before.parentNode.insertBefore(radio, before);\n          else\n            this.appendChild(radio);\n          this._radioChildren = null;\n          return radio;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"removeItemAt\">\n        <parameter name=\"index\"/>\n        <body>\n        <![CDATA[\n          var remove = this.getItemAtIndex(index);\n          if (remove) {\n            remove.remove();\n            this._radioChildren = null;\n          }\n          return remove;\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"mousedown\">\n        if (this.disabled)\n          event.preventDefault();\n       </handler>\n\n      <!-- keyboard navigation -->\n      <!-- Here's how keyboard navigation works in radio groups on Windows:\n           The group takes 'focus'\n           The user is then free to navigate around inside the group\n           using the arrow keys. Accessing previous or following radio buttons\n           is done solely through the arrow keys and not the tab button. Tab\n           takes you to the next widget in the tab order -->\n      <handler event=\"keypress\" key=\" \" phase=\"target\">\n        this.selectedItem = this.focusedItem;\n        this.selectedItem.doCommand();\n        // Prevent page from scrolling on the space key.\n        event.preventDefault();\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_UP\" phase=\"target\">\n        this.checkAdjacentElement(false);\n        event.stopPropagation();\n        event.preventDefault();\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" phase=\"target\">\n        // left arrow goes back when we are ltr, forward when we are rtl\n        this.checkAdjacentElement(document.defaultView.getComputedStyle(\n                                    this).direction == \"rtl\");\n        event.stopPropagation();\n        event.preventDefault();\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" phase=\"target\">\n        this.checkAdjacentElement(true);\n        event.stopPropagation();\n        event.preventDefault();\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" phase=\"target\">\n        // right arrow goes forward when we are ltr, back when we are rtl\n        this.checkAdjacentElement(document.defaultView.getComputedStyle(\n                                    this).direction == \"ltr\");\n        event.stopPropagation();\n        event.preventDefault();\n      </handler>\n\n      <!-- set a focused attribute on the selected item when the group\n           receives focus so that we can style it as if it were focused even though\n           it is not (Windows platform behaviour is for the group to receive focus,\n           not the item -->\n      <handler event=\"focus\" phase=\"target\">\n        <![CDATA[\n          this.setAttribute(\"focused\", \"true\");\n          if (this.focusedItem)\n            return;\n\n          var val = this.selectedItem;\n          if (!val || val.disabled || val.hidden || val.collapsed) {\n            var children = this._getRadioChildren();\n            for (var i = 0; i < children.length; ++i) {\n              if (!children[i].hidden && !children[i].collapsed && !children[i].disabled) {\n                val = children[i];\n                break;\n              }\n            }\n          }\n          this.focusedItem = val;\n        ]]>\n      </handler>\n      <handler event=\"blur\" phase=\"target\">\n        this.removeAttribute(\"focused\");\n        this.focusedItem = null;\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"radio\" role=\"xul:radiobutton\"\n    extends=\"chrome://global/content/bindings/general.xml#control-item\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/radio.css\"/>\n    </resources>\n\n    <content>\n      <xul:image class=\"radio-check\" xbl:inherits=\"disabled,selected\"/>\n      <xul:hbox class=\"radio-label-box\" align=\"center\" flex=\"1\">\n        <xul:image class=\"radio-icon\" xbl:inherits=\"src\"/>\n        <xul:label class=\"radio-label\" xbl:inherits=\"xbl:text=label,accesskey,crop\" flex=\"1\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n        <![CDATA[\n          // Just clear out the parent's cached list of radio children\n          var control = this.control;\n          if (control)\n            control._radioChildren = null;\n        ]]>\n      </constructor>\n      <destructor>\n        <![CDATA[\n          if (!this.control)\n            return;\n\n          var radioList = this.control._radioChildren;\n          if (!radioList)\n            return;\n          for (var i = 0; i < radioList.length; ++i) {\n            if (radioList[i] == this) {\n              radioList.splice(i, 1);\n              return;\n            }\n          }\n        ]]>\n      </destructor>\n      <property name=\"selected\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            return this.hasAttribute(\"selected\");\n          ]]>\n        </getter>\n      </property>\n      <property name=\"radioGroup\" readonly=\"true\" onget=\"return this.control\"/>\n      <property name=\"control\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          const XUL_NS = \"http://www.mozilla.org/keymaster/\"\n                       + \"gatekeeper/there.is.only.xul\";\n          var parent = this.parentNode;\n          while (parent) {\n            if ((parent.namespaceURI == XUL_NS) &&\n                (parent.localName == \"radiogroup\")) {\n              return parent;\n            }\n            parent = parent.parentNode;\n          }\n\n          var group = this.getAttribute(\"group\");\n          if (!group) {\n            return null;\n          }\n\n          parent = this.ownerDocument.getElementById(group);\n          if (!parent ||\n              (parent.namespaceURI != XUL_NS) ||\n              (parent.localName != \"radiogroup\")) {\n            parent = null;\n          }\n          return parent;\n        ]]>\n        </getter>\n      </property>\n    </implementation>\n    <handlers>\n      <handler event=\"click\" button=\"0\">\n        <![CDATA[\n          if (!this.disabled)\n            this.control.selectedItem = this;\n         ]]>\n      </handler>\n\n      <handler event=\"mousedown\" button=\"0\">\n        <![CDATA[\n          if (!this.disabled)\n            this.control.focusedItem = this;\n         ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"remote-browser.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"firefoxBrowserBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"remote-browser\" extends=\"chrome://global/content/bindings/browser.xml#browser\">\n\n    <implementation type=\"application/javascript\"\n                    implements=\"nsIObserver, nsIDOMEventListener, nsIMessageListener, nsIRemoteBrowser\">\n\n      <field name=\"_securityUI\">null</field>\n\n      <property name=\"securityUI\"\n                readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._securityUI) {\n            // Don't attempt to create the remote web progress if the\n            // messageManager has already gone away\n            if (!this.messageManager)\n              return null;\n\n            let jsm = \"resource://gre/modules/RemoteSecurityUI.jsm\";\n            let RemoteSecurityUI = Components.utils.import(jsm, {}).RemoteSecurityUI;\n            this._securityUI = new RemoteSecurityUI();\n          }\n\n          // We want to double-wrap the JS implemented interface, so that QI and instanceof works.\n          var ptr = Components.classes[\"@mozilla.org/supports-interface-pointer;1\"]\n                              .createInstance(Components.interfaces.nsISupportsInterfacePointer);\n          ptr.data = this._securityUI;\n          return ptr.data.QueryInterface(Components.interfaces.nsISecureBrowserUI);\n        ]]></getter>\n      </property>\n\n      <field name=\"_controller\">null</field>\n\n      <field name=\"_selectParentHelper\">null</field>\n\n      <field name=\"_remoteWebNavigation\">null</field>\n\n      <property name=\"webNavigation\"\n                onget=\"return this._remoteWebNavigation;\"\n                readonly=\"true\"/>\n\n      <field name=\"_remoteWebProgress\">null</field>\n\n      <property name=\"webProgress\" readonly=\"true\">\n      \t<getter>\n      \t  <![CDATA[\n            if (!this._remoteWebProgress) {\n              // Don't attempt to create the remote web progress if the\n              // messageManager has already gone away\n              if (!this.messageManager)\n                return null;\n\n              let jsm = \"resource://gre/modules/RemoteWebProgress.jsm\";\n              let { RemoteWebProgressManager } = Components.utils.import(jsm, {});\n              this._remoteWebProgressManager = new RemoteWebProgressManager(this);\n              this._remoteWebProgress = this._remoteWebProgressManager.topLevelWebProgress;\n            }\n            return this._remoteWebProgress;\n      \t  ]]>\n      \t</getter>\n      </property>\n\n      <field name=\"_remoteFinder\">null</field>\n\n      <property name=\"finder\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._remoteFinder) {\n            // Don't attempt to create the remote finder if the\n            // messageManager has already gone away\n            if (!this.messageManager)\n              return null;\n\n            let jsm = \"resource://gre/modules/RemoteFinder.jsm\";\n            let { RemoteFinder } = Components.utils.import(jsm, {});\n            this._remoteFinder = new RemoteFinder(this);\n          }\n          return this._remoteFinder;\n        ]]></getter>\n      </property>\n\n      <field name=\"_documentURI\">null</field>\n\n      <field name=\"_documentContentType\">null</field>\n\n      <!--\n        Used by session restore to ensure that currentURI is set so\n        that switch-to-tab works before the tab is fully\n        restored. This function also invokes onLocationChanged\n        listeners in tabbrowser.xml.\n      -->\n      <method name=\"_setCurrentURI\">\n        <parameter name=\"aURI\"/>\n        <body><![CDATA[\n          this._remoteWebProgressManager.setCurrentURI(aURI);\n        ]]></body>\n      </method>\n\n      <property name=\"documentURI\"\n                onget=\"return this._documentURI;\"\n                readonly=\"true\"/>\n\n      <property name=\"documentContentType\"\n                onget=\"return this._documentContentType;\"\n                readonly=\"true\"/>\n\n      <field name=\"_contentTitle\">\"\"</field>\n\n      <property name=\"contentTitle\"\n                onget=\"return this._contentTitle\"\n                readonly=\"true\"/>\n\n      <field name=\"_characterSet\">\"\"</field>\n\n      <property name=\"characterSet\"\n                onget=\"return this._characterSet\">\n        <setter><![CDATA[\n          this.messageManager.sendAsyncMessage(\"UpdateCharacterSet\", {value: val});\n          this._characterSet = val;\n        ]]></setter>\n      </property>\n\n      <field name=\"_mayEnableCharacterEncodingMenu\">null</field>\n\n      <property name=\"mayEnableCharacterEncodingMenu\"\n                onget=\"return this._mayEnableCharacterEncodingMenu;\"\n                readonly=\"true\"/>\n\n      <field name=\"_contentWindow\">null</field>\n\n      <property name=\"contentWindow\"\n                onget=\"return null\"\n                readonly=\"true\"/>\n\n      <property name=\"contentWindowAsCPOW\"\n                onget=\"return this._contentWindow\"\n                readonly=\"true\"/>\n\n      <property name=\"contentDocument\"\n                onget=\"return null\"\n                readonly=\"true\"/>\n\n      <field name=\"_contentPrincipal\">null</field>\n\n      <property name=\"contentPrincipal\"\n                onget=\"return this._contentPrincipal\"\n                readonly=\"true\"/>\n\n      <field name=\"_contentRequestContextID\">null</field>\n\n      <property name=\"contentRequestContextID\"\n                onget=\"return this._contentRequestContextID\"\n                readonly=\"true\"/>\n\n      <property name=\"contentDocumentAsCPOW\"\n                onget=\"return this.contentWindowAsCPOW ? this.contentWindowAsCPOW.document : null\"\n                readonly=\"true\"/>\n\n      <field name=\"_imageDocument\">null</field>\n\n      <property name=\"imageDocument\"\n                onget=\"return this._imageDocument\"\n                readonly=\"true\"/>\n\n      <field name=\"_fullZoom\">1</field>\n      <property name=\"fullZoom\">\n        <getter><![CDATA[\n          return this._fullZoom;\n        ]]></getter>\n        <setter><![CDATA[\n          let changed = val.toFixed(2) != this._fullZoom.toFixed(2);\n\n          this._fullZoom = val;\n          try {\n            this.messageManager.sendAsyncMessage(\"FullZoom\", {value: val});\n          } catch (ex) {}\n\n          if (changed) {\n            let event = new Event(\"FullZoomChange\", {bubbles: true});\n            this.dispatchEvent(event);\n          }\n        ]]></setter>\n      </property>\n\n      <field name=\"_textZoom\">1</field>\n      <property name=\"textZoom\">\n        <getter><![CDATA[\n          return this._textZoom;\n        ]]></getter>\n        <setter><![CDATA[\n          let changed = val.toFixed(2) != this._textZoom.toFixed(2);\n\n          this._textZoom = val;\n          try {\n            this.messageManager.sendAsyncMessage(\"TextZoom\", {value: val});\n          } catch (ex) {}\n\n          if (changed) {\n            let event = new Event(\"TextZoomChange\", {bubbles: true});\n            this.dispatchEvent(event);\n          }\n        ]]></setter>\n      </property>\n\n      <field name=\"_isSyntheticDocument\">false</field>\n      <property name=\"isSyntheticDocument\">\n        <getter><![CDATA[\n          return this._isSyntheticDocument;\n        ]]></getter>\n      </property>\n\n      <property name=\"hasContentOpener\">\n        <getter><![CDATA[\n          return this.frameLoader.tabParent.hasContentOpener;\n        ]]></getter>\n      </property>\n\n      <field name=\"_outerWindowID\">null</field>\n      <property name=\"outerWindowID\"\n                onget=\"return this._outerWindowID\"\n                readonly=\"true\"/>\n\n      <field name=\"_innerWindowID\">null</field>\n      <property name=\"innerWindowID\">\n        <getter><![CDATA[\n          return this._innerWindowID;\n        ]]></getter>\n      </property>\n\n      <property name=\"docShellIsActive\">\n        <getter>\n          <![CDATA[\n            return this.frameLoader.tabParent.docShellIsActive;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            this.frameLoader.tabParent.docShellIsActive = val;\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"preserveLayers\">\n        <parameter name=\"preserve\"/>\n        <body><![CDATA[\n          let {frameLoader} = this;\n          if (frameLoader.tabParent) {\n            frameLoader.tabParent.preserveLayers(preserve);\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_manifestURI\"/>\n      <property name=\"manifestURI\"\n                onget=\"return this._manifestURI\"\n                readonly=\"true\"/>\n\n      <field name=\"mDestroyed\">false</field>\n\n      <field name=\"_permitUnloadId\">0</field>\n\n      <method name=\"getInPermitUnload\">\n        <parameter name=\"aCallback\"/>\n        <body>\n        <![CDATA[\n          let id = this._permitUnloadId++;\n          let mm = this.messageManager;\n          mm.sendAsyncMessage(\"InPermitUnload\", {id});\n          mm.addMessageListener(\"InPermitUnload\", function listener(msg) {\n            if (msg.data.id != id) {\n              return;\n            }\n            aCallback(msg.data.inPermitUnload);\n          });\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"permitUnload\">\n        <body>\n        <![CDATA[\n          let {tabParent} = this.frameLoader;\n\n          if (!tabParent.hasBeforeUnload) {\n            return { permitUnload: true, timedOut: false };\n          }\n\n          const kTimeout = 1000;\n\n          let finished = false;\n          let responded = false;\n          let permitUnload;\n          let id = this._permitUnloadId++;\n          let mm = this.messageManager;\n          let Services = Components.utils.import(\"resource://gre/modules/Services.jsm\", {}).Services;\n\n          let msgListener = msg => {\n            if (msg.data.id != id) {\n              return;\n            }\n            if (msg.data.kind == \"start\") {\n              responded = true;\n              return;\n            }\n            done(msg.data.permitUnload);\n          };\n\n          let observer = subject => {\n            if (subject == mm) {\n              done(true);\n            }\n          };\n\n          function done(result) {\n            finished = true;\n            permitUnload = result;\n            mm.removeMessageListener(\"PermitUnload\", msgListener);\n            Services.obs.removeObserver(observer, \"message-manager-close\");\n          }\n\n          mm.sendAsyncMessage(\"PermitUnload\", {id});\n          mm.addMessageListener(\"PermitUnload\", msgListener);\n          Services.obs.addObserver(observer, \"message-manager-close\");\n\n          let timedOut = false;\n          function timeout() {\n            if (!responded) {\n              timedOut = true;\n            }\n\n            // Dispatch something to ensure that the main thread wakes up.\n            Services.tm.dispatchToMainThread(function() {});\n          }\n\n          let timer = Components.classes[\"@mozilla.org/timer;1\"].createInstance(Components.interfaces.nsITimer);\n          timer.initWithCallback(timeout, kTimeout, timer.TYPE_ONE_SHOT);\n\n          while (!finished && !timedOut) {\n            Services.tm.currentThread.processNextEvent(true);\n          }\n\n          return {permitUnload, timedOut};\n        ]]>\n        </body>\n      </method>\n\n      <constructor>\n        <![CDATA[\n          /*\n           * Don't try to send messages from this function. The message manager for\n           * the <browser> element may not be initialized yet.\n           */\n\n          this._remoteWebNavigation = Components.classes[\"@mozilla.org/remote-web-navigation;1\"]\n                                                .createInstance(Components.interfaces.nsIWebNavigation);\n          this._remoteWebNavigationImpl = this._remoteWebNavigation.wrappedJSObject;\n          this._remoteWebNavigationImpl.swapBrowser(this);\n\n          // Initialize contentPrincipal to the about:blank principal for this loadcontext\n          let {Services} = Components.utils.import(\"resource://gre/modules/Services.jsm\", {});\n          let aboutBlank = Services.io.newURI(\"about:blank\");\n          let ssm = Services.scriptSecurityManager;\n          this._contentPrincipal = ssm.getLoadContextCodebasePrincipal(aboutBlank, this.loadContext);\n\n          this.messageManager.addMessageListener(\"Browser:Init\", this);\n          this.messageManager.addMessageListener(\"DOMTitleChanged\", this);\n          this.messageManager.addMessageListener(\"ImageDocumentLoaded\", this);\n          this.messageManager.addMessageListener(\"FullZoomChange\", this);\n          this.messageManager.addMessageListener(\"TextZoomChange\", this);\n          this.messageManager.addMessageListener(\"ZoomChangeUsingMouseWheel\", this);\n          this.messageManager.addMessageListener(\"DOMFullscreen:RequestExit\", this);\n          this.messageManager.addMessageListener(\"DOMFullscreen:RequestRollback\", this);\n          this.messageManager.addMessageListener(\"MozApplicationManifest\", this);\n          this.messageManager.loadFrameScript(\"chrome://global/content/browser-child.js\", true);\n\n          if (this.hasAttribute(\"selectmenulist\")) {\n            this.messageManager.addMessageListener(\"Forms:ShowDropDown\", this);\n            this.messageManager.addMessageListener(\"Forms:HideDropDown\", this);\n          }\n\n          if (!this.hasAttribute(\"disablehistory\")) {\n            Services.obs.addObserver(this, \"browser:purge-session-history\", true);\n          }\n\n          let rc_js = \"resource://gre/modules/RemoteController.js\";\n          let scope = {};\n          Services.scriptloader.loadSubScript(rc_js, scope);\n          let RemoteController = scope.RemoteController;\n          this._controller = new RemoteController(this);\n          this.controllers.appendController(this._controller);\n        ]]>\n      </constructor>\n\n      <destructor>\n        <![CDATA[\n          this.destroy();\n        ]]>\n      </destructor>\n\n      <!-- This is necessary because the destructor doesn't always get called when\n           we are removed from a tabbrowser. This will be explicitly called by tabbrowser.\n\n           Note: This overrides the destroy() method from browser.xml. -->\n      <method name=\"destroy\">\n        <body><![CDATA[\n          // Make sure that any open select is closed.\n          if (this._selectParentHelper) {\n            let menulist = document.getElementById(this.getAttribute(\"selectmenulist\"));\n            this._selectParentHelper.hide(menulist, this);\n          }\n\n          if (this.mDestroyed)\n            return;\n          this.mDestroyed = true;\n\n          try {\n            this.controllers.removeController(this._controller);\n          } catch (ex) {\n            // This can fail when this browser element is not attached to a\n            // BrowserDOMWindow.\n          }\n\n          if (!this.hasAttribute(\"disablehistory\")) {\n            let Services = Components.utils.import(\"resource://gre/modules/Services.jsm\", {}).Services;\n            try {\n              Services.obs.removeObserver(this, \"browser:purge-session-history\");\n            } catch (ex) {\n              // It's not clear why this sometimes throws an exception.\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"receiveMessage\">\n        <parameter name=\"aMessage\"/>\n        <body><![CDATA[\n          let data = aMessage.data;\n          switch (aMessage.name) {\n            case \"Browser:Init\":\n              this._outerWindowID = data.outerWindowID;\n              break;\n            case \"DOMTitleChanged\":\n              this._contentTitle = data.title;\n              break;\n            case \"ImageDocumentLoaded\":\n              this._imageDocument = {\n                width: data.width,\n                height: data.height\n              };\n              break;\n\n            case \"Forms:ShowDropDown\": {\n              if (!this._selectParentHelper) {\n                this._selectParentHelper =\n                  Cu.import(\"resource://gre/modules/SelectParentHelper.jsm\", {}).SelectParentHelper;\n              }\n\n              let menulist = document.getElementById(this.getAttribute(\"selectmenulist\"));\n              menulist.menupopup.style.direction = data.direction;\n\n              let zoom = Services.prefs.getBoolPref(\"browser.zoom.full\") ||\n                         this.isSyntheticDocument ? this._fullZoom : this._textZoom;\n              this._selectParentHelper.populate(menulist, data.options, data.selectedIndex,\n                                                zoom, data.uaBackgroundColor, data.uaColor,\n                                                data.uaSelectBackgroundColor, data.uaSelectColor,\n                                                data.selectBackgroundColor, data.selectColor, data.selectTextShadow);\n              this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);\n              break;\n            }\n\n            case \"FullZoomChange\": {\n              this._fullZoom = data.value;\n              let event = document.createEvent(\"Events\");\n              event.initEvent(\"FullZoomChange\", true, false);\n              this.dispatchEvent(event);\n              break;\n            }\n\n            case \"TextZoomChange\": {\n              this._textZoom = data.value;\n              let event = document.createEvent(\"Events\");\n              event.initEvent(\"TextZoomChange\", true, false);\n              this.dispatchEvent(event);\n              break;\n            }\n\n            case \"ZoomChangeUsingMouseWheel\": {\n              let event = document.createEvent(\"Events\");\n              event.initEvent(\"ZoomChangeUsingMouseWheel\", true, false);\n              this.dispatchEvent(event);\n              break;\n            }\n\n            case \"DOMFullscreen:RequestExit\": {\n              let windowUtils = window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)\n                                      .getInterface(Components.interfaces.nsIDOMWindowUtils);\n              windowUtils.exitFullscreen();\n              break;\n            }\n\n            case \"DOMFullscreen:RequestRollback\": {\n              let windowUtils = window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)\n                                      .getInterface(Components.interfaces.nsIDOMWindowUtils);\n              windowUtils.remoteFrameFullscreenReverted();\n              break;\n            }\n\n            case \"MozApplicationManifest\":\n              this._manifestURI = aMessage.data.manifest;\n              break;\n\n            default:\n              // Delegate to browser.xml.\n              return this._receiveMessage(aMessage);\n          }\n          return undefined;\n        ]]></body>\n      </method>\n\n      <method name=\"enableDisableCommands\">\n        <parameter name=\"aAction\"/>\n        <parameter name=\"aEnabledLength\"/>\n        <parameter name=\"aEnabledCommands\"/>\n        <parameter name=\"aDisabledLength\"/>\n        <parameter name=\"aDisabledCommands\"/>\n        <body>\n          if (this._controller) {\n            this._controller.enableDisableCommands(aAction,\n                                                   aEnabledLength, aEnabledCommands,\n                                                   aDisabledLength, aDisabledCommands);\n          }\n        </body>\n      </method>\n\n      <method name=\"purgeSessionHistory\">\n        <body>\n          <![CDATA[\n            try {\n              this.messageManager.sendAsyncMessage(\"Browser:PurgeSessionHistory\");\n            } catch (ex) {\n              // This can throw if the browser has started to go away.\n              if (ex.result != Components.results.NS_ERROR_NOT_INITIALIZED) {\n                throw ex;\n              }\n            }\n            this._remoteWebNavigationImpl.canGoBack = false;\n            this._remoteWebNavigationImpl.canGoForward = false;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"createAboutBlankContentViewer\">\n        <parameter name=\"aPrincipal\"/>\n        <body>\n          <![CDATA[\n            // Ensure that the content process has the permissions which are\n            // needed to create a document with the given principal.\n            let permissionPrincipal =\n              BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);\n            this.frameLoader.tabParent.transmitPermissionsForPrincipal(permissionPrincipal);\n\n            // Create the about blank content viewer in the content process\n            this.messageManager.sendAsyncMessage(\"Browser:CreateAboutBlank\", aPrincipal);\n          ]]>\n        </body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"dragstart\">\n      <![CDATA[\n        // If we're a remote browser dealing with a dragstart, stop it\n        // from propagating up, since our content process should be dealing\n        // with the mouse movement.\n        event.stopPropagation();\n      ]]>\n      </handler>\n    </handlers>\n\n  </binding>\n\n</bindings>\n"},{"file":"resizer.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"resizerBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"resizer\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/resizer.css\"/>\n    </resources>\n    <implementation>\n      <constructor>\n      <![CDATA[\n        // don't do this for viewport resizers; causes a crash related to\n        // bugs 563665 and 581536 otherwise\n        if (this.parentNode == this.ownerDocument.documentElement)\n          return;\n\n        // if the direction is rtl, set the rtl attribute so that the\n        // stylesheet can use this to make the cursor appear properly\n        var cs = window.getComputedStyle(this);\n        if (cs.writingMode === undefined || cs.writingMode == \"horizontal-tb\") {\n          if (cs.direction == \"rtl\") {\n            this.setAttribute(\"rtl\", \"true\");\n          }\n        } else if (cs.writingMode.endsWith(\"-rl\")) {\n          // writing-modes 'vertical-rl' and 'sideways-rl' want rtl resizers,\n          // as they will appear at the bottom left of the element\n          this.setAttribute(\"rtl\", \"true\");\n        }\n      ]]>\n      </constructor>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"richlistbox.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"richlistboxBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"richlistbox\"\n           extends=\"chrome://global/content/bindings/listbox.xml#listbox-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/richlistbox.css\"/>\n    </resources>\n\n    <content>\n      <children includes=\"listheader\"/>\n      <xul:scrollbox allowevents=\"true\" orient=\"vertical\" anonid=\"main-box\"\n                     flex=\"1\" style=\"overflow: auto;\" xbl:inherits=\"dir,pack\">\n        <children/>\n      </xul:scrollbox>\n    </content>\n\n    <implementation>\n      <field name=\"_scrollbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"main-box\");\n      </field>\n      <field name=\"scrollBoxObject\">\n        this._scrollbox.boxObject;\n      </field>\n      <constructor>\n        <![CDATA[\n          // add a template build listener\n          if (this.builder)\n            this.builder.addListener(this._builderListener);\n          else\n            this._refreshSelection();\n        ]]>\n      </constructor>\n\n      <destructor>\n        <![CDATA[\n          // remove the template build listener\n          if (this.builder)\n            this.builder.removeListener(this._builderListener);\n        ]]>\n      </destructor>\n\n    <!-- Overriding baselistbox -->\n      <method name=\"_fireOnSelect\">\n        <body>\n          <![CDATA[\n            // make sure not to modify last-selected when suppressing select events\n            // (otherwise we'll lose the selection when a template gets rebuilt)\n            if (this._suppressOnSelect || this.suppressOnSelect)\n              return;\n\n            // remember the current item and all selected items with IDs\n            var state = this.currentItem ? this.currentItem.id : \"\";\n            if (this.selType == \"multiple\" && this.selectedCount) {\n              let getId = function getId(aItem) { return aItem.id; }\n              state += \" \" + [...this.selectedItems].filter(getId).map(getId).join(\" \");\n            }\n            if (state)\n              this.setAttribute(\"last-selected\", state);\n            else\n              this.removeAttribute(\"last-selected\");\n\n            // preserve the index just in case no IDs are available\n            if (this.currentIndex > -1)\n              this._currentIndex = this.currentIndex + 1;\n\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"select\", true, true);\n            this.dispatchEvent(event);\n\n            // always call this (allows a commandupdater without controller)\n            document.commandDispatcher.updateCommands(\"richlistbox-select\");\n          ]]>\n        </body>\n      </method>\n\n      <!-- We override base-listbox here because those methods don't take dir\n           into account on listbox (which doesn't support dir yet) -->\n      <method name=\"getNextItem\">\n        <parameter name=\"aStartItem\"/>\n        <parameter name=\"aDelta\"/>\n        <body>\n        <![CDATA[\n          var prop = this.dir == \"reverse\" && this._mayReverse ?\n                                                \"previousSibling\" :\n                                                \"nextSibling\";\n          while (aStartItem) {\n            aStartItem = aStartItem[prop];\n            if (aStartItem && aStartItem instanceof\n                Components.interfaces.nsIDOMXULSelectControlItemElement &&\n                (!this._userSelecting || this._canUserSelect(aStartItem))) {\n              --aDelta;\n              if (aDelta == 0)\n                return aStartItem;\n            }\n          }\n          return null;\n        ]]></body>\n      </method>\n\n      <method name=\"getPreviousItem\">\n        <parameter name=\"aStartItem\"/>\n        <parameter name=\"aDelta\"/>\n        <body>\n        <![CDATA[\n          var prop = this.dir == \"reverse\" && this._mayReverse ?\n                                                \"nextSibling\" :\n                                                \"previousSibling\";\n          while (aStartItem) {\n            aStartItem = aStartItem[prop];\n            if (aStartItem && aStartItem instanceof\n                Components.interfaces.nsIDOMXULSelectControlItemElement &&\n                (!this._userSelecting || this._canUserSelect(aStartItem))) {\n              --aDelta;\n              if (aDelta == 0)\n                return aStartItem;\n            }\n          }\n          return null;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"appendItem\">\n        <parameter name=\"aLabel\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n          return this.insertItemAt(-1, aLabel, aValue);\n        </body>\n      </method>\n\n      <method name=\"insertItemAt\">\n        <parameter name=\"aIndex\"/>\n        <parameter name=\"aLabel\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n          const XULNS =\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\n          var item =\n            this.ownerDocument.createElementNS(XULNS, \"richlistitem\");\n          item.setAttribute(\"value\", aValue);\n\n          var label = this.ownerDocument.createElementNS(XULNS, \"label\");\n          label.setAttribute(\"value\", aLabel);\n          label.setAttribute(\"flex\", \"1\");\n          label.setAttribute(\"crop\", \"end\");\n          item.appendChild(label);\n\n          var before = this.getItemAtIndex(aIndex);\n          if (!before)\n            this.appendChild(item);\n          else\n            this.insertBefore(item, before);\n\n          return item;\n        </body>\n      </method>\n\n      <property name=\"itemCount\" readonly=\"true\"\n                onget=\"return this.children.length\"/>\n\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"aItem\"/>\n        <body>\n          <![CDATA[\n            // don't search the children, if we're looking for none of them\n            if (aItem == null)\n              return -1;\n            if (this._selecting && this._selecting.item == aItem)\n              return this._selecting.index;\n            return this.children.indexOf(aItem);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"aIndex\"/>\n        <body>\n          <![CDATA[\n            if (this._selecting && this._selecting.index == aIndex)\n              return this._selecting.item;\n            return this.children[aIndex] || null;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"ensureIndexIsVisible\">\n        <parameter name=\"aIndex\"/>\n        <body>\n          <![CDATA[\n            // work around missing implementation in scrollBoxObject\n            return this.ensureElementIsVisible(this.getItemAtIndex(aIndex));\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"ensureElementIsVisible\">\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n            if (!aElement)\n              return;\n            var targetRect = aElement.getBoundingClientRect();\n            var scrollRect = this._scrollbox.getBoundingClientRect();\n            var offset = targetRect.top - scrollRect.top;\n            if (offset >= 0) {\n              // scrollRect.bottom wouldn't take a horizontal scroll bar into account\n              let scrollRectBottom = scrollRect.top + this._scrollbox.clientHeight;\n              offset = targetRect.bottom - scrollRectBottom;\n              if (offset <= 0)\n                return;\n            }\n            this._scrollbox.scrollTop += offset;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"scrollToIndex\">\n        <parameter name=\"aIndex\"/>\n        <body>\n          <![CDATA[\n            var item = this.getItemAtIndex(aIndex);\n            if (item)\n              this.scrollBoxObject.scrollToElement(item);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getNumberOfVisibleRows\">\n        <!-- returns the number of currently visible rows                -->\n        <!-- don't rely on this function, if the items' height can vary! -->\n        <body>\n          <![CDATA[\n            var children = this.children;\n\n            for (var top = 0; top < children.length && !this._isItemVisible(children[top]); top++);\n            for (var ix = top; ix < children.length && this._isItemVisible(children[ix]); ix++);\n\n            return ix - top;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getIndexOfFirstVisibleRow\">\n        <body>\n          <![CDATA[\n            var children = this.children;\n\n            for (var ix = 0; ix < children.length; ix++)\n              if (this._isItemVisible(children[ix]))\n                return ix;\n\n            return -1;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getRowCount\">\n        <body>\n          <![CDATA[\n            return this.children.length;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"scrollOnePage\">\n        <parameter name=\"aDirection\"/> <!-- Must be -1 or 1 -->\n        <body>\n          <![CDATA[\n            var children = this.children;\n\n            if (children.length == 0)\n              return 0;\n\n            // If nothing is selected, we just select the first element\n            // at the extreme we're moving away from\n            if (!this.currentItem)\n              return aDirection == -1 ? children.length : 0;\n\n            // If the current item is visible, scroll by one page so that\n            // the new current item is at approximately the same position as\n            // the existing current item.\n            if (this._isItemVisible(this.currentItem))\n              this.scrollBoxObject.scrollBy(0, this.scrollBoxObject.height * aDirection);\n\n            // Figure out, how many items fully fit into the view port\n            // (including the currently selected one), and determine\n            // the index of the first one lying (partially) outside\n            var height = this.scrollBoxObject.height;\n            var startBorder = this.currentItem.boxObject.y;\n            if (aDirection == -1)\n              startBorder += this.currentItem.boxObject.height;\n\n            var index = this.currentIndex;\n            for (var ix = index; 0 <= ix && ix < children.length; ix += aDirection) {\n              var boxObject = children[ix].boxObject;\n              if (boxObject.height == 0)\n                continue; // hidden children have a y of 0\n              var endBorder = boxObject.y + (aDirection == -1 ? boxObject.height : 0);\n              if ((endBorder - startBorder) * aDirection > height)\n                break; // we've reached the desired distance\n              index = ix;\n            }\n\n            return index != this.currentIndex ? index - this.currentIndex : aDirection;\n          ]]>\n        </body>\n      </method>\n\n    <!-- richlistbox specific -->\n      <property name=\"children\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            let iface = Components.interfaces.nsIDOMXULSelectControlItemElement;\n            let children = Array.from(this.childNodes)\n                                .filter(node => node instanceof iface);\n            if (this.dir == \"reverse\" && this._mayReverse) {\n              children.reverse();\n            }\n            return children;\n          ]]>\n        </getter>\n      </property>\n\n      <field name=\"_builderListener\" readonly=\"true\">\n        <![CDATA[\n          ({\n            mOuter: this,\n            item: null,\n            willRebuild(builder) { },\n            didRebuild(builder) {\n              this.mOuter._refreshSelection();\n            }\n          });\n        ]]>\n      </field>\n\n      <method name=\"_refreshSelection\">\n        <body>\n          <![CDATA[\n            // when this method is called, we know that either the currentItem\n            // and selectedItems we have are null (ctor) or a reference to an\n            // element no longer in the DOM (template).\n\n            // first look for the last-selected attribute\n            var state = this.getAttribute(\"last-selected\");\n            if (state) {\n              var ids = state.split(\" \");\n\n              var suppressSelect = this._suppressOnSelect;\n              this._suppressOnSelect = true;\n              this.clearSelection();\n              for (let i = 1; i < ids.length; i++) {\n                var selectedItem = document.getElementById(ids[i]);\n                if (selectedItem)\n                  this.addItemToSelection(selectedItem);\n              }\n\n              var currentItem = document.getElementById(ids[0]);\n              if (!currentItem && this._currentIndex)\n                currentItem = this.getItemAtIndex(Math.min(\n                  this._currentIndex - 1, this.getRowCount()));\n              if (currentItem) {\n                this.currentItem = currentItem;\n                if (this.selType != \"multiple\" && this.selectedCount == 0)\n                  this.selectedItem = currentItem;\n\n                if (this.scrollBoxObject.height) {\n                  this.ensureElementIsVisible(currentItem);\n                } else {\n                  // XXX hack around a bug in ensureElementIsVisible as it will\n                  // scroll beyond the last element, bug 493645.\n                  var previousElement = this.dir == \"reverse\" ? currentItem.nextSibling :\n                                                                currentItem.previousSibling;\n                  this.ensureElementIsVisible(previousElement);\n                }\n              }\n              this._suppressOnSelect = suppressSelect;\n              // XXX actually it's just a refresh, but at least\n              // the Extensions manager expects this:\n              this._fireOnSelect();\n              return;\n            }\n\n            // try to restore the selected items according to their IDs\n            // (applies after a template rebuild, if last-selected was not set)\n            if (this.selectedItems) {\n              let itemIds = [];\n              for (let i = this.selectedCount - 1; i >= 0; i--) {\n                let selectedItem = this.selectedItems[i];\n                itemIds.push(selectedItem.id);\n                this.selectedItems.remove(selectedItem);\n              }\n              for (let i = 0; i < itemIds.length; i++) {\n                let selectedItem = document.getElementById(itemIds[i]);\n                if (selectedItem) {\n                  this.selectedItems.append(selectedItem);\n                }\n              }\n            }\n            if (this.currentItem && this.currentItem.id)\n              this.currentItem = document.getElementById(this.currentItem.id);\n            else\n              this.currentItem = null;\n\n            // if we have no previously current item or if the above check fails to\n            // find the previous nodes (which causes it to clear selection)\n            if (!this.currentItem && this.selectedCount == 0) {\n              this.currentIndex = this._currentIndex ? this._currentIndex - 1 : 0;\n\n              // cf. listbox constructor:\n              // select items according to their attributes\n              var children = this.children;\n              for (let i = 0; i < children.length; ++i) {\n                if (children[i].getAttribute(\"selected\") == \"true\")\n                  this.selectedItems.append(children[i]);\n              }\n            }\n\n            if (this.selType != \"multiple\" && this.selectedCount == 0)\n              this.selectedItem = this.currentItem;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_isItemVisible\">\n        <parameter name=\"aItem\"/>\n        <body>\n          <![CDATA[\n            if (!aItem)\n              return false;\n\n            var y = this.scrollBoxObject.positionY + this.scrollBoxObject.y;\n\n            // Partially visible items are also considered visible\n            return (aItem.boxObject.y + aItem.boxObject.height > y) &&\n                   (aItem.boxObject.y < y + this.scrollBoxObject.height);\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"_currentIndex\">null</field>\n\n      <!-- For backwards-compatibility and for convenience.\n        Use getIndexOfItem instead. -->\n      <method name=\"getIndexOf\">\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n            return this.getIndexOfItem(aElement);\n          ]]>\n        </body>\n      </method>\n\n      <!-- For backwards-compatibility and for convenience.\n        Use ensureElementIsVisible instead -->\n      <method name=\"ensureSelectedElementIsVisible\">\n        <body>\n          <![CDATA[\n            return this.ensureElementIsVisible(this.selectedItem);\n          ]]>\n        </body>\n      </method>\n\n      <!-- For backwards-compatibility and for convenience.\n        Use moveByOffset instead. -->\n      <method name=\"goUp\">\n        <body>\n          <![CDATA[\n            var index = this.currentIndex;\n            this.moveByOffset(-1, true, false);\n            return index != this.currentIndex;\n          ]]>\n        </body>\n      </method>\n      <method name=\"goDown\">\n        <body>\n          <![CDATA[\n            var index = this.currentIndex;\n            this.moveByOffset(1, true, false);\n            return index != this.currentIndex;\n          ]]>\n        </body>\n      </method>\n\n      <!-- deprecated (is implied by currentItem and selectItem) -->\n      <method name=\"fireActiveItemEvent\"><body/></method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"click\">\n        <![CDATA[\n          // clicking into nothing should unselect\n          if (event.originalTarget == this._scrollbox) {\n            this.clearSelection();\n            this.currentItem = null;\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"MozSwipeGesture\">\n        <![CDATA[\n          // Only handle swipe gestures up and down\n          switch (event.direction) {\n            case event.DIRECTION_DOWN:\n              this._scrollbox.scrollTop = this._scrollbox.scrollHeight;\n              break;\n            case event.DIRECTION_UP:\n              this._scrollbox.scrollTop = 0;\n              break;\n          }\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"richlistitem\"\n           extends=\"chrome://global/content/bindings/listbox.xml#listitem\">\n    <content>\n      <children/>\n    </content>\n\n    <resources>\n      <stylesheet src=\"chrome://global/skin/richlistbox.css\"/>\n    </resources>\n\n    <implementation>\n      <field name=\"selectedByMouseOver\">false</field>\n\n      <destructor>\n        <![CDATA[\n          var control = this.control;\n          if (!control)\n            return;\n          // When we are destructed and we are current or selected, unselect ourselves\n          // so that richlistbox's selection doesn't point to something not in the DOM.\n          // We don't want to reset last-selected, so we set _suppressOnSelect.\n          if (this.selected) {\n            var suppressSelect = control._suppressOnSelect;\n            control._suppressOnSelect = true;\n            control.removeItemFromSelection(this);\n            control._suppressOnSelect = suppressSelect;\n          }\n          if (this.current)\n            control.currentItem = null;\n        ]]>\n      </destructor>\n\n      <property name=\"label\" readonly=\"true\">\n        <!-- Setter purposely not implemented; the getter returns a\n             concatentation of label text to expose via accessibility APIs -->\n        <getter>\n          <![CDATA[\n            const XULNS =\n              \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n            return Array.map(this.getElementsByTagNameNS(XULNS, \"label\"),\n                             label => label.value)\n                        .join(\" \");\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"searchLabel\">\n        <getter>\n          <![CDATA[\n            return this.hasAttribute(\"searchlabel\") ?\n                   this.getAttribute(\"searchlabel\") : this.label;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            if (val !== null)\n              this.setAttribute(\"searchlabel\", val);\n            else\n              // fall back to the label property (default value)\n              this.removeAttribute(\"searchlabel\");\n            return val;\n          ]]>\n        </setter>\n      </property>\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"scale.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"scaleBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n  \n  <binding id=\"scalethumb\" extends=\"xul:button\" role=\"xul:thumb\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/scale.css\"/>\n    </resources>\n  </binding>\n\n  <binding id=\"scaleslider\" display=\"xul:slider\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/scale.css\"/>\n    </resources>\n  </binding>\n\n  <binding id=\"scale\" role=\"xul:scale\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/scale.css\"/>\n    </resources>\n\n    <content align=\"center\" pack=\"center\">\n      <xul:slider anonid=\"slider\" class=\"scale-slider\" snap=\"true\" flex=\"1\"\n                  xbl:inherits=\"disabled,orient,dir,curpos=value,minpos=min,maxpos=max,increment,pageincrement,movetoclick\">\n        <xul:thumb class=\"scale-thumb\" xbl:inherits=\"disabled,orient\"/>\n      </xul:slider>\n    </content>\n    \n    <implementation implements=\"nsISliderListener\">\n      <property name=\"value\" onget=\"return this._getIntegerAttribute('curpos', 0);\"\n                             onset=\"return this._setIntegerAttribute('curpos', val);\"/>\n      <property name=\"min\" onget=\"return this._getIntegerAttribute('minpos', 0);\"\n                           onset=\"return this._setIntegerAttribute('minpos', val);\"/>\n      <property name=\"max\" onget=\"return this._getIntegerAttribute('maxpos', 100);\"\n                           onset=\"return this._setIntegerAttribute('maxpos', val);\"/>\n      <property name=\"increment\" onget=\"return this._getIntegerAttribute('increment', 1);\"\n                                 onset=\"return this._setIntegerAttribute('increment', val);\"/>\n      <property name=\"pageIncrement\" onget=\"return this._getIntegerAttribute('pageincrement', 10);\"\n                                     onset=\"return this._setIntegerAttribute('pageincrement', val);\"/>\n\n      <property name=\"_slider\" readonly=\"true\">\n        <getter>\n          if (!this._sliderElement)\n            this._sliderElement = document.getAnonymousElementByAttribute(this, \"anonid\", \"slider\");\n          return this._sliderElement;\n        </getter>\n      </property>\n\n      <constructor>\n        <![CDATA[\n          this._userChanged = false;\n          var value = parseInt(this.getAttribute(\"value\"), 10);\n          if (!isNaN(value))\n            this.value = value;\n          else if (this.min > 0)\n            this.value = this.min;\n          else if (this.max < 0)\n            this.value = this.max;\n        ]]>\n      </constructor>\n\n      <method name=\"_getIntegerAttribute\">\n        <parameter name=\"aAttr\"/>\n        <parameter name=\"aDefaultValue\"/>\n        <body>\n          var value = this._slider.getAttribute(aAttr);\n          var intvalue = parseInt(value, 10);\n          if (!isNaN(intvalue))\n            return intvalue;\n          return aDefaultValue;\n        </body>\n      </method>\n\n      <method name=\"_setIntegerAttribute\">\n        <parameter name=\"aAttr\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          var intvalue = parseInt(aValue, 10);\n          if (!isNaN(intvalue)) {\n            if (aAttr == \"curpos\") {\n              if (intvalue < this.min)\n                intvalue = this.min;\n              else if (intvalue > this.max)\n                intvalue = this.max;\n            }\n            this._slider.setAttribute(aAttr, intvalue);\n          }\n          return aValue;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"decrease\">\n        <body>\n        <![CDATA[\n          var newpos = this.value - this.increment;\n          var startpos = this.min;\n          this.value = (newpos > startpos) ? newpos : startpos;\n        ]]>\n        </body>\n      </method>\n      <method name=\"increase\">\n        <body>\n        <![CDATA[\n          var newpos = this.value + this.increment;\n          var endpos = this.max;\n          this.value = (newpos < endpos) ? newpos : endpos;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"decreasePage\">\n        <body>\n        <![CDATA[\n          var newpos = this.value - this.pageIncrement;\n          var startpos = this.min;\n          this.value = (newpos > startpos) ? newpos : startpos;\n        ]]>\n        </body>\n      </method>\n      <method name=\"increasePage\">\n        <body>\n        <![CDATA[\n          var newpos = this.value + this.pageIncrement;\n          var endpos = this.max;\n          this.value = (newpos < endpos) ? newpos : endpos;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"valueChanged\">\n        <parameter name=\"which\"/>\n        <parameter name=\"newValue\"/>\n        <parameter name=\"userChanged\"/>\n        <body>\n        <![CDATA[\n          switch (which) {\n            case \"curpos\":\n              this.setAttribute(\"value\", newValue);\n\n              // in the future, only fire the change event when userChanged\n              // or _userChanged is true\n              var changeEvent = document.createEvent(\"Events\");\n              changeEvent.initEvent(\"change\", true, true);\n              this.dispatchEvent(changeEvent);\n              break;\n\n            case \"minpos\":\n              this.setAttribute(\"min\", newValue);\n              break;\n\n            case \"maxpos\":\n              this.setAttribute(\"max\", newValue);\n              break;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"dragStateChanged\">\n        <parameter name=\"isDragging\"/>\n        <body/>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" preventdefault=\"true\">\n        <![CDATA[\n          this._userChanged = true;\n          (this.orient != \"vertical\" && this.dir == \"reverse\") ? this.increase() : this.decrease();\n          this._userChanged = false;\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" preventdefault=\"true\">\n        <![CDATA[\n          this._userChanged = true;\n          (this.orient != \"vertical\" && this.dir == \"reverse\") ? this.decrease() : this.increase();\n          this._userChanged = false;\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_UP\" preventdefault=\"true\">\n        <![CDATA[\n          this._userChanged = true;\n          (this.orient == \"vertical\" && this.dir != \"reverse\") ? this.decrease() : this.increase();\n          this._userChanged = false;\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" preventdefault=\"true\">\n        <![CDATA[\n          this._userChanged = true;\n          (this.orient == \"vertical\" && this.dir != \"reverse\") ? this.increase() : this.decrease();\n          this._userChanged = false;\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" preventdefault=\"true\">\n        <![CDATA[\n          this._userChanged = true;\n          (this.orient == \"vertical\" && this.dir != \"reverse\") ? this.decreasePage() : this.increasePage();\n          this._userChanged = false;\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" preventdefault=\"true\">\n        <![CDATA[\n          this._userChanged = true;\n          (this.orient == \"vertical\" && this.dir != \"reverse\") ? this.increasePage() : this.decreasePage();\n          this._userChanged = false;\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" preventdefault=\"true\">\n        this._userChanged = true;\n        this.value = (this.dir == \"reverse\") ? this.max : this.min;\n        this._userChanged = false;\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_END\" preventdefault=\"true\">\n        this._userChanged = true;\n        this.value = (this.dir == \"reverse\") ? this.min : this.max;\n        this._userChanged = false;\n      </handler>\n    </handlers>\n\n  </binding>\n</bindings>\n"},{"file":"scrollbar.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"scrollbarBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n  \n  <binding id=\"thumb\" extends=\"xul:button\" />\n\n  <binding id=\"scrollbar-base\" bindToUntrustedContent=\"true\">\n    <handlers>\n      <handler event=\"contextmenu\" preventdefault=\"true\" action=\"event.stopPropagation();\"/>\n      <handler event=\"click\" preventdefault=\"true\" action=\"event.stopPropagation();\"/>\n      <handler event=\"dblclick\" action=\"event.stopPropagation();\"/>\n      <handler event=\"command\" action=\"event.stopPropagation();\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"scrollbar\" bindToUntrustedContent=\"true\" extends=\"chrome://global/content/bindings/scrollbar.xml#scrollbar-base\">\n    <content clickthrough=\"always\">\n      <xul:scrollbarbutton sbattr=\"scrollbar-up-top\" type=\"decrement\" xbl:inherits=\"curpos,maxpos,disabled,sborient=orient\"/>\n      <xul:scrollbarbutton sbattr=\"scrollbar-down-top\" type=\"increment\" xbl:inherits=\"curpos,maxpos,disabled,sborient=orient\"/>\n      <xul:slider flex=\"1\" xbl:inherits=\"disabled,curpos,maxpos,pageincrement,increment,orient,sborient=orient\">\n        <xul:thumb sbattr=\"scrollbar-thumb\" xbl:inherits=\"orient,sborient=orient,collapsed=disabled\" \n                   align=\"center\" pack=\"center\"/>\n      </xul:slider>\n      <xul:scrollbarbutton sbattr=\"scrollbar-up-bottom\" type=\"decrement\" xbl:inherits=\"curpos,maxpos,disabled,sborient=orient\"/>\n      <xul:scrollbarbutton sbattr=\"scrollbar-down-bottom\" type=\"increment\" xbl:inherits=\"curpos,maxpos,disabled,sborient=orient\"/>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"scrollbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"arrowscrollboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"scrollbox-base\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/scrollbox.css\"/>\n    </resources>\n  </binding>\n\n  <binding id=\"scrollbox\" extends=\"chrome://global/content/bindings/scrollbox.xml#scrollbox-base\">\n    <content>\n      <xul:box class=\"box-inherit scrollbox-innerbox\" xbl:inherits=\"orient,align,pack,dir\" flex=\"1\">\n        <children/>\n      </xul:box>\n    </content>\n\n    <implementation>\n      <method name=\"scrollByIndex\">\n        <parameter name=\"index\"/>\n        <body>\n          this.boxObject.scrollByIndex(index);\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"arrowscrollbox\" extends=\"chrome://global/content/bindings/scrollbox.xml#scrollbox-base\">\n    <content>\n      <xul:autorepeatbutton class=\"autorepeatbutton-up\"\n                            anonid=\"scrollbutton-up\"\n                            xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtostart\"\n                            oncommand=\"_autorepeatbuttonScroll(event);\"/>\n      <xul:spacer class=\"arrowscrollbox-overflow-start-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtostart\"/>\n      <xul:scrollbox class=\"arrowscrollbox-scrollbox\"\n                     anonid=\"scrollbox\"\n                     flex=\"1\"\n                     xbl:inherits=\"orient,align,pack,dir,smoothscroll\">\n        <children/>\n      </xul:scrollbox>\n      <xul:spacer class=\"arrowscrollbox-overflow-end-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtoend\"/>\n      <xul:autorepeatbutton class=\"autorepeatbutton-down\"\n                            anonid=\"scrollbutton-down\"\n                            xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtoend\"\n                            oncommand=\"_autorepeatbuttonScroll(event);\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (!this.hasAttribute(\"smoothscroll\")) {\n          this.smoothScroll = this._prefBranch\n                                  .getBoolPref(\"toolkit.scrollbox.smoothScroll\", true);\n        }\n\n        this.setAttribute(\"notoverflowing\", \"true\");\n        this._updateScrollButtonsDisabledState();\n      ]]></constructor>\n\n      <field name=\"_scrollbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbox\");\n      </field>\n      <field name=\"_scrollButtonUp\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbutton-up\");\n      </field>\n      <field name=\"_scrollButtonDown\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbutton-down\");\n      </field>\n\n      <field name=\"__prefBranch\">null</field>\n      <property name=\"_prefBranch\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.__prefBranch === null) {\n            this.__prefBranch = Components.classes[\"@mozilla.org/preferences-service;1\"]\n                                          .getService(Components.interfaces.nsIPrefBranch);\n          }\n          return this.__prefBranch;\n        ]]></getter>\n      </property>\n\n      <field name=\"_scrollIncrement\">null</field>\n      <property name=\"scrollIncrement\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._scrollIncrement === null) {\n            this._scrollIncrement = this._prefBranch\n                                        .getIntPref(\"toolkit.scrollbox.scrollIncrement\", 20);\n          }\n          return this._scrollIncrement;\n        ]]></getter>\n      </property>\n\n      <property name=\"smoothScroll\">\n        <getter><![CDATA[\n          return this.getAttribute(\"smoothscroll\") == \"true\";\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"smoothscroll\", !!val);\n          return val;\n        ]]></setter>\n      </property>\n\n      <field name=\"_scrollBoxObject\">null</field>\n      <property name=\"scrollBoxObject\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._scrollBoxObject) {\n            this._scrollBoxObject = this._scrollbox.boxObject;\n          }\n          return this._scrollBoxObject;\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollClientRect\" readonly=\"true\">\n        <getter><![CDATA[\n          return this._scrollbox.getBoundingClientRect();\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollClientSize\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this._scrollbox.clientHeight :\n                 this._scrollbox.clientWidth;\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollSize\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this._scrollbox.scrollHeight :\n                 this._scrollbox.scrollWidth;\n        ]]></getter>\n      </property>\n\n      <property name=\"lineScrollAmount\" readonly=\"true\">\n        <getter><![CDATA[\n          // line scroll amout should be the width (at horizontal scrollbox) or\n          // the height (at vertical scrollbox) of the scrolled elements.\n          // However, the elements may have different width or height.  So,\n          // for consistent speed, let's use avalage with of the elements.\n          var elements = this._getScrollableElements();\n          return elements.length && (this.scrollSize / elements.length);\n        ]]></getter>\n      </property>\n\n      <field name=\"_startEndProps\"><![CDATA[\n        this.orient == \"vertical\" ? [\"top\", \"bottom\"] : [\"left\", \"right\"];\n      ]]></field>\n\n      <field name=\"_isRTLScrollbox\"><![CDATA[\n        this.orient != \"vertical\" &&\n        document.defaultView.getComputedStyle(this._scrollbox).direction == \"rtl\";\n      ]]></field>\n\n      <field name=\"_scrollTarget\">null</field>\n\n      <method name=\"_boundsWithoutFlushing\">\n        <parameter name=\"element\"/>\n        <body><![CDATA[\n          if (!(\"_DOMWindowUtils\" in this)) {\n            try {\n              this._DOMWindowUtils =\n                window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)\n                      .getInterface(Components.interfaces.nsIDOMWindowUtils);\n            } catch (e) {\n              // Can't access nsIDOMWindowUtils if we're unprivileged.\n              this._DOMWindowUtils = null;\n            }\n          }\n\n          return this._DOMWindowUtils ?\n                 this._DOMWindowUtils.getBoundsWithoutFlushing(element) :\n                 element.getBoundingClientRect();\n        ]]></body>\n      </method>\n\n      <method name=\"_canScrollToElement\">\n        <parameter name=\"element\"/>\n        <body><![CDATA[\n          if (element.hidden) {\n            return false;\n          }\n\n          // See if the element is hidden via CSS without the hidden attribute.\n          // If we get only zeros for the client rect, this means the element\n          // is hidden. As a performance optimization, we don't flush layout\n          // here which means that on the fly changes aren't fully supported.\n          let rect = this._boundsWithoutFlushing(element);\n          return !!(rect.top || rect.left || rect.width || rect.height);\n        ]]></body>\n      </method>\n\n      <method name=\"ensureElementIsVisible\">\n        <parameter name=\"element\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (!this._canScrollToElement(element))\n            return;\n\n          element.scrollIntoView({ behavior: aInstant ? \"instant\" : \"auto\" });\n        ]]></body>\n      </method>\n\n      <method name=\"scrollByIndex\">\n        <parameter name=\"index\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (index == 0)\n            return;\n\n          // Each scrollByIndex call is expected to scroll the given number of\n          // items. If a previous call is still in progress because of smooth\n          // scrolling, we need to complete it before starting a new one.\n          if (this._scrollTarget) {\n            let elements = this._getScrollableElements();\n            if (this._scrollTarget != elements[0] &&\n                this._scrollTarget != elements[elements.length - 1])\n              this.ensureElementIsVisible(this._scrollTarget, true);\n          }\n\n          var rect = this.scrollClientRect;\n          var [start, end] = this._startEndProps;\n          var x = index > 0 ? rect[end] + 1 : rect[start] - 1;\n          var nextElement = this._elementFromPoint(x, index);\n          if (!nextElement)\n            return;\n\n          var targetElement;\n          if (this._isRTLScrollbox)\n            index *= -1;\n          while (index < 0 && nextElement) {\n            if (this._canScrollToElement(nextElement))\n              targetElement = nextElement;\n            nextElement = nextElement.previousSibling;\n            index++;\n          }\n          while (index > 0 && nextElement) {\n            if (this._canScrollToElement(nextElement))\n              targetElement = nextElement;\n            nextElement = nextElement.nextSibling;\n            index--;\n          }\n          if (!targetElement)\n            return;\n\n          this.ensureElementIsVisible(targetElement, aInstant);\n        ]]></body>\n      </method>\n\n      <method name=\"scrollByPage\">\n        <parameter name=\"pageDelta\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (pageDelta == 0)\n            return;\n\n          // If a previous call is still in progress because of smooth\n          // scrolling, we need to complete it before starting a new one.\n          if (this._scrollTarget) {\n            let elements = this._getScrollableElements();\n            if (this._scrollTarget != elements[0] &&\n                this._scrollTarget != elements[elements.length - 1])\n              this.ensureElementIsVisible(this._scrollTarget, true);\n          }\n\n          var [start, end] = this._startEndProps;\n          var rect = this.scrollClientRect;\n          var containerEdge = pageDelta > 0 ? rect[end] + 1 : rect[start] - 1;\n          var pixelDelta = pageDelta * (rect[end] - rect[start]);\n          var destinationPosition = containerEdge + pixelDelta;\n          var nextElement = this._elementFromPoint(containerEdge, pageDelta);\n          if (!nextElement)\n            return;\n\n          // We need to iterate over our elements in the direction of pageDelta.\n          // pageDelta is the physical direction, so in a horizontal scroll box,\n          // positive values scroll to the right no matter if the scrollbox is\n          // LTR or RTL. But RTL changes how we need to advance the iteration\n          // (whether to get the next or the previous sibling of the current\n          // element).\n          var logicalAdvanceDir = pageDelta * (this._isRTLScrollbox ? -1 : 1);\n          var advance = logicalAdvanceDir > 0 ? (e => e.nextSibling) : (e => e.previousSibling);\n\n          var extendsPastTarget = (pageDelta > 0)\n            ? (e => e.getBoundingClientRect()[end] > destinationPosition)\n            : (e => e.getBoundingClientRect()[start] < destinationPosition);\n\n          // We want to scroll to the last element we encounter before we find\n          // an element which extends past destinationPosition.\n          var targetElement;\n          do {\n            if (this._canScrollToElement(nextElement))\n              targetElement = nextElement;\n            nextElement = advance(nextElement);\n          } while (nextElement && !extendsPastTarget(nextElement));\n\n          if (!targetElement)\n            return;\n\n          this.ensureElementIsVisible(targetElement, aInstant);\n        ]]></body>\n      </method>\n\n      <method name=\"_getScrollableElements\">\n        <body><![CDATA[\n          var nodes = this.childNodes;\n          if (nodes.length == 1 &&\n              nodes[0].localName == \"children\" &&\n              nodes[0].namespaceURI == \"http://www.mozilla.org/xbl\") {\n            nodes = document.getBindingParent(this).childNodes;\n          }\n\n          return Array.filter(nodes, this._canScrollToElement, this);\n        ]]></body>\n      </method>\n\n      <method name=\"_elementFromPoint\">\n        <parameter name=\"aX\"/>\n        <parameter name=\"aPhysicalScrollDir\"/>\n        <body><![CDATA[\n          var elements = this._getScrollableElements();\n          if (!elements.length)\n            return null;\n\n          if (this._isRTLScrollbox)\n            elements.reverse();\n\n          var [start, end] = this._startEndProps;\n          var low = 0;\n          var high = elements.length - 1;\n\n          if (aX < elements[low].getBoundingClientRect()[start] ||\n              aX > elements[high].getBoundingClientRect()[end])\n            return null;\n\n          var mid, rect;\n          while (low <= high) {\n            mid = Math.floor((low + high) / 2);\n            rect = elements[mid].getBoundingClientRect();\n            if (rect[start] > aX)\n              high = mid - 1;\n            else if (rect[end] < aX)\n              low = mid + 1;\n            else\n              return elements[mid];\n          }\n\n          // There's no element at the requested coordinate, but the algorithm\n          // from above yields an element next to it, in a random direction.\n          // The desired scrolling direction leads to the correct element.\n\n          if (!aPhysicalScrollDir)\n            return null;\n\n          if (aPhysicalScrollDir < 0 && rect[start] > aX)\n            mid = Math.max(mid - 1, 0);\n          else if (aPhysicalScrollDir > 0 && rect[end] < aX)\n            mid = Math.min(mid + 1, elements.length - 1);\n\n          return elements[mid];\n        ]]></body>\n      </method>\n\n      <method name=\"_autorepeatbuttonScroll\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          var dir = event.originalTarget == this._scrollButtonUp ? -1 : 1;\n          if (this._isRTLScrollbox)\n            dir *= -1;\n\n          this.scrollByPixels(this.scrollIncrement * dir);\n\n          event.stopPropagation();\n        ]]></body>\n      </method>\n\n      <method name=\"scrollByPixels\">\n        <parameter name=\"aPixels\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          let scrollOptions = { behavior: aInstant ? \"instant\" : \"auto\" };\n          scrollOptions[this._startEndProps[0]] = aPixels;\n          this._scrollbox.scrollBy(scrollOptions);\n        ]]></body>\n      </method>\n\n      <field name=\"_prevMouseScrolls\">[null, null]</field>\n\n      <field name=\"_touchStart\">-1</field>\n\n      <field name=\"_scrollButtonUpdatePending\">false</field>\n      <method name=\"_updateScrollButtonsDisabledState\">\n        <body><![CDATA[\n          if (this.hasAttribute(\"notoverflowing\")) {\n            this.setAttribute(\"scrolledtoend\", \"true\");\n            this.setAttribute(\"scrolledtostart\", \"true\");\n            return;\n          }\n\n          if (this._scrollButtonUpdatePending) {\n            return;\n          }\n          this._scrollButtonUpdatePending = true;\n\n          // Wait until after the next paint to get current layout data from\n          // getBoundsWithoutFlushing.\n          window.requestAnimationFrame(() => {\n            setTimeout(() => {\n              this._scrollButtonUpdatePending = false;\n\n              let scrolledToStart = false;\n              let scrolledToEnd = false;\n\n              if (this.hasAttribute(\"notoverflowing\")) {\n                scrolledToStart = true;\n                scrolledToEnd = true;\n              } else {\n                let [leftOrTop, rightOrBottom] = this._startEndProps;\n                let leftOrTopEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[leftOrTop]);\n                let rightOrBottomEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[rightOrBottom]);\n\n                let elements = this._getScrollableElements();\n                let [leftOrTopElement, rightOrBottomElement] = [elements[0], elements[elements.length - 1]];\n                if (this._isRTLScrollbox) {\n                  [leftOrTopElement, rightOrBottomElement] = [rightOrBottomElement, leftOrTopElement];\n                }\n\n                if (leftOrTopElement &&\n                    leftOrTopEdge(leftOrTopElement) >= leftOrTopEdge(this._scrollbox)) {\n                  scrolledToStart = !this._isRTLScrollbox;\n                  scrolledToEnd = this._isRTLScrollbox;\n                } else if (rightOrBottomElement &&\n                           rightOrBottomEdge(rightOrBottomElement) <= rightOrBottomEdge(this._scrollbox)) {\n                  scrolledToStart = this._isRTLScrollbox;\n                  scrolledToEnd = !this._isRTLScrollbox;\n                }\n              }\n\n              if (scrolledToEnd) {\n                this.setAttribute(\"scrolledtoend\", \"true\");\n              } else {\n                this.removeAttribute(\"scrolledtoend\");\n              }\n\n              if (scrolledToStart) {\n                this.setAttribute(\"scrolledtostart\", \"true\");\n              } else {\n                this.removeAttribute(\"scrolledtostart\");\n              }\n            }, 0);\n          });\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"wheel\"><![CDATA[\n        let doScroll = false;\n        let instant;\n        let scrollAmount = 0;\n        if (this.orient == \"vertical\") {\n          doScroll = true;\n          if (event.deltaMode == event.DOM_DELTA_PIXEL)\n            scrollAmount = event.deltaY;\n          else if (event.deltaMode == event.DOM_DELTA_PAGE)\n            scrollAmount = event.deltaY * this.scrollClientSize;\n          else\n            scrollAmount = event.deltaY * this.lineScrollAmount;\n        } else {\n          // We allow vertical scrolling to scroll a horizontal scrollbox\n          // because many users have a vertical scroll wheel but no\n          // horizontal support.\n          // Because of this, we need to avoid scrolling chaos on trackpads\n          // and mouse wheels that support simultaneous scrolling in both axes.\n          // We do this by scrolling only when the last two scroll events were\n          // on the same axis as the current scroll event.\n          // For diagonal scroll events we only respect the dominant axis.\n          let isVertical = Math.abs(event.deltaY) > Math.abs(event.deltaX);\n          let delta = isVertical ? event.deltaY : event.deltaX;\n          let scrollByDelta = isVertical && this._isRTLScrollbox ? -delta : delta;\n\n          if (this._prevMouseScrolls.every(prev => prev == isVertical)) {\n            doScroll = true;\n            if (event.deltaMode == event.DOM_DELTA_PIXEL) {\n              scrollAmount = scrollByDelta;\n              instant = true;\n            } else if (event.deltaMode == event.DOM_DELTA_PAGE) {\n              scrollAmount = scrollByDelta * this.scrollClientSize;\n            } else {\n              scrollAmount = scrollByDelta * this.lineScrollAmount;\n            }\n          }\n\n          if (this._prevMouseScrolls.length > 1)\n            this._prevMouseScrolls.shift();\n          this._prevMouseScrolls.push(isVertical);\n        }\n\n        if (doScroll) {\n          this.scrollByPixels(scrollAmount, instant);\n        }\n\n        event.stopPropagation();\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"touchstart\"><![CDATA[\n        if (event.touches.length > 1) {\n          // Multiple touch points detected, abort. In particular this aborts\n          // the panning gesture when the user puts a second finger down after\n          // already panning with one finger. Aborting at this point prevents\n          // the pan gesture from being resumed until all fingers are lifted\n          // (as opposed to when the user is back down to one finger).\n          this._touchStart = -1;\n        } else {\n          this._touchStart = (this.orient == \"vertical\"\n                ? event.touches[0].screenY\n                : event.touches[0].screenX);\n        }\n      ]]></handler>\n\n      <handler event=\"touchmove\"><![CDATA[\n        if (event.touches.length == 1 &&\n            this._touchStart >= 0) {\n          var touchPoint = (this.orient == \"vertical\"\n                ? event.touches[0].screenY\n                : event.touches[0].screenX);\n          var delta = this._touchStart - touchPoint;\n          if (Math.abs(delta) > 0) {\n            this.scrollByPixels(delta, true);\n            this._touchStart = touchPoint;\n          }\n          event.preventDefault();\n        }\n      ]]></handler>\n\n      <handler event=\"touchend\"><![CDATA[\n        this._touchStart = -1;\n      ]]></handler>\n\n      <handler event=\"underflow\" phase=\"capturing\"><![CDATA[\n        // filter underflow events which were dispatched on nested scrollboxes\n        if (event.target != this)\n          return;\n\n        // Ignore events that doesn't match our orientation.\n        // Scrollport event orientation:\n        //   0: vertical\n        //   1: horizontal\n        //   2: both\n        if (this.orient == \"vertical\") {\n          if (event.detail == 1)\n            return;\n        } else if (event.detail == 0) {\n          // horizontal scrollbox\n          return;\n        }\n\n        this.setAttribute(\"notoverflowing\", \"true\");\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"overflow\" phase=\"capturing\"><![CDATA[\n        // filter underflow events which were dispatched on nested scrollboxes\n        if (event.target != this)\n          return;\n\n        // Ignore events that doesn't match our orientation.\n        // Scrollport event orientation:\n        //   0: vertical\n        //   1: horizontal\n        //   2: both\n        if (this.orient == \"vertical\") {\n          if (event.detail == 1)\n            return;\n        } else if (event.detail == 0) {\n          // horizontal scrollbox\n          return;\n        }\n\n        this.removeAttribute(\"notoverflowing\");\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"scroll\"><![CDATA[\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autorepeatbutton\" extends=\"chrome://global/content/bindings/scrollbox.xml#scrollbox-base\">\n    <content repeat=\"hover\">\n      <xul:image class=\"autorepeatbutton-icon\"/>\n    </content>\n  </binding>\n\n  <binding id=\"arrowscrollbox-clicktoscroll\" extends=\"chrome://global/content/bindings/scrollbox.xml#arrowscrollbox\">\n    <content>\n      <xul:toolbarbutton class=\"scrollbutton-up\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtostart\"\n                         anonid=\"scrollbutton-up\"\n                         onclick=\"_distanceScroll(event);\"\n                         onmousedown=\"if (event.button == 0) _startScroll(-1);\"\n                         onmouseup=\"if (event.button == 0) _stopScroll();\"\n                         onmouseover=\"_continueScroll(-1);\"\n                         onmouseout=\"_pauseScroll();\"/>\n      <xul:spacer class=\"arrowscrollbox-overflow-start-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtostart\"/>\n      <xul:scrollbox class=\"arrowscrollbox-scrollbox\"\n                     anonid=\"scrollbox\"\n                     flex=\"1\"\n                     xbl:inherits=\"orient,align,pack,dir,smoothscroll\">\n        <children/>\n      </xul:scrollbox>\n      <xul:spacer class=\"arrowscrollbox-overflow-end-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtoend\"/>\n      <xul:toolbarbutton class=\"scrollbutton-down\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtoend\"\n                         anonid=\"scrollbutton-down\"\n                         onclick=\"_distanceScroll(event);\"\n                         onmousedown=\"if (event.button == 0) _startScroll(1);\"\n                         onmouseup=\"if (event.button == 0) _stopScroll();\"\n                         onmouseover=\"_continueScroll(1);\"\n                         onmouseout=\"_pauseScroll();\"/>\n    </content>\n    <implementation implements=\"nsITimerCallback, nsIDOMEventListener\">\n      <constructor><![CDATA[\n        this._scrollDelay =\n          this._prefBranch.getIntPref(\"toolkit.scrollbox.clickToScroll.scrollDelay\",\n                                      this._scrollDelay);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // Release timer to avoid reference cycles.\n        if (this._scrollTimer) {\n          this._scrollTimer.cancel();\n          this._scrollTimer = null;\n        }\n      ]]></destructor>\n\n      <field name=\"_scrollIndex\">0</field>\n      <field name=\"_scrollDelay\">150</field>\n\n      <method name=\"notify\">\n        <parameter name=\"aTimer\"/>\n        <body>\n        <![CDATA[\n          if (!document)\n            aTimer.cancel();\n\n          this.scrollByIndex(this._scrollIndex);\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"_arrowScrollAnim\"><![CDATA[({\n        scrollbox: this,\n        requestHandle: 0, /* 0 indicates there is no pending request */\n        start: function arrowSmoothScroll_start() {\n          this.lastFrameTime = window.performance.now();\n          if (!this.requestHandle)\n            this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));\n        },\n        stop: function arrowSmoothScroll_stop() {\n          window.cancelAnimationFrame(this.requestHandle);\n          this.requestHandle = 0;\n        },\n        sample: function arrowSmoothScroll_handleEvent(timeStamp) {\n          const scrollIndex = this.scrollbox._scrollIndex;\n          const timePassed = timeStamp - this.lastFrameTime;\n          this.lastFrameTime = timeStamp;\n\n          const scrollDelta = 0.5 * timePassed * scrollIndex;\n          this.scrollbox.scrollByPixels(scrollDelta, true);\n          this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));\n        }\n      })]]></field>\n\n      <method name=\"_startScroll\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._isRTLScrollbox)\n            index *= -1;\n          this._scrollIndex = index;\n          this._mousedown = true;\n\n          if (this.smoothScroll) {\n            this._arrowScrollAnim.start();\n            return;\n          }\n\n          if (!this._scrollTimer)\n            this._scrollTimer =\n              Components.classes[\"@mozilla.org/timer;1\"]\n                        .createInstance(Components.interfaces.nsITimer);\n          else\n            this._scrollTimer.cancel();\n\n          this._scrollTimer.initWithCallback(this, this._scrollDelay,\n                                             this._scrollTimer.TYPE_REPEATING_SLACK);\n          this.notify(this._scrollTimer);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_stopScroll\">\n        <body><![CDATA[\n          if (this._scrollTimer)\n            this._scrollTimer.cancel();\n          this._mousedown = false;\n          if (!this._scrollIndex || !this.smoothScroll)\n            return;\n\n          this.scrollByIndex(this._scrollIndex);\n          this._scrollIndex = 0;\n\n          this._arrowScrollAnim.stop();\n        ]]></body>\n      </method>\n\n      <method name=\"_pauseScroll\">\n        <body><![CDATA[\n          if (this._mousedown) {\n            this._stopScroll();\n            this._mousedown = true;\n            document.addEventListener(\"mouseup\", this);\n            document.addEventListener(\"blur\", this, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_continueScroll\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._mousedown)\n            this._startScroll(index);\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.type == \"mouseup\" ||\n              aEvent.type == \"blur\" && aEvent.target == document) {\n            this._mousedown = false;\n            document.removeEventListener(\"mouseup\", this);\n            document.removeEventListener(\"blur\", this, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_distanceScroll\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.detail < 2 || aEvent.detail > 3)\n            return;\n\n          var scrollBack = (aEvent.originalTarget == this._scrollButtonUp);\n          var scrollLeftOrUp = this._isRTLScrollbox ? !scrollBack : scrollBack;\n          var targetElement;\n\n          if (aEvent.detail == 2) {\n            // scroll by the size of the scrollbox\n            let [start, end] = this._startEndProps;\n            let x;\n            if (scrollLeftOrUp)\n              x = this.scrollClientRect[start] - this.scrollClientSize;\n            else\n              x = this.scrollClientRect[end] + this.scrollClientSize;\n            targetElement = this._elementFromPoint(x, scrollLeftOrUp ? -1 : 1);\n\n            // the next partly-hidden element will become fully visible,\n            // so don't scroll too far\n            if (targetElement)\n              targetElement = scrollBack ?\n                              targetElement.nextSibling :\n                              targetElement.previousSibling;\n          }\n\n          if (!targetElement) {\n            // scroll to the first resp. last element\n            let elements = this._getScrollableElements();\n            targetElement = scrollBack ?\n                            elements[0] :\n                            elements[elements.length - 1];\n          }\n\n          this.ensureElementIsVisible(targetElement);\n        ]]></body>\n      </method>\n\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"spinbuttons.xml","body":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"spinbuttonsBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"spinbuttons\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n\n    <resources>\n      <stylesheet src=\"chrome://global/skin/spinbuttons.css\"/>\n    </resources>\n\n    <content>\n      <xul:vbox class=\"spinbuttons-box\" flex=\"1\">\n        <xul:button anonid=\"increaseButton\" type=\"repeat\" flex=\"1\"\n                    class=\"spinbuttons-button spinbuttons-up\"\n                    xbl:inherits=\"disabled,disabled=increasedisabled\"/>\n        <xul:button anonid=\"decreaseButton\" type=\"repeat\" flex=\"1\"\n                    class=\"spinbuttons-button spinbuttons-down\"\n                    xbl:inherits=\"disabled,disabled=decreasedisabled\"/>\n      </xul:vbox>\n    </content>\n\n    <implementation>\n      <property name=\"_increaseButton\" readonly=\"true\">\n        <getter>\n          return document.getAnonymousElementByAttribute(this, \"anonid\", \"increaseButton\");\n        </getter>\n      </property>\n      <property name=\"_decreaseButton\" readonly=\"true\">\n        <getter>\n          return document.getAnonymousElementByAttribute(this, \"anonid\", \"decreaseButton\");\n        </getter>\n      </property>\n\n      <property name=\"increaseDisabled\"\n                onget=\"return this._increaseButton.getAttribute('disabled') == 'true';\"\n                onset=\"if (val) this._increaseButton.setAttribute('disabled', 'true');\n                       else this._increaseButton.removeAttribute('disabled'); return val;\"/>\n      <property name=\"decreaseDisabled\"\n                onget=\"return this._decreaseButton.getAttribute('disabled') == 'true';\"\n                onset=\"if (val) this._decreaseButton.setAttribute('disabled', 'true');\n                       else this._decreaseButton.removeAttribute('disabled'); return val;\"/>\n    </implementation>\n\n    <handlers>\n      <handler event=\"mousedown\">\n        <![CDATA[\n          // on the Mac, the native theme draws the spinbutton as a single widget\n          // so a state attribute is set based on where the mouse button was pressed\n          if (event.originalTarget == this._increaseButton)\n            this.setAttribute(\"state\", \"up\");\n          else if (event.originalTarget == this._decreaseButton)\n            this.setAttribute(\"state\", \"down\");\n        ]]>\n      </handler>\n\n      <handler event=\"mouseup\">\n        this.removeAttribute(\"state\");\n      </handler>\n      <handler event=\"mouseout\">\n        this.removeAttribute(\"state\");\n      </handler>\n\n      <handler event=\"command\">\n        <![CDATA[\n          var eventname;\n          if (event.originalTarget == this._increaseButton)\n            eventname = \"up\";\n          else if (event.originalTarget == this._decreaseButton)\n            eventname = \"down\";\n\n          var evt = document.createEvent(\"Events\");\n          evt.initEvent(eventname, true, true);\n          var cancel = this.dispatchEvent(evt);\n\n          if (this.hasAttribute(\"on\" + eventname)) {\n            var fn = new Function(\"event\", this.getAttribute(\"on\" + eventname));\n            if (fn.call(this, event) == false)\n              cancel = true;\n          }\n\n          return !cancel;\n        ]]>\n      </handler>\n\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"splitter.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"splitterBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"splitter\" extends=\"xul:splitter\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/splitter.css\"/>\n    </resources>\n  </binding>\n\n  <binding id=\"grippy\" extends=\"xul:button\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/splitter.css\"/>\n    </resources>\n    <handlers>\n      <handler event=\"command\">\n        <![CDATA[\n          var splitter = this.parentNode;\n          if (splitter) {\n            var state = splitter.getAttribute(\"state\");\n            if (state == \"collapsed\")\n              splitter.setAttribute(\"state\", \"open\");\n            else\n              splitter.setAttribute(\"state\", \"collapsed\");\n          }\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"stringbundle.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"stringBundleBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"stringbundleset\" extends=\"xul:box\"/>\n\n  <binding id=\"stringbundle\" extends=\"xul:spacer\">\n    <implementation name=\"XStringBundle\">\n\n      <method name=\"getString\">\n        <parameter name=\"aStringKey\"/>\n        <body>\n          <![CDATA[\n            try {\n              return this.stringBundle.GetStringFromName(aStringKey);\n            } catch (e) {\n              dump(\"*** Failed to get string \" + aStringKey + \" in bundle: \" + this.src + \"\\n\");\n              throw e;\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getFormattedString\">\n        <parameter name=\"aStringKey\"/>\n        <parameter name=\"aStringsArray\"/>\n        <body>\n          <![CDATA[\n            try {\n              return this.stringBundle.formatStringFromName(aStringKey, aStringsArray, aStringsArray.length);\n            } catch (e) {\n              dump(\"*** Failed to format string \" + aStringKey + \" in bundle: \" + this.src + \"\\n\");\n              throw e;\n            }\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"stringBundle\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (!this._bundle) {\n              try {\n                this._bundle = Components.classes[\"@mozilla.org/intl/stringbundle;1\"]\n                                         .getService(Components.interfaces.nsIStringBundleService)\n                                         .createBundle(this.src);\n              } catch (e) {\n                dump(\"Failed to get stringbundle:\\n\");\n                dump(e + \"\\n\");\n              }\n            }\n            return this._bundle;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"src\">\n        <getter>\n          <![CDATA[\n            return this.getAttribute(\"src\");\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            this._bundle = null;\n            this.setAttribute(\"src\", val);\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"strings\">\n        <getter>\n          <![CDATA[\n            // Note: this is a sucky method name! Should be:\n            //       readonly attribute nsISimpleEnumerator strings;\n            return this.stringBundle.getSimpleEnumeration();\n          ]]>\n        </getter>\n      </property>\n\n      <field name=\"_bundle\">null</field>\n\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"tabbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"tabBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"tab-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/tabbox.css\"/>\n    </resources>\n  </binding>\n\n  <binding id=\"tabbox\"\n           extends=\"chrome://global/content/bindings/tabbox.xml#tab-base\">\n    <implementation implements=\"nsIDOMEventListener\">\n      <property name=\"handleCtrlTab\">\n        <setter>\n        <![CDATA[\n          this.setAttribute(\"handleCtrlTab\", val);\n          return val;\n        ]]>\n        </setter>\n        <getter>\n        <![CDATA[\n          return (this.getAttribute(\"handleCtrlTab\") != \"false\");\n        ]]>\n        </getter>\n      </property>\n\n      <field name=\"_handleMetaAltArrows\" readonly=\"true\">\n        /Mac/.test(navigator.platform)\n      </field>\n\n      <!-- _tabs and _tabpanels are deprecated, they exist only for\n           backwards compatibility. -->\n      <property name=\"_tabs\" readonly=\"true\" onget=\"return this.tabs;\"/>\n      <property name=\"_tabpanels\" readonly=\"true\" onget=\"return this.tabpanels;\"/>\n\n      <property name=\"tabs\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          if (this.hasAttribute(\"tabcontainer\")) {\n            return document.getElementById(this.getAttribute(\"tabcontainer\"));\n          }\n          return this.getElementsByTagNameNS(\n              \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\",\n              \"tabs\").item(0);\n        ]]>\n        </getter>\n      </property>\n\n      <property name=\"tabpanels\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          return this.getElementsByTagNameNS(\n              \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\",\n              \"tabpanels\").item(0);\n        ]]>\n        </getter>\n      </property>\n\n      <property name=\"selectedIndex\">\n        <getter>\n        <![CDATA[\n          var tabs = this.tabs;\n          return tabs ? tabs.selectedIndex : -1;\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          var tabs = this.tabs;\n          if (tabs)\n            tabs.selectedIndex = val;\n          this.setAttribute(\"selectedIndex\", val);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedTab\">\n        <getter>\n        <![CDATA[\n          var tabs = this.tabs;\n          return tabs && tabs.selectedItem;\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          if (val) {\n            var tabs = this.tabs;\n            if (tabs)\n              tabs.selectedItem = val;\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedPanel\">\n        <getter>\n        <![CDATA[\n          var tabpanels = this.tabpanels;\n          return tabpanels && tabpanels.selectedPanel;\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          if (val) {\n            var tabpanels = this.tabpanels;\n            if (tabpanels)\n              tabpanels.selectedPanel = val;\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"event\"/>\n        <body>\n        <![CDATA[\n          if (!event.isTrusted) {\n            // Don't let untrusted events mess with tabs.\n            return;\n          }\n\n          // Don't check if the event was already consumed because tab\n          // navigation should always work for better user experience.\n\n          switch (event.keyCode) {\n            case event.DOM_VK_TAB:\n              if (event.ctrlKey && !event.altKey && !event.metaKey)\n                if (this.tabs && this.handleCtrlTab) {\n                  this.tabs.advanceSelectedTab(event.shiftKey ? -1 : 1, true);\n                  event.preventDefault();\n                }\n              break;\n            case event.DOM_VK_PAGE_UP:\n              if (event.ctrlKey && !event.shiftKey && !event.altKey && !event.metaKey &&\n                  this.tabs) {\n                this.tabs.advanceSelectedTab(-1, true);\n                event.preventDefault();\n              }\n              break;\n            case event.DOM_VK_PAGE_DOWN:\n              if (event.ctrlKey && !event.shiftKey && !event.altKey && !event.metaKey &&\n                  this.tabs) {\n                this.tabs.advanceSelectedTab(1, true);\n                event.preventDefault();\n              }\n              break;\n            case event.DOM_VK_LEFT:\n              if (event.metaKey && event.altKey && !event.shiftKey && !event.ctrlKey)\n                if (this.tabs && this._handleMetaAltArrows) {\n                  var offset = window.getComputedStyle(this)\n                                     .direction == \"ltr\" ? -1 : 1;\n                  this.tabs.advanceSelectedTab(offset, true);\n                  event.preventDefault();\n                }\n              break;\n            case event.DOM_VK_RIGHT:\n              if (event.metaKey && event.altKey && !event.shiftKey && !event.ctrlKey)\n                if (this.tabs && this._handleMetaAltArrows) {\n                  offset = window.getComputedStyle(this)\n                                     .direction == \"ltr\" ? 1 : -1;\n                  this.tabs.advanceSelectedTab(offset, true);\n                  event.preventDefault();\n                }\n              break;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"_eventNode\">this</field>\n\n      <property name=\"eventNode\" onget=\"return this._eventNode;\">\n        <setter>\n          <![CDATA[\n            if (val != this._eventNode) {\n              const nsIEventListenerService =\n                Components.interfaces.nsIEventListenerService;\n              let els = Components.classes[\"@mozilla.org/eventlistenerservice;1\"]\n                                  .getService(nsIEventListenerService);\n              els.addSystemEventListener(val, \"keydown\", this, false);\n              els.removeSystemEventListener(this._eventNode, \"keydown\", this, false);\n              this._eventNode = val;\n            }\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <constructor>\n        switch (this.getAttribute(\"eventnode\")) {\n          case \"parent\": this._eventNode = this.parentNode; break;\n          case \"window\": this._eventNode = window; break;\n          case \"document\": this._eventNode = document; break;\n        }\n        const nsIEventListenerService =\n          Components.interfaces.nsIEventListenerService;\n        let els = Components.classes[\"@mozilla.org/eventlistenerservice;1\"]\n                            .getService(nsIEventListenerService);\n        els.addSystemEventListener(this._eventNode, \"keydown\", this, false);\n      </constructor>\n\n      <destructor>\n        const nsIEventListenerService =\n          Components.interfaces.nsIEventListenerService;\n        let els = Components.classes[\"@mozilla.org/eventlistenerservice;1\"]\n                            .getService(nsIEventListenerService);\n        els.removeSystemEventListener(this._eventNode, \"keydown\", this, false);\n      </destructor>\n    </implementation>\n  </binding>\n\n  <binding id=\"tabs\" role=\"xul:tabs\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/tabbox.css\"/>\n    </resources>\n\n    <content>\n      <xul:spacer class=\"tabs-left\"/>\n      <children/>\n      <xul:spacer class=\"tabs-right\" flex=\"1\"/>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlElement, nsIDOMXULRelatedElement\">\n      <constructor>\n      <![CDATA[\n        // first and last tabs need to be able to have unique styles\n        // and also need to select first tab on startup.\n        if (this.firstChild)\n          this.firstChild.setAttribute(\"first-tab\", \"true\");\n        if (this.lastChild)\n          this.lastChild.setAttribute(\"last-tab\", \"true\");\n\n        if (!this.hasAttribute(\"orient\"))\n          this.setAttribute(\"orient\", \"horizontal\");\n\n        if (this.tabbox && this.tabbox.hasAttribute(\"selectedIndex\")) {\n          let selectedIndex = parseInt(this.tabbox.getAttribute(\"selectedIndex\"));\n          this.selectedIndex = selectedIndex > 0 ? selectedIndex : 0;\n          return;\n        }\n\n        var children = this.childNodes;\n        var length = children.length;\n        for (var i = 0; i < length; i++) {\n          if (children[i].getAttribute(\"selected\") == \"true\") {\n            this.selectedIndex = i;\n            return;\n          }\n        }\n\n        var value = this.value;\n        if (value)\n          this.value = value;\n        else\n          this.selectedIndex = 0;\n      ]]>\n      </constructor>\n\n      <!-- nsIDOMXULRelatedElement -->\n      <method name=\"getRelatedElement\">\n        <parameter name=\"aTabElm\"/>\n        <body>\n        <![CDATA[\n          if (!aTabElm)\n            return null;\n\n          let tabboxElm = this.tabbox;\n          if (!tabboxElm)\n            return null;\n\n          let tabpanelsElm = tabboxElm.tabpanels;\n          if (!tabpanelsElm)\n            return null;\n\n          // Get linked tab panel by 'linkedpanel' attribute on the given tab\n          // element.\n          let linkedPanelId = aTabElm.linkedPanel;\n          if (linkedPanelId) {\n            let ownerDoc = this.ownerDocument;\n\n            // XXX bug 565858: if XUL tab element is anonymous element then\n            // suppose linked tab panel is hosted within the same XBL binding\n            // and search it by ID attribute inside an anonymous content of\n            // the binding. This is not robust assumption since tab elements may\n            // live outside a tabbox element so that for example tab elements\n            // can be explicit content but tab panels can be anonymous.\n\n            let bindingParent = ownerDoc.getBindingParent(aTabElm);\n            if (bindingParent)\n              return ownerDoc.getAnonymousElementByAttribute(bindingParent,\n                                                             \"id\",\n                                                             linkedPanelId);\n\n            return ownerDoc.getElementById(linkedPanelId);\n          }\n\n          // otherwise linked tabpanel element has the same index as the given\n          // tab element.\n          let tabElmIdx = this.getIndexOfItem(aTabElm);\n          return tabpanelsElm.childNodes[tabElmIdx];\n        ]]>\n        </body>\n      </method>\n\n      <!-- nsIDOMXULSelectControlElement -->\n      <property name=\"itemCount\" readonly=\"true\"\n                onget=\"return this.childNodes.length\"/>\n\n      <property name=\"value\" onget=\"return this.getAttribute('value');\">\n        <setter>\n          <![CDATA[\n            this.setAttribute(\"value\", val);\n            var children = this.childNodes;\n            for (var c = children.length - 1; c >= 0; c--) {\n              if (children[c].value == val) {\n                this.selectedIndex = c;\n                break;\n              }\n            }\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <field name=\"_tabbox\">null</field>\n      <property name=\"tabbox\" readonly=\"true\">\n        <getter><![CDATA[\n          // Memoize the result in a field rather than replacing this property,\n          // so that it can be reset along with the binding.\n          if (this._tabbox) {\n            return this._tabbox;\n          }\n\n          let parent = this.parentNode;\n          while (parent) {\n            if (parent.localName == \"tabbox\") {\n              break;\n            }\n            parent = parent.parentNode;\n          }\n\n          return this._tabbox = parent;\n        ]]></getter>\n      </property>\n\n      <!-- _tabbox is deprecated, it exists only for backwards compatibility. -->\n      <field name=\"_tabbox\" readonly=\"true\"><![CDATA[\n        this.tabbox;\n      ]]></field>\n\n      <property name=\"selectedIndex\">\n        <getter>\n        <![CDATA[\n          const tabs = this.childNodes;\n          for (var i = 0; i < tabs.length; i++) {\n            if (tabs[i].selected)\n              return i;\n          }\n          return -1;\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          var tab = this.getItemAtIndex(val);\n          if (tab) {\n            var alreadySelected = tab.selected;\n\n            Array.forEach(this.childNodes, function(aTab) {\n              if (aTab.selected && aTab != tab)\n                aTab._selected = false;\n            });\n            tab._selected = true;\n\n            this.setAttribute(\"value\", tab.value);\n\n            let linkedPanel = this.getRelatedElement(tab);\n            if (linkedPanel) {\n              this.tabbox.setAttribute(\"selectedIndex\", val);\n\n              // This will cause an onselect event to fire for the tabpanel\n              // element.\n              this.tabbox.tabpanels.selectedPanel = linkedPanel;\n            }\n\n            if (!alreadySelected) {\n              // Fire an onselect event for the tabs element.\n              var event = document.createEvent(\"Events\");\n              event.initEvent(\"select\", true, true);\n              this.dispatchEvent(event);\n            }\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedItem\">\n        <getter>\n        <![CDATA[\n          const tabs = this.childNodes;\n          for (var i = 0; i < tabs.length; i++) {\n            if (tabs[i].selected)\n              return tabs[i];\n          }\n          return null;\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          if (val && !val.selected)\n            // The selectedIndex setter ignores invalid values\n            // such as -1 if |val| isn't one of our child nodes.\n            this.selectedIndex = this.getIndexOfItem(val);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"item\"/>\n        <body>\n        <![CDATA[\n          return Array.indexOf(this.childNodes, item);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"index\"/>\n        <body>\n        <![CDATA[\n          return this.childNodes.item(index);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_selectNewTab\">\n        <parameter name=\"aNewTab\"/>\n        <parameter name=\"aFallbackDir\"/>\n        <parameter name=\"aWrap\"/>\n        <body>\n        <![CDATA[\n          var requestedTab = aNewTab;\n          while (aNewTab.hidden || aNewTab.disabled || !this._canAdvanceToTab(aNewTab)) {\n            aNewTab = aFallbackDir == -1 ? aNewTab.previousSibling : aNewTab.nextSibling;\n            if (!aNewTab && aWrap)\n              aNewTab = aFallbackDir == -1 ? this.childNodes[this.childNodes.length - 1] :\n                                             this.childNodes[0];\n            if (!aNewTab || aNewTab == requestedTab)\n              return;\n          }\n\n          var isTabFocused = false;\n          try {\n            isTabFocused =\n              (document.commandDispatcher.focusedElement == this.selectedItem);\n          } catch (e) {}\n          this.selectedItem = aNewTab;\n          if (isTabFocused) {\n            aNewTab.focus();\n          } else if (this.getAttribute(\"setfocus\") != \"false\") {\n            let selectedPanel = this.tabbox.selectedPanel;\n            document.commandDispatcher.advanceFocusIntoSubtree(selectedPanel);\n\n            // Make sure that the focus doesn't move outside the tabbox\n            if (this.tabbox) {\n              try {\n                let el = document.commandDispatcher.focusedElement;\n                while (el && el != this.tabbox.tabpanels) {\n                  if (el == this.tabbox || el == selectedPanel)\n                    return;\n                  el = el.parentNode;\n                }\n                aNewTab.focus();\n              } catch (e) {\n              }\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_canAdvanceToTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          return true;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"advanceSelectedTab\">\n        <parameter name=\"aDir\"/>\n        <parameter name=\"aWrap\"/>\n        <body>\n        <![CDATA[\n          var startTab = this.selectedItem;\n          var next = startTab[aDir == -1 ? \"previousSibling\" : \"nextSibling\"];\n          if (!next && aWrap) {\n            next = aDir == -1 ? this.childNodes[this.childNodes.length - 1] :\n                                this.childNodes[0];\n          }\n          if (next && next != startTab) {\n            this._selectNewTab(next, aDir, aWrap);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"appendItem\">\n        <parameter name=\"label\"/>\n        <parameter name=\"value\"/>\n        <body>\n        <![CDATA[\n          var XULNS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          var tab = document.createElementNS(XULNS, \"tab\");\n          tab.setAttribute(\"label\", label);\n          tab.setAttribute(\"value\", value);\n          this.appendChild(tab);\n          return tab;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"insertItemAt\">\n        <parameter name=\"index\"/>\n        <parameter name=\"label\"/>\n        <parameter name=\"value\"/>\n        <body>\n        <![CDATA[\n          var XULNS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          var tab = document.createElementNS(XULNS, \"tab\");\n          tab.setAttribute(\"label\", label);\n          tab.setAttribute(\"value\", value);\n          var before = this.getItemAtIndex(index);\n          if (before)\n            this.insertBefore(tab, before);\n          else\n            this.appendChild(tab);\n          return tab;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"removeItemAt\">\n        <parameter name=\"index\"/>\n        <body>\n        <![CDATA[\n          var remove = this.getItemAtIndex(index);\n          if (remove)\n            this.removeChild(remove);\n          return remove;\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n\n  </binding>\n\n  <binding id=\"tabpanels\" role=\"xul:tabpanels\"\n           extends=\"chrome://global/content/bindings/tabbox.xml#tab-base\">\n    <implementation implements=\"nsIDOMXULRelatedElement\">\n      <!-- nsIDOMXULRelatedElement -->\n      <method name=\"getRelatedElement\">\n        <parameter name=\"aTabPanelElm\"/>\n        <body>\n        <![CDATA[\n          if (!aTabPanelElm)\n            return null;\n\n          let tabboxElm = this.tabbox;\n          if (!tabboxElm)\n            return null;\n\n          let tabsElm = tabboxElm.tabs;\n          if (!tabsElm)\n            return null;\n\n          // Return tab element having 'linkedpanel' attribute equal to the id\n          // of the tab panel or the same index as the tab panel element.\n          let tabpanelIdx = Array.indexOf(this.childNodes, aTabPanelElm);\n          if (tabpanelIdx == -1)\n            return null;\n\n          let tabElms = tabsElm.childNodes;\n          let tabElmFromIndex = tabElms[tabpanelIdx];\n\n          let tabpanelId = aTabPanelElm.id;\n          if (tabpanelId) {\n            for (let idx = 0; idx < tabElms.length; idx++) {\n              var tabElm = tabElms[idx];\n              if (tabElm.linkedPanel == tabpanelId)\n                return tabElm;\n            }\n          }\n\n          return tabElmFromIndex;\n        ]]>\n        </body>\n      </method>\n\n      <!-- public -->\n      <field name=\"_tabbox\">null</field>\n      <property name=\"tabbox\" readonly=\"true\">\n        <getter><![CDATA[\n          // Memoize the result in a field rather than replacing this property,\n          // so that it can be reset along with the binding.\n          if (this._tabbox) {\n            return this._tabbox;\n          }\n\n          let parent = this.parentNode;\n          while (parent) {\n            if (parent.localName == \"tabbox\") {\n              break;\n            }\n            parent = parent.parentNode;\n          }\n\n          return this._tabbox = parent;\n        ]]></getter>\n      </property>\n\n      <field name=\"_selectedPanel\">this.childNodes.item(this.selectedIndex)</field>\n\n      <property name=\"selectedIndex\">\n        <getter>\n        <![CDATA[\n          var indexStr = this.getAttribute(\"selectedIndex\");\n          return indexStr ? parseInt(indexStr) : -1;\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          if (val < 0 || val >= this.childNodes.length)\n            return val;\n          var panel = this._selectedPanel;\n          this._selectedPanel = this.childNodes[val];\n          this.setAttribute(\"selectedIndex\", val);\n          if (this._selectedPanel != panel) {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"select\", true, true);\n            this.dispatchEvent(event);\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedPanel\">\n        <getter>\n          <![CDATA[\n            return this._selectedPanel;\n          ]]>\n        </getter>\n\n        <setter>\n          <![CDATA[\n            var selectedIndex = -1;\n            for (var panel = val; panel != null; panel = panel.previousSibling)\n              ++selectedIndex;\n            this.selectedIndex = selectedIndex;\n            return val;\n          ]]>\n        </setter>\n      </property>\n    </implementation>\n  </binding>\n\n  <binding id=\"tab\" display=\"xul:button\" role=\"xul:tab\"\n           extends=\"chrome://global/content/bindings/general.xml#control-item\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/tabbox.css\"/>\n    </resources>\n\n    <content>\n      <xul:hbox class=\"tab-middle box-inherit\" xbl:inherits=\"align,dir,pack,orient,selected,visuallyselected\" flex=\"1\">\n        <xul:image class=\"tab-icon\"\n                   xbl:inherits=\"validate,src=image\"\n                   role=\"presentation\"/>\n        <xul:label class=\"tab-text\"\n                   xbl:inherits=\"value=label,accesskey,crop,disabled\"\n                   flex=\"1\"\n                   role=\"presentation\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <property name=\"control\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var parent = this.parentNode;\n            if (parent instanceof Components.interfaces.nsIDOMXULSelectControlElement)\n              return parent;\n            return null;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"selected\" readonly=\"true\"\n                onget=\"return this.getAttribute('selected') == 'true';\"/>\n\n      <property name=\"_selected\">\n        <setter><![CDATA[\n          if (val) {\n            this.setAttribute(\"selected\", \"true\");\n            this.setAttribute(\"visuallyselected\", \"true\");\n          } else {\n            this.removeAttribute(\"selected\");\n            this.removeAttribute(\"visuallyselected\");\n          }\n\n          this._setPositionAttributes(val);\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <method name=\"_setPositionAttributes\">\n        <parameter name=\"aSelected\"/>\n        <body><![CDATA[\n          if (this.previousSibling && this.previousSibling.localName == \"tab\") {\n            if (aSelected)\n              this.previousSibling.setAttribute(\"beforeselected\", \"true\");\n            else\n              this.previousSibling.removeAttribute(\"beforeselected\");\n            this.removeAttribute(\"first-tab\");\n          } else {\n            this.setAttribute(\"first-tab\", \"true\");\n          }\n\n          if (this.nextSibling && this.nextSibling.localName == \"tab\") {\n            if (aSelected)\n              this.nextSibling.setAttribute(\"afterselected\", \"true\");\n            else\n              this.nextSibling.removeAttribute(\"afterselected\");\n            this.removeAttribute(\"last-tab\");\n          } else {\n            this.setAttribute(\"last-tab\", \"true\");\n          }\n        ]]></body>\n      </method>\n\n      <property name=\"linkedPanel\" onget=\"return this.getAttribute('linkedpanel')\"\n                                   onset=\"this.setAttribute('linkedpanel', val); return val;\"/>\n\n      <field name=\"arrowKeysShouldWrap\" readonly=\"true\">\n        /Mac/.test(navigator.platform)\n      </field>\n      <property name=\"TelemetryStopwatch\" readonly=\"true\">\n        <getter><![CDATA[\n          let module = {};\n          Cu.import(\"resource://gre/modules/TelemetryStopwatch.jsm\", module);\n          Object.defineProperty(this, \"TelemetryStopwatch\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: module.TelemetryStopwatch\n          });\n          return module.TelemetryStopwatch;\n        ]]></getter>\n      </property>\n    </implementation>\n\n    <handlers>\n      <handler event=\"mousedown\" button=\"0\">\n      <![CDATA[\n        if (this.disabled)\n          return;\n\n        if (this != this.parentNode.selectedItem) { // Not selected yet\n          let stopwatchid = this.parentNode.getAttribute(\"stopwatchid\");\n          if (stopwatchid) {\n            this.TelemetryStopwatch.start(stopwatchid);\n          }\n\n          // Call this before setting the 'ignorefocus' attribute because this\n          // will pass on focus if the formerly selected tab was focused as well.\n          this.parentNode._selectNewTab(this);\n\n          var isTabFocused = false;\n          try {\n            isTabFocused = (document.commandDispatcher.focusedElement == this);\n          } catch (e) {}\n\n          // Set '-moz-user-focus' to 'ignore' so that PostHandleEvent() can't\n          // focus the tab; we only want tabs to be focusable by the mouse if\n          // they are already focused. After a short timeout we'll reset\n          // '-moz-user-focus' so that tabs can be focused by keyboard again.\n          if (!isTabFocused) {\n            this.setAttribute(\"ignorefocus\", \"true\");\n            setTimeout(tab => tab.removeAttribute(\"ignorefocus\"), 0, this);\n          }\n\n          if (stopwatchid) {\n            this.TelemetryStopwatch.finish(stopwatchid);\n          }\n        }\n        // Otherwise this tab is already selected and we will fall\n        // through to mousedown behavior which sets focus on the current tab,\n        // Only a click on an already selected tab should focus the tab itself.\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_LEFT\" group=\"system\" preventdefault=\"true\">\n      <![CDATA[\n        var direction = window.getComputedStyle(this.parentNode).direction;\n        this.parentNode.advanceSelectedTab(direction == \"ltr\" ? -1 : 1, this.arrowKeysShouldWrap);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_RIGHT\" group=\"system\" preventdefault=\"true\">\n      <![CDATA[\n        var direction = window.getComputedStyle(this.parentNode).direction;\n        this.parentNode.advanceSelectedTab(direction == \"ltr\" ? 1 : -1, this.arrowKeysShouldWrap);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_UP\" group=\"system\" preventdefault=\"true\">\n      <![CDATA[\n        this.parentNode.advanceSelectedTab(-1, this.arrowKeysShouldWrap);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_DOWN\" group=\"system\" preventdefault=\"true\">\n      <![CDATA[\n        this.parentNode.advanceSelectedTab(1, this.arrowKeysShouldWrap);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_HOME\" group=\"system\" preventdefault=\"true\">\n      <![CDATA[\n        this.parentNode._selectNewTab(this.parentNode.childNodes[0]);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_END\" group=\"system\" preventdefault=\"true\">\n      <![CDATA[\n        var tabs = this.parentNode.childNodes;\n        this.parentNode._selectNewTab(tabs[tabs.length - 1], -1);\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"text.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"textBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\">\n\n  <!-- bound to <description>s -->\n  <binding id=\"text-base\" role=\"xul:text\">\n    <implementation implements=\"nsIDOMXULDescriptionElement\">\n      <property name=\"disabled\" onset=\"if (val) this.setAttribute('disabled', 'true');\n                                       else this.removeAttribute('disabled');\n                                       return val;\"\n                                onget=\"return this.getAttribute('disabled') == 'true';\"/>\n      <property name=\"value\" onget=\"return this.getAttribute('value');\"\n                             onset=\"this.setAttribute('value', val); return val;\"/>\n      <property name=\"crop\" onget=\"return this.getAttribute('crop');\"\n                            onset=\"this.setAttribute('crop', val); return val;\"/>\n    </implementation>\n  </binding>\n\n  <binding id=\"text-label\" extends=\"chrome://global/content/bindings/text.xml#text-base\">\n    <implementation implements=\"nsIDOMXULLabelElement\">\n      <property name=\"accessKey\">\n        <getter>\n          <![CDATA[\n            var accessKey = this.getAttribute(\"accesskey\");\n            return accessKey ? accessKey[0] : null;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            this.setAttribute(\"accesskey\", val);\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"control\" onget=\"return getAttribute('control');\">\n        <setter>\n          <![CDATA[\n            // After this gets set, the label will use the binding #label-control\n            this.setAttribute(\"control\", val);\n            return val;\n          ]]>\n        </setter>\n      </property>\n    </implementation>\n  </binding>\n\n  <binding id=\"label-control\" extends=\"chrome://global/content/bindings/text.xml#text-label\">\n    <content>\n      <children/><html:span anonid=\"accessKeyParens\"></html:span>\n    </content>\n    <implementation implements=\"nsIDOMXULLabelElement\">\n      <constructor>\n        <![CDATA[\n          this.formatAccessKey(true);\n        ]]>\n      </constructor>\n\n      <method name=\"formatAccessKey\">\n        <parameter name=\"firstTime\"/>\n        <body>\n          <![CDATA[\n            var control = this.labeledControlElement;\n            if (!control) {\n              var bindingParent = document.getBindingParent(this);\n              if (bindingParent instanceof Components.interfaces.nsIDOMXULLabeledControlElement) {\n                control = bindingParent; // For controls that make the <label> an anon child\n              }\n            }\n            if (control) {\n              control.labelElement = this;\n            }\n\n            var accessKey = this.accessKey;\n            // No need to remove existing formatting the first time.\n            if (firstTime && !accessKey)\n              return;\n\n            if (this.mInsertSeparator === undefined) {\n              try {\n                var prefs = Components.classes[\"@mozilla.org/preferences-service;1\"].\n                                       getService(Components.interfaces.nsIPrefBranch);\n                this.mUnderlineAccesskey = (prefs.getIntPref(\"ui.key.menuAccessKey\") != 0);\n\n                const nsIPrefLocalizedString =\n                  Components.interfaces.nsIPrefLocalizedString;\n\n                const prefNameInsertSeparator =\n                  \"intl.menuitems.insertseparatorbeforeaccesskeys\";\n                const prefNameAlwaysAppendAccessKey =\n                  \"intl.menuitems.alwaysappendaccesskeys\";\n\n                var val = prefs.getComplexValue(prefNameInsertSeparator,\n                                                nsIPrefLocalizedString).data;\n                this.mInsertSeparator = (val == \"true\");\n\n                val = prefs.getComplexValue(prefNameAlwaysAppendAccessKey,\n                                            nsIPrefLocalizedString).data;\n                this.mAlwaysAppendAccessKey = (val == \"true\");\n              } catch (e) {\n                this.mInsertSeparator = true;\n              }\n            }\n\n            if (!this.mUnderlineAccesskey)\n              return;\n\n            var afterLabel = document.getAnonymousElementByAttribute(this, \"anonid\", \"accessKeyParens\");\n            afterLabel.textContent = \"\";\n\n            var oldAccessKey = this.getElementsByAttribute(\"class\", \"accesskey\").item(0);\n            if (oldAccessKey) { // Clear old accesskey\n              this.mergeElement(oldAccessKey);\n            }\n\n            var oldHiddenSpan =\n              this.getElementsByAttribute(\"class\", \"hiddenColon\").item(0);\n            if (oldHiddenSpan) {\n              this.mergeElement(oldHiddenSpan);\n            }\n\n            var labelText = this.textContent;\n            if (!accessKey || !labelText || !control) {\n              return;\n            }\n            var accessKeyIndex = -1;\n            if (!this.mAlwaysAppendAccessKey) {\n              accessKeyIndex = labelText.indexOf(accessKey);\n              if (accessKeyIndex < 0) { // Try again in upper case\n                accessKeyIndex =\n                  labelText.toUpperCase().indexOf(accessKey.toUpperCase());\n              }\n            }\n\n            const HTML_NS = \"http://www.w3.org/1999/xhtml\";\n            var span = document.createElementNS(HTML_NS, \"span\");\n            span.className = \"accesskey\";\n\n            // Note that if you change the following code, see the comment of\n            // nsTextBoxFrame::UpdateAccessTitle.\n\n            // If accesskey is not in string, append in parentheses\n            if (accessKeyIndex < 0) {\n              // If end is colon, we should insert before colon.\n              // i.e., \"label:\" -> \"label(X):\"\n              var colonHidden = false;\n              if (/:$/.test(labelText)) {\n                labelText = labelText.slice(0, -1);\n                var hiddenSpan = document.createElementNS(HTML_NS, \"span\");\n                hiddenSpan.className = \"hiddenColon\";\n                hiddenSpan.style.display = \"none\";\n                // Hide the last colon by using span element.\n                // I.e., label<span style=\"display:none;\">:</span>\n                this.wrapChar(hiddenSpan, labelText.length);\n                colonHidden = true;\n              }\n              // If end is space(U+20),\n              // we should not add space before parentheses.\n              var endIsSpace = false;\n              if (/ $/.test(labelText)) {\n                endIsSpace = true;\n              }\n              if (this.mInsertSeparator && !endIsSpace)\n                afterLabel.textContent = \" (\";\n              else\n                afterLabel.textContent = \"(\";\n              span.textContent = accessKey.toUpperCase();\n              afterLabel.appendChild(span);\n              if (!colonHidden)\n                afterLabel.appendChild(document.createTextNode(\")\"));\n              else\n                afterLabel.appendChild(document.createTextNode(\"):\"));\n              return;\n            }\n            this.wrapChar(span, accessKeyIndex);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"wrapChar\">\n        <parameter name=\"element\"/>\n        <parameter name=\"index\"/>\n        <body>\n          <![CDATA[\n             var treeWalker = document.createTreeWalker(this,\n                                                        NodeFilter.SHOW_TEXT,\n                                                        null);\n             var node = treeWalker.nextNode();\n             while (index >= node.length) {\n               index -= node.length;\n               node = treeWalker.nextNode();\n             }\n             if (index) {\n               node = node.splitText(index);\n             }\n             node.parentNode.insertBefore(element, node);\n             if (node.length > 1) {\n               node.splitText(1);\n             }\n             element.appendChild(node);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"mergeElement\">\n        <parameter name=\"element\"/>\n        <body>\n          <![CDATA[\n            if (element.previousSibling instanceof Text) {\n              element.previousSibling.appendData(element.textContent)\n            } else {\n              element.parentNode.insertBefore(element.firstChild, element);\n            }\n            element.remove();\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"mUnderlineAccesskey\">\n        !/Mac/.test(navigator.platform)\n      </field>\n      <field name=\"mInsertSeparator\"/>\n      <field name=\"mAlwaysAppendAccessKey\">false</field>\n\n      <property name=\"accessKey\">\n        <getter>\n          <![CDATA[\n            var accessKey = null;\n            var labeledEl = this.labeledControlElement;\n            if (labeledEl) {\n              accessKey = labeledEl.getAttribute(\"accesskey\");\n            }\n            if (!accessKey) {\n              accessKey = this.getAttribute(\"accesskey\");\n            }\n            return accessKey ? accessKey[0] : null;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            // If this label already has an accesskey attribute store it here as well\n            if (this.hasAttribute(\"accesskey\")) {\n              this.setAttribute(\"accesskey\", val);\n            }\n            var control = this.labeledControlElement;\n            if (control) {\n              control.setAttribute(\"accesskey\", val);\n            }\n            this.formatAccessKey(false);\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"labeledControlElement\" readonly=\"true\"\n                onget=\"var control = this.control; return control ? document.getElementById(control) : null;\" />\n\n      <property name=\"control\" onget=\"return this.getAttribute('control');\">\n        <setter>\n          <![CDATA[\n            var control = this.labeledControlElement;\n            if (control) {\n              control.labelElement = null; // No longer pointed to be this label\n            }\n            this.setAttribute(\"control\", val);\n            this.formatAccessKey(false);\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"click\" action=\"if (this.disabled) return;\n                                     var controlElement = this.labeledControlElement;\n                                     if(controlElement)\n                                       controlElement.focus();\n                                    \"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"text-link\" extends=\"chrome://global/content/bindings/text.xml#text-label\" role=\"xul:link\">\n    <implementation>\n      <property name=\"href\" onget=\"return this.getAttribute('href');\"\n                            onset=\"this.setAttribute('href', val); return val;\" />\n      <method name=\"open\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          var href = this.href;\n          if (!href || this.disabled || aEvent.defaultPrevented)\n            return;\n\n          var uri = null;\n          try {\n            const nsISSM = Components.interfaces.nsIScriptSecurityManager;\n            const secMan =\n                     Components.classes[\"@mozilla.org/scriptsecuritymanager;1\"]\n                               .getService(nsISSM);\n\n            const ioService =\n                     Components.classes[\"@mozilla.org/network/io-service;1\"]\n                               .getService(Components.interfaces.nsIIOService);\n\n            uri = ioService.newURI(href);\n\n            let principal;\n            if (this.getAttribute(\"useoriginprincipal\") == \"true\") {\n              principal = this.nodePrincipal;\n            } else {\n              principal = secMan.createNullPrincipal({});\n            }\n            try {\n              secMan.checkLoadURIWithPrincipal(principal, uri,\n                                               nsISSM.DISALLOW_INHERIT_PRINCIPAL);\n            } catch (ex) {\n              var msg = \"Error: Cannot open a \" + uri.scheme + \": link using \\\n                         the text-link binding.\";\n              Components.utils.reportError(msg);\n              return;\n            }\n\n            const cID = \"@mozilla.org/uriloader/external-protocol-service;1\";\n            const nsIEPS = Components.interfaces.nsIExternalProtocolService;\n            var protocolSvc = Components.classes[cID].getService(nsIEPS);\n\n            // if the scheme is not an exposed protocol, then opening this link\n            // should be deferred to the system's external protocol handler\n            if (!protocolSvc.isExposedProtocol(uri.scheme)) {\n              protocolSvc.loadURI(uri);\n              aEvent.preventDefault()\n              return;\n            }\n\n          } catch (ex) {\n            Components.utils.reportError(ex);\n          }\n\n          aEvent.preventDefault();\n          href = uri ? uri.spec : href;\n\n          // Try handing off the link to the host application, e.g. for\n          // opening it in a tabbed browser.\n          var linkHandled = Components.classes[\"@mozilla.org/supports-PRBool;1\"]\n                                      .createInstance(Components.interfaces.nsISupportsPRBool);\n          linkHandled.data = false;\n          let {shiftKey, ctrlKey, metaKey, altKey, button} = aEvent;\n          let data = {shiftKey, ctrlKey, metaKey, altKey, button, href};\n          Components.classes[\"@mozilla.org/observer-service;1\"]\n                    .getService(Components.interfaces.nsIObserverService)\n                    .notifyObservers(linkHandled, \"handle-xul-text-link\", JSON.stringify(data));\n          if (linkHandled.data)\n            return;\n\n          // otherwise, fall back to opening the anchor directly\n          var win = window;\n          if (window.isChromeWindow) {\n            while (win.opener && !win.opener.closed)\n              win = win.opener;\n          }\n          win.open(href);\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"click\" phase=\"capturing\" button=\"0\" action=\"this.open(event)\"/>\n      <handler event=\"click\" phase=\"capturing\" button=\"1\" action=\"this.open(event)\"/>\n      <handler event=\"keypress\" preventdefault=\"true\" keycode=\"VK_RETURN\" action=\"this.click()\" />\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"textbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This files relies on these specific Chrome/XBL globals -->\n<!-- globals ChromeWindow -->\n\n\n<!DOCTYPE bindings [\n  <!ENTITY % textcontextDTD SYSTEM \"chrome://global/locale/textcontext.dtd\" >\n  %textcontextDTD;\n]>\n\n<bindings id=\"textboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"textbox\" extends=\"xul:box\" role=\"xul:textbox\">\n    <resources>\n      <stylesheet src=\"chrome://global/content/textbox.css\"/>\n      <stylesheet src=\"chrome://global/skin/textbox.css\"/>\n    </resources>\n\n    <content>\n      <children/>\n      <xul:hbox class=\"textbox-input-box\" flex=\"1\" xbl:inherits=\"context,spellcheck\">\n        <html:input class=\"textbox-input\" anonid=\"input\"\n                    xbl:inherits=\"value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,noinitialfocus,mozactionhint,spellcheck\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULTextBoxElement, nsIDOMXULLabeledControlElement\">\n      <!-- nsIDOMXULLabeledControlElement -->\n      <field name=\"crop\">\"\"</field>\n      <field name=\"image\">\"\"</field>\n      <field name=\"command\">\"\"</field>\n      <field name=\"accessKey\">\"\"</field>\n\n      <field name=\"mInputField\">null</field>\n      <field name=\"mIgnoreClick\">false</field>\n      <field name=\"mIgnoreFocus\">false</field>\n      <field name=\"mEditor\">null</field>\n\n      <property name=\"inputField\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.mInputField)\n            this.mInputField = document.getAnonymousElementByAttribute(this, \"anonid\", \"input\");\n          return this.mInputField;\n        ]]></getter>\n      </property>\n\n      <property name=\"value\"      onset=\"this.inputField.value = val; return val;\"\n                                  onget=\"return this.inputField.value;\"/>\n      <property name=\"defaultValue\" onset=\"this.inputField.defaultValue = val; return val;\"\n                                  onget=\"return this.inputField.defaultValue;\"/>\n      <property name=\"label\"      onset=\"this.setAttribute('label', val); return val;\"\n                                  onget=\"return this.getAttribute('label') ||\n                                                (this.labelElement ? this.labelElement.value :\n                                                 this.placeholder);\"/>\n      <property name=\"placeholder\" onset=\"this.inputField.placeholder = val; return val;\"\n                                  onget=\"return this.inputField.placeholder;\"/>\n      <property name=\"emptyText\"  onset=\"this.placeholder = val; return val;\"\n                                  onget=\"return this.placeholder;\"/>\n      <property name=\"type\"       onset=\"if (val) this.setAttribute('type', val);\n                                         else this.removeAttribute('type'); return val;\"\n                                  onget=\"return this.getAttribute('type');\"/>\n      <property name=\"maxLength\"  onset=\"this.inputField.maxLength = val; return val;\"\n                                  onget=\"return this.inputField.maxLength;\"/>\n      <property name=\"disabled\"   onset=\"this.inputField.disabled = val;\n                                         if (val) this.setAttribute('disabled', 'true');\n                                         else this.removeAttribute('disabled'); return val;\"\n                                  onget=\"return this.inputField.disabled;\"/>\n      <property name=\"tabIndex\"   onget=\"return parseInt(this.getAttribute('tabindex'));\"\n                                  onset=\"this.inputField.tabIndex = val;\n                                         if (val) this.setAttribute('tabindex', val);\n                                         else this.removeAttribute('tabindex'); return val;\"/>\n      <property name=\"size\"       onset=\"this.inputField.size = val; return val;\"\n                                  onget=\"return this.inputField.size;\"/>\n      <property name=\"readOnly\"   onset=\"this.inputField.readOnly = val;\n                                         if (val) this.setAttribute('readonly', 'true');\n                                         else this.removeAttribute('readonly'); return val;\"\n                                  onget=\"return this.inputField.readOnly;\"/>\n      <property name=\"clickSelectsAll\"\n                onget=\"return this.getAttribute('clickSelectsAll') == 'true';\"\n                onset=\"if (val) this.setAttribute('clickSelectsAll', 'true');\n                       else this.removeAttribute('clickSelectsAll'); return val;\" />\n\n      <property name=\"editor\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.mEditor) {\n            const nsIDOMNSEditableElement = Components.interfaces.nsIDOMNSEditableElement;\n            this.mEditor = this.inputField.QueryInterface(nsIDOMNSEditableElement).editor;\n          }\n          return this.mEditor;\n        ]]></getter>\n      </property>\n\n      <method name=\"reset\">\n        <body><![CDATA[\n          this.value = this.defaultValue;\n          try {\n            this.editor.transactionManager.clear();\n            return true;\n          } catch (e) {}\n          return false;\n        ]]></body>\n      </method>\n\n      <method name=\"select\">\n        <body>\n          this.inputField.select();\n        </body>\n      </method>\n\n      <property name=\"controllers\"    readonly=\"true\" onget=\"return this.inputField.controllers\"/>\n      <property name=\"textLength\"     readonly=\"true\"\n                                      onget=\"return this.inputField.textLength;\"/>\n      <property name=\"selectionStart\" onset=\"this.inputField.selectionStart = val; return val;\"\n                                      onget=\"return this.inputField.selectionStart;\"/>\n      <property name=\"selectionEnd\"   onset=\"this.inputField.selectionEnd = val; return val;\"\n                                      onget=\"return this.inputField.selectionEnd;\"/>\n\n      <method name=\"setSelectionRange\">\n        <parameter name=\"aSelectionStart\"/>\n        <parameter name=\"aSelectionEnd\"/>\n        <body>\n          this.inputField.setSelectionRange( aSelectionStart, aSelectionEnd );\n        </body>\n      </method>\n\n      <method name=\"_setNewlineHandling\">\n        <body><![CDATA[\n          var str = this.getAttribute(\"newlines\");\n          if (str && this.editor) {\n            const nsIPlaintextEditor = Components.interfaces.nsIPlaintextEditor;\n            for (var x in nsIPlaintextEditor) {\n              if (/^eNewlines/.test(x)) {\n                if (str == RegExp.rightContext.toLowerCase()) {\n                  this.editor.QueryInterface(nsIPlaintextEditor)\n                      .newlineHandling = nsIPlaintextEditor[x];\n                  break;\n                }\n              }\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_maybeSelectAll\">\n        <body><![CDATA[\n          if (!this.mIgnoreClick && this.clickSelectsAll &&\n              document.activeElement == this.inputField &&\n              this.inputField.selectionStart == this.inputField.selectionEnd)\n            this.editor.selectAll();\n        ]]></body>\n      </method>\n\n      <constructor><![CDATA[\n        var str = this.boxObject.getProperty(\"value\");\n        if (str) {\n          this.inputField.value = str;\n          this.boxObject.removeProperty(\"value\");\n        }\n\n        this._setNewlineHandling();\n\n        if (this.hasAttribute(\"emptytext\"))\n          this.placeholder = this.getAttribute(\"emptytext\");\n      ]]></constructor>\n\n      <destructor>\n        <![CDATA[\n          var field = this.inputField;\n          if (field && field.value)\n            this.boxObject.setProperty(\"value\", field.value);\n          this.mInputField = null;\n        ]]>\n      </destructor>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"focus\" phase=\"capturing\">\n        <![CDATA[\n          if (this.hasAttribute(\"focused\"))\n            return;\n\n          switch (event.originalTarget) {\n            case this:\n              // Forward focus to actual HTML input\n              this.inputField.focus();\n              break;\n            case this.inputField:\n              if (this.mIgnoreFocus) {\n                this.mIgnoreFocus = false;\n              } else if (this.clickSelectsAll) {\n                try {\n                  if (!this.editor || !this.editor.composing)\n                    this.editor.selectAll();\n                } catch (e) {}\n              }\n              break;\n            default:\n              // Allow other children (e.g. URL bar buttons) to get focus\n              return;\n          }\n          this.setAttribute(\"focused\", \"true\");\n        ]]>\n      </handler>\n\n      <handler event=\"blur\" phase=\"capturing\">\n        <![CDATA[\n          this.removeAttribute(\"focused\");\n\n          // don't trigger clickSelectsAll when switching application windows\n          if (window == window.top &&\n              window.isChromeWindow &&\n              document.activeElement == this.inputField)\n            this.mIgnoreFocus = true;\n        ]]>\n      </handler>\n\n      <handler event=\"mousedown\">\n        <![CDATA[\n          this.mIgnoreClick = this.hasAttribute(\"focused\");\n\n          if (!this.mIgnoreClick) {\n            this.mIgnoreFocus = true;\n            this.inputField.setSelectionRange(0, 0);\n            if (event.originalTarget == this ||\n                event.originalTarget == this.inputField.parentNode)\n              this.inputField.focus();\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"click\" action=\"this._maybeSelectAll();\"/>\n\n\n    </handlers>\n  </binding>\n\n  <binding id=\"timed-textbox\" extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <implementation>\n      <constructor><![CDATA[\n        try {\n          var consoleService = Components.classes[\"@mozilla.org/consoleservice;1\"]\n                                         .getService(Components.interfaces.nsIConsoleService);\n          var scriptError = Components.classes[\"@mozilla.org/scripterror;1\"]\n                                      .createInstance(Components.interfaces.nsIScriptError);\n          scriptError.init(\"Timed textboxes are deprecated. Consider using type=\\\"search\\\" instead.\",\n                           this.ownerDocument.location.href, null, null,\n                           null, scriptError.warningFlag, \"XUL Widgets\");\n          consoleService.logMessage(scriptError);\n        } catch (e) {}\n      ]]></constructor>\n      <field name=\"_timer\">null</field>\n      <property name=\"timeout\"\n                onset=\"this.setAttribute('timeout', val); return val;\"\n                onget=\"return parseInt(this.getAttribute('timeout')) || 0;\"/>\n      <property name=\"value\"\n                onget=\"return this.inputField.value;\">\n        <setter><![CDATA[\n          this.inputField.value = val;\n          if (this._timer)\n            clearTimeout(this._timer);\n          return val;\n        ]]></setter>\n      </property>\n      <method name=\"_fireCommand\">\n        <parameter name=\"me\"/>\n        <body>\n          <![CDATA[\n            me._timer = null;\n            me.doCommand();\n          ]]>\n        </body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"input\">\n        <![CDATA[\n          if (this._timer)\n            clearTimeout(this._timer);\n          this._timer = this.timeout && setTimeout(this._fireCommand, this.timeout, this);\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\">\n        <![CDATA[\n          if (this._timer)\n            clearTimeout(this._timer);\n          this._fireCommand(this);\n          event.preventDefault();\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"search-textbox\" extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content>\n      <children/>\n      <xul:hbox class=\"textbox-input-box\" flex=\"1\" xbl:inherits=\"context,spellcheck\" align=\"center\">\n        <xul:image class=\"textbox-search-sign\"/>\n        <html:input class=\"textbox-input\" anonid=\"input\" mozactionhint=\"search\"\n                    xbl:inherits=\"value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,mozactionhint,spellcheck\"/>\n        <xul:deck class=\"textbox-search-icons\" anonid=\"search-icons\">\n          <xul:image class=\"textbox-search-icon\" anonid=\"searchbutton-icon\"\n                     xbl:inherits=\"src=image,label=searchbuttonlabel,searchbutton,disabled\"/>\n          <xul:image class=\"textbox-search-clear\"\n                     onclick=\"document.getBindingParent(this)._clearSearch();\"\n                     label=\"FROM-DTD-searchTextBox-clear-label\"\n                     xbl:inherits=\"disabled\"/>\n        </xul:deck>\n      </xul:hbox>\n    </content>\n    <implementation>\n      <field name=\"_timer\">null</field>\n      <field name=\"_searchIcons\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"search-icons\");\n      </field>\n      <field name=\"_searchButtonIcon\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"searchbutton-icon\");\n      </field>\n      <property name=\"timeout\"\n                onset=\"this.setAttribute('timeout', val); return val;\"\n                onget=\"return parseInt(this.getAttribute('timeout')) || 500;\"/>\n      <property name=\"searchButton\"\n                onget=\"return this.getAttribute('searchbutton') == 'true';\">\n        <setter><![CDATA[\n          if (val) {\n            this.setAttribute(\"searchbutton\", \"true\");\n            this.removeAttribute(\"aria-autocomplete\");\n            // Hack for the button to get the right accessible:\n            this._searchButtonIcon.setAttribute(\"onclick\", \"true\");\n          } else {\n            this.removeAttribute(\"searchbutton\");\n            this._searchButtonIcon.removeAttribute(\"onclick\");\n            this.setAttribute(\"aria-autocomplete\", \"list\");\n          }\n          return val;\n        ]]></setter>\n      </property>\n      <property name=\"value\"\n                onget=\"return this.inputField.value;\">\n        <setter><![CDATA[\n          this.inputField.value = val;\n\n          if (val)\n            this._searchIcons.selectedIndex = this.searchButton ? 0 : 1;\n          else\n            this._searchIcons.selectedIndex = 0;\n\n          if (this._timer)\n            clearTimeout(this._timer);\n\n          return val;\n        ]]></setter>\n      </property>\n      <constructor><![CDATA[\n        // Ensure the button state is up to date:\n        this.searchButton = this.searchButton;\n        this._searchButtonIcon.addEventListener(\"click\", (e) => this._iconClick(e));\n      ]]></constructor>\n      <method name=\"_fireCommand\">\n        <parameter name=\"me\"/>\n        <body><![CDATA[\n          if (me._timer)\n            clearTimeout(me._timer);\n          me._timer = null;\n          me.doCommand();\n        ]]></body>\n      </method>\n      <method name=\"_iconClick\">\n        <body><![CDATA[\n          if (this.searchButton)\n            this._enterSearch();\n          else\n            this.focus();\n        ]]></body>\n      </method>\n      <method name=\"_enterSearch\">\n        <body><![CDATA[\n          if (this.disabled)\n            return;\n          if (this.searchButton && this.value && !this.readOnly)\n            this._searchIcons.selectedIndex = 1;\n          this._fireCommand(this);\n        ]]></body>\n      </method>\n      <method name=\"_clearSearch\">\n        <body><![CDATA[\n          if (!this.disabled && !this.readOnly && this.value) {\n            this.value = \"\";\n            this._fireCommand(this);\n            this._searchIcons.selectedIndex = 0;\n            return true;\n          }\n          return false;\n        ]]></body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"input\">\n        <![CDATA[\n          if (this.searchButton) {\n            this._searchIcons.selectedIndex = 0;\n            return;\n          }\n          if (this._timer)\n            clearTimeout(this._timer);\n          this._timer = this.timeout && setTimeout(this._fireCommand, this.timeout, this);\n          this._searchIcons.selectedIndex = this.value ? 1 : 0;\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_ESCAPE\">\n        <![CDATA[\n          if (this._clearSearch()) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\">\n        <![CDATA[\n          this._enterSearch();\n          event.preventDefault();\n          event.stopPropagation();\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"textarea\" extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content>\n      <xul:hbox class=\"textbox-input-box\" flex=\"1\" xbl:inherits=\"context,spellcheck\">\n        <html:textarea class=\"textbox-textarea\" anonid=\"input\"\n                       xbl:inherits=\"xbl:text=value,disabled,tabindex,rows,cols,readonly,wrap,placeholder,mozactionhint,spellcheck\"><children/></html:textarea>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"input-box\">\n    <content context=\"_child\">\n      <children/>\n      <xul:menupopup anonid=\"input-box-contextmenu\"\n                     class=\"textbox-contextmenu\"\n                     onpopupshowing=\"var input =\n                                       this.parentNode.getElementsByAttribute('anonid', 'input')[0];\n                                     if (document.commandDispatcher.focusedElement != input)\n                                       input.focus();\n                                     this.parentNode._doPopupItemEnabling(this);\"\n                     oncommand=\"var cmd = event.originalTarget.getAttribute('cmd'); if(cmd) { this.parentNode.doCommand(cmd); event.stopPropagation(); }\">\n        <xul:menuitem label=\"FROM-DTD-undoCmd-label\" accesskey=\"FROM-DTD-undoCmd-accesskey\" cmd=\"cmd_undo\"/>\n        <xul:menuseparator/>\n        <xul:menuitem label=\"FROM-DTD-cutCmd-label\" accesskey=\"FROM-DTD-cutCmd-accesskey\" cmd=\"cmd_cut\"/>\n        <xul:menuitem label=\"FROM-DTD-copyCmd-label\" accesskey=\"FROM-DTD-copyCmd-accesskey\" cmd=\"cmd_copy\"/>\n        <xul:menuitem label=\"FROM-DTD-pasteCmd-label\" accesskey=\"FROM-DTD-pasteCmd-accesskey\" cmd=\"cmd_paste\"/>\n        <xul:menuitem label=\"FROM-DTD-deleteCmd-label\" accesskey=\"FROM-DTD-deleteCmd-accesskey\" cmd=\"cmd_delete\"/>\n        <xul:menuseparator/>\n        <xul:menuitem label=\"FROM-DTD-selectAllCmd-label\" accesskey=\"FROM-DTD-selectAllCmd-accesskey\" cmd=\"cmd_selectAll\"/>\n      </xul:menupopup>\n    </content>\n\n    <implementation>\n      <method name=\"_doPopupItemEnabling\">\n        <parameter name=\"popupNode\"/>\n        <body>\n          <![CDATA[\n            var children = popupNode.childNodes;\n            for (var i = 0; i < children.length; i++) {\n              var command = children[i].getAttribute(\"cmd\");\n              if (command) {\n                var controller = document.commandDispatcher.getControllerForCommand(command);\n                var enabled = controller.isCommandEnabled(command);\n                if (enabled)\n                  children[i].removeAttribute(\"disabled\");\n                else\n                  children[i].setAttribute(\"disabled\", \"true\");\n              }\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_setMenuItemVisibility\">\n        <parameter name=\"anonid\"/>\n        <parameter name=\"visible\"/>\n        <body><![CDATA[\n          document.getAnonymousElementByAttribute(this, \"anonid\", anonid).\n            hidden = !visible;\n        ]]></body>\n      </method>\n\n      <method name=\"doCommand\">\n        <parameter name=\"command\"/>\n        <body>\n          <![CDATA[\n            var controller = document.commandDispatcher.getControllerForCommand(command);\n            controller.doCommand(command);\n          ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"input-box-spell\" extends=\"chrome://global/content/bindings/textbox.xml#input-box\">\n    <content context=\"_child\">\n      <children/>\n      <xul:menupopup anonid=\"input-box-contextmenu\"\n                     class=\"textbox-contextmenu\"\n                     onpopupshowing=\"var input =\n                                       this.parentNode.getElementsByAttribute('anonid', 'input')[0];\n                                     if (document.commandDispatcher.focusedElement != input)\n                                       input.focus();\n                                     this.parentNode._doPopupItemEnablingSpell(this);\"\n                     onpopuphiding=\"this.parentNode._doPopupItemDisabling(this);\"\n                     oncommand=\"var cmd = event.originalTarget.getAttribute('cmd'); if(cmd) { this.parentNode.doCommand(cmd); event.stopPropagation(); }\">\n        <xul:menuitem label=\"FROM-DTD-spellNoSuggestions-label\" anonid=\"spell-no-suggestions\" disabled=\"true\"/>\n        <xul:menuitem label=\"FROM-DTD-spellAddToDictionary-label\" accesskey=\"FROM-DTD-spellAddToDictionary-accesskey\" anonid=\"spell-add-to-dictionary\"\n                      oncommand=\"this.parentNode.parentNode.spellCheckerUI.addToDictionary();\"/>\n        <xul:menuitem label=\"FROM-DTD-spellUndoAddToDictionary-label\" accesskey=\"FROM-DTD-spellUndoAddToDictionary-accesskey\" anonid=\"spell-undo-add-to-dictionary\"\n                      oncommand=\"this.parentNode.parentNode.spellCheckerUI.undoAddToDictionary();\"/>\n        <xul:menuseparator anonid=\"spell-suggestions-separator\"/>\n        <xul:menuitem label=\"FROM-DTD-undoCmd-label\" accesskey=\"FROM-DTD-undoCmd-accesskey\" cmd=\"cmd_undo\"/>\n        <xul:menuseparator/>\n        <xul:menuitem label=\"FROM-DTD-cutCmd-label\" accesskey=\"FROM-DTD-cutCmd-accesskey\" cmd=\"cmd_cut\"/>\n        <xul:menuitem label=\"FROM-DTD-copyCmd-label\" accesskey=\"FROM-DTD-copyCmd-accesskey\" cmd=\"cmd_copy\"/>\n        <xul:menuitem label=\"FROM-DTD-pasteCmd-label\" accesskey=\"FROM-DTD-pasteCmd-accesskey\" cmd=\"cmd_paste\"/>\n        <xul:menuitem label=\"FROM-DTD-deleteCmd-label\" accesskey=\"FROM-DTD-deleteCmd-accesskey\" cmd=\"cmd_delete\"/>\n        <xul:menuseparator/>\n        <xul:menuitem label=\"FROM-DTD-selectAllCmd-label\" accesskey=\"FROM-DTD-selectAllCmd-accesskey\" cmd=\"cmd_selectAll\"/>\n        <xul:menuseparator anonid=\"spell-check-separator\"/>\n        <xul:menuitem label=\"FROM-DTD-spellCheckToggle-label\" type=\"checkbox\" accesskey=\"FROM-DTD-spellCheckToggle-accesskey\" anonid=\"spell-check-enabled\"\n                      oncommand=\"this.parentNode.parentNode.spellCheckerUI.toggleEnabled();\"/>\n        <xul:menu label=\"FROM-DTD-spellDictionaries-label\" accesskey=\"FROM-DTD-spellDictionaries-accesskey\" anonid=\"spell-dictionaries\">\n          <xul:menupopup anonid=\"spell-dictionaries-menu\"\n                         onpopupshowing=\"event.stopPropagation();\"\n                         onpopuphiding=\"event.stopPropagation();\"/>\n        </xul:menu>\n      </xul:menupopup>\n    </content>\n\n    <implementation>\n      <field name=\"_spellCheckInitialized\">false</field>\n      <field name=\"_enabledCheckbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"spell-check-enabled\");\n      </field>\n      <field name=\"_suggestionsSeparator\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"spell-no-suggestions\");\n      </field>\n      <field name=\"_dictionariesMenu\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"spell-dictionaries-menu\");\n      </field>\n\n      <property name=\"spellCheckerUI\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._spellCheckInitialized) {\n            this._spellCheckInitialized = true;\n\n            const CI = Components.interfaces;\n            if (!(document instanceof CI.nsIDOMXULDocument))\n              return null;\n\n            var textbox = document.getBindingParent(this);\n            if (!textbox || !(textbox instanceof CI.nsIDOMXULTextBoxElement))\n              return null;\n\n            try {\n              Components.utils.import(\"resource://gre/modules/InlineSpellChecker.jsm\", this);\n              this.InlineSpellCheckerUI = new this.InlineSpellChecker(textbox.editor);\n            } catch (ex) { }\n          }\n\n          return this.InlineSpellCheckerUI;\n        ]]></getter>\n      </property>\n\n      <method name=\"_doPopupItemEnablingSpell\">\n        <parameter name=\"popupNode\"/>\n        <body>\n          <![CDATA[\n            var spellui = this.spellCheckerUI;\n            if (!spellui || !spellui.canSpellCheck) {\n              this._setMenuItemVisibility(\"spell-no-suggestions\", false);\n              this._setMenuItemVisibility(\"spell-check-enabled\", false);\n              this._setMenuItemVisibility(\"spell-check-separator\", false);\n              this._setMenuItemVisibility(\"spell-add-to-dictionary\", false);\n              this._setMenuItemVisibility(\"spell-undo-add-to-dictionary\", false);\n              this._setMenuItemVisibility(\"spell-suggestions-separator\", false);\n              this._setMenuItemVisibility(\"spell-dictionaries\", false);\n              return;\n            }\n\n            spellui.initFromEvent(document.popupRangeParent,\n                                  document.popupRangeOffset);\n\n            var enabled = spellui.enabled;\n            var showUndo = spellui.canSpellCheck && spellui.canUndo();\n            this._enabledCheckbox.setAttribute(\"checked\", enabled);\n\n            var overMisspelling = spellui.overMisspelling;\n            this._setMenuItemVisibility(\"spell-add-to-dictionary\", overMisspelling);\n            this._setMenuItemVisibility(\"spell-undo-add-to-dictionary\", showUndo);\n            this._setMenuItemVisibility(\"spell-suggestions-separator\", overMisspelling || showUndo);\n\n            // suggestion list\n            var numsug = spellui.addSuggestionsToMenu(popupNode, this._suggestionsSeparator, 5);\n            this._setMenuItemVisibility(\"spell-no-suggestions\", overMisspelling && numsug == 0);\n\n            // dictionary list\n            var numdicts = spellui.addDictionaryListToMenu(this._dictionariesMenu, null);\n            this._setMenuItemVisibility(\"spell-dictionaries\", enabled && numdicts > 1);\n\n            this._doPopupItemEnabling(popupNode);\n          ]]>\n        </body>\n      </method>\n      <method name=\"_doPopupItemDisabling\">\n        <body><![CDATA[\n          if (this.spellCheckerUI) {\n            this.spellCheckerUI.clearSuggestionsFromMenu();\n            this.spellCheckerUI.clearDictionaryListFromMenu();\n          }\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"toolbar.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"toolbarBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"toolbar-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/toolbar.css\"/>\n    </resources>\n  </binding>\n\n  <binding id=\"toolbox\" extends=\"chrome://global/content/bindings/toolbar.xml#toolbar-base\">\n    <implementation>\n      <field name=\"palette\">\n        null\n      </field>\n\n      <field name=\"toolbarset\">\n        null\n      </field>\n\n      <field name=\"customToolbarCount\">\n        0\n      </field>\n\n      <field name=\"externalToolbars\">\n       []\n      </field>\n\n      <!-- Set by customizeToolbar.js -->\n      <property name=\"customizing\">\n        <getter><![CDATA[\n          return this.getAttribute(\"customizing\") == \"true\";\n        ]]></getter>\n        <setter><![CDATA[\n          if (val)\n            this.setAttribute(\"customizing\", \"true\");\n          else\n            this.removeAttribute(\"customizing\");\n          return val;\n        ]]></setter>\n      </property>\n\n      <constructor>\n        <![CDATA[\n          // Look to see if there is a toolbarset.\n          this.toolbarset = this.firstChild;\n          while (this.toolbarset && this.toolbarset.localName != \"toolbarset\")\n            this.toolbarset = this.toolbarset.nextSibling;\n\n          if (this.toolbarset) {\n            // Create each toolbar described by the toolbarset.\n            var index = 0;\n            while (this.toolbarset.hasAttribute(\"toolbar\" + (++index))) {\n              var toolbarInfo = this.toolbarset.getAttribute(\"toolbar\" + index);\n              var infoSplit = toolbarInfo.split(\":\");\n              this.appendCustomToolbar(infoSplit[0], infoSplit[1]);\n            }\n          }\n        ]]>\n      </constructor>\n\n      <method name=\"appendCustomToolbar\">\n        <parameter name=\"aName\"/>\n        <parameter name=\"aCurrentSet\"/>\n        <body>\n          <![CDATA[\n            if (!this.toolbarset)\n              return null;\n            var toolbar = document.createElementNS(\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\",\n                                                  \"toolbar\");\n            toolbar.id = \"__customToolbar_\" + aName.replace(\" \", \"_\");\n            toolbar.setAttribute(\"customizable\", \"true\");\n            toolbar.setAttribute(\"customindex\", ++this.customToolbarCount);\n            toolbar.setAttribute(\"toolbarname\", aName);\n            toolbar.setAttribute(\"currentset\", aCurrentSet);\n            toolbar.setAttribute(\"mode\", this.getAttribute(\"mode\"));\n            toolbar.setAttribute(\"iconsize\", this.getAttribute(\"iconsize\"));\n            toolbar.setAttribute(\"context\", this.toolbarset.getAttribute(\"context\"));\n            toolbar.setAttribute(\"class\", \"chromeclass-toolbar\");\n\n            this.insertBefore(toolbar, this.toolbarset);\n            return toolbar;\n          ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"toolbar\" role=\"xul:toolbar\"\n           extends=\"chrome://global/content/bindings/toolbar.xml#toolbar-base\">\n    <implementation>\n      <property name=\"toolbarName\"\n                onget=\"return this.getAttribute('toolbarname');\"\n                onset=\"this.setAttribute('toolbarname', val); return val;\"/>\n\n      <field name=\"_toolbox\">null</field>\n      <property name=\"toolbox\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._toolbox)\n            return this._toolbox;\n\n          let toolboxId = this.getAttribute(\"toolboxid\");\n          if (toolboxId) {\n            let toolbox = document.getElementById(toolboxId);\n            if (!toolbox) {\n              let tbName = this.toolbarName;\n              if (tbName)\n                tbName = \" (\" + tbName + \")\";\n              else\n                tbName = \"\";\n              throw new Error(`toolbar ID ${this.id}${tbName}: toolboxid attribute '${toolboxId}' points to a toolbox that doesn't exist`);\n            }\n\n            if (toolbox.externalToolbars.indexOf(this) == -1)\n              toolbox.externalToolbars.push(this);\n\n            return this._toolbox = toolbox;\n          }\n\n          return this._toolbox = (this.parentNode &&\n                                  this.parentNode.localName == \"toolbox\") ?\n                                 this.parentNode : null;\n        ]]></getter>\n      </property>\n\n      <constructor>\n        <![CDATA[\n          if (document.readyState == \"complete\") {\n            this._init();\n          } else {\n            // Need to wait until XUL overlays are loaded. See bug 554279.\n            let self = this;\n            document.addEventListener(\"readystatechange\", function listener(event) {\n              if (document.readyState != \"complete\")\n                return;\n              document.removeEventListener(\"readystatechange\", listener);\n              self._init();\n            });\n          }\n        ]]>\n      </constructor>\n\n      <method name=\"_init\">\n        <body>\n        <![CDATA[\n          // Searching for the toolbox palette in the toolbar binding because\n          // toolbars are constructed first.\n          var toolbox = this.toolbox;\n          if (!toolbox)\n            return;\n\n          if (!toolbox.palette) {\n            // Look to see if there is a toolbarpalette.\n            var node = toolbox.firstChild;\n            while (node) {\n              if (node.localName == \"toolbarpalette\")\n                break;\n              node = node.nextSibling;\n            }\n\n            if (!node)\n              return;\n\n            // Hold on to the palette but remove it from the document.\n            toolbox.palette = node;\n            toolbox.removeChild(node);\n          }\n\n          // Build up our contents from the palette.\n          var currentSet = this.getAttribute(\"currentset\");\n          if (!currentSet)\n            currentSet = this.getAttribute(\"defaultset\");\n          if (currentSet)\n            this.currentSet = currentSet;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_idFromNode\">\n        <parameter name=\"aNode\"/>\n        <body>\n        <![CDATA[\n          if (aNode.getAttribute(\"skipintoolbarset\") == \"true\")\n            return \"\";\n\n          switch (aNode.localName) {\n            case \"toolbarseparator\":\n              return \"separator\";\n            case \"toolbarspring\":\n              return \"spring\";\n            case \"toolbarspacer\":\n              return \"spacer\";\n            default:\n              return aNode.id;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"currentSet\">\n        <getter>\n          <![CDATA[\n            var node = this.firstChild;\n            var currentSet = [];\n            while (node) {\n              var id = this._idFromNode(node);\n              if (id) {\n                currentSet.push(id);\n              }\n              node = node.nextSibling;\n            }\n\n            return currentSet.join(\",\") || \"__empty\";\n          ]]>\n        </getter>\n\n        <setter>\n          <![CDATA[\n            if (val == this.currentSet)\n              return val;\n\n            var ids = (val == \"__empty\") ? [] : val.split(\",\");\n\n            var nodeidx = 0;\n            var paletteItems = { }, added = { };\n\n            var palette = this.toolbox ? this.toolbox.palette : null;\n\n            // build a cache of items in the toolbarpalette\n            var paletteChildren = palette ? palette.childNodes : [];\n            for (let c = 0; c < paletteChildren.length; c++) {\n              let curNode = paletteChildren[c];\n              paletteItems[curNode.id] = curNode;\n            }\n\n            var children = this.childNodes;\n\n            // iterate over the ids to use on the toolbar\n            for (let i = 0; i < ids.length; i++) {\n              let id = ids[i];\n              // iterate over the existing nodes on the toolbar. nodeidx is the\n              // spot where we want to insert items.\n              let found = false;\n              for (let c = nodeidx; c < children.length; c++) {\n                let curNode = children[c];\n                if (this._idFromNode(curNode) == id) {\n                  // the node already exists. If c equals nodeidx, we haven't\n                  // iterated yet, so the item is already in the right position.\n                  // Otherwise, insert it here.\n                  if (c != nodeidx) {\n                    this.insertBefore(curNode, children[nodeidx]);\n                  }\n\n                  added[curNode.id] = true;\n                  nodeidx++;\n                  found = true;\n                  break;\n                }\n              }\n              if (found) {\n                // move on to the next id\n                continue;\n              }\n\n              // the node isn't already on the toolbar, so add a new one.\n              var nodeToAdd = paletteItems[id] || this._getToolbarItem(id);\n              if (nodeToAdd && !(nodeToAdd.id in added)) {\n                added[nodeToAdd.id] = true;\n                this.insertBefore(nodeToAdd, children[nodeidx] || null);\n                nodeToAdd.setAttribute(\"removable\", \"true\");\n                nodeidx++;\n              }\n            }\n\n            // remove any leftover removable nodes\n            for (let i = children.length - 1; i >= nodeidx; i--) {\n              let curNode = children[i];\n\n              let curNodeId = this._idFromNode(curNode);\n              // skip over fixed items\n              if (curNodeId && curNode.getAttribute(\"removable\") == \"true\") {\n                if (palette)\n                  palette.appendChild(curNode);\n                else\n                  this.removeChild(curNode);\n              }\n            }\n\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <field name=\"_newElementCount\">0</field>\n      <method name=\"_getToolbarItem\">\n        <parameter name=\"aId\"/>\n        <body>\n          <![CDATA[\n            const XUL_NS = \"http://www.mozilla.org/keymaster/\" +\n                           \"gatekeeper/there.is.only.xul\";\n\n            var newItem = null;\n            switch (aId) {\n              // Handle special cases\n              case \"separator\":\n              case \"spring\":\n              case \"spacer\":\n                newItem = document.createElementNS(XUL_NS, \"toolbar\" + aId);\n                // Due to timers resolution Date.now() can be the same for\n                // elements created in small timeframes.  So ids are\n                // differentiated through a unique count suffix.\n                newItem.id = aId + Date.now() + (++this._newElementCount);\n                if (aId == \"spring\")\n                  newItem.flex = 1;\n                break;\n              default:\n                var toolbox = this.toolbox;\n                if (!toolbox)\n                  break;\n\n                // look for an item with the same id, as the item may be\n                // in a different toolbar.\n                var item = document.getElementById(aId);\n                if (item && item.parentNode &&\n                    item.parentNode.localName == \"toolbar\" &&\n                    item.parentNode.toolbox == toolbox) {\n                  newItem = item;\n                  break;\n                }\n\n                if (toolbox.palette) {\n                  // Attempt to locate an item with a matching ID within\n                  // the palette.\n                  let paletteItem = this.toolbox.palette.firstChild;\n                  while (paletteItem) {\n                    if (paletteItem.id == aId) {\n                      newItem = paletteItem;\n                      break;\n                    }\n                    paletteItem = paletteItem.nextSibling;\n                  }\n                }\n                break;\n            }\n\n            return newItem;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"insertItem\">\n        <parameter name=\"aId\"/>\n        <parameter name=\"aBeforeElt\"/>\n        <parameter name=\"aWrapper\"/>\n        <body>\n          <![CDATA[\n            var newItem = this._getToolbarItem(aId);\n            if (!newItem)\n              return null;\n\n            var insertItem = newItem;\n            // make sure added items are removable\n            newItem.setAttribute(\"removable\", \"true\");\n\n            // Wrap the item in another node if so inclined.\n            if (aWrapper) {\n              aWrapper.appendChild(newItem);\n              insertItem = aWrapper;\n            }\n\n            // Insert the palette item into the toolbar.\n            if (aBeforeElt)\n              this.insertBefore(insertItem, aBeforeElt);\n            else\n              this.appendChild(insertItem);\n\n            return newItem;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"hasCustomInteractiveItems\">\n        <parameter name=\"aCurrentSet\"/>\n        <body><![CDATA[\n          if (aCurrentSet == \"__empty\")\n            return false;\n\n          var defaultOrNoninteractive = (this.getAttribute(\"defaultset\") || \"\")\n                                          .split(\",\")\n                                          .concat([\"separator\", \"spacer\", \"spring\"]);\n          return aCurrentSet.split(\",\").some(function(item) {\n            return defaultOrNoninteractive.indexOf(item) == -1;\n          });\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"toolbar-menubar-autohide\"\n           extends=\"chrome://global/content/bindings/toolbar.xml#toolbar\">\n    <implementation>\n      <constructor>\n        this._setInactive();\n      </constructor>\n      <destructor>\n        this._setActive();\n      </destructor>\n\n      <field name=\"_inactiveTimeout\">null</field>\n\n      <field name=\"_contextMenuListener\"><![CDATA[({\n        toolbar: this,\n        contextMenu: null,\n\n        get active() {\n          return !!this.contextMenu;\n        },\n\n        init(event) {\n          var node = event.target;\n          while (node != this.toolbar) {\n            if (node.localName == \"menupopup\")\n              return;\n            node = node.parentNode;\n          }\n\n          var contextMenuId = this.toolbar.getAttribute(\"context\");\n          if (!contextMenuId)\n            return;\n\n          this.contextMenu = document.getElementById(contextMenuId);\n          if (!this.contextMenu)\n            return;\n\n          this.contextMenu.addEventListener(\"popupshown\", this);\n          this.contextMenu.addEventListener(\"popuphiding\", this);\n          this.toolbar.addEventListener(\"mousemove\", this);\n        },\n        handleEvent(event) {\n          switch (event.type) {\n            case \"popupshown\":\n              this.toolbar.removeEventListener(\"mousemove\", this);\n              break;\n            case \"popuphiding\":\n            case \"mousemove\":\n              this.toolbar._setInactiveAsync();\n              this.toolbar.removeEventListener(\"mousemove\", this);\n              this.contextMenu.removeEventListener(\"popuphiding\", this);\n              this.contextMenu.removeEventListener(\"popupshown\", this);\n              this.contextMenu = null;\n              break;\n          }\n        }\n      })]]></field>\n\n      <method name=\"_setInactive\">\n        <body><![CDATA[\n          this.setAttribute(\"inactive\", \"true\");\n        ]]></body>\n      </method>\n\n      <method name=\"_setInactiveAsync\">\n        <body><![CDATA[\n          this._inactiveTimeout = setTimeout(function(self) {\n            if (self.getAttribute(\"autohide\") == \"true\") {\n              self._inactiveTimeout = null;\n              self._setInactive();\n            }\n          }, 0, this);\n        ]]></body>\n      </method>\n\n      <method name=\"_setActive\">\n        <body><![CDATA[\n          if (this._inactiveTimeout) {\n            clearTimeout(this._inactiveTimeout);\n            this._inactiveTimeout = null;\n          }\n          this.removeAttribute(\"inactive\");\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"DOMMenuBarActive\"     action=\"this._setActive();\"/>\n      <handler event=\"popupshowing\"         action=\"this._setActive();\"/>\n      <handler event=\"mousedown\" button=\"2\" action=\"this._contextMenuListener.init(event);\"/>\n      <handler event=\"DOMMenuBarInactive\"><![CDATA[\n        if (!this._contextMenuListener.active)\n          this._setInactiveAsync();\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"toolbar-drag\"\n           extends=\"chrome://global/content/bindings/toolbar.xml#toolbar\">\n    <implementation>\n      <field name=\"_dragBindingAlive\">true</field>\n      <constructor><![CDATA[\n        if (!this._draggableStarted) {\n          this._draggableStarted = true;\n          try {\n            let tmp = {};\n            Components.utils.import(\"resource://gre/modules/WindowDraggingUtils.jsm\", tmp);\n            let draggableThis = new tmp.WindowDraggingElement(this);\n            draggableThis.mouseDownCheck = function(e) {\n              // Don't move while customizing.\n              return this._dragBindingAlive &&\n                     this.getAttribute(\"customizing\") != \"true\";\n            };\n          } catch (e) {}\n        }\n      ]]></constructor>\n    </implementation>\n  </binding>\n\n  <binding id=\"menubar\" role=\"xul:menubar\"\n           extends=\"chrome://global/content/bindings/toolbar.xml#toolbar-base\" display=\"xul:menubar\">\n    <implementation>\n       <field name=\"_active\">false</field>\n       <field name=\"_statusbar\">null</field>\n       <field name=\"_originalStatusText\">null</field>\n       <property name=\"statusbar\" onget=\"return this.getAttribute('statusbar');\"\n                                  onset=\"this.setAttribute('statusbar', val); return val;\"/>\n       <method name=\"_updateStatusText\">\n          <parameter name=\"itemText\"/>\n          <body>\n           <![CDATA[\n            if (!this._active)\n                return;\n            var newText = itemText ? itemText : this._originalStatusText;\n            if (newText != this._statusbar.label)\n                this._statusbar.label = newText;\n           ]]>\n          </body>\n        </method>\n    </implementation>\n    <handlers>\n        <handler event=\"DOMMenuBarActive\">\n          <![CDATA[\n            if (!this.statusbar) return;\n            this._statusbar = document.getElementById(this.statusbar);\n            if (!this._statusbar)\n              return;\n            this._active = true;\n            this._originalStatusText = this._statusbar.label;\n          ]]>\n        </handler>\n        <handler event=\"DOMMenuBarInactive\">\n          <![CDATA[\n            if (!this._active)\n              return;\n            this._active = false;\n            this._statusbar.label = this._originalStatusText;\n          ]]>\n        </handler>\n        <handler event=\"DOMMenuItemActive\">this._updateStatusText(event.target.statusText);</handler>\n        <handler event=\"DOMMenuItemInactive\">this._updateStatusText(\"\");</handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"toolbardecoration\" role=\"xul:toolbarseparator\" extends=\"chrome://global/content/bindings/toolbar.xml#toolbar-base\">\n  </binding>\n\n  <binding id=\"toolbarpaletteitem\" extends=\"chrome://global/content/bindings/toolbar.xml#toolbar-base\" display=\"xul:button\">\n    <content>\n      <xul:hbox class=\"toolbarpaletteitem-box\" flex=\"1\" xbl:inherits=\"type,place\">\n        <children/>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"toolbarpaletteitem-palette\" extends=\"chrome://global/content/bindings/toolbar.xml#toolbarpaletteitem\">\n    <content>\n      <xul:hbox class=\"toolbarpaletteitem-box\" xbl:inherits=\"type,place\">\n        <children/>\n      </xul:hbox>\n      <xul:label xbl:inherits=\"value=title\"/>\n    </content>\n  </binding>\n\n  <binding id=\"toolbarpaletteitem-palette-wrapping-label\" extends=\"chrome://global/content/bindings/toolbar.xml#toolbarpaletteitem\">\n    <content>\n      <xul:hbox class=\"toolbarpaletteitem-box\" xbl:inherits=\"type,place\">\n        <children/>\n      </xul:hbox>\n      <xul:label xbl:inherits=\"xbl:text=title\"/>\n    </content>\n  </binding>\n\n</bindings>\n"},{"file":"toolbarbutton.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"toolbarbuttonBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"toolbarbutton\" display=\"xul:button\" role=\"xul:toolbarbutton\"\n           extends=\"chrome://global/content/bindings/button.xml#button-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/toolbarbutton.css\"/>\n    </resources>\n\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:image class=\"toolbarbutton-icon\" xbl:inherits=\"validate,src=image,label,consumeanchor\"/>\n      <xul:label class=\"toolbarbutton-text\" crop=\"right\" flex=\"1\"\n                 xbl:inherits=\"value=label,accesskey,crop,wrap\"/>\n      <xul:label class=\"toolbarbutton-multiline-text\" flex=\"1\"\n                 xbl:inherits=\"xbl:text=label,accesskey,wrap\"/>\n      <children includes=\"box\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menu\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton\">\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:image class=\"toolbarbutton-icon\" xbl:inherits=\"validate,src=image,label,type,consumeanchor\"/>\n      <xul:label class=\"toolbarbutton-text\" crop=\"right\" flex=\"1\"\n                 xbl:inherits=\"value=label,accesskey,crop,dragover-top,wrap\"/>\n      <xul:label class=\"toolbarbutton-multiline-text\" flex=\"1\"\n                 xbl:inherits=\"xbl:text=label,accesskey,wrap\"/>\n      <xul:dropmarker anonid=\"dropmarker\" type=\"menu\"\n                      class=\"toolbarbutton-menu-dropmarker\" xbl:inherits=\"disabled,label\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menu-vertical\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton\">\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:hbox flex=\"1\" align=\"center\">\n        <xul:vbox flex=\"1\" align=\"center\">\n          <xul:image class=\"toolbarbutton-icon\" xbl:inherits=\"validate,src=image,label,consumeanchor\"/>\n          <xul:label class=\"toolbarbutton-text\" crop=\"right\" flex=\"1\"\n                     xbl:inherits=\"value=label,accesskey,crop,dragover-top,wrap\"/>\n          <xul:label class=\"toolbarbutton-multiline-text\" flex=\"1\"\n                     xbl:inherits=\"xbl:text=label,accesskey,wrap\"/>\n        </xul:vbox>\n        <xul:dropmarker anonid=\"dropmarker\" type=\"menu\"\n                        class=\"toolbarbutton-menu-dropmarker\" xbl:inherits=\"disabled,label\"/>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"menu-button\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/button.xml#menu-button-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/toolbarbutton.css\"/>\n    </resources>\n\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:toolbarbutton class=\"box-inherit toolbarbutton-menubutton-button\"\n                         anonid=\"button\" flex=\"1\" allowevents=\"true\"\n                         xbl:inherits=\"disabled,crop,image,label,accesskey,command,wrap,badge,\n                                       align,dir,pack,orient,tooltiptext=buttontooltiptext\"/>\n      <xul:dropmarker type=\"menu-button\" class=\"toolbarbutton-menubutton-dropmarker\"\n                      anonid=\"dropmarker\" xbl:inherits=\"align,dir,pack,orient,disabled,label,open,consumeanchor\"/>\n    </content>\n  </binding>\n\n  <binding id=\"toolbarbutton-image\"\n           extends=\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton\">\n    <content>\n      <xul:image class=\"toolbarbutton-icon\" xbl:inherits=\"src=image\"/>\n    </content>\n  </binding>\n\n  <binding id=\"toolbarbutton-badged\"\n           extends=\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton\">\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:stack class=\"toolbarbutton-badge-stack\">\n        <xul:image class=\"toolbarbutton-icon\" xbl:inherits=\"validate,src=image,label,consumeanchor\"/>\n        <xul:label class=\"toolbarbutton-badge\" xbl:inherits=\"value=badge,style=badgeStyle\" top=\"0\" end=\"0\" crop=\"none\"/>\n      </xul:stack>\n      <xul:label class=\"toolbarbutton-text\" crop=\"right\" flex=\"1\"\n                 xbl:inherits=\"value=label,accesskey,crop,wrap\"/>\n      <xul:label class=\"toolbarbutton-multiline-text\" flex=\"1\"\n                 xbl:inherits=\"xbl:text=label,accesskey,wrap\"/>\n    </content>\n  </binding>\n\n  <binding id=\"toolbarbutton-badged-menu\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton\">\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:stack class=\"toolbarbutton-badge-stack\">\n        <xul:image class=\"toolbarbutton-icon\" xbl:inherits=\"validate,src=image,label,consumeanchor\"/>\n        <xul:label class=\"toolbarbutton-badge\" xbl:inherits=\"value=badge\" top=\"0\" end=\"0\" crop=\"none\"/>\n      </xul:stack>\n      <xul:label class=\"toolbarbutton-text\" crop=\"right\" flex=\"1\"\n                 xbl:inherits=\"value=label,accesskey,crop,dragover-top,wrap\"/>\n      <xul:label class=\"toolbarbutton-multiline-text\" flex=\"1\"\n                 xbl:inherits=\"xbl:text=label,accesskey,wrap\"/>\n      <xul:dropmarker anonid=\"dropmarker\" type=\"menu\"\n                      class=\"toolbarbutton-menu-dropmarker\" xbl:inherits=\"disabled,label\"/>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"tree.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE bindings [\n<!ENTITY % treeDTD SYSTEM \"chrome://global/locale/tree.dtd\">\n%treeDTD;\n]>\n\n<bindings id=\"treeBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"tree-base\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/tree.css\"/>\n    </resources>\n    <implementation>\n      <method name=\"_isAccelPressed\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          return aEvent.getModifierState(\"Accel\");\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"tree\" extends=\"chrome://global/content/bindings/tree.xml#tree-base\" role=\"xul:tree\">\n    <content hidevscroll=\"true\" hidehscroll=\"true\" clickthrough=\"never\">\n      <children includes=\"treecols\"/>\n      <xul:stack class=\"tree-stack\" flex=\"1\">\n        <xul:treerows class=\"tree-rows\" flex=\"1\" xbl:inherits=\"hidevscroll\">\n          <children/>\n        </xul:treerows>\n        <xul:textbox anonid=\"input\" class=\"tree-input\" left=\"0\" top=\"0\" hidden=\"true\"/>\n      </xul:stack>\n      <xul:hbox xbl:inherits=\"collapsed=hidehscroll\">\n        <xul:scrollbar orient=\"horizontal\" flex=\"1\" increment=\"16\" style=\"position:relative; z-index:2147483647;\"/>\n        <xul:scrollcorner xbl:inherits=\"collapsed=hidevscroll\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULTreeElement, nsIDOMXULMultiSelectControlElement\">\n\n      <!-- ///////////////// nsIDOMXULTreeElement ///////////////// -->\n\n      <property name=\"columns\"\n                onget=\"return this.treeBoxObject.columns;\"/>\n\n      <property name=\"view\"\n                onget=\"return this.treeBoxObject.view ?\n                       this.treeBoxObject.view.QueryInterface(Components.interfaces.nsITreeView) :\n                       null;\"\n                onset=\"return this.treeBoxObject.view = val;\"/>\n\n      <property name=\"body\"\n                onget=\"return this.treeBoxObject.treeBody;\"/>\n\n      <property name=\"editable\"\n                onget=\"return this.getAttribute('editable') == 'true';\"\n                onset=\"if (val) this.setAttribute('editable', 'true');\n                       else this.removeAttribute('editable'); return val;\"/>\n\n      <!-- ///////////////// nsIDOMXULSelectControlElement ///////////////// -->\n\n      <!-- ///////////////// nsIDOMXULMultiSelectControlElement ///////////////// -->\n\n      <property name=\"selType\"\n                onget=\"return this.getAttribute('seltype')\"\n                onset=\"this.setAttribute('seltype', val); return val;\"/>\n\n      <property name=\"currentIndex\"\n                onget=\"return this.view ? this.view.selection.currentIndex: - 1;\"\n                onset=\"if (this.view) return this.view.selection.currentIndex = val; return val;\"/>\n\n      <property name=\"treeBoxObject\"\n                onget=\"return this.boxObject;\"\n                readonly=\"true\"/>\n\n      <property name=\"contentView\"\n                onget=\"return this.view; /*.QueryInterface(Components.interfaces.nsITreeContentView)*/\"\n                readonly=\"true\"/>\n\n      <property name=\"builderView\"\n                onget=\"return this.view; /*.QueryInterface(Components.interfaces.nsIXULTreeBuilder)*/\"\n                readonly=\"true\"/>\n      <field name=\"pageUpOrDownMovesSelection\">\n        !/Mac/.test(navigator.platform)\n      </field>\n      <property name=\"keepCurrentInView\"\n                onget=\"return (this.getAttribute('keepcurrentinview') == 'true');\"\n                onset=\"if (val) this.setAttribute('keepcurrentinview', 'true');\n                       else this.removeAttribute('keepcurrentinview'); return val;\"/>\n\n      <property name=\"enableColumnDrag\"\n                onget=\"return this.hasAttribute('enableColumnDrag');\"\n                onset=\"if (val) this.setAttribute('enableColumnDrag', 'true');\n                       else this.removeAttribute('enableColumnDrag'); return val;\"/>\n\n      <field name=\"_inputField\">null</field>\n\n      <property name=\"inputField\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._inputField)\n            this._inputField = document.getAnonymousElementByAttribute(this, \"anonid\", \"input\");\n          return this._inputField;\n        ]]></getter>\n      </property>\n\n      <property name=\"disableKeyNavigation\"\n                onget=\"return this.hasAttribute('disableKeyNavigation');\"\n                onset=\"if (val) this.setAttribute('disableKeyNavigation', 'true');\n                       else this.removeAttribute('disableKeyNavigation'); return val;\"/>\n\n      <field name=\"_editingRow\">-1</field>\n      <field name=\"_editingColumn\">null</field>\n\n      <property name=\"editingRow\" readonly=\"true\"\n                onget=\"return this._editingRow;\"/>\n      <property name=\"editingColumn\" readonly=\"true\"\n                onget=\"return this._editingColumn;\"/>\n\n      <property name=\"_selectDelay\"\n                onset=\"this.setAttribute('_selectDelay', val);\"\n                onget=\"return this.getAttribute('_selectDelay') || 50;\"/>\n      <field name=\"_columnsDirty\">true</field>\n      <field name=\"_lastKeyTime\">0</field>\n      <field name=\"_incrementalString\">\"\"</field>\n\n      <field name=\"_touchY\">-1</field>\n\n      <method name=\"_ensureColumnOrder\">\n        <body><![CDATA[\n          if (!this._columnsDirty)\n            return;\n\n          if (this.columns) {\n            // update the ordinal position of each column to assure that it is\n            // an odd number and 2 positions above its next sibling\n            var cols = [];\n            var i;\n            for (var col = this.columns.getFirstColumn(); col; col = col.getNext())\n              cols.push(col.element);\n            for (i = 0; i < cols.length; ++i)\n              cols[i].setAttribute(\"ordinal\", (i * 2) + 1);\n\n            // update the ordinal positions of splitters to even numbers, so that\n            // they are in between columns\n            var splitters = this.getElementsByTagName(\"splitter\");\n            for (i = 0; i < splitters.length; ++i)\n              splitters[i].setAttribute(\"ordinal\", (i + 1) * 2);\n          }\n          this._columnsDirty = false;\n        ]]></body>\n      </method>\n\n      <method name=\"_reorderColumn\">\n        <parameter name=\"aColMove\"/>\n        <parameter name=\"aColBefore\"/>\n        <parameter name=\"aBefore\"/>\n        <body><![CDATA[\n          this._ensureColumnOrder();\n\n          var i;\n          var cols = [];\n          var col = this.columns.getColumnFor(aColBefore);\n          if (parseInt(aColBefore.ordinal) < parseInt(aColMove.ordinal)) {\n            if (aBefore)\n              cols.push(aColBefore);\n            for (col = col.getNext(); col.element != aColMove;\n                 col = col.getNext())\n              cols.push(col.element);\n\n            aColMove.ordinal = cols[0].ordinal;\n            for (i = 0; i < cols.length; ++i)\n              cols[i].ordinal = parseInt(cols[i].ordinal) + 2;\n          } else if (aColBefore.ordinal != aColMove.ordinal) {\n            if (!aBefore)\n              cols.push(aColBefore);\n            for (col = col.getPrevious(); col.element != aColMove;\n                 col = col.getPrevious())\n              cols.push(col.element);\n\n            aColMove.ordinal = cols[0].ordinal;\n            for (i = 0; i < cols.length; ++i)\n              cols[i].ordinal = parseInt(cols[i].ordinal) - 2;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_getColumnAtX\">\n        <parameter name=\"aX\"/>\n        <parameter name=\"aThresh\"/>\n        <parameter name=\"aPos\"/>\n        <body><![CDATA[\n          var isRTL = document.defaultView.getComputedStyle(this)\n                              .direction == \"rtl\";\n\n          if (aPos)\n            aPos.value = isRTL ? \"after\" : \"before\";\n\n          var columns = [];\n          var col = this.columns.getFirstColumn();\n          while (col) {\n            columns.push(col);\n            col = col.getNext();\n          }\n          if (isRTL)\n            columns.reverse();\n          var currentX = this.boxObject.x;\n          var adjustedX = aX + this.treeBoxObject.horizontalPosition;\n          for (var i = 0; i < columns.length; ++i) {\n            col = columns[i];\n            var cw = col.element.boxObject.width;\n            if (cw > 0) {\n              currentX += cw;\n              if (currentX - (cw * aThresh) > adjustedX)\n                return col.element;\n            }\n          }\n\n          if (aPos)\n            aPos.value = isRTL ? \"before\" : \"after\";\n          return columns.pop().element;\n        ]]></body>\n      </method>\n\n      <method name=\"changeOpenState\">\n        <parameter name=\"row\"/>\n        <!-- Optional parameter openState == true or false to set.\n             No openState param == toggle -->\n        <parameter name=\"openState\"/>\n        <body><![CDATA[\n          if (row < 0 || !this.view.isContainer(row)) {\n            return false;\n          }\n\n          if (this.view.isContainerOpen(row) != openState) {\n            this.view.toggleOpenState(row);\n            if (row == this.currentIndex) {\n              // Only fire event when current row is expanded or collapsed\n              // because that's all the assistive technology really cares about.\n              var event = document.createEvent(\"Events\");\n              event.initEvent(\"OpenStateChange\", true, true);\n              this.dispatchEvent(event);\n            }\n            return true;\n          }\n          return false;\n        ]]></body>\n      </method>\n\n      <property name=\"_cellSelType\">\n        <getter>\n          <![CDATA[\n            var seltype = this.selType;\n            if (seltype == \"cell\" || seltype == \"text\")\n              return seltype;\n            return null;\n          ]]>\n        </getter>\n      </property>\n\n      <method name=\"_getNextColumn\">\n        <parameter name=\"row\"/>\n        <parameter name=\"left\"/>\n        <body><![CDATA[\n          var col = this.view.selection.currentColumn;\n          if (col) {\n            col = left ? col.getPrevious() : col.getNext();\n          } else {\n            col = this.columns.getKeyColumn();\n          }\n          while (col && (col.width == 0 || !col.selectable ||\n                 !this.view.isSelectable(row, col)))\n            col = left ? col.getPrevious() : col.getNext();\n          return col;\n        ]]></body>\n      </method>\n\n      <method name=\"_keyNavigate\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          var key = String.fromCharCode(event.charCode).toLowerCase();\n          if (event.timeStamp - this._lastKeyTime > 1000)\n            this._incrementalString = key;\n          else\n            this._incrementalString += key;\n          this._lastKeyTime = event.timeStamp;\n\n          var length = this._incrementalString.length;\n          var incrementalString = this._incrementalString;\n          var charIndex = 1;\n          while (charIndex < length && incrementalString[charIndex] == incrementalString[charIndex - 1])\n            charIndex++;\n          // If all letters in incremental string are same, just try to match the first one\n          if (charIndex == length) {\n            length = 1;\n            incrementalString = incrementalString.substring(0, length);\n          }\n\n          var keyCol = this.columns.getKeyColumn();\n          var rowCount = this.view.rowCount;\n          var start = 1;\n\n          var c = this.currentIndex;\n          if (length > 1) {\n            start = 0;\n            if (c < 0)\n              c = 0;\n          }\n\n          for (var i = 0; i < rowCount; i++) {\n            var l = (i + start + c) % rowCount;\n            var cellText = this.view.getCellText(l, keyCol);\n            cellText = cellText.substring(0, length).toLowerCase();\n            if (cellText == incrementalString)\n              return l;\n          }\n          return -1;\n        ]]></body>\n      </method>\n\n      <method name=\"startEditing\">\n        <parameter name=\"row\"/>\n        <parameter name=\"column\"/>\n        <body>\n          <![CDATA[\n            if (!this.editable)\n              return false;\n            if (row < 0 || row >= this.view.rowCount || !column)\n              return false;\n            if (column.type != Components.interfaces.nsITreeColumn.TYPE_TEXT &&\n                column.type != Components.interfaces.nsITreeColumn.TYPE_PASSWORD)\n              return false;\n            if (column.cycler || !this.view.isEditable(row, column))\n              return false;\n\n            // Beyond this point, we are going to edit the cell.\n            if (this._editingColumn)\n              this.stopEditing();\n\n            var input = this.inputField;\n\n            var box = this.treeBoxObject;\n            box.ensureCellIsVisible(row, column);\n\n            // Get the coordinates of the text inside the cell.\n            var textRect = box.getCoordsForCellItem(row, column, \"text\");\n\n            // Get the coordinates of the cell itself.\n            var cellRect = box.getCoordsForCellItem(row, column, \"cell\");\n\n            // Calculate the top offset of the textbox.\n            var style = window.getComputedStyle(input);\n            var topadj = parseInt(style.borderTopWidth) + parseInt(style.paddingTop);\n            input.top = textRect.y - topadj;\n\n            // The leftside of the textbox is aligned to the left side of the text\n            // in LTR mode, and left side of the cell in RTL mode.\n            var left, widthdiff;\n            if (style.direction == \"rtl\") {\n              left = cellRect.x;\n              widthdiff = cellRect.x - textRect.x;\n            } else {\n              left = textRect.x;\n              widthdiff = textRect.x - cellRect.x;\n            }\n\n            input.left = left;\n            input.height = textRect.height + topadj +\n                           parseInt(style.borderBottomWidth) +\n                           parseInt(style.paddingBottom);\n            input.width = cellRect.width - widthdiff;\n            input.hidden = false;\n\n            input.value = this.view.getCellText(row, column);\n            var selectText = function selectText() {\n              input.select();\n              input.inputField.focus();\n            }\n            setTimeout(selectText, 0);\n\n            this._editingRow = row;\n            this._editingColumn = column;\n            this.setAttribute(\"editing\", \"true\");\n\n            box.invalidateCell(row, column);\n            return true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"stopEditing\">\n        <parameter name=\"accept\"/>\n        <body>\n          <![CDATA[\n            if (!this._editingColumn)\n              return;\n\n            var input = this.inputField;\n            var editingRow = this._editingRow;\n            var editingColumn = this._editingColumn;\n            this._editingRow = -1;\n            this._editingColumn = null;\n\n            if (accept) {\n              var value = input.value;\n              this.view.setCellText(editingRow, editingColumn, value);\n            }\n            input.hidden = true;\n            input.value = \"\";\n            this.removeAttribute(\"editing\");\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByOffset\">\n        <parameter name=\"offset\"/>\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this._isAccelPressed(event) && this.view.selection.single) {\n              this.treeBoxObject.scrollByLines(offset);\n              return;\n            }\n\n            var c = this.currentIndex + offset;\n            if (offset > 0 ? c > edge : c < edge) {\n              if (this.view.selection.isSelected(edge) && this.view.selection.count <= 1)\n                return;\n              c = edge;\n            }\n\n            var cellSelType = this._cellSelType;\n            if (cellSelType) {\n              var column = this.view.selection.currentColumn;\n              if (!column)\n                return;\n\n              while ((offset > 0 ? c <= edge : c >= edge) && !this.view.isSelectable(c, column))\n                c += offset;\n              if (offset > 0 ? c > edge : c < edge)\n                return;\n            }\n\n            if (!this._isAccelPressed(event))\n              this.view.selection.timedSelect(c, this._selectDelay);\n            else // Ctrl+Up/Down moves the anchor without selecting\n              this.currentIndex = c;\n            this.treeBoxObject.ensureRowIsVisible(c);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByOffsetShift\">\n        <parameter name=\"offset\"/>\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.view.selection.single) {\n              this.treeBoxObject.scrollByLines(offset);\n              return;\n            }\n\n            if (this.view.rowCount == 1 && !this.view.selection.isSelected(0)) {\n              this.view.selection.timedSelect(0, this._selectDelay);\n              return;\n            }\n\n            var c = this.currentIndex;\n            if (c == -1)\n                c = 0;\n\n            if (c == edge) {\n              if (this.view.selection.isSelected(c))\n                return;\n            }\n\n            // Extend the selection from the existing pivot, if any\n            this.view.selection.rangedSelect(-1, c + offset,\n                                             this._isAccelPressed(event));\n            this.treeBoxObject.ensureRowIsVisible(c + offset);\n\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByPage\">\n        <parameter name=\"offset\"/>\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.pageUpOrDownMovesSelection == this._isAccelPressed(event)) {\n               this.treeBoxObject.scrollByPages(offset);\n               return;\n            }\n\n            if (this.view.rowCount == 1 && !this.view.selection.isSelected(0)) {\n              this.view.selection.timedSelect(0, this._selectDelay);\n              return;\n            }\n\n            var c = this.currentIndex;\n            if (c == -1)\n              return;\n\n            if (c == edge && this.view.selection.isSelected(c)) {\n              this.treeBoxObject.ensureRowIsVisible(c);\n              return;\n            }\n            var i = this.treeBoxObject.getFirstVisibleRow();\n            var p = this.treeBoxObject.getPageLength();\n\n            if (offset > 0) {\n              i += p - 1;\n              if (c >= i) {\n                 i = c + p;\n                 this.treeBoxObject.ensureRowIsVisible(i > edge ? edge : i);\n              }\n              i = i > edge ? edge : i;\n\n            } else if (c <= i) {\n               i = c <= p ? 0 : c - p;\n               this.treeBoxObject.ensureRowIsVisible(i);\n            }\n            this.view.selection.timedSelect(i, this._selectDelay);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByPageShift\">\n        <parameter name=\"offset\"/>\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.view.rowCount == 1 && !this.view.selection.isSelected(0) &&\n                !(this.pageUpOrDownMovesSelection == this._isAccelPressed(event))) {\n              this.view.selection.timedSelect(0, this._selectDelay);\n              return;\n            }\n\n            if (this.view.selection.single)\n              return;\n\n            var c = this.currentIndex;\n            if (c == -1)\n              return;\n            if (c == edge && this.view.selection.isSelected(c)) {\n              this.treeBoxObject.ensureRowIsVisible(edge);\n              return;\n            }\n            var i = this.treeBoxObject.getFirstVisibleRow();\n            var p = this.treeBoxObject.getPageLength();\n\n            if (offset > 0) {\n              i += p - 1;\n              if (c >= i) {\n                 i = c + p;\n                 this.treeBoxObject.ensureRowIsVisible(i > edge ? edge : i);\n              }\n              // Extend the selection from the existing pivot, if any\n              this.view.selection.rangedSelect(-1, i > edge ? edge : i, this._isAccelPressed(event));\n\n            } else {\n\n              if (c <= i) {\n                 i = c <= p ? 0 : c - p;\n                 this.treeBoxObject.ensureRowIsVisible(i);\n              }\n              // Extend the selection from the existing pivot, if any\n              this.view.selection.rangedSelect(-1, i, this._isAccelPressed(event));\n            }\n\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveToEdge\">\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.view.selection.isSelected(edge) && this.view.selection.count == 1) {\n              this.currentIndex = edge;\n              return;\n            }\n\n            // Normal behaviour is to select the first/last row\n            if (!this._isAccelPressed(event))\n              this.view.selection.timedSelect(edge, this._selectDelay);\n\n            // In a multiselect tree Ctrl+Home/End moves the anchor\n            else if (!this.view.selection.single)\n              this.currentIndex = edge;\n\n            this.treeBoxObject.ensureRowIsVisible(edge);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveToEdgeShift\">\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.view.rowCount == 1 && !this.view.selection.isSelected(0)) {\n              this.view.selection.timedSelect(0, this._selectDelay);\n              return;\n            }\n\n            if (this.view.selection.single ||\n                (this.view.selection.isSelected(edge)) && this.view.selection.isSelected(this.currentIndex))\n              return;\n\n            // Extend the selection from the existing pivot, if any.\n            // -1 doesn't work here, so using currentIndex instead\n            this.view.selection.rangedSelect(this.currentIndex, edge, this._isAccelPressed(event));\n\n            this.treeBoxObject.ensureRowIsVisible(edge);\n          ]]>\n        </body>\n      </method>\n      <method name=\"_handleEnter\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (this._editingColumn) {\n            this.stopEditing(true);\n            this.focus();\n            return true;\n          }\n\n          if (/Mac/.test(navigator.platform)) {\n            // See if we can edit the cell.\n            var row = this.currentIndex;\n            if (this._cellSelType) {\n              var column = this.view.selection.currentColumn;\n              var startedEditing = this.startEditing(row, column);\n              if (startedEditing)\n                return true;\n            }\n          }\n          return this.changeOpenState(this.currentIndex);\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"touchstart\">\n        <![CDATA[\n          function isScrollbarElement(target) {\n            return (target.localName == \"thumb\" || target.localName == \"slider\")\n                && target.namespaceURI == \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          }\n          if (event.touches.length > 1 || isScrollbarElement(event.touches[0].target)) {\n            // Multiple touch points detected, abort. In particular this aborts\n            // the panning gesture when the user puts a second finger down after\n            // already panning with one finger. Aborting at this point prevents\n            // the pan gesture from being resumed until all fingers are lifted\n            // (as opposed to when the user is back down to one finger).\n            // Additionally, if the user lands on the scrollbar don't use this\n            // code for scrolling, instead allow gecko to handle scrollbar\n            // interaction normally.\n            this._touchY = -1;\n          } else {\n            this._touchY = event.touches[0].screenY;\n          }\n        ]]>\n      </handler>\n      <handler event=\"touchmove\">\n        <![CDATA[\n          if (event.touches.length == 1 &&\n              this._touchY >= 0) {\n            var deltaY = this._touchY - event.touches[0].screenY;\n            var lines = Math.trunc(deltaY / this.treeBoxObject.rowHeight);\n            if (Math.abs(lines) > 0) {\n              this.treeBoxObject.scrollByLines(lines);\n              deltaY -= lines * this.treeBoxObject.rowHeight;\n              this._touchY = event.touches[0].screenY + deltaY;\n            }\n            event.preventDefault();\n          }\n        ]]>\n      </handler>\n      <handler event=\"touchend\">\n        <![CDATA[\n          this._touchY = -1;\n        ]]>\n      </handler>\n      <handler event=\"MozMousePixelScroll\">\n        <![CDATA[\n          if (!(this.getAttribute(\"allowunderflowscroll\") == \"true\" &&\n                this.getAttribute(\"hidevscroll\") == \"true\"))\n            event.preventDefault();\n        ]]>\n      </handler>\n      <handler event=\"DOMMouseScroll\">\n        <![CDATA[\n          if (!(this.getAttribute(\"allowunderflowscroll\") == \"true\" &&\n                this.getAttribute(\"hidevscroll\") == \"true\"))\n            event.preventDefault();\n\n          if (this._editingColumn)\n            return;\n          if (event.axis == event.HORIZONTAL_AXIS)\n            return;\n\n          var rows = event.detail;\n          if (rows == UIEvent.SCROLL_PAGE_UP)\n            this.treeBoxObject.scrollByPages(-1);\n          else if (rows == UIEvent.SCROLL_PAGE_DOWN)\n            this.treeBoxObject.scrollByPages(1);\n          else\n            this.treeBoxObject.scrollByLines(rows);\n        ]]>\n      </handler>\n      <handler event=\"MozSwipeGesture\" preventdefault=\"true\">\n        <![CDATA[\n          // Figure out which row to show\n          let targetRow = 0;\n\n          // Only handle swipe gestures up and down\n          switch (event.direction) {\n            case event.DIRECTION_DOWN:\n              targetRow = this.view.rowCount - 1;\n              // Fall through for actual action\n            case event.DIRECTION_UP:\n              this.treeBoxObject.ensureRowIsVisible(targetRow);\n              break;\n          }\n        ]]>\n      </handler>\n      <handler event=\"select\" phase=\"target\"\n               action=\"if (event.originalTarget == this) this.stopEditing(true);\"/>\n      <handler event=\"focus\">\n        <![CDATA[\n          this.treeBoxObject.focused = true;\n          if (this.currentIndex == -1 && this.view.rowCount > 0) {\n            this.currentIndex = this.treeBoxObject.getFirstVisibleRow();\n          }\n          if (this._cellSelType && !this.view.selection.currentColumn) {\n            var col = this._getNextColumn(this.currentIndex, false);\n            this.view.selection.currentColumn = col;\n          }\n        ]]>\n      </handler>\n      <handler event=\"blur\" action=\"this.treeBoxObject.focused = false;\"/>\n      <handler event=\"blur\" phase=\"capturing\"\n               action=\"if (event.originalTarget == this.inputField.inputField) this.stopEditing(true);\"/>\n      <handler event=\"keydown\" keycode=\"VK_RETURN\">\n        if (this._handleEnter(event)) {\n          event.stopPropagation();\n          event.preventDefault();\n        }\n      </handler>\n\n      <!-- Use F2 key to enter text editing. -->\n      <handler event=\"keydown\" keycode=\"VK_F2\">\n        <![CDATA[\n          if (!this._cellSelType)\n            return;\n          var row = this.currentIndex;\n          var column = this.view.selection.currentColumn;\n          if (this.startEditing(row, column))\n            event.preventDefault();\n        ]]>\n      </handler>\n\n\n      <handler event=\"keydown\" keycode=\"VK_ESCAPE\">\n        <![CDATA[\n          if (this._editingColumn) {\n            this.stopEditing(false);\n            this.focus();\n            event.stopPropagation();\n            event.preventDefault();\n          }\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_LEFT\">\n        <![CDATA[\n         if (this._editingColumn)\n           return;\n\n         var row = this.currentIndex;\n         if (row < 0)\n           return;\n\n         var cellSelType = this._cellSelType;\n         var checkContainers = true;\n\n         var currentColumn;\n         if (cellSelType) {\n           currentColumn = this.view.selection.currentColumn;\n           if (currentColumn && !currentColumn.primary)\n             checkContainers = false;\n         }\n\n         if (checkContainers) {\n           if (this.changeOpenState(this.currentIndex, false)) {\n             event.preventDefault();\n             return;\n           }\n           var parentIndex = this.view.getParentIndex(this.currentIndex);\n           if (parentIndex >= 0) {\n             if (cellSelType && !this.view.isSelectable(parentIndex, currentColumn)) {\n               return;\n             }\n             this.view.selection.select(parentIndex);\n             this.treeBoxObject.ensureRowIsVisible(parentIndex);\n             event.preventDefault();\n             return;\n           }\n         }\n\n         if (cellSelType) {\n           var col = this._getNextColumn(row, true);\n           if (col) {\n             this.view.selection.currentColumn = col;\n             this.treeBoxObject.ensureCellIsVisible(row, col);\n             event.preventDefault();\n           }\n         }\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_RIGHT\">\n        <![CDATA[\n         if (this._editingColumn)\n           return;\n\n          var row = this.currentIndex;\n          if (row < 0)\n            return;\n\n          var cellSelType = this._cellSelType;\n          var checkContainers = true;\n\n          var currentColumn;\n          if (cellSelType) {\n            currentColumn = this.view.selection.currentColumn;\n            if (currentColumn && !currentColumn.primary)\n              checkContainers = false;\n          }\n\n          if (checkContainers) {\n            if (this.changeOpenState(row, true)) {\n              event.preventDefault();\n              return;\n            }\n            var c = row + 1;\n            var view = this.view;\n            if (c < view.rowCount &&\n                view.getParentIndex(c) == row) {\n              // If already opened, select the first child.\n              // The getParentIndex test above ensures that the children\n              // are already populated and ready.\n              if (cellSelType && !this.view.isSelectable(c, currentColumn)) {\n                let col = this._getNextColumn(c, false);\n                if (col) {\n                  this.view.selection.currentColumn = col;\n                }\n              }\n              this.view.selection.timedSelect(c, this._selectDelay);\n              this.treeBoxObject.ensureRowIsVisible(c);\n              event.preventDefault();\n              return;\n            }\n          }\n\n          if (cellSelType) {\n            let col = this._getNextColumn(row, false);\n            if (col) {\n              this.view.selection.currentColumn = col;\n              this.treeBoxObject.ensureCellIsVisible(row, col);\n              event.preventDefault();\n            }\n          }\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_UP\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByOffset(-1, 0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_DOWN\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByOffset(1, this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_UP\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByOffsetShift(-1, 0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_DOWN\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByOffsetShift(1, this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_PAGE_UP\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByPage(-1, 0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_PAGE_DOWN\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByPage(1, this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_PAGE_UP\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByPageShift(-1, 0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_PAGE_DOWN\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByPageShift(1, this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_HOME\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveToEdge(0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_END\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveToEdge(this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_HOME\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveToEdgeShift(0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_END\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveToEdgeShift(this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keypress\">\n        <![CDATA[\n         if (this._editingColumn)\n           return;\n\n         if (event.charCode == \" \".charCodeAt(0)) {\n           var c = this.currentIndex;\n           if (!this.view.selection.isSelected(c) ||\n               (!this.view.selection.single && this._isAccelPressed(event))) {\n             this.view.selection.toggleSelect(c);\n             event.preventDefault();\n           }\n         } else if (!this.disableKeyNavigation && event.charCode > 0 &&\n                    !event.altKey && !this._isAccelPressed(event) &&\n                    !event.metaKey && !event.ctrlKey) {\n           var l = this._keyNavigate(event);\n           if (l >= 0) {\n             this.view.selection.timedSelect(l, this._selectDelay);\n             this.treeBoxObject.ensureRowIsVisible(l);\n           }\n           event.preventDefault();\n         }\n         ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"treecols\" role=\"xul:treecolumns\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/tree.css\"/>\n    </resources>\n    <content orient=\"horizontal\">\n      <xul:hbox class=\"tree-scrollable-columns\" flex=\"1\">\n        <children includes=\"treecol|splitter\"/>\n      </xul:hbox>\n      <xul:treecolpicker class=\"treecol-image\" fixed=\"true\" xbl:inherits=\"tooltiptext=pickertooltiptext\"/>\n    </content>\n    <implementation>\n      <constructor><![CDATA[\n        // Set resizeafter=\"farthest\" on the splitters if nothing else has been\n        // specified.\n        Array.forEach(this.getElementsByTagName(\"splitter\"), function(splitter) {\n          if (!splitter.hasAttribute(\"resizeafter\"))\n            splitter.setAttribute(\"resizeafter\", \"farthest\");\n        });\n      ]]></constructor>\n    </implementation>\n  </binding>\n\n  <binding id=\"treerows\" extends=\"chrome://global/content/bindings/tree.xml#tree-base\">\n    <content>\n      <xul:hbox flex=\"1\" class=\"tree-bodybox\">\n        <children/>\n      </xul:hbox>\n      <xul:scrollbar height=\"0\" minwidth=\"0\" minheight=\"0\" orient=\"vertical\" xbl:inherits=\"collapsed=hidevscroll\" style=\"position:relative; z-index:2147483647;\"/>\n    </content>\n    <handlers>\n      <handler event=\"underflow\">\n        <![CDATA[\n          // Scrollport event orientation\n          // 0: vertical\n          // 1: horizontal\n          // 2: both (not used)\n          var tree = document.getBindingParent(this);\n          if (event.detail == 1)\n            tree.setAttribute(\"hidehscroll\", \"true\");\n          else if (event.detail == 0)\n            tree.setAttribute(\"hidevscroll\", \"true\");\n          event.stopPropagation();\n        ]]>\n      </handler>\n      <handler event=\"overflow\">\n        <![CDATA[\n          var tree = document.getBindingParent(this);\n          if (event.detail == 1)\n            tree.removeAttribute(\"hidehscroll\");\n          else if (event.detail == 0)\n            tree.removeAttribute(\"hidevscroll\");\n          event.stopPropagation();\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"treebody\" extends=\"chrome://global/content/bindings/tree.xml#tree-base\">\n    <implementation>\n      <constructor>\n        if (\"_ensureColumnOrder\" in this.parentNode)\n          this.parentNode._ensureColumnOrder();\n      </constructor>\n\n      <field name=\"_lastSelectedRow\">\n        -1\n      </field>\n    </implementation>\n    <handlers>\n      <!-- If there is no modifier key, we select on mousedown, not\n           click, so that drags work correctly. -->\n      <handler event=\"mousedown\" clickcount=\"1\">\n      <![CDATA[\n         if (this.parentNode.disabled)\n           return;\n         if (((!this._isAccelPressed(event) ||\n             !this.parentNode.pageUpOrDownMovesSelection) &&\n             !event.shiftKey && !event.metaKey) ||\n             this.parentNode.view.selection.single) {\n           var b = this.parentNode.treeBoxObject;\n           var cell = b.getCellAt(event.clientX, event.clientY);\n           var view = this.parentNode.view;\n\n           // save off the last selected row\n           this._lastSelectedRow = cell.row;\n\n           if (cell.row == -1)\n             return;\n\n           if (cell.childElt == \"twisty\")\n             return;\n\n           if (cell.col && event.button == 0) {\n             if (cell.col.cycler) {\n               view.cycleCell(cell.row, cell.col);\n               return;\n             } else if (cell.col.type == Components.interfaces.nsITreeColumn.TYPE_CHECKBOX) {\n               if (this.parentNode.editable && cell.col.editable &&\n                   view.isEditable(cell.row, cell.col)) {\n                 var value = view.getCellValue(cell.row, cell.col);\n                 value = value == \"true\" ? \"false\" : \"true\";\n                 view.setCellValue(cell.row, cell.col, value);\n                 return;\n               }\n             }\n           }\n\n           var cellSelType = this.parentNode._cellSelType;\n           if (cellSelType == \"text\" && cell.childElt != \"text\" && cell.childElt != \"image\")\n             return;\n\n           if (cellSelType) {\n             if (!cell.col.selectable ||\n                 !view.isSelectable(cell.row, cell.col)) {\n               return;\n             }\n           }\n\n           if (!view.selection.isSelected(cell.row)) {\n             view.selection.select(cell.row);\n             b.ensureRowIsVisible(cell.row);\n           }\n\n           if (cellSelType) {\n             view.selection.currentColumn = cell.col;\n           }\n         }\n      ]]>\n      </handler>\n\n      <!-- On a click (up+down on the same item), deselect everything\n           except this item. -->\n      <handler event=\"click\" button=\"0\" clickcount=\"1\">\n      <![CDATA[\n        if (this.parentNode.disabled)\n          return;\n        var b = this.parentNode.treeBoxObject;\n        var cell = b.getCellAt(event.clientX, event.clientY);\n        var view = this.parentNode.view;\n\n        if (cell.row == -1)\n          return;\n\n        if (cell.childElt == \"twisty\") {\n          if (view.selection.currentIndex >= 0 &&\n              view.isContainerOpen(cell.row)) {\n            var parentIndex = view.getParentIndex(view.selection.currentIndex);\n            while (parentIndex >= 0 && parentIndex != cell.row)\n              parentIndex = view.getParentIndex(parentIndex);\n            if (parentIndex == cell.row) {\n              var parentSelectable = true;\n              if (this.parentNode._cellSelType) {\n                var currentColumn = view.selection.currentColumn;\n                if (!view.isSelectable(parentIndex, currentColumn))\n                  parentSelectable = false;\n              }\n              if (parentSelectable)\n                view.selection.select(parentIndex);\n            }\n          }\n          this.parentNode.changeOpenState(cell.row);\n          return;\n        }\n\n        if (!view.selection.single) {\n          var augment = this._isAccelPressed(event);\n          if (event.shiftKey) {\n            view.selection.rangedSelect(-1, cell.row, augment);\n            b.ensureRowIsVisible(cell.row);\n            return;\n          }\n          if (augment) {\n            view.selection.toggleSelect(cell.row);\n            b.ensureRowIsVisible(cell.row);\n            view.selection.currentIndex = cell.row;\n            return;\n          }\n        }\n\n        /* We want to deselect all the selected items except what was\n          clicked, UNLESS it was a right-click.  We have to do this\n          in click rather than mousedown so that you can drag a\n          selected group of items */\n\n        if (!cell.col) return;\n\n        // if the last row has changed in between the time we\n        // mousedown and the time we click, don't fire the select handler.\n        // see bug #92366\n        if (!cell.col.cycler && this._lastSelectedRow == cell.row &&\n            cell.col.type != Components.interfaces.nsITreeColumn.TYPE_CHECKBOX) {\n\n          var cellSelType = this.parentNode._cellSelType;\n          if (cellSelType == \"text\" && cell.childElt != \"text\" && cell.childElt != \"image\")\n            return;\n\n          if (cellSelType) {\n            if (!cell.col.selectable ||\n                !view.isSelectable(cell.row, cell.col)) {\n              return;\n            }\n          }\n\n          view.selection.select(cell.row);\n          b.ensureRowIsVisible(cell.row);\n\n          if (cellSelType) {\n            view.selection.currentColumn = cell.col;\n          }\n        }\n      ]]>\n      </handler>\n\n      <!-- double-click -->\n      <handler event=\"click\" clickcount=\"2\">\n      <![CDATA[\n        if (this.parentNode.disabled)\n          return;\n        var tbo = this.parentNode.treeBoxObject;\n        var view = this.parentNode.view;\n        var row = view.selection.currentIndex;\n\n        if (row == -1)\n          return;\n\n        var cell = tbo.getCellAt(event.clientX, event.clientY);\n\n        if (cell.childElt != \"twisty\") {\n          view.selection.currentColumn = cell.col;\n          this.parentNode.startEditing(row, cell.col);\n        }\n\n        if (this.parentNode._editingColumn || !view.isContainer(row))\n          return;\n\n        // Cyclers and twisties respond to single clicks, not double clicks\n        if (cell.col && !cell.col.cycler && cell.childElt != \"twisty\")\n          this.parentNode.changeOpenState(row);\n      ]]>\n      </handler>\n\n    </handlers>\n  </binding>\n\n  <binding id=\"treecol-base\" role=\"xul:treecolumnitem\"\n           extends=\"chrome://global/content/bindings/tree.xml#tree-base\">\n    <implementation>\n      <constructor>\n        this.parentNode.parentNode._columnsDirty = true;\n      </constructor>\n\n      <property name=\"ordinal\">\n        <getter><![CDATA[\n          var val = this.getAttribute(\"ordinal\");\n          if (val == \"\")\n            return \"1\";\n\n          return \"\" + (val == \"0\" ? 0 : parseInt(val));\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"ordinal\", val);\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"_previousVisibleColumn\">\n        <getter><![CDATA[\n          var sib = this.boxObject.previousSibling;\n          while (sib) {\n            if (sib.localName == \"treecol\" && sib.boxObject.width > 0 && sib.parentNode == this.parentNode)\n              return sib;\n            sib = sib.boxObject.previousSibling;\n          }\n          return null;\n        ]]></getter>\n      </property>\n\n      <method name=\"_onDragMouseMove\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          var col = document.treecolDragging;\n          if (!col) return;\n\n          // determine if we have moved the mouse far enough\n          // to initiate a drag\n          if (col.mDragGesturing) {\n            if (Math.abs(aEvent.clientX - col.mStartDragX) < 5 &&\n                Math.abs(aEvent.clientY - col.mStartDragY) < 5) {\n              return;\n            }\n            col.mDragGesturing = false;\n            col.setAttribute(\"dragging\", \"true\");\n            window.addEventListener(\"click\", col._onDragMouseClick, true);\n          }\n\n          var pos = {};\n          var targetCol = col.parentNode.parentNode._getColumnAtX(aEvent.clientX, 0.5, pos);\n\n          // bail if we haven't mousemoved to a different column\n          if (col.mTargetCol == targetCol && col.mTargetDir == pos.value)\n            return;\n\n          var tree = col.parentNode.parentNode;\n          var sib;\n          var column;\n          if (col.mTargetCol) {\n            // remove previous insertbefore/after attributes\n            col.mTargetCol.removeAttribute(\"insertbefore\");\n            col.mTargetCol.removeAttribute(\"insertafter\");\n            column = tree.columns.getColumnFor(col.mTargetCol);\n            tree.treeBoxObject.invalidateColumn(column);\n            sib = col.mTargetCol._previousVisibleColumn;\n            if (sib) {\n              sib.removeAttribute(\"insertafter\");\n              column = tree.columns.getColumnFor(sib);\n              tree.treeBoxObject.invalidateColumn(column);\n            }\n            col.mTargetCol = null;\n            col.mTargetDir = null;\n          }\n\n          if (targetCol) {\n            // set insertbefore/after attributes\n            if (pos.value == \"after\") {\n              targetCol.setAttribute(\"insertafter\", \"true\");\n            } else {\n              targetCol.setAttribute(\"insertbefore\", \"true\");\n              sib = targetCol._previousVisibleColumn;\n              if (sib) {\n                sib.setAttribute(\"insertafter\", \"true\");\n                column = tree.columns.getColumnFor(sib);\n                tree.treeBoxObject.invalidateColumn(column);\n              }\n            }\n            column = tree.columns.getColumnFor(targetCol);\n            tree.treeBoxObject.invalidateColumn(column);\n            col.mTargetCol = targetCol;\n            col.mTargetDir = pos.value;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onDragMouseUp\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          var col = document.treecolDragging;\n          if (!col) return;\n\n          if (!col.mDragGesturing) {\n            if (col.mTargetCol) {\n              // remove insertbefore/after attributes\n              var before = col.mTargetCol.hasAttribute(\"insertbefore\");\n              col.mTargetCol.removeAttribute(before ? \"insertbefore\" : \"insertafter\");\n\n              var sib = col.mTargetCol._previousVisibleColumn;\n              if (before && sib) {\n                sib.removeAttribute(\"insertafter\");\n              }\n\n              // Move the column only if it will result in a different column\n              // ordering\n              var move = true;\n\n              // If this is a before move and the previous visible column is\n              // the same as the column we're moving, don't move\n              if (before && col == sib) {\n                move = false;\n              } else if (!before && col == col.mTargetCol) {\n                // If this is an after move and the column we're moving is\n                // the same as the target column, don't move.\n                move = false;\n              }\n\n              if (move) {\n                col.parentNode.parentNode._reorderColumn(col, col.mTargetCol, before);\n              }\n\n              // repaint to remove lines\n              col.parentNode.parentNode.treeBoxObject.invalidate();\n\n              col.mTargetCol = null;\n            }\n          } else\n            col.mDragGesturing = false;\n\n          document.treecolDragging = null;\n          col.removeAttribute(\"dragging\");\n\n          window.removeEventListener(\"mousemove\", col._onDragMouseMove, true);\n          window.removeEventListener(\"mouseup\", col._onDragMouseUp, true);\n          // we have to wait for the click event to fire before removing\n          // cancelling handler\n          var clickHandler = function(handler) {\n            window.removeEventListener(\"click\", handler, true);\n          };\n          window.setTimeout(clickHandler, 0, col._onDragMouseClick);\n        ]]></body>\n      </method>\n\n      <method name=\"_onDragMouseClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          // prevent click event from firing after column drag and drop\n          aEvent.stopPropagation();\n          aEvent.preventDefault();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"mousedown\" button=\"0\"><![CDATA[\n        if (this.parentNode.parentNode.enableColumnDrag) {\n          var xulns = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          var cols = this.parentNode.getElementsByTagNameNS(xulns, \"treecol\");\n\n          // only start column drag operation if there are at least 2 visible columns\n          var visible = 0;\n          for (var i = 0; i < cols.length; ++i)\n            if (cols[i].boxObject.width > 0) ++visible;\n\n          if (visible > 1) {\n            window.addEventListener(\"mousemove\", this._onDragMouseMove, true);\n            window.addEventListener(\"mouseup\", this._onDragMouseUp, true);\n            document.treecolDragging = this;\n            this.mDragGesturing = true;\n            this.mStartDragX = event.clientX;\n            this.mStartDragY = event.clientY;\n          }\n        }\n      ]]></handler>\n      <handler event=\"click\" button=\"0\" phase=\"target\">\n        <![CDATA[\n          if (event.target != event.originalTarget)\n            return;\n\n          // On Windows multiple clicking on tree columns only cycles one time\n          // every 2 clicks.\n          if (/Win/.test(navigator.platform) && event.detail % 2 == 0)\n            return;\n\n          var tree = this.parentNode.parentNode;\n          if (tree.columns) {\n            tree.view.cycleHeader(tree.columns.getColumnFor(this));\n          }\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"treecol\" extends=\"chrome://global/content/bindings/tree.xml#treecol-base\">\n    <content>\n      <xul:label class=\"treecol-text\" xbl:inherits=\"crop,value=label\" flex=\"1\" crop=\"right\"/>\n      <xul:image class=\"treecol-sortdirection\" xbl:inherits=\"sortDirection,hidden=hideheader\"/>\n    </content>\n  </binding>\n\n  <binding id=\"treecol-image\" extends=\"chrome://global/content/bindings/tree.xml#treecol-base\">\n    <content>\n      <xul:image class=\"treecol-icon\" xbl:inherits=\"src\"/>\n    </content>\n  </binding>\n\n  <binding id=\"columnpicker\" display=\"xul:button\" role=\"xul:button\"\n           extends=\"chrome://global/content/bindings/tree.xml#tree-base\">\n    <content>\n      <xul:image class=\"tree-columnpicker-icon\"/>\n      <xul:menupopup anonid=\"popup\">\n        <xul:menuseparator anonid=\"menuseparator\"/>\n        <xul:menuitem anonid=\"menuitem\" label=\"FROM-DTD-restoreColumnOrder-label\"/>\n      </xul:menupopup>\n    </content>\n\n    <implementation>\n      <method name=\"buildPopup\">\n        <parameter name=\"aPopup\"/>\n        <body>\n          <![CDATA[\n            // We no longer cache the picker content, remove the old content.\n            while (aPopup.childNodes.length > 2)\n              aPopup.firstChild.remove();\n\n            var refChild = aPopup.firstChild;\n\n            var tree = this.parentNode.parentNode;\n            for (var currCol = tree.columns.getFirstColumn(); currCol;\n                 currCol = currCol.getNext()) {\n              // Construct an entry for each column in the row, unless\n              // it is not being shown.\n              var currElement = currCol.element;\n              if (!currElement.hasAttribute(\"ignoreincolumnpicker\")) {\n                var popupChild = document.createElement(\"menuitem\");\n                popupChild.setAttribute(\"type\", \"checkbox\");\n                var columnName = currElement.getAttribute(\"display\") ||\n                                 currElement.getAttribute(\"label\");\n                popupChild.setAttribute(\"label\", columnName);\n                popupChild.setAttribute(\"colindex\", currCol.index);\n                if (currElement.getAttribute(\"hidden\") != \"true\")\n                  popupChild.setAttribute(\"checked\", \"true\");\n                if (currCol.primary)\n                  popupChild.setAttribute(\"disabled\", \"true\");\n                aPopup.insertBefore(popupChild, refChild);\n              }\n            }\n\n            var hidden = !tree.enableColumnDrag;\n            const anonids = [\"menuseparator\", \"menuitem\"];\n            for (var i = 0; i < anonids.length; i++) {\n              var element = document.getAnonymousElementByAttribute(this, \"anonid\", anonids[i]);\n              element.hidden = hidden;\n            }\n          ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"command\">\n        <![CDATA[\n          if (event.originalTarget == this) {\n            var popup = document.getAnonymousElementByAttribute(this, \"anonid\", \"popup\");\n            this.buildPopup(popup);\n            popup.showPopup(this, -1, -1, \"popup\", \"bottomright\", \"topright\");\n          } else {\n            var tree = this.parentNode.parentNode;\n            tree.stopEditing(true);\n            var menuitem = document.getAnonymousElementByAttribute(this, \"anonid\", \"menuitem\");\n            if (event.originalTarget == menuitem) {\n              tree.columns.restoreNaturalOrder();\n              tree._ensureColumnOrder();\n            } else {\n              var colindex = event.originalTarget.getAttribute(\"colindex\");\n              var column = tree.columns[colindex];\n              if (column) {\n                var element = column.element;\n                if (element.getAttribute(\"hidden\") == \"true\")\n                  element.setAttribute(\"hidden\", \"false\");\n                else\n                  element.setAttribute(\"hidden\", \"true\");\n              }\n            }\n          }\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"videocontrols.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings [\n<!ENTITY % videocontrolsDTD SYSTEM \"chrome://global/locale/videocontrols.dtd\">\n%videocontrolsDTD;\n]>\n\n<bindings id=\"videoControlBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:svg=\"http://www.w3.org/2000/svg\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\">\n\n<binding id=\"suppressChangeEvent\"\n         extends=\"chrome://global/content/bindings/scale.xml#scale\">\n<implementation implements=\"nsIXBLAccessible\">\n  <!-- nsIXBLAccessible -->\n  <property name=\"accessibleName\" readonly=\"true\">\n    <getter>\n      var currTime = this.positionValue;\n      var totalTime = this.durationValue;\n\n      return this.scrubberNameFormat\n                 .replace(/#1/, currTime)\n                 .replace(/#2/, totalTime);\n    </getter>\n  </property>\n\n  <constructor>\n    <![CDATA[\n    /* eslint-disable no-multi-spaces */\n    this.scrubberNameFormat = ]]>\"FROM-DTD-scrubberScale-nameFormat\"<![CDATA[;\n    /* eslint-enable no-multi-spaces */\n    this.positionValue = \"\";\n    this.durationValue = \"\";\n    this.valueBar = null;\n    this.isDragging = false;\n    this.isPausedByDragging = false;\n\n    this.type = this.getAttribute(\"class\");\n    this.Utils = document.getBindingParent(this.parentNode).Utils;\n    this.valueBar = this.Utils.progressBar;\n    ]]>\n  </constructor>\n\n  <method name=\"valueChanged\">\n    <parameter name=\"which\"/>\n    <parameter name=\"newValue\"/>\n    <parameter name=\"userChanged\"/>\n    <body>\n      <![CDATA[\n      // This method is a copy of the base binding's valueChanged(), except that it does\n      // not dispatch a |change| event (to avoid exposing the event to web content), and\n      // just calls the videocontrol's seekToPosition() method directly.\n      switch (which) {\n        case \"curpos\":\n          // Update the time shown in the thumb.\n          this.positionValue = this.Utils.formatTime(newValue, this.Utils.showHours);\n          this.Utils.positionLabel.setAttribute(\"value\", this.positionValue);\n          // Update the value bar to match the thumb position.\n          let percent = newValue / this.max;\n          if (!isNaN(percent) && percent != Infinity) {\n            this.valueBar.value = Math.round(percent * 10000); // has max=10000\n          } else {\n            this.valueBar.removeAttribute(\"value\");\n          }\n\n          // The value of userChanged is true when changing the position with the mouse,\n          // but not when pressing an arrow key. However, the base binding sets\n          // ._userChanged in its keypress handlers, so we just need to check both.\n          if (!userChanged && !this._userChanged) {\n            return;\n          }\n          this.setAttribute(\"value\", newValue);\n          this.Utils.seekToPosition(newValue);\n          break;\n\n        case \"minpos\":\n          this.setAttribute(\"min\", newValue);\n          break;\n\n        case \"maxpos\":\n          // Update the value bar to match the thumb position.\n          this.valueBar.value = Math.round(this.value / newValue * 10000); // has max=10000\n          this.setAttribute(\"max\", newValue);\n          break;\n      }\n      ]]>\n    </body>\n  </method>\n\n  <method name=\"dragStateChanged\">\n    <parameter name=\"isDragging\"/>\n    <body>\n      <![CDATA[\n      this.Utils.log(\"--- dragStateChanged: \" + isDragging + \" ---\");\n      this.isDragging = isDragging;\n      if (this.isPausedByDragging && !isDragging) {\n        // After the drag ends, resume playing.\n        this.Utils.video.play();\n        this.isPausedByDragging = false;\n      }\n      ]]>\n    </body>\n  </method>\n\n  <method name=\"pauseVideoDuringDragging\">\n    <body>\n      <![CDATA[\n      if (this.isDragging &&\n         !this.Utils.video.paused && !this.isPausedByDragging) {\n        this.isPausedByDragging = true;\n        this.Utils.video.pause();\n      }\n      ]]>\n    </body>\n  </method>\n\n</implementation>\n</binding>\n\n<binding id=\"videoControls\">\n  <resources>\n    <stylesheet src=\"chrome://global/content/bindings/videocontrols.css\"/>\n    <stylesheet src=\"chrome://global/skin/media/videocontrols.css\"/>\n  </resources>\n\n  <xbl:content xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n    xmlns=\"http://www.w3.org/1999/xhtml\" class=\"mediaControlsFrame\">\n    <div anonid=\"controlsContainer\" class=\"controlsContainer\" role=\"none\">\n      <div anonid=\"statusOverlay\" class=\"statusOverlay stackItem\" hidden=\"true\">\n        <div anonid=\"statusIcon\" class=\"statusIcon\"></div>\n        <span class=\"errorLabel\" anonid=\"errorAborted\">FROM-DTD-error-aborted</span>\n        <span class=\"errorLabel\" anonid=\"errorNetwork\">FROM-DTD-error-network</span>\n        <span class=\"errorLabel\" anonid=\"errorDecode\">FROM-DTD-error-decode</span>\n        <span class=\"errorLabel\" anonid=\"errorSrcNotSupported\">FROM-DTD-error-srcNotSupported</span>\n        <span class=\"errorLabel\" anonid=\"errorNoSource\">FROM-DTD-error-noSource2</span>\n        <span class=\"errorLabel\" anonid=\"errorGeneric\">FROM-DTD-error-generic</span>\n      </div>\n\n      <div anonid=\"controlsOverlay\" class=\"controlsOverlay stackItem\">\n        <div class=\"controlsSpacerStack\" aria-hideen=\"true\">\n          <div anonid=\"controlsSpacer\" class=\"controlsSpacer stackItem\" role=\"none\"></div>\n          <div anonid=\"clickToPlay\" class=\"clickToPlay\" hidden=\"true\"></div>\n        </div>\n        <div anonid=\"controlBar\" class=\"controlBar\" hidden=\"true\">\n          <button anonid=\"playButton\"\n                  class=\"playButton\"\n                  playlabel=\"FROM-DTD-playButton-playLabel\"\n                  pauselabel=\"FROM-DTD-playButton-pauseLabel\"\n                  tabindex=\"-1\"/>\n          <div anonid=\"scrubberStack\" class=\"scrubberStack progressContainer\" role=\"none\">\n            <div class=\"progressBackgroundBar stackItem\" role=\"none\">\n              <div class=\"progressStack\" role=\"none\">\n                <progress anonid=\"bufferBar\" class=\"bufferBar\" value=\"0\" max=\"100\" tabindex=\"-1\"></progress>\n                <progress anonid=\"progressBar\" class=\"progressBar\" value=\"0\" max=\"100\" tabindex=\"-1\"></progress>\n              </div>\n            </div>\n            <input type=\"range\" anonid=\"scrubber\" class=\"scrubber\" tabindex=\"-1\" mozinputrangeignorepreventdefault=\"true\" />\n          </div>\n          <span anonid=\"positionLabel\" class=\"positionLabel\" role=\"presentation\"></span>\n          <span anonid=\"durationLabel\" class=\"durationLabel\" role=\"presentation\"></span>\n          <span anonid=\"positionDurationBox\" class=\"positionDurationBox\" aria-hidden=\"true\">\n            FROM-DTD-positionAndDuration-nameFormat\n          </span>\n          <div anonid=\"controlBarSpacer\" class=\"controlBarSpacer\" hidden=\"true\" role=\"none\"></div>\n          <button anonid=\"muteButton\"\n                  class=\"muteButton\"\n                  mutelabel=\"FROM-DTD-muteButton-muteLabel\"\n                  unmutelabel=\"FROM-DTD-muteButton-unmuteLabel\"\n                  tabindex=\"-1\"/>\n          <div anonid=\"volumeStack\" class=\"volumeStack progressContainer\" role=\"none\">\n            <input type=\"range\" anonid=\"volumeControl\" class=\"volumeControl\" min=\"0\" max=\"100\" step=\"1\" tabindex=\"-1\" mozinputrangeignorepreventdefault=\"true\" />\n          </div>\n          <button anonid=\"closedCaptionButton\" class=\"closedCaptionButton\"/>\n          <button anonid=\"fullscreenButton\"\n                  class=\"fullscreenButton\"\n                  enterfullscreenlabel=\"FROM-DTD-fullscreenButton-enterfullscreenlabel\"\n                  exitfullscreenlabel=\"FROM-DTD-fullscreenButton-exitfullscreenlabel\"/>\n        </div>\n        <div anonid=\"textTrackList\" class=\"textTrackList\" hidden=\"true\" offlabel=\"FROM-DTD-closedCaption-off\"></div>\n      </div>\n    </div>\n  </xbl:content>\n\n  <implementation>\n\n  <constructor>\n    <![CDATA[\n    this.isTouchControls = false;\n    this.randomID = 0;\n\n    this.Utils = {\n      debug: false,\n      video: null,\n      videocontrols: null,\n      controlBar: null,\n      playButton: null,\n      muteButton: null,\n      volumeControl: null,\n      durationLabel: null,\n      positionLabel: null,\n      scrubber: null,\n      progressBar: null,\n      bufferBar: null,\n      statusOverlay: null,\n      controlsSpacer: null,\n      clickToPlay: null,\n      controlsOverlay: null,\n      fullscreenButton: null,\n      layoutControls: null,\n\n      textTracksCount: 0,\n      randomID: 0,\n      videoEvents: [\"play\", \"pause\", \"ended\", \"volumechange\", \"loadeddata\",\n                    \"loadstart\", \"timeupdate\", \"progress\",\n                    \"playing\", \"waiting\", \"canplay\", \"canplaythrough\",\n                    \"seeking\", \"seeked\", \"emptied\", \"loadedmetadata\",\n                    \"error\", \"suspend\", \"stalled\",\n                    \"mozvideoonlyseekbegin\", \"mozvideoonlyseekcompleted\"],\n\n      showHours: false,\n      firstFrameShown: false,\n      timeUpdateCount: 0,\n      maxCurrentTimeSeen: 0,\n      isPausedByDragging: false,\n      _isAudioOnly: false,\n\n      get isAudioOnly() { return this._isAudioOnly; },\n      set isAudioOnly(val) {\n        this._isAudioOnly = val;\n        this.setFullscreenButtonState();\n\n        if (!this.isTopLevelSyntheticDocument) {\n          return;\n        }\n        if (this._isAudioOnly) {\n          this.video.style.height = this.controlBarMinHeight + \"px\";\n          this.video.style.width = \"66%\";\n        } else {\n          this.video.style.removeProperty(\"height\");\n          this.video.style.removeProperty(\"width\");\n        }\n      },\n\n      get isControlBarHidden() {\n        return this.controlBar.hidden ||\n               this.controlBar.hideByAdjustment ||\n               this.controlBar.getAttribute(\"fadeout\") === \"true\";\n      },\n\n      suppressError: false,\n\n      setupStatusFader(immediate) {\n        // Since the play button will be showing, we don't want to\n        // show the throbber behind it. The throbber here will\n        // only show if needed after the play button has been pressed.\n        if (!this.clickToPlay.hidden) {\n          this.startFadeOut(this.statusOverlay, true);\n          return;\n        }\n\n        var show = false;\n        if (this.video.seeking ||\n            (this.video.error && !this.suppressError) ||\n            this.video.networkState == this.video.NETWORK_NO_SOURCE ||\n            (this.video.networkState == this.video.NETWORK_LOADING &&\n              (this.video.paused || this.video.ended\n                ? this.video.readyState < this.video.HAVE_CURRENT_DATA\n                : this.video.readyState < this.video.HAVE_FUTURE_DATA)) ||\n            (this.timeUpdateCount <= 1 && !this.video.ended &&\n             this.video.readyState < this.video.HAVE_FUTURE_DATA &&\n             this.video.networkState == this.video.NETWORK_LOADING)) {\n          show = true;\n        }\n\n        // Explicitly hide the status fader if this\n        // is audio only until bug 619421 is fixed.\n        if (this.isAudioOnly) {\n          show = false;\n        }\n\n        if (this._showThrobberTimer) {\n          show = true;\n        }\n\n        this.log(\"Status overlay: seeking=\" + this.video.seeking +\n                 \" error=\" + this.video.error + \" readyState=\" + this.video.readyState +\n                 \" paused=\" + this.video.paused + \" ended=\" + this.video.ended +\n                 \" networkState=\" + this.video.networkState +\n                 \" timeUpdateCount=\" + this.timeUpdateCount +\n                 \" _showThrobberTimer=\" + this._showThrobberTimer +\n                 \" --> \" + (show ? \"SHOW\" : \"HIDE\"));\n        this.startFade(this.statusOverlay, show, immediate);\n      },\n\n      /*\n      * Set the initial state of the controls. The binding is normally created along\n      * with video element, but could be attached at any point (eg, if the video is\n      * removed from the document and then reinserted). Thus, some one-time events may\n      * have already fired, and so we'll need to explicitly check the initial state.\n      */\n      setupInitialState() {\n        this.randomID = Math.random();\n        this.videocontrols.randomID = this.randomID;\n\n        this.setPlayButtonState(this.video.paused);\n\n        this.setFullscreenButtonState();\n\n        var duration = Math.round(this.video.duration * 1000); // in ms\n        var currentTime = Math.round(this.video.currentTime * 1000); // in ms\n        this.log(\"Initial playback position is at \" + currentTime + \" of \" + duration);\n        // It would be nice to retain maxCurrentTimeSeen, but it would be difficult\n        // to determine if the media source changed while we were detached.\n        this.initPositionDurationBox();\n        this.maxCurrentTimeSeen = currentTime;\n        this.showPosition(currentTime, duration);\n\n        // If we have metadata, check if this is a <video> without\n        // video data, or a video with no audio track.\n        if (this.video.readyState >= this.video.HAVE_METADATA) {\n          if (this.video instanceof HTMLVideoElement &&\n              (this.video.videoWidth == 0 || this.video.videoHeight == 0)) {\n            this.isAudioOnly = true;\n          }\n\n          // We have to check again if the media has audio here,\n          // because of bug 718107: switching to fullscreen may\n          // cause the bindings to detach and reattach, hence\n          // unsetting the attribute.\n          if (!this.isAudioOnly && !this.video.mozHasAudio) {\n            this.muteButton.setAttribute(\"noAudio\", \"true\");\n            this.muteButton.setAttribute(\"disabled\", \"true\");\n          }\n        }\n\n        if (this.isAudioOnly) {\n          this.clickToPlay.hidden = true;\n        }\n\n        // If the first frame hasn't loaded, kick off a throbber fade-in.\n        if (this.video.readyState >= this.video.HAVE_CURRENT_DATA) {\n          this.firstFrameShown = true;\n        }\n\n        // We can't determine the exact buffering status, but do know if it's\n        // fully loaded. (If it's still loading, it will fire a progress event\n        // and we'll figure out the exact state then.)\n        this.bufferBar.max = 100;\n        if (this.video.readyState >= this.video.HAVE_METADATA) {\n          this.showBuffered();\n        } else {\n          this.bufferBar.value = 0;\n        }\n\n        // Set the current status icon.\n        if (this.hasError()) {\n          this.clickToPlay.hidden = true;\n          this.statusIcon.setAttribute(\"type\", \"error\");\n          this.updateErrorText();\n          this.setupStatusFader(true);\n        }\n\n        let adjustableControls = [\n          ...this.prioritizedControls,\n          this.controlBar,\n          this.clickToPlay\n        ];\n\n        for (let control of adjustableControls) {\n          if (!control) {\n            break;\n          }\n\n          Object.defineProperties(control, {\n            // We should directly access CSSOM to get pre-defined style instead of\n            // retrieving computed dimensions from layout.\n            minWidth: {\n              get: () => {\n                let controlAnonId = control.getAttribute(\"anonid\");\n                let propertyName = `--${controlAnonId}-width`;\n                if (control.modifier) {\n                  propertyName += \"-\" + control.modifier;\n                }\n                let preDefinedSize = this.controlBarComputedStyles.getPropertyValue(propertyName);\n\n                return parseInt(preDefinedSize, 10);\n              }\n            },\n            isAdjustableControl: {\n              value: true\n            },\n            modifier: {\n              value: \"\",\n              writable: true\n            },\n            isWanted: {\n              value: true,\n              writable: true\n            },\n            hideByAdjustment: {\n              set: (v) => {\n                if (v) {\n                  control.setAttribute(\"hidden\", \"true\");\n                } else {\n                  control.removeAttribute(\"hidden\");\n                }\n\n                control._isHiddenByAdjustment = v;\n              },\n              get: () => control._isHiddenByAdjustment\n            },\n            _isHiddenByAdjustment: {\n              value: false,\n              writable: true\n            }\n          });\n        }\n        this.adjustControlSize();\n\n        // Can only update the volume controls once we've computed\n        // _volumeControlWidth, since the volume slider implementation\n        // depends on it.\n        this.updateVolumeControls();\n      },\n\n      setupNewLoadState() {\n        // videocontrols.css hides the control bar by default, because if script\n        // is disabled our binding's script is disabled too (bug 449358). Thus,\n        // the controls are broken and we don't want them shown. But if script is\n        // enabled, the code here will run and can explicitly unhide the controls.\n        //\n        // For videos with |autoplay| set, we'll leave the controls initially hidden,\n        // so that they don't get in the way of the playing video. Otherwise we'll\n        // go ahead and reveal the controls now, so they're an obvious user cue.\n        //\n        // (Note: the |controls| attribute is already handled via layout/style/html.css)\n        var shouldShow = !this.dynamicControls ||\n                         (this.video.paused &&\n                         !(this.video.autoplay && this.video.mozAutoplayEnabled));\n        // Hide the overlay if the video time is non-zero or if an error occurred to workaround bug 718107.\n        let shouldClickToPlayShow = shouldShow && !this.isAudioOnly &&\n                                    this.video.currentTime == 0 && !this.hasError();\n        this.startFade(this.clickToPlay, shouldClickToPlayShow, true);\n        this.startFade(this.controlsSpacer, shouldClickToPlayShow, true);\n        this.startFade(this.controlBar, shouldShow, true);\n      },\n\n      get dynamicControls() {\n        // Don't fade controls for <audio> elements.\n        var enabled = !this.isAudioOnly;\n\n        // Allow tests to explicitly suppress the fading of controls.\n        if (this.video.hasAttribute(\"mozNoDynamicControls\")) {\n          enabled = false;\n        }\n\n        // If the video hits an error, suppress controls if it\n        // hasn't managed to do anything else yet.\n        if (!this.firstFrameShown && this.hasError()) {\n          enabled = false;\n        }\n\n        return enabled;\n      },\n\n      updateVolume() {\n        const volume = this.volumeControl.value;\n        this.setVolume(volume / 100);\n      },\n\n      updateVolumeControls() {\n        var volume = this.video.muted ? 0 : this.video.volume;\n        var volumePercentage = Math.round(volume * 100);\n        this.updateMuteButtonState();\n        this.volumeControl.value = volumePercentage;\n      },\n\n      /*\n       * We suspend a video element's video decoder if the video\n       * element is invisible. However, resuming the video decoder\n       * takes time and we show the throbber UI if it takes more than\n       * 250 ms.\n       *\n       * When an already-suspended video element becomes visible, we\n       * resume its video decoder immediately and queue a video-only seek\n       * task to seek the resumed video decoder to the current position;\n       * meanwhile, we also file a \"mozvideoonlyseekbegin\" event which\n       * we used to start the timer here.\n       *\n       * Once the queued seek operation is done, we dispatch a\n       * \"canplay\" event which indicates that the resuming operation\n       * is completed.\n       */\n      SHOW_THROBBER_TIMEOUT_MS: 250,\n      _showThrobberTimer: null,\n      _delayShowThrobberWhileResumingVideoDecoder() {\n        this._showThrobberTimer = setTimeout(() => {\n          this.statusIcon.setAttribute(\"type\", \"throbber\");\n          // Show the throbber immediately since we have waited for SHOW_THROBBER_TIMEOUT_MS.\n          // We don't want to wait for another transition-delay(750ms) and the\n          // transition-duration(300ms).\n          this.setupStatusFader(true);\n        }, this.SHOW_THROBBER_TIMEOUT_MS);\n      },\n      _cancelShowThrobberWhileResumingVideoDecoder() {\n        if (this._showThrobberTimer) {\n          clearTimeout(this._showThrobberTimer);\n          this._showThrobberTimer = null;\n        }\n      },\n\n      handleEvent(aEvent) {\n        this.log(\"Got media event ----> \" + aEvent.type);\n\n        // If the binding is detached (or has been replaced by a\n        // newer instance of the binding), nuke our event-listeners.\n        if (this.videocontrols.randomID != this.randomID) {\n          this.terminateEventListeners();\n          return;\n        }\n\n        switch (aEvent.type) {\n          case \"play\":\n            this.setPlayButtonState(false);\n            this.setupStatusFader();\n            if (!this._triggeredByControls && this.dynamicControls && this.videocontrols.isTouchControls) {\n              this.startFadeOut(this.controlBar);\n            }\n            if (!this._triggeredByControls) {\n              this.clickToPlay.hidden = true;\n              this.controlsSpacer.setAttribute(\"fadeout\", \"true\");\n            }\n            this._triggeredByControls = false;\n            break;\n          case \"pause\":\n            // Little white lie: if we've internally paused the video\n            // while dragging the scrubber, don't change the button state.\n            if (!this.scrubber.isDragging) {\n              this.setPlayButtonState(true);\n            }\n            this.setupStatusFader();\n            break;\n          case \"ended\":\n            this.setPlayButtonState(true);\n            // We throttle timechange events, so the thumb might not be\n            // exactly at the end when the video finishes.\n            this.showPosition(Math.round(this.video.currentTime * 1000),\n            Math.round(this.video.duration * 1000));\n            this.startFadeIn(this.controlBar);\n            this.setupStatusFader();\n            break;\n          case \"volumechange\":\n            this.updateVolumeControls();\n            // Show the controls to highlight the changing volume,\n            // but only if the click-to-play overlay has already\n            // been hidden (we don't hide controls when the overlay is visible).\n            if (this.clickToPlay.hidden && !this.isAudioOnly) {\n              this.startFadeIn(this.controlBar);\n              clearTimeout(this._hideControlsTimeout);\n              this._hideControlsTimeout = setTimeout(this._hideControlsFn, this.HIDE_CONTROLS_TIMEOUT_MS);\n            }\n            break;\n          case \"loadedmetadata\":\n            // If a <video> doesn't have any video data, treat it as <audio>\n            // and show the controls (they won't fade back out)\n            if (this.video instanceof HTMLVideoElement &&\n                (this.video.videoWidth == 0 || this.video.videoHeight == 0)) {\n              this.isAudioOnly = true;\n              this.clickToPlay.hidden = true;\n              this.startFadeIn(this.controlBar);\n              this.setFullscreenButtonState();\n            }\n            this.showPosition(Math.round(this.video.currentTime * 1000), Math.round(this.video.duration * 1000));\n            if (!this.isAudioOnly && !this.video.mozHasAudio) {\n              this.muteButton.setAttribute(\"noAudio\", \"true\");\n              this.muteButton.setAttribute(\"disabled\", \"true\");\n            }\n            this.adjustControlSize();\n            break;\n          case \"loadeddata\":\n            this.firstFrameShown = true;\n            this.setupStatusFader();\n            break;\n          case \"loadstart\":\n            this.maxCurrentTimeSeen = 0;\n            this.controlsSpacer.removeAttribute(\"aria-label\");\n            this.statusOverlay.removeAttribute(\"error\");\n            this.statusIcon.setAttribute(\"type\", \"throbber\");\n            this.isAudioOnly = (this.video instanceof HTMLAudioElement);\n            this.setPlayButtonState(true);\n            this.setupNewLoadState();\n            this.setupStatusFader();\n            break;\n          case \"progress\":\n            this.statusIcon.removeAttribute(\"stalled\");\n            this.showBuffered();\n            this.setupStatusFader();\n            break;\n          case \"stalled\":\n            this.statusIcon.setAttribute(\"stalled\", \"true\");\n            this.statusIcon.setAttribute(\"type\", \"throbber\");\n            this.setupStatusFader();\n            break;\n          case \"suspend\":\n            this.setupStatusFader();\n            break;\n          case \"timeupdate\":\n            var currentTime = Math.round(this.video.currentTime * 1000); // in ms\n            var duration = Math.round(this.video.duration * 1000); // in ms\n\n            // If playing/seeking after the video ended, we won't get a \"play\"\n            // event, so update the button state here.\n            if (!this.video.paused) {\n              this.setPlayButtonState(false);\n            }\n\n            this.timeUpdateCount++;\n            // Whether we show the statusOverlay sometimes depends\n            // on whether we've seen more than one timeupdate\n            // event (if we haven't, there hasn't been any\n            // \"playback activity\" and we may wish to show the\n            // statusOverlay while we wait for HAVE_ENOUGH_DATA).\n            // If we've seen more than 2 timeupdate events,\n            // the count is no longer relevant to setupStatusFader.\n            if (this.timeUpdateCount <= 2) {\n              this.setupStatusFader();\n            }\n\n            // If the user is dragging the scrubber ignore the delayed seek\n            // responses (don't yank the thumb away from the user)\n            if (this.scrubber.isDragging) {\n              return;\n            }\n            this.showPosition(currentTime, duration);\n            this.showBuffered();\n            break;\n          case \"emptied\":\n            this.bufferBar.value = 0;\n            this.showPosition(0, 0);\n            break;\n          case \"seeking\":\n            this.showBuffered();\n            this.statusIcon.setAttribute(\"type\", \"throbber\");\n            this.setupStatusFader();\n            break;\n          case \"waiting\":\n            this.statusIcon.setAttribute(\"type\", \"throbber\");\n            this.setupStatusFader();\n            break;\n          case \"seeked\":\n          case \"playing\":\n          case \"canplay\":\n          case \"canplaythrough\":\n            this.setupStatusFader();\n            break;\n          case \"error\":\n            // We'll show the error status icon when we receive an error event\n            // under either of the following conditions:\n            // 1. The video has its error attribute set; this means we're loading\n            //    from our src attribute, and the load failed, or we we're loading\n            //    from source children and the decode or playback failed after we\n            //    determined our selected resource was playable.\n            // 2. The video's networkState is NETWORK_NO_SOURCE. This means we we're\n            //    loading from child source elements, but we were unable to select\n            //    any of the child elements for playback during resource selection.\n            if (this.hasError()) {\n              this.suppressError = false;\n              this.clickToPlay.hidden = true;\n              this.statusIcon.setAttribute(\"type\", \"error\");\n              this.updateErrorText();\n              this.setupStatusFader(true);\n              // If video hasn't shown anything yet, disable the controls.\n              if (!this.firstFrameShown && !this.isAudioOnly) {\n                this.startFadeOut(this.controlBar);\n              }\n              this.controlsSpacer.removeAttribute(\"hideCursor\");\n            }\n            break;\n          case \"mozvideoonlyseekbegin\":\n            this._delayShowThrobberWhileResumingVideoDecoder();\n            break;\n          case \"mozvideoonlyseekcompleted\":\n            this._cancelShowThrobberWhileResumingVideoDecoder();\n            this.setupStatusFader();\n            break;\n          default:\n            this.log(\"!!! event \" + aEvent.type + \" not handled!\");\n        }\n      },\n\n      terminateEventListeners() {\n        if (this.videoEvents) {\n          for (let event of this.videoEvents) {\n            try {\n              this.video.removeEventListener(event, this, {\n                capture: true,\n                mozSystemGroup: true\n              });\n            } catch (ex) {}\n          }\n        }\n\n        if (this.controlListeners) {\n          for (let element of this.controlListeners) {\n            try {\n              element.item.removeEventListener(element.event, element.func,\n                { mozSystemGroup: true, capture: element.capture });\n            } catch (ex) {}\n          }\n\n          delete this.controlListeners;\n        }\n\n        this.log(\"--- videocontrols terminated ---\");\n      },\n\n      hasError() {\n        // We either have an explicit error, or the resource selection\n        // algorithm is running and we've tried to load something and failed.\n        // Note: we don't consider the case where we've tried to load but\n        // there's no sources to load as an error condition, as sites may\n        // do this intentionally to work around requires-user-interaction to\n        // play restrictions, and we don't want to display a debug message\n        // if that's the case.\n        return this.video.error != null ||\n               (this.video.networkState == this.video.NETWORK_NO_SOURCE &&\n               this.hasSources());\n      },\n\n      hasSources() {\n        if (this.video.hasAttribute(\"src\") &&\n            this.video.getAttribute(\"src\") !== \"\") {\n          return true;\n        }\n        for (var child = this.video.firstChild;\n             child !== null;\n             child = child.nextElementSibling) {\n          if (child instanceof HTMLSourceElement) {\n            return true;\n          }\n        }\n        return false;\n      },\n\n      updateErrorText() {\n        let error;\n        let v = this.video;\n        // It is possible to have both v.networkState == NETWORK_NO_SOURCE\n        // as well as v.error being non-null. In this case, we will show\n        // the v.error.code instead of the v.networkState error.\n        if (v.error) {\n          switch (v.error.code) {\n            case v.error.MEDIA_ERR_ABORTED:\n              error = \"errorAborted\";\n              break;\n            case v.error.MEDIA_ERR_NETWORK:\n              error = \"errorNetwork\";\n              break;\n            case v.error.MEDIA_ERR_DECODE:\n              error = \"errorDecode\";\n              break;\n            case v.error.MEDIA_ERR_SRC_NOT_SUPPORTED:\n              error = \"errorSrcNotSupported\";\n              break;\n            default:\n              error = \"errorGeneric\";\n              break;\n          }\n        } else if (v.networkState == v.NETWORK_NO_SOURCE) {\n          error = \"errorNoSource\";\n        } else {\n          return; // No error found.\n        }\n\n        let label = document.getAnonymousElementByAttribute(this.videocontrols, \"anonid\", error);\n        this.controlsSpacer.setAttribute(\"aria-label\", label.textContent);\n        this.statusOverlay.setAttribute(\"error\", error);\n      },\n\n      formatTime(aTime, showHours = false) {\n        // Format the duration as \"h:mm:ss\" or \"m:ss\"\n        aTime = Math.round(aTime / 1000);\n        let hours = Math.floor(aTime / 3600);\n        let mins  = Math.floor((aTime % 3600) / 60);\n        let secs  = Math.floor(aTime % 60);\n        let timeString;\n        if (secs < 10) {\n          secs = \"0\" + secs;\n        }\n        if (hours || showHours) {\n          if (mins < 10) {\n            mins = \"0\" + mins;\n          }\n          timeString = hours + \":\" + mins + \":\" + secs;\n        } else {\n          timeString = mins + \":\" + secs;\n        }\n        return timeString;\n      },\n\n      initPositionDurationBox() {\n        if (this.videocontrols.isTouchControls) {\n          return;\n        }\n\n        const positionTextNode = Array.prototype.find.call(\n          this.positionDurationBox.childNodes, (n) => !!~n.textContent.search(\"#1\"));\n        const durationSpan = this.durationSpan;\n        const durationFormat = durationSpan.textContent;\n        const positionFormat = positionTextNode.textContent;\n\n        durationSpan.classList.add(\"duration\");\n        durationSpan.setAttribute(\"role\", \"none\");\n        durationSpan.setAttribute(\"anonid\", \"durationSpan\");\n\n        Object.defineProperties(this.positionDurationBox, {\n          durationSpan: {\n            value: durationSpan\n          },\n          position: {\n            set: (v) => {\n              positionTextNode.textContent = positionFormat.replace(\"#1\", v);\n            }\n          },\n          duration: {\n            set: (v) => {\n              durationSpan.textContent = v ? durationFormat.replace(\"#2\", v) : \"\";\n            }\n          }\n        });\n      },\n\n      showDuration(duration) {\n        let isInfinite = (duration == Infinity);\n        this.log(\"Duration is \" + duration + \"ms.\\n\");\n\n        if (isNaN(duration) || isInfinite) {\n          duration = this.maxCurrentTimeSeen;\n        }\n\n        // If the duration is over an hour, thumb should show h:mm:ss instead of mm:ss\n        this.showHours = (duration >= 3600000);\n\n        // Format the duration as \"h:mm:ss\" or \"m:ss\"\n        let timeString = isInfinite ? \"\" : this.formatTime(duration);\n        if (this.videocontrols.isTouchControls) {\n          this.durationLabel.setAttribute(\"value\", timeString);\n        } else {\n          this.positionDurationBox.duration = timeString;\n\n          if (this.showHours) {\n            this.positionDurationBox.modifier = \"long\";\n            this.durationSpan.modifier = \"long\";\n          }\n        }\n\n        // \"durationValue\" property is used by scale binding to\n        // generate accessible name.\n        this.scrubber.durationValue = timeString;\n\n        this.scrubber.max = duration;\n        // XXX Can't set increment here, due to bug 473103. Also, doing so causes\n        // snapping when dragging with the mouse, so we can't just set a value for\n        // the arrow-keys.\n        this.scrubber.pageIncrement = Math.round(duration / 10);\n      },\n\n      pauseVideoDuringDragging() {\n        if (!this.video.paused &&\n            !this.isPausedByDragging &&\n            this.scrubber.isDragging) {\n          this.isPausedByDragging = true;\n          this.video.pause();\n        }\n      },\n\n      onScrubberInput(e) {\n        const duration = Math.round(this.video.duration * 1000); // in ms\n        let time = this.scrubber.value;\n\n        this.seekToPosition(time);\n        this.showPosition(time, duration);\n\n        this.scrubber.isDragging = true;\n        this.pauseVideoDuringDragging();\n      },\n\n      onScrubberChange(e) {\n        this.scrubber.isDragging = false;\n\n        if (this.isPausedByDragging) {\n          this.video.play();\n          this.isPausedByDragging = false;\n        }\n      },\n\n      updateScrubberProgress() {\n        if (this.videocontrols.isTouchControls) {\n          return;\n        }\n\n        const positionPercent = this.scrubber.value / this.scrubber.max * 100;\n\n        if (!isNaN(positionPercent) && positionPercent != Infinity) {\n          this.progressBar.value = positionPercent;\n        } else {\n          this.progressBar.value = 0;\n        }\n      },\n\n      seekToPosition(newPosition) {\n        newPosition /= 1000; // convert from ms\n        this.log(\"+++ seeking to \" + newPosition);\n        this.video.currentTime = newPosition;\n      },\n\n      setVolume(newVolume) {\n        this.log(\"*** setting volume to \" + newVolume);\n        this.video.volume = newVolume;\n        this.video.muted = false;\n      },\n\n      showPosition(currentTime, duration) {\n        // If the duration is unknown (because the server didn't provide\n        // it, or the video is a stream), then we want to fudge the duration\n        // by using the maximum playback position that's been seen.\n        if (currentTime > this.maxCurrentTimeSeen) {\n          this.maxCurrentTimeSeen = currentTime;\n        }\n        this.showDuration(duration);\n\n        this.log(\"time update @ \" + currentTime + \"ms of \" + duration + \"ms\");\n\n        let positionTime = this.formatTime(currentTime, this.showHours);\n\n        this.scrubber.value = currentTime;\n        if (this.videocontrols.isTouchControls) {\n          this.positionLabel.setAttribute(\"value\", positionTime);\n        } else {\n          this.positionDurationBox.position = positionTime;\n          this.updateScrubberProgress();\n        }\n      },\n\n      showBuffered() {\n        function bsearch(haystack, needle, cmp) {\n          var length = haystack.length;\n          var low = 0;\n          var high = length;\n          while (low < high) {\n            var probe = low + ((high - low) >> 1);\n            var r = cmp(haystack, probe, needle);\n            if (r == 0) {\n              return probe;\n            } else if (r > 0) {\n              low = probe + 1;\n            } else {\n              high = probe;\n            }\n          }\n          return -1;\n        }\n\n        function bufferedCompare(buffered, i, time) {\n          if (time > buffered.end(i)) {\n            return 1;\n          } else if (time >= buffered.start(i)) {\n            return 0;\n          }\n          return -1;\n        }\n\n        var duration = Math.round(this.video.duration * 1000);\n        if (isNaN(duration) || duration == Infinity) {\n          duration = this.maxCurrentTimeSeen;\n        }\n\n        // Find the range that the current play position is in and use that\n        // range for bufferBar.  At some point we may support multiple ranges\n        // displayed in the bar.\n        var currentTime = this.video.currentTime;\n        var buffered = this.video.buffered;\n        var index = bsearch(buffered, currentTime, bufferedCompare);\n        var endTime = 0;\n        if (index >= 0) {\n          endTime = Math.round(buffered.end(index) * 1000);\n        }\n        this.bufferBar.max = duration;\n        this.bufferBar.value = endTime;\n      },\n\n      _controlsHiddenByTimeout: false,\n      _showControlsTimeout: 0,\n      SHOW_CONTROLS_TIMEOUT_MS: 500,\n      _showControlsFn() {\n        if (Utils.video.matches(\"video:hover\")) {\n          Utils.startFadeIn(Utils.controlBar, false);\n          Utils._showControlsTimeout = 0;\n          Utils._controlsHiddenByTimeout = false;\n        }\n      },\n\n      _hideControlsTimeout: 0,\n      _hideControlsFn() {\n        if (!Utils.scrubber.isDragging) {\n          Utils.startFade(Utils.controlBar, false);\n          Utils._hideControlsTimeout = 0;\n          Utils._controlsHiddenByTimeout = true;\n        }\n      },\n      HIDE_CONTROLS_TIMEOUT_MS: 2000,\n      onMouseMove(event) {\n        // If the controls are static, don't change anything.\n        if (!this.dynamicControls) {\n          return;\n        }\n\n        clearTimeout(this._hideControlsTimeout);\n\n        // Suppress fading out the controls until the video has rendered\n        // its first frame. But since autoplay videos start off with no\n        // controls, let them fade-out so the controls don't get stuck on.\n        if (!this.firstFrameShown &&\n            !(this.video.autoplay && this.video.mozAutoplayEnabled)) {\n          return;\n        }\n\n        if (this._controlsHiddenByTimeout) {\n          this._showControlsTimeout = setTimeout(this._showControlsFn, this.SHOW_CONTROLS_TIMEOUT_MS);\n        } else {\n          this.startFade(this.controlBar, true);\n        }\n\n        // Hide the controls if the mouse cursor is left on top of the video\n        // but above the control bar and if the click-to-play overlay is hidden.\n        if ((this._controlsHiddenByTimeout ||\n            event.clientY < this.controlBar.getBoundingClientRect().top) &&\n            this.clickToPlay.hidden) {\n          this._hideControlsTimeout = setTimeout(this._hideControlsFn, this.HIDE_CONTROLS_TIMEOUT_MS);\n        }\n      },\n\n      onMouseInOut(event) {\n        // If the controls are static, don't change anything.\n        if (!this.dynamicControls) {\n          return;\n        }\n\n        clearTimeout(this._hideControlsTimeout);\n\n        // Ignore events caused by transitions between child nodes.\n        // Note that the videocontrols element is the same\n        // size as the *content area* of the video element,\n        // but this is not the same as the video element's\n        // border area if the video has border or padding.\n        if (this.isEventWithin(event, this.videocontrols)) {\n          return;\n        }\n\n        var isMouseOver = (event.type == \"mouseover\");\n\n        var controlRect = this.controlBar.getBoundingClientRect();\n        var isMouseInControls = event.clientY > controlRect.top &&\n        event.clientY < controlRect.bottom &&\n        event.clientX > controlRect.left &&\n        event.clientX < controlRect.right;\n\n        // Suppress fading out the controls until the video has rendered\n        // its first frame. But since autoplay videos start off with no\n        // controls, let them fade-out so the controls don't get stuck on.\n        if (!this.firstFrameShown && !isMouseOver &&\n            !(this.video.autoplay && this.video.mozAutoplayEnabled)) {\n          return;\n        }\n\n        if (!isMouseOver && !isMouseInControls) {\n          this.adjustControlSize();\n\n          // Keep the controls visible if the click-to-play is visible.\n          if (!this.clickToPlay.hidden) {\n            return;\n          }\n\n          this.startFadeOut(this.controlBar, false);\n          this.textTrackList.setAttribute(\"hidden\", \"true\");\n          clearTimeout(this._showControlsTimeout);\n          Utils._controlsHiddenByTimeout = false;\n        }\n      },\n\n      startFadeIn(element, immediate) {\n        this.startFade(element, true, immediate);\n      },\n\n      startFadeOut(element, immediate) {\n        this.startFade(element, false, immediate);\n      },\n\n      startFade(element, fadeIn, immediate) {\n        if (element.classList.contains(\"controlBar\") && fadeIn) {\n          // Bug 493523, the scrubber doesn't call valueChanged while hidden,\n          // so our dependent state (eg, timestamp in the thumb) will be stale.\n          // As a workaround, update it manually when it first becomes unhidden.\n          if (element.hidden) {\n            if (this.videocontrols.isTouchControls) {\n              this.scrubber.valueChanged(\"curpos\", this.video.currentTime * 1000, false);\n            } else {\n              this.scrubber.value = this.video.currentTime * 1000;\n            }\n          }\n        }\n\n        if (immediate) {\n          element.setAttribute(\"immediate\", true);\n        } else {\n          element.removeAttribute(\"immediate\");\n        }\n\n        if (fadeIn) {\n          // hidden state should be controlled by adjustControlSize\n          if (!(element.isAdjustableControl && element.hideByAdjustment)) {\n            element.hidden = false;\n          }\n          // force style resolution, so that transition begins\n          // when we remove the attribute.\n          element.clientTop;\n          element.removeAttribute(\"fadeout\");\n          if (element.classList.contains(\"controlBar\")) {\n            this.controlsSpacer.removeAttribute(\"hideCursor\");\n          }\n        } else {\n          element.setAttribute(\"fadeout\", true);\n          if (element.classList.contains(\"controlBar\") && !this.hasError() &&\n              document.mozFullScreenElement == this.video) {\n            this.controlsSpacer.setAttribute(\"hideCursor\", true);\n          }\n        }\n      },\n\n      onTransitionEnd(event) {\n        // Ignore events for things other than opacity changes.\n        if (event.propertyName != \"opacity\") {\n          return;\n        }\n\n        var element = event.originalTarget;\n\n        // Nothing to do when a fade *in* finishes.\n        if (!element.hasAttribute(\"fadeout\")) {\n          return;\n        }\n\n        if (this.videocontrols.isTouchControls) {\n          this.scrubber.dragStateChanged(false);\n        }\n        element.hidden = true;\n      },\n\n      _triggeredByControls: false,\n\n      startPlay() {\n        this._triggeredByControls = true;\n        this.hideClickToPlay();\n        this.video.play();\n      },\n\n      togglePause() {\n        if (this.video.paused || this.video.ended) {\n          this.startPlay();\n        } else {\n          this.video.pause();\n        }\n\n        // We'll handle style changes in the event listener for\n        // the \"play\" and \"pause\" events, same as if content\n        // script was controlling video playback.\n      },\n\n      isVideoWithoutAudioTrack() {\n        return this.video.readyState >= this.video.HAVE_METADATA &&\n               !this.isAudioOnly &&\n               !this.video.mozHasAudio;\n      },\n\n      toggleMute() {\n        if (this.isVideoWithoutAudioTrack()) {\n          return;\n        }\n        this.video.muted = !this.isEffectivelyMuted();\n        if (this.video.volume === 0) {\n          this.video.volume = 0.5;\n        }\n\n        // We'll handle style changes in the event listener for\n        // the \"volumechange\" event, same as if content script was\n        // controlling volume.\n      },\n\n      isVideoInFullScreen() {\n        return document.mozFullScreenElement == this.video;\n      },\n\n      toggleFullscreen() {\n        this.isVideoInFullScreen() ?\n          document.mozCancelFullScreen() :\n          this.video.mozRequestFullScreen();\n      },\n\n      setFullscreenButtonState() {\n        if (this.isAudioOnly || !document.mozFullScreenEnabled) {\n          this.controlBar.setAttribute(\"fullscreen-unavailable\", true);\n          this.adjustControlSize();\n          return;\n        }\n        this.controlBar.removeAttribute(\"fullscreen-unavailable\");\n        this.adjustControlSize();\n\n        var attrName = this.isVideoInFullScreen() ? \"exitfullscreenlabel\" : \"enterfullscreenlabel\";\n        var value = this.fullscreenButton.getAttribute(attrName);\n        this.fullscreenButton.setAttribute(\"aria-label\", value);\n\n        if (this.isVideoInFullScreen()) {\n          this.fullscreenButton.setAttribute(\"fullscreened\", \"true\");\n        } else {\n          this.fullscreenButton.removeAttribute(\"fullscreened\");\n        }\n      },\n\n      onFullscreenChange() {\n        this.updateOrientationState(this.isVideoInFullScreen());\n        if (this.isVideoInFullScreen()) {\n          Utils._hideControlsTimeout = setTimeout(this._hideControlsFn, this.HIDE_CONTROLS_TIMEOUT_MS);\n        }\n        this.setFullscreenButtonState();\n      },\n\n      updateOrientationState(lock) {\n        if (!this.video.mozOrientationLockEnabled) {\n          return;\n        }\n        if (lock) {\n          if (this.video.mozIsOrientationLocked) {\n            return;\n          }\n          let dimenDiff = this.video.videoWidth - this.video.videoHeight;\n          if (dimenDiff > 0) {\n            this.video.mozIsOrientationLocked = window.screen.mozLockOrientation(\"landscape\");\n          } else if (dimenDiff < 0) {\n            this.video.mozIsOrientationLocked = window.screen.mozLockOrientation(\"portrait\");\n          } else {\n            this.video.mozIsOrientationLocked = window.screen.mozLockOrientation(window.screen.orientation);\n          }\n        } else {\n          if (!this.video.mozIsOrientationLocked) {\n            return;\n          }\n          window.screen.mozUnlockOrientation();\n          this.video.mozIsOrientationLocked = false;\n        }\n      },\n\n      clickToPlayClickHandler(e) {\n        if (e.button != 0) {\n          return;\n        }\n        if (this.hasError() && !this.suppressError) {\n          // Errors that can be dismissed should be placed here as we discover them.\n          if (this.video.error.code != this.video.error.MEDIA_ERR_ABORTED) {\n            return;\n          }\n          this.statusOverlay.hidden = true;\n          this.suppressError = true;\n          return;\n        }\n        if (e.defaultPrevented) {\n          return;\n        }\n        if (this.playButton.hasAttribute(\"paused\")) {\n          this.startPlay();\n        } else {\n          this.video.pause();\n        }\n      },\n      hideClickToPlay() {\n        let videoHeight = this.video.clientHeight;\n        let videoWidth = this.video.clientWidth;\n\n        // The play button will animate to 3x its size. This\n        // shows the animation unless the video is too small\n        // to show 2/3 of the animation.\n        let animationScale = 2;\n        let animationMinSize = this.clickToPlay.minWidth * animationScale;\n\n        if (animationMinSize > videoWidth ||\n            animationMinSize > (videoHeight - this.controlBarMinHeight)) {\n          this.clickToPlay.setAttribute(\"immediate\", \"true\");\n          this.clickToPlay.hidden = true;\n        } else {\n          this.clickToPlay.removeAttribute(\"immediate\");\n        }\n        this.clickToPlay.setAttribute(\"fadeout\", \"true\");\n        this.controlsSpacer.setAttribute(\"fadeout\", \"true\");\n      },\n\n      setPlayButtonState(aPaused) {\n        if (aPaused) {\n          this.playButton.setAttribute(\"paused\", \"true\");\n        } else {\n          this.playButton.removeAttribute(\"paused\");\n        }\n\n        var attrName = aPaused ? \"playlabel\" : \"pauselabel\";\n        var value = this.playButton.getAttribute(attrName);\n        this.playButton.setAttribute(\"aria-label\", value);\n      },\n\n      isEffectivelyMuted() {\n        return this.video.muted || !this.video.volume;\n      },\n\n      updateMuteButtonState() {\n        var muted = this.isEffectivelyMuted();\n\n        if (muted) {\n          this.muteButton.setAttribute(\"muted\", \"true\");\n        } else {\n          this.muteButton.removeAttribute(\"muted\");\n        }\n\n        var attrName = muted ? \"unmutelabel\" : \"mutelabel\";\n        var value = this.muteButton.getAttribute(attrName);\n        this.muteButton.setAttribute(\"aria-label\", value);\n      },\n\n      _getComputedPropertyValueAsInt(element, property) {\n        let value = getComputedStyle(element, null).getPropertyValue(property);\n        return parseInt(value, 10);\n      },\n\n      keyHandler(event) {\n        // Ignore keys when content might be providing its own.\n        if (!this.video.hasAttribute(\"controls\")) {\n          return;\n        }\n\n        var keystroke = \"\";\n        if (event.altKey) {\n          keystroke += \"alt-\";\n        }\n        if (event.shiftKey) {\n          keystroke += \"shift-\";\n        }\n        if (navigator.platform.startsWith(\"Mac\")) {\n          if (event.metaKey) {\n            keystroke += \"accel-\";\n          }\n          if (event.ctrlKey) {\n            keystroke += \"control-\";\n          }\n        } else {\n          if (event.metaKey) {\n            keystroke += \"meta-\";\n          }\n          if (event.ctrlKey) {\n            keystroke += \"accel-\";\n          }\n        }\n        switch (event.keyCode) {\n          case KeyEvent.DOM_VK_UP:\n            keystroke += \"upArrow\";\n            break;\n          case KeyEvent.DOM_VK_DOWN:\n            keystroke += \"downArrow\";\n            break;\n          case KeyEvent.DOM_VK_LEFT:\n            keystroke += \"leftArrow\";\n            break;\n          case KeyEvent.DOM_VK_RIGHT:\n            keystroke += \"rightArrow\";\n            break;\n          case KeyEvent.DOM_VK_HOME:\n            keystroke += \"home\";\n            break;\n          case KeyEvent.DOM_VK_END:\n            keystroke += \"end\";\n            break;\n        }\n\n        if (String.fromCharCode(event.charCode) == \" \") {\n          keystroke += \"space\";\n        }\n\n        this.log(\"Got keystroke: \" + keystroke);\n        var oldval, newval;\n\n        try {\n          switch (keystroke) {\n            case \"space\": /* Play */\n              let target = event.originalTarget;\n              if (target.localName === \"button\" && !target.disabled) {\n                break;\n              }\n\n              this.togglePause();\n              break;\n            case \"downArrow\": /* Volume decrease */\n              oldval = this.video.volume;\n              this.video.volume = (oldval < 0.1 ? 0 : oldval - 0.1);\n              this.video.muted = false;\n              break;\n            case \"upArrow\": /* Volume increase */\n              oldval = this.video.volume;\n              this.video.volume = (oldval > 0.9 ? 1 : oldval + 0.1);\n              this.video.muted = false;\n              break;\n            case \"accel-downArrow\": /* Mute */\n              this.video.muted = true;\n              break;\n            case \"accel-upArrow\": /* Unmute */\n              this.video.muted = false;\n              break;\n            case \"leftArrow\": /* Seek back 15 seconds */\n            case \"accel-leftArrow\": /* Seek back 10% */\n              oldval = this.video.currentTime;\n              if (keystroke == \"leftArrow\") {\n                newval = oldval - 15;\n              } else {\n                newval = oldval - (this.video.duration || this.maxCurrentTimeSeen / 1000) / 10;\n              }\n              this.video.currentTime = (newval >= 0 ? newval : 0);\n              break;\n            case \"rightArrow\": /* Seek forward 15 seconds */\n            case \"accel-rightArrow\": /* Seek forward 10% */\n              oldval = this.video.currentTime;\n              var maxtime = (this.video.duration || this.maxCurrentTimeSeen / 1000);\n              if (keystroke == \"rightArrow\") {\n                newval = oldval + 15;\n              } else {\n                newval = oldval + maxtime / 10;\n              }\n              this.video.currentTime = (newval <= maxtime ? newval : maxtime);\n              break;\n            case \"home\": /* Seek to beginning */\n              this.video.currentTime = 0;\n              break;\n            case \"end\": /* Seek to end */\n              if (this.video.currentTime != this.video.duration) {\n                this.video.currentTime = (this.video.duration || this.maxCurrentTimeSeen / 1000);\n              }\n              break;\n            default:\n              return;\n          }\n        } catch (e) { /* ignore any exception from setting .currentTime */ }\n\n        event.preventDefault(); // Prevent page scrolling\n      },\n\n      isSupportedTextTrack(textTrack) {\n        return textTrack.kind == \"subtitles\" ||\n               textTrack.kind == \"captions\";\n      },\n\n      get isClosedCaptionAvailable() {\n        return this.overlayableTextTracks.length && !this.videocontrols.isTouchControls;\n      },\n\n      get overlayableTextTracks() {\n        return Array.prototype.filter.call(this.video.textTracks, this.isSupportedTextTrack);\n      },\n\n      get currentTextTrackIndex() {\n        const showingTT = this.overlayableTextTracks.find(tt => tt.mode == \"showing\");\n\n        // fallback to off button if there's no showing track.\n        return showingTT ? showingTT.index : 0;\n      },\n\n      isClosedCaptionOn() {\n        for (let tt of this.overlayableTextTracks) {\n          if (tt.mode === \"showing\") {\n            return true;\n          }\n        }\n\n        return false;\n      },\n\n      setClosedCaptionButtonState() {\n        if (this.isClosedCaptionOn()) {\n          this.closedCaptionButton.setAttribute(\"enabled\", \"true\");\n        } else {\n          this.closedCaptionButton.removeAttribute(\"enabled\");\n        }\n\n        let ttItems = this.textTrackList.childNodes;\n\n        for (let tti of ttItems) {\n          const idx = +tti.getAttribute(\"index\");\n\n          if (idx == this.currentTextTrackIndex) {\n            tti.setAttribute(\"on\", \"true\");\n          } else {\n            tti.removeAttribute(\"on\");\n          }\n        }\n\n        this.adjustControlSize();\n      },\n\n      addNewTextTrack(tt) {\n        if (!this.isSupportedTextTrack(tt)) {\n          return;\n        }\n\n        if (tt.index && tt.index < this.textTracksCount) {\n          // Don't create items for initialized tracks. However, we\n          // still need to care about mode since TextTrackManager would\n          // turn on the first available track automatically.\n          if (tt.mode === \"showing\") {\n            this.changeTextTrack(tt.index);\n          }\n          return;\n        }\n\n        tt.index = this.textTracksCount++;\n\n        const label = tt.label || \"\";\n        const ttText = document.createTextNode(label);\n        const ttBtn = document.createElement(\"button\");\n\n        ttBtn.classList.add(\"textTrackItem\");\n        ttBtn.setAttribute(\"index\", tt.index);\n\n        ttBtn.addEventListener(\"click\", event => {\n          event.stopPropagation();\n\n          this.changeTextTrack(tt.index);\n        });\n\n        ttBtn.appendChild(ttText);\n\n        this.textTrackList.appendChild(ttBtn);\n\n        if (tt.mode === \"showing\" && tt.index) {\n          this.changeTextTrack(tt.index);\n        }\n      },\n\n      changeTextTrack(index) {\n        for (let tt of this.overlayableTextTracks) {\n          if (tt.index === index) {\n            tt.mode = \"showing\";\n          } else {\n            tt.mode = \"disabled\";\n          }\n        }\n\n        this.textTrackList.setAttribute(\"hidden\", \"true\");\n      },\n\n      onControlBarTransitioned() {\n        this.textTrackList.setAttribute(\"hidden\", \"true\");\n        this.video.dispatchEvent(new CustomEvent(\"controlbarchange\"));\n        this.adjustControlSize();\n      },\n\n      toggleClosedCaption() {\n        if (this.textTrackList.hasAttribute(\"hidden\")) {\n          this.textTrackList.removeAttribute(\"hidden\");\n        } else {\n          this.textTrackList.setAttribute(\"hidden\", \"true\");\n        }\n      },\n\n      onTextTrackAdd(trackEvent) {\n        this.addNewTextTrack(trackEvent.track);\n        this.setClosedCaptionButtonState();\n      },\n\n      onTextTrackRemove(trackEvent) {\n        const toRemoveIndex = trackEvent.track.index;\n        const ttItems = this.textTrackList.childNodes;\n\n        if (!ttItems) {\n          return;\n        }\n\n        for (let tti of ttItems) {\n          const idx = +tti.getAttribute(\"index\");\n\n          if (idx === toRemoveIndex) {\n            tti.remove();\n            this.textTracksCount--;\n          }\n\n          this.video.dispatchEvent(new CustomEvent(\"texttrackchange\"));\n        }\n\n        this.setClosedCaptionButtonState();\n      },\n\n      initTextTracks() {\n        // add 'off' button anyway as new text track might be\n        // dynamically added after initialization.\n        const offLabel = this.textTrackList.getAttribute(\"offlabel\");\n        this.addNewTextTrack({\n          label: offLabel,\n          kind: \"subtitles\"\n        });\n\n        for (let tt of this.overlayableTextTracks) {\n          this.addNewTextTrack(tt);\n        }\n\n        this.setClosedCaptionButtonState();\n      },\n\n      isEventWithin(event, parent1, parent2) {\n        function isDescendant(node) {\n          while (node) {\n            if (node == parent1 || node == parent2) {\n              return true;\n            }\n            node = node.parentNode;\n          }\n          return false;\n        }\n        return isDescendant(event.target) && isDescendant(event.relatedTarget);\n      },\n\n      log(msg) {\n        if (this.debug) {\n          console.log(\"videoctl: \" + msg + \"\\n\");\n        }\n      },\n\n      get isTopLevelSyntheticDocument() {\n        let doc = this.video.ownerDocument;\n        let win = doc.defaultView;\n        return doc.mozSyntheticDocument && win === win.top;\n      },\n\n      controlBarMinHeight: 40,\n      controlBarMinVisibleHeight: 28,\n      adjustControlSize() {\n        if (this.videocontrols.isTouchControls) {\n          return;\n        }\n\n        const minControlBarPaddingWidth = 18;\n\n        this.fullscreenButton.isWanted = !this.controlBar.hasAttribute(\"fullscreen-unavailable\");\n        this.closedCaptionButton.isWanted = this.isClosedCaptionAvailable;\n        this.volumeStack.isWanted = !this.muteButton.hasAttribute(\"noAudio\");\n\n        let minRequiredWidth = this.prioritizedControls\n          .filter(control => control && control.isWanted)\n          .reduce((accWidth, cc) => accWidth + cc.minWidth, minControlBarPaddingWidth);\n        // Skip the adjustment in case the stylesheets haven't been loaded yet.\n        if (!minRequiredWidth) {\n          return;\n        }\n\n        let givenHeight = this.video.clientHeight;\n        let videoWidth = (this.isAudioOnly ?\n                          this.videocontrols.clientWidth :\n                          this.video.clientWidth) || minRequiredWidth;\n        let videoHeight = this.isAudioOnly ? this.controlBarMinHeight : givenHeight;\n        let videocontrolsWidth = this.videocontrols.clientWidth;\n\n        let widthUsed = minControlBarPaddingWidth;\n        let preventAppendControl = false;\n\n        for (let control of this.prioritizedControls) {\n          if (!control.isWanted) {\n            control.hideByAdjustment = true;\n            continue;\n          }\n\n          control.hideByAdjustment = preventAppendControl ||\n          widthUsed + control.minWidth > videoWidth;\n\n          if (control.hideByAdjustment) {\n            preventAppendControl = true;\n          } else {\n            widthUsed += control.minWidth;\n          }\n        }\n\n        // Use flexible spacer to separate controls when scrubber is hidden.\n        // As long as muteButton hidden, which means only play button presents,\n        // hide spacer and make playButton centered.\n        this.controlBarSpacer.hidden = !this.scrubberStack.hidden || this.muteButton.hidden;\n\n        // Since the size of videocontrols is expanded with controlBar in <audio>, we\n        // should fix the dimensions in order not to recursively trigger reflow afterwards.\n        if (this.video instanceof HTMLAudioElement) {\n          if (givenHeight) {\n            // The height of controlBar should be capped with the bounds between controlBarMinHeight\n            // and controlBarMinVisibleHeight.\n            let controlBarHeight = Math.max(Math.min(givenHeight, this.controlBarMinHeight), this.controlBarMinVisibleHeight);\n            this.controlBar.style.height = `${controlBarHeight}px`;\n          }\n          // Bug 1367875: Set minimum required width to controlBar if the given size is smaller than padding.\n          // This can help us expand the control and restore to the default size the next time we need\n          // to adjust the sizing.\n          if (videocontrolsWidth <= minControlBarPaddingWidth) {\n            this.controlBar.style.width = `${minRequiredWidth}px`;\n          } else {\n            this.controlBar.style.width = `${videoWidth}px`;\n          }\n          return;\n        }\n\n        if (videoHeight < this.controlBarMinHeight ||\n            widthUsed === minControlBarPaddingWidth) {\n          this.controlBar.setAttribute(\"size\", \"hidden\");\n          this.controlBar.hideByAdjustment = true;\n        } else {\n          this.controlBar.removeAttribute(\"size\");\n          this.controlBar.hideByAdjustment = false;\n        }\n\n        // Adjust clickToPlayButton size.\n        const minVideoSideLength = Math.min(videoWidth, videoHeight);\n        const clickToPlayViewRatio = 0.15;\n        const clickToPlayScaledSize = Math.max(\n        this.clickToPlay.minWidth, minVideoSideLength * clickToPlayViewRatio);\n\n        if (clickToPlayScaledSize >= videoWidth ||\n           (clickToPlayScaledSize + this.controlBarMinHeight / 2 >= videoHeight / 2 )) {\n          this.clickToPlay.hideByAdjustment = true;\n        } else {\n          if (this.clickToPlay.hidden && !this.video.played.length && this.video.paused) {\n            this.clickToPlay.hideByAdjustment = false;\n          }\n          this.clickToPlay.style.width = `${clickToPlayScaledSize}px`;\n          this.clickToPlay.style.height = `${clickToPlayScaledSize}px`;\n        }\n      },\n\n      init(binding) {\n        this.video = binding.parentNode;\n        this.videocontrols = binding;\n\n        this.controlsContainer    = document.getAnonymousElementByAttribute(binding, \"anonid\", \"controlsContainer\");\n        this.statusIcon    = document.getAnonymousElementByAttribute(binding, \"anonid\", \"statusIcon\");\n        this.controlBar    = document.getAnonymousElementByAttribute(binding, \"anonid\", \"controlBar\");\n        this.playButton    = document.getAnonymousElementByAttribute(binding, \"anonid\", \"playButton\");\n        this.controlBarSpacer    = document.getAnonymousElementByAttribute(binding, \"anonid\", \"controlBarSpacer\");\n        this.muteButton    = document.getAnonymousElementByAttribute(binding, \"anonid\", \"muteButton\");\n        this.volumeStack   = document.getAnonymousElementByAttribute(binding, \"anonid\", \"volumeStack\");\n        this.volumeControl = document.getAnonymousElementByAttribute(binding, \"anonid\", \"volumeControl\");\n        this.progressBar   = document.getAnonymousElementByAttribute(binding, \"anonid\", \"progressBar\");\n        this.bufferBar     = document.getAnonymousElementByAttribute(binding, \"anonid\", \"bufferBar\");\n        this.scrubberStack = document.getAnonymousElementByAttribute(binding, \"anonid\", \"scrubberStack\");\n        this.scrubber      = document.getAnonymousElementByAttribute(binding, \"anonid\", \"scrubber\");\n        this.durationLabel = document.getAnonymousElementByAttribute(binding, \"anonid\", \"durationLabel\");\n        this.positionLabel = document.getAnonymousElementByAttribute(binding, \"anonid\", \"positionLabel\");\n        this.positionDurationBox   = document.getAnonymousElementByAttribute(binding, \"anonid\", \"positionDurationBox\");\n        this.statusOverlay = document.getAnonymousElementByAttribute(binding, \"anonid\", \"statusOverlay\");\n        this.controlsOverlay = document.getAnonymousElementByAttribute(binding, \"anonid\", \"controlsOverlay\");\n        this.controlsSpacer     = document.getAnonymousElementByAttribute(binding, \"anonid\", \"controlsSpacer\");\n        this.clickToPlay        = document.getAnonymousElementByAttribute(binding, \"anonid\", \"clickToPlay\");\n        this.fullscreenButton   = document.getAnonymousElementByAttribute(binding, \"anonid\", \"fullscreenButton\");\n        this.closedCaptionButton = document.getAnonymousElementByAttribute(binding, \"anonid\", \"closedCaptionButton\");\n        this.textTrackList = document.getAnonymousElementByAttribute(binding, \"anonid\", \"textTrackList\");\n\n        if (this.positionDurationBox) {\n          this.durationSpan = this.positionDurationBox.getElementsByTagName(\"span\")[0];\n        }\n\n        this.controlBarComputedStyles = getComputedStyle(this.controlBar);\n\n        // Hide and show control in certain order.\n        this.prioritizedControls = [\n          this.playButton,\n          this.muteButton,\n          this.fullscreenButton,\n          this.closedCaptionButton,\n          this.positionDurationBox,\n          this.scrubberStack,\n          this.durationSpan,\n          this.volumeStack\n        ];\n\n        // XXX controlsContainer is a desktop only element. To determine whether\n        // isTouchControls or not during the whole initialization process, get\n        // this state overridden here.\n        this.videocontrols.isTouchControls = !this.controlsContainer;\n        this.isAudioOnly = (this.video instanceof HTMLAudioElement);\n        this.setupInitialState();\n        this.setupNewLoadState();\n        this.initTextTracks();\n\n        // Use the handleEvent() callback for all media events.\n        // Only the \"error\" event listener must capture, so that it can trap error\n        // events from <source> children, which don't bubble. But we use capture\n        // for all events in order to simplify the event listener add/remove.\n        for (let event of this.videoEvents) {\n          this.video.addEventListener(event, this, {\n            capture: true,\n            mozSystemGroup: true\n          });\n        }\n\n        var self = this;\n        this.controlListeners = [];\n\n        // Helper function to add an event listener to the given element\n        // Due to this helper function, \"Utils\" is made available to the event\n        // listener functions. Hence declare it as a global for ESLint.\n        /* global Utils */\n        function addListener(elem, eventName, func, capture = false) {\n          let boundFunc = func.bind(self);\n          self.controlListeners.push({ item: elem, event: eventName, func: boundFunc, capture });\n          elem.addEventListener(eventName, boundFunc, { mozSystemGroup: true, capture });\n        }\n\n        addListener(this.muteButton, \"click\", this.toggleMute);\n        addListener(this.closedCaptionButton, \"click\", this.toggleClosedCaption);\n        addListener(this.fullscreenButton, \"click\", this.toggleFullscreen);\n        addListener(this.playButton, \"click\", this.clickToPlayClickHandler);\n        addListener(this.clickToPlay, \"click\", this.clickToPlayClickHandler);\n        addListener(this.controlsSpacer, \"click\", this.clickToPlayClickHandler);\n        addListener(this.controlsSpacer, \"dblclick\", this.toggleFullscreen);\n\n        addListener(this.videocontrols, \"resizevideocontrols\", this.adjustControlSize);\n        addListener(this.videocontrols, \"transitionend\", this.onTransitionEnd);\n        addListener(this.video.ownerDocument, \"mozfullscreenchange\", this.onFullscreenChange);\n        addListener(this.controlBar, \"transitionend\", this.onControlBarTransitioned);\n        addListener(this.video.ownerDocument, \"fullscreenchange\", this.onFullscreenChange);\n        addListener(this.video, \"keypress\", this.keyHandler, true);\n\n        addListener(this.videocontrols, \"dragstart\", function(event) {\n          event.preventDefault(); // prevent dragging of controls image (bug 517114)\n        });\n\n        if (!this.videocontrols.isTouchControls) {\n          addListener(this.scrubber, \"input\", this.onScrubberInput);\n          addListener(this.scrubber, \"change\", this.onScrubberChange);\n          // add mouseup listener additionally to handle the case that `change` event\n          // isn't fired when the input value before/after dragging are the same. (bug 1328061)\n          addListener(this.scrubber, \"mouseup\", this.onScrubberChange);\n          addListener(this.volumeControl, \"input\", this.updateVolume);\n          addListener(this.video.textTracks, \"addtrack\", this.onTextTrackAdd);\n          addListener(this.video.textTracks, \"removetrack\", this.onTextTrackRemove);\n          addListener(this.video.textTracks, \"change\", this.setClosedCaptionButtonState);\n        }\n\n        this.log(\"--- videocontrols initialized ---\");\n      }\n    };\n\n    this.Utils.init(this);\n    ]]>\n  </constructor>\n  <destructor>\n    <![CDATA[\n    this.Utils.terminateEventListeners();\n    this.Utils.updateOrientationState(false);\n    // randomID used to be a <field>, which meant that the XBL machinery\n    // undefined the property when the element was unbound. The code in\n    // this file actually depends on this, so now that randomID is an\n    // expando, we need to make sure to explicitly delete it.\n    delete this.randomID;\n    ]]>\n  </destructor>\n\n  </implementation>\n\n  <handlers>\n    <handler event=\"mouseover\">\n      if (!this.isTouchControls) {\n        this.Utils.onMouseInOut(event);\n      }\n    </handler>\n    <handler event=\"mouseout\">\n      if (!this.isTouchControls) {\n        this.Utils.onMouseInOut(event);\n      }\n    </handler>\n    <handler event=\"mousemove\">\n      if (!this.isTouchControls) {\n        this.Utils.onMouseMove(event);\n      }\n    </handler>\n  </handlers>\n</binding>\n\n<binding id=\"touchControls\" extends=\"chrome://global/content/bindings/videocontrols.xml#videoControls\">\n\n  <xbl:content xmlns=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\" class=\"mediaControlsFrame\">\n    <stack flex=\"1\">\n      <vbox anonid=\"statusOverlay\" flex=\"1\" class=\"statusOverlay\" hidden=\"true\">\n        <box anonid=\"statusIcon\" class=\"statusIcon\"/>\n        <label class=\"errorLabel\" anonid=\"errorAborted\">FROM-DTD-error-aborted</label>\n        <label class=\"errorLabel\" anonid=\"errorNetwork\">FROM-DTD-error-network</label>\n        <label class=\"errorLabel\" anonid=\"errorDecode\">FROM-DTD-error-decode</label>\n        <label class=\"errorLabel\" anonid=\"errorSrcNotSupported\">FROM-DTD-error-srcNotSupported</label>\n        <label class=\"errorLabel\" anonid=\"errorNoSource\">FROM-DTD-error-noSource2</label>\n        <label class=\"errorLabel\" anonid=\"errorGeneric\">FROM-DTD-error-generic</label>\n      </vbox>\n\n      <vbox anonid=\"controlsOverlay\" class=\"controlsOverlay\">\n        <spacer anonid=\"controlsSpacer\" class=\"controlsSpacer\" flex=\"1\"/>\n        <box flex=\"1\" hidden=\"true\">\n          <box anonid=\"clickToPlay\" class=\"clickToPlay\" hidden=\"true\" flex=\"1\"/>\n          <vbox anonid=\"textTrackList\" class=\"textTrackList\" hidden=\"true\" offlabel=\"FROM-DTD-closedCaption-off\"></vbox>\n        </box>\n        <vbox anonid=\"controlBar\" class=\"controlBar\" hidden=\"true\">\n          <hbox class=\"buttonsBar\">\n            <button anonid=\"playButton\"\n                    class=\"playButton\"\n                    playlabel=\"FROM-DTD-playButton-playLabel\"\n                    pauselabel=\"FROM-DTD-playButton-pauseLabel\"/>\n            <label anonid=\"positionLabel\" class=\"positionLabel\" role=\"presentation\"/>\n            <stack anonid=\"scrubberStack\" class=\"scrubberStack\">\n              <box class=\"backgroundBar\"/>\n              <progressmeter class=\"flexibleBar\" value=\"100\"/>\n              <progressmeter anonid=\"bufferBar\" class=\"bufferBar\"/>\n              <progressmeter anonid=\"progressBar\" class=\"progressBar\" max=\"10000\"/>\n              <scale anonid=\"scrubber\" class=\"scrubber\" movetoclick=\"true\"/>\n            </stack>\n            <label anonid=\"durationLabel\" class=\"durationLabel\" role=\"presentation\"/>\n            <button anonid=\"muteButton\"\n                    class=\"muteButton\"\n                    mutelabel=\"FROM-DTD-muteButton-muteLabel\"\n                    unmutelabel=\"FROM-DTD-muteButton-unmuteLabel\"/>\n            <stack anonid=\"volumeStack\" class=\"volumeStack\">\n              <box anonid=\"volumeBackground\" class=\"volumeBackground\"/>\n              <box anonid=\"volumeForeground\" class=\"volumeForeground\"/>\n              <scale anonid=\"volumeControl\" class=\"volumeControl\" movetoclick=\"true\"/>\n            </stack>\n            <button anonid=\"castingButton\" class=\"castingButton\" hidden=\"true\"\n                    aria-label=\"FROM-DTD-castingButton-castingLabel\"/>\n            <button anonid=\"closedCaptionButton\" class=\"closedCaptionButton\" hidden=\"true\"/>\n            <button anonid=\"fullscreenButton\"\n                    class=\"fullscreenButton\"\n                    enterfullscreenlabel=\"FROM-DTD-fullscreenButton-enterfullscreenlabel\"\n                    exitfullscreenlabel=\"FROM-DTD-fullscreenButton-exitfullscreenlabel\"/>\n          </hbox>\n        </vbox>\n      </vbox>\n    </stack>\n  </xbl:content>\n\n  <implementation>\n  <constructor>\n    <![CDATA[\n    this.isTouchControls = true;\n    this.TouchUtils = {\n      videocontrols: null,\n      video: null,\n      controlsTimer: null,\n      controlsTimeout: 5000,\n      positionLabel: null,\n      castingButton: null,\n\n      get Utils() {\n        return this.videocontrols.Utils;\n      },\n\n      get visible() {\n        return !this.Utils.controlBar.hasAttribute(\"fadeout\") &&\n               !(this.Utils.controlBar.getAttribute(\"hidden\") == \"true\");\n      },\n\n      _firstShow: false,\n      get firstShow() { return this._firstShow; },\n      set firstShow(val) {\n        this._firstShow = val;\n        this.Utils.controlBar.setAttribute(\"firstshow\", val);\n      },\n\n      toggleControls() {\n        if (!this.Utils.dynamicControls || !this.visible) {\n          this.showControls();\n        } else {\n          this.delayHideControls(0);\n        }\n      },\n\n      showControls() {\n        if (this.Utils.dynamicControls) {\n          this.Utils.startFadeIn(this.Utils.controlBar);\n          this.delayHideControls(this.controlsTimeout);\n        }\n      },\n\n      clearTimer() {\n        if (this.controlsTimer) {\n          clearTimeout(this.controlsTimer);\n          this.controlsTimer = null;\n        }\n      },\n\n      delayHideControls(aTimeout) {\n        this.clearTimer();\n        let self = this;\n        this.controlsTimer = setTimeout(function() {\n          self.hideControls();\n        }, aTimeout);\n      },\n\n      hideControls() {\n        if (!this.Utils.dynamicControls) {\n          return;\n        }\n        this.Utils.startFadeOut(this.Utils.controlBar);\n        if (this.firstShow) {\n          this.videocontrols.addEventListener(\"transitionend\", this);\n        }\n      },\n\n      handleEvent(aEvent) {\n        if (aEvent.type == \"transitionend\") {\n          this.firstShow = false;\n          try {\n            this.videocontrols.removeEventListener(\"transitionend\", this);\n          } catch (ex) {}\n          return;\n        }\n\n        if (this.videocontrols.randomID != this.Utils.randomID) {\n          this.terminateEventListeners();\n        }\n      },\n\n      terminateEventListeners() {\n        for (var event of this.videoEvents) {\n          try {\n            this.Utils.video.removeEventListener(event, this);\n          } catch (ex) {}\n        }\n      },\n\n      isVideoCasting() {\n        return this.video.mozIsCasting;\n      },\n\n      updateCasting(eventDetail) {\n        let castingData = JSON.parse(eventDetail);\n        if (\"allow\" in castingData) {\n          this.video.mozAllowCasting = !!castingData.allow;\n        }\n\n        if (\"active\" in castingData) {\n          this.video.mozIsCasting = !!castingData.active;\n        }\n        this.setCastButtonState();\n      },\n\n      startCasting() {\n        this.videocontrols.dispatchEvent(new CustomEvent(\"VideoBindingCast\"));\n      },\n\n      setCastButtonState() {\n        if (this.isAudioOnly || !this.video.mozAllowCasting) {\n          this.castingButton.hidden = true;\n          return;\n        }\n\n        if (this.video.mozIsCasting) {\n          this.castingButton.setAttribute(\"active\", \"true\");\n        } else {\n          this.castingButton.removeAttribute(\"active\");\n        }\n\n        this.castingButton.hidden = false;\n      },\n\n      init(binding) {\n        this.videocontrols = binding;\n        this.video = binding.parentNode;\n\n        let self = this;\n        this.Utils.playButton.addEventListener(\"command\", function() {\n          if (!self.video.paused) {\n            self.delayHideControls(0);\n          } else {\n            self.showControls();\n          }\n        });\n        this.Utils.scrubber.addEventListener(\"touchstart\", function() {\n          self.clearTimer();\n        });\n        this.Utils.scrubber.addEventListener(\"touchend\", function() {\n          self.delayHideControls(self.controlsTimeout);\n        });\n        this.Utils.muteButton.addEventListener(\"click\", function() { self.delayHideControls(self.controlsTimeout); });\n\n        this.castingButton = document.getAnonymousElementByAttribute(binding, \"anonid\", \"castingButton\");\n        this.castingButton.addEventListener(\"command\", function() {\n          self.startCasting();\n        });\n\n        this.video.addEventListener(\"media-videoCasting\", function(e) {\n          if (!e.isTrusted) {\n            return;\n          }\n          self.updateCasting(e.detail);\n        }, false, true);\n\n        // The first time the controls appear we want to just display\n        // a play button that does not fade away. The firstShow property\n        // makes that happen. But because of bug 718107 this init() method\n        // may be called again when we switch in or out of fullscreen\n        // mode. So we only set firstShow if we're not autoplaying and\n        // if we are at the beginning of the video and not already playing\n        if (!this.video.autoplay && this.Utils.dynamicControls && this.video.paused &&\n            this.video.currentTime === 0) {\n          this.firstShow = true;\n        }\n\n        // If the video is not at the start, then we probably just\n        // transitioned into or out of fullscreen mode, and we don't want\n        // the controls to remain visible. this.controlsTimeout is a full\n        // 5s, which feels too long after the transition.\n        if (this.video.currentTime !== 0) {\n          this.delayHideControls(this.Utils.HIDE_CONTROLS_TIMEOUT_MS);\n        }\n      }\n    };\n\n    this.TouchUtils.init(this)\n    this.dispatchEvent(new CustomEvent(\"VideoBindingAttached\"));\n    ]]>\n  </constructor>\n  <destructor>\n    <![CDATA[\n    // XBL destructors don't appear to be inherited properly, so we need\n    // to do this here in addition to the videoControls destructor. :-(\n    delete this.randomID;\n    ]]>\n  </destructor>\n\n  </implementation>\n\n  <handlers>\n    <handler event=\"mouseup\">\n      if (event.originalTarget.nodeName == \"vbox\") {\n        if (this.TouchUtils.firstShow) {\n          this.Utils.video.play();\n        }\n        this.TouchUtils.toggleControls();\n      }\n    </handler>\n  </handlers>\n\n</binding>\n\n<binding id=\"noControls\">\n\n  <resources>\n    <stylesheet src=\"chrome://global/content/bindings/videocontrols.css\"/>\n    <stylesheet src=\"chrome://global/skin/media/videocontrols.css\"/>\n  </resources>\n\n  <xbl:content xmlns=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\" class=\"mediaControlsFrame\">\n    <vbox flex=\"1\" class=\"statusOverlay\" hidden=\"true\">\n      <box flex=\"1\">\n        <box class=\"clickToPlay\" flex=\"1\"/>\n      </box>\n    </vbox>\n  </xbl:content>\n\n  <implementation>\n  <constructor>\n    <![CDATA[\n    this.randomID = 0;\n    this.Utils = {\n      randomID: 0,\n      videoEvents: [\"play\",\n                    \"playing\"],\n      controlListeners: [],\n      terminateEventListeners() {\n        for (let event of this.videoEvents) {\n          try {\n            this.video.removeEventListener(event, this, { mozSystemGroup: true });\n          } catch (ex) {}\n        }\n\n        for (let element of this.controlListeners) {\n          try {\n            element.item.removeEventListener(element.event, element.func,\n              { mozSystemGroup: true });\n          } catch (ex) {}\n        }\n\n        delete this.controlListeners;\n      },\n\n      hasError() {\n        return (this.video.error != null || this.video.networkState == this.video.NETWORK_NO_SOURCE);\n      },\n\n      handleEvent(aEvent) {\n        // If the binding is detached (or has been replaced by a\n        // newer instance of the binding), nuke our event-listeners.\n        if (this.binding.randomID != this.randomID) {\n          this.terminateEventListeners();\n          return;\n        }\n\n        switch (aEvent.type) {\n          case \"play\":\n            this.noControlsOverlay.hidden = true;\n            break;\n          case \"playing\":\n            this.noControlsOverlay.hidden = true;\n            break;\n        }\n      },\n\n      blockedVideoHandler() {\n        if (this.binding.randomID != this.randomID) {\n          this.terminateEventListeners();\n          return;\n        } else if (this.hasError()) {\n          this.noControlsOverlay.hidden = true;\n          return;\n        }\n        this.noControlsOverlay.hidden = false;\n      },\n\n      clickToPlayClickHandler(e) {\n        if (this.binding.randomID != this.randomID) {\n          this.terminateEventListeners();\n          return;\n        } else if (e.button != 0) {\n          return;\n        }\n\n        this.noControlsOverlay.hidden = true;\n        this.video.play();\n      },\n\n      init(binding) {\n        this.binding = binding;\n        this.randomID = Math.random();\n        this.binding.randomID = this.randomID;\n        this.video = binding.parentNode;\n        this.clickToPlay       = document.getAnonymousElementByAttribute(binding, \"class\", \"clickToPlay\");\n        this.noControlsOverlay = document.getAnonymousElementByAttribute(binding, \"class\", \"statusOverlay\");\n\n        let self = this;\n        function addListener(elem, eventName, func) {\n          let boundFunc = func.bind(self);\n          self.controlListeners.push({ item: elem, event: eventName, func: boundFunc });\n          elem.addEventListener(eventName, boundFunc, { mozSystemGroup: true });\n        }\n        addListener(this.clickToPlay, \"click\", this.clickToPlayClickHandler);\n        addListener(this.video, \"MozNoControlsBlockedVideo\", this.blockedVideoHandler);\n\n        for (let event of this.videoEvents) {\n          this.video.addEventListener(event, this, { mozSystemGroup: true });\n        }\n\n        if (this.video.autoplay && !this.video.mozAutoplayEnabled) {\n          this.blockedVideoHandler();\n        }\n      }\n    };\n    this.Utils.init(this);\n    this.Utils.video.dispatchEvent(new CustomEvent(\"MozNoControlsVideoBindingAttached\"));\n    ]]>\n  </constructor>\n  <destructor>\n    <![CDATA[\n    this.Utils.terminateEventListeners();\n    // randomID used to be a <field>, which meant that the XBL machinery\n    // undefined the property when the element was unbound. The code in\n    // this file actually depends on this, so now that randomID is an\n    // expando, we need to make sure to explicitly delete it.\n    delete this.randomID;\n    ]]>\n  </destructor>\n  </implementation>\n</binding>\n\n</bindings>\n"},{"file":"wizard.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE bindings [\n  <!ENTITY % wizardDTD SYSTEM \"chrome://global/locale/wizard.dtd\">\n  %wizardDTD;\n]>\n\n<bindings id=\"wizardBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"wizard-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/wizard.css\"/>\n    </resources>\n  </binding>\n\n  <binding id=\"wizard\" extends=\"chrome://global/content/bindings/general.xml#root-element\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/wizard.css\"/>\n    </resources>\n    <content>\n      <xul:hbox class=\"wizard-header\" anonid=\"Header\"/>\n\n      <xul:deck class=\"wizard-page-box\" flex=\"1\" anonid=\"Deck\">\n        <children includes=\"wizardpage\"/>\n      </xul:deck>\n      <children/>\n\n      <xul:hbox class=\"wizard-buttons\" anonid=\"Buttons\" xbl:inherits=\"pagestep,firstpage,lastpage\"/>\n    </content>\n\n    <implementation>\n      <property name=\"title\" onget=\"return document.title;\"\n                             onset=\"return document.title = val;\"/>\n\n      <property name=\"canAdvance\" onget=\"return this._canAdvance;\"\n                                  onset=\"this._nextButton.disabled = !val; return this._canAdvance = val;\"/>\n      <property name=\"canRewind\" onget=\"return this._canRewind;\"\n                                 onset=\"this._backButton.disabled = !val; return this._canRewind = val;\"/>\n\n      <property name=\"pageStep\" readonly=\"true\" onget=\"return this._pageStack.length\"/>\n\n      <field name=\"pageCount\">0</field>\n\n      <field name=\"_accessMethod\">null</field>\n      <field name=\"_pageStack\">null</field>\n      <field name=\"_currentPage\">null</field>\n\n      <property name=\"wizardPages\">\n        <getter>\n        <![CDATA[\n          var xulns = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          return this.getElementsByTagNameNS(xulns, \"wizardpage\");\n        ]]>\n        </getter>\n      </property>\n\n      <property name=\"currentPage\" onget=\"return this._currentPage\">\n        <setter>\n        <![CDATA[\n          if (!val)\n            return val;\n\n          this._currentPage = val;\n\n          // Setting this attribute allows wizard's clients to dynamically\n          // change the styles of each page based on purpose of the page.\n          this.setAttribute(\"currentpageid\", val.pageid);\n          if (this.onFirstPage) {\n            this.canRewind = false;\n            this.setAttribute(\"firstpage\", \"true\");\n            if (/Linux/.test(navigator.platform)) {\n              this._backButton.setAttribute('hidden', 'true');\n            }\n          } else {\n            this.canRewind = true;\n            this.setAttribute(\"firstpage\", \"false\");\n            if (/Linux/.test(navigator.platform)) {\n              this._backButton.setAttribute('hidden', 'false');\n            }\n          }\n\n          if (this.onLastPage) {\n            this.canAdvance = true;\n            this.setAttribute(\"lastpage\", \"true\");\n          } else {\n            this.setAttribute(\"lastpage\", \"false\");\n          }\n\n          this._deck.setAttribute(\"selectedIndex\", val.pageIndex);\n          this._advanceFocusToPage(val);\n\n          this._adjustWizardHeader();\n          this._wizardButtons.onPageChange();\n\n          this._fireEvent(val, \"pageshow\");\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"pageIndex\"\n                onget=\"return this._currentPage ? this._currentPage.pageIndex : -1;\">\n        <setter>\n        <![CDATA[\n          if (val < 0 || val >= this.pageCount)\n            return val;\n\n          var page = this.wizardPages[val];\n          this._pageStack[this._pageStack.length-1] = page;\n          this.currentPage = page;\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"onFirstPage\" readonly=\"true\"\n                onget=\"return this._pageStack.length == 1;\"/>\n\n      <property name=\"onLastPage\" readonly=\"true\">\n        <getter><![CDATA[\n          var cp = this.currentPage;\n          return cp && ((this._accessMethod == \"sequential\" && cp.pageIndex == this.pageCount-1) ||\n                       (this._accessMethod == \"random\" && cp.next == \"\"));\n         ]]></getter>\n      </property>\n\n      <method name=\"getButton\">\n        <parameter name=\"aDlgType\"/>\n        <body>\n        <![CDATA[\n          var btns = this.getElementsByAttribute(\"dlgtype\", aDlgType);\n          return btns.item(0) ? btns[0] : document.getAnonymousElementByAttribute(this._wizardButtons, \"dlgtype\", aDlgType);\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"_canAdvance\"/>\n      <field name=\"_canRewind\"/>\n      <field name=\"_wizardHeader\"/>\n      <field name=\"_wizardButtons\"/>\n      <field name=\"_deck\"/>\n      <field name=\"_backButton\"/>\n      <field name=\"_nextButton\"/>\n      <field name=\"_cancelButton\"/>\n\n      <!-- functions to be added as oncommand listeners to the wizard buttons -->\n      <field name=\"_backFunc\">(function() { document.documentElement.rewind(); })</field>\n      <field name=\"_nextFunc\">(function() { document.documentElement.advance(); })</field>\n      <field name=\"_finishFunc\">(function() { document.documentElement.advance(); })</field>\n      <field name=\"_cancelFunc\">(function() { document.documentElement.cancel(); })</field>\n      <field name=\"_extra1Func\">(function() { document.documentElement.extra1(); })</field>\n      <field name=\"_extra2Func\">(function() { document.documentElement.extra2(); })</field>\n\n      <field name=\"_closeHandler\">(function(event) {\n        if (document.documentElement.cancel())\n          event.preventDefault();\n      })</field>\n\n      <constructor><![CDATA[\n        this._canAdvance = true;\n        this._canRewind = false;\n        this._hasLoaded = false;\n\n        this._pageStack = [];\n\n        try {\n          // need to create string bundle manually instead of using <xul:stringbundle/>\n          // see bug 63370 for details\n          this._bundle = Components.classes[\"@mozilla.org/intl/stringbundle;1\"]\n                                   .getService(Components.interfaces.nsIStringBundleService)\n                                   .createBundle(\"chrome://global/locale/wizard.properties\");\n        } catch (e) {\n          // This fails in remote XUL, which has to provide titles for all pages\n          // see bug 142502\n        }\n\n        // get anonymous content references\n        this._wizardHeader = document.getAnonymousElementByAttribute(this, \"anonid\", \"Header\");\n        this._wizardButtons = document.getAnonymousElementByAttribute(this, \"anonid\", \"Buttons\");\n        this._deck = document.getAnonymousElementByAttribute(this, \"anonid\", \"Deck\");\n\n        this._initWizardButton(\"back\");\n        this._initWizardButton(\"next\");\n        this._initWizardButton(\"finish\");\n        this._initWizardButton(\"cancel\");\n        this._initWizardButton(\"extra1\");\n        this._initWizardButton(\"extra2\");\n\n        this._initPages();\n\n        window.addEventListener(\"close\", this._closeHandler);\n\n        // start off on the first page\n        this.pageCount = this.wizardPages.length;\n        this.advance();\n\n        // give focus to the first focusable element in the dialog\n        window.addEventListener(\"load\", this._setInitialFocus);\n      ]]></constructor>\n\n      <method name=\"getPageById\">\n        <parameter name=\"aPageId\"/>\n        <body><![CDATA[\n          var els = this.getElementsByAttribute(\"pageid\", aPageId);\n          return els.item(0);\n        ]]></body>\n      </method>\n\n      <method name=\"extra1\">\n        <body><![CDATA[\n          if (this.currentPage)\n            this._fireEvent(this.currentPage, \"extra1\");\n        ]]></body>\n      </method>\n\n      <method name=\"extra2\">\n        <body><![CDATA[\n          if (this.currentPage)\n            this._fireEvent(this.currentPage, \"extra2\");\n        ]]></body>\n      </method>\n\n      <method name=\"rewind\">\n        <body><![CDATA[\n          if (!this.canRewind)\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pagehide\"))\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pagerewound\"))\n            return;\n\n          if (!this._fireEvent(this, \"wizardback\"))\n            return;\n\n\n          this._pageStack.pop();\n          this.currentPage = this._pageStack[this._pageStack.length-1];\n          this.setAttribute(\"pagestep\", this._pageStack.length);\n        ]]></body>\n      </method>\n\n      <method name=\"advance\">\n        <parameter name=\"aPageId\"/>\n        <body><![CDATA[\n          if (!this.canAdvance)\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pagehide\"))\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pageadvanced\"))\n            return;\n\n          if (this.onLastPage && !aPageId) {\n            if (this._fireEvent(this, \"wizardfinish\"))\n              window.setTimeout(function() {window.close();}, 1);\n          } else {\n            if (!this._fireEvent(this, \"wizardnext\"))\n              return;\n\n            var page;\n            if (aPageId)\n              page = this.getPageById(aPageId);\n            else {\n              if (this.currentPage) {\n                if (this._accessMethod == \"random\")\n                  page = this.getPageById(this.currentPage.next);\n                else\n                  page = this.wizardPages[this.currentPage.pageIndex+1];\n              } else\n                page = this.wizardPages[0];\n            }\n\n            if (page) {\n              this._pageStack.push(page);\n              this.setAttribute(\"pagestep\", this._pageStack.length);\n\n              this.currentPage = page;\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"goTo\">\n        <parameter name=\"aPageId\"/>\n        <body><![CDATA[\n          var page = this.getPageById(aPageId);\n          if (page) {\n            this._pageStack[this._pageStack.length-1] = page;\n            this.currentPage = page;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"cancel\">\n        <body><![CDATA[\n          if (!this._fireEvent(this, \"wizardcancel\"))\n            return true;\n\n          window.close();\n          window.setTimeout(function() {window.close();}, 1);\n          return false;\n        ]]></body>\n      </method>\n\n      <method name=\"_setInitialFocus\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          document.documentElement._hasLoaded = true;\n          var focusInit =\n            function() {\n              // give focus to the first focusable element in the dialog\n              if (!document.commandDispatcher.focusedElement)\n                document.commandDispatcher.advanceFocusIntoSubtree(document.documentElement);\n\n              try {\n                var button =\n                      document.documentElement._wizardButtons.defaultButton;\n                if (button)\n                  window.notifyDefaultButtonLoaded(button);\n              } catch (e) { }\n            };\n\n          // Give focus after onload completes, see bug 103197.\n          setTimeout(focusInit, 0);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_advanceFocusToPage\">\n        <parameter name=\"aPage\"/>\n        <body>\n        <![CDATA[\n          if (!this._hasLoaded)\n            return;\n\n          document.commandDispatcher.advanceFocusIntoSubtree(aPage);\n\n          // if advanceFocusIntoSubtree tries to focus one of our\n          // dialog buttons, then remove it and put it on the root\n          var focused = document.commandDispatcher.focusedElement;\n          if (focused && focused.hasAttribute(\"dlgtype\"))\n            this.focus();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_initPages\">\n        <body><![CDATA[\n          var meth = \"sequential\";\n          var pages = this.wizardPages;\n          for (var i = 0; i < pages.length; ++i) {\n            var page = pages[i];\n            page.pageIndex = i;\n            if (page.next != \"\")\n              meth = \"random\";\n          }\n          this._accessMethod = meth;\n        ]]></body>\n      </method>\n\n      <method name=\"_initWizardButton\">\n        <parameter name=\"aName\"/>\n        <body><![CDATA[\n         var btn = document.getAnonymousElementByAttribute(this._wizardButtons, \"dlgtype\", aName);\n         if (btn) {\n           btn.addEventListener(\"command\", this[\"_\"+aName+\"Func\"]);\n           this[\"_\"+aName+\"Button\"] = btn;\n         }\n         return btn;\n        ]]></body>\n      </method>\n\n      <method name=\"_adjustWizardHeader\">\n        <body><![CDATA[\n          var label = this.currentPage.getAttribute(\"label\");\n          if (!label && this.onFirstPage && this._bundle) {\n            if (/Mac/.test(navigator.platform)) {\n              label = this._bundle.GetStringFromName(\"default-first-title-mac\");\n            } else {\n              label = this._bundle.formatStringFromName(\"default-first-title\", [this.title], 1);\n            }\n          } else if (!label && this.onLastPage && this._bundle) {\n            if (/Mac/.test(navigator.platform)) {\n              label = this._bundle.GetStringFromName(\"default-last-title-mac\");\n            } else {\n              label = this._bundle.formatStringFromName(\"default-last-title\", [this.title], 1);\n            }\n          }\n          this._wizardHeader.setAttribute(\"label\", label);\n          this._wizardHeader.setAttribute(\"description\", this.currentPage.getAttribute(\"description\"));\n        ]]></body>\n      </method>\n\n      <method name=\"_hitEnter\">\n        <parameter name=\"evt\"/>\n        <body>\n        <![CDATA[\n          if (!evt.defaultPrevented)\n            this.advance();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_fireEvent\">\n        <parameter name=\"aTarget\"/>\n        <parameter name=\"aType\"/>\n        <body>\n        <![CDATA[\n          var event = document.createEvent(\"Events\");\n          event.initEvent(aType, true, true);\n\n          // handle dom event handlers\n          var noCancel = aTarget.dispatchEvent(event);\n\n          // handle any xml attribute event handlers\n          var handler = aTarget.getAttribute(\"on\"+aType);\n          if (handler != \"\") {\n            var fn = new Function(\"event\", handler);\n            var returned = fn.apply(aTarget, [event]);\n            if (returned == false)\n              noCancel = false;\n          }\n\n          return noCancel;\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\"\n               group=\"system\" action=\"this._hitEnter(event)\"/>\n      <handler event=\"keypress\" keycode=\"VK_ESCAPE\" group=\"system\">\n        if (!event.defaultPrevented)\n          this.cancel();\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"wizardpage\" extends=\"chrome://global/content/bindings/wizard.xml#wizard-base\">\n    <implementation>\n      <field name=\"pageIndex\">-1</field>\n\n      <property name=\"pageid\" onget=\"return this.getAttribute('pageid');\"\n                              onset=\"this.setAttribute('pageid', val);\"/>\n\n      <property name=\"next\"   onget=\"return this.getAttribute('next');\"\n                              onset=\"this.setAttribute('next', val);\n                                     this.parentNode._accessMethod = 'random';\n                                     return val;\"/>\n    </implementation>\n  </binding>\n\n\n\n  <binding id=\"wizard-header\" extends=\"chrome://global/content/bindings/wizard.xml#wizard-base\">\n    <content>\n      <xul:hbox class=\"wizard-header-box-1\" flex=\"1\">\n        <xul:vbox class=\"wizard-header-box-text\" flex=\"1\">\n          <xul:label class=\"wizard-header-label\" xbl:inherits=\"xbl:text=label\"/>\n          <xul:label class=\"wizard-header-description\" xbl:inherits=\"xbl:text=description\"/>\n        </xul:vbox>\n        <xul:image class=\"wizard-header-icon\" xbl:inherits=\"src=iconsrc\"/>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"wizard-buttons\" extends=\"chrome://global/content/bindings/wizard.xml#wizard-base\">\n    <content>\n      <xul:vbox class=\"wizard-buttons-box-1\" flex=\"1\">\n        <xul:separator class=\"wizard-buttons-separator groove\"/>\n        <xul:hbox class=\"wizard-buttons-box-2\">\n          <xul:button class=\"wizard-button\" dlgtype=\"extra1\" hidden=\"true\"/>\n          <xul:button class=\"wizard-button\" dlgtype=\"extra2\" hidden=\"true\"/>\n          <xul:spacer flex=\"1\" anonid=\"spacer\"/>\n\n          <xul:button label=\"FROM-DTD-button-back-win-label\" accesskey=\"FROM-DTD-button-back-win-accesskey\"\n                      class=\"wizard-button\" dlgtype=\"back\" icon=\"go-back\"/>\n          <xul:deck class=\"wizard-next-deck\" anonid=\"WizardButtonDeck\">\n            <xul:hbox>\n              <xul:button label=\"FROM-DTD-button-finish-win-label\" class=\"wizard-button\"\n                          dlgtype=\"finish\" default=\"true\" flex=\"1\"/>\n            </xul:hbox>\n            <xul:hbox>\n              <xul:button label=\"FROM-DTD-button-next-win-label\" accesskey=\"FROM-DTD-button-next-win-accesskey\"\n                          class=\"wizard-button\" dlgtype=\"next\" icon=\"go-forward\"\n                          default=\"true\" flex=\"1\"/>\n            </xul:hbox>\n          </xul:deck>\n          <xul:button label=\"FROM-DTD-button-cancel-win-label\" class=\"wizard-button\"\n                      dlgtype=\"cancel\" icon=\"cancel\"/>\n\n        </xul:hbox>\n      </xul:vbox>\n    </content>\n\n    <implementation>\n      <field name=\"_wizardButtonDeck\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"WizardButtonDeck\");\n      </field>\n\n      <method name=\"onPageChange\">\n        <body><![CDATA[\n          if (this.getAttribute(\"lastpage\") == \"true\") {\n            this._wizardButtonDeck.setAttribute(\"selectedIndex\", 0);\n          } else {\n            this._wizardButtonDeck.setAttribute(\"selectedIndex\", 1);\n          }\n        ]]></body>\n      </method>\n\n      <property name=\"defaultButton\" readonly=\"true\">\n        <getter><![CDATA[\n          const kXULNS =\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          var buttons = this._wizardButtonDeck.selectedPanel\n                            .getElementsByTagNameNS(kXULNS, \"button\");\n          for (var i = 0; i < buttons.length; i++) {\n            if (buttons[i].getAttribute(\"default\") == \"true\" &&\n                !buttons[i].hidden && !buttons[i].disabled)\n              return buttons[i];\n          }\n          return null;\n        ]]></getter>\n      </property>\n    </implementation>\n  </binding>\n\n\n</bindings>\n"}];
    </script>
  </head>
  <body>
  <main>
  <header>
  <div id="links">
    <a href="../">Home</a>
    <a href="https://github.com/bgrins/xbl-analysis">Code</a>
  </div>
  <h1>XBL To Custom Element Converter</h1>
  </header>
  <div id="converter">
    <ul>
    <li><a href='#' data-index=0>browser-tabPreviews.xml</a></li>
<li><a href='#' data-index=1>feeds.xml</a></li>
<li><a href='#' data-index=2>pageInfo.xml</a></li>
<li><a href='#' data-index=3>tabbrowser.xml</a></li>
<li><a href='#' data-index=4>urlbarBindings.xml</a></li>
<li><a href='#' data-index=5>panelUI.xml</a></li>
<li><a href='#' data-index=6>toolbar.xml</a></li>
<li><a href='#' data-index=7>download.xml</a></li>
<li><a href='#' data-index=8>menu.xml</a></li>
<li><a href='#' data-index=9>tree.xml</a></li>
<li><a href='#' data-index=10>handlers.xml</a></li>
<li><a href='#' data-index=11>siteListItem.xml</a></li>
<li><a href='#' data-index=12>search.xml</a></li>
<li><a href='#' data-index=13>translation-infobar.xml</a></li>
<li><a href='#' data-index=14>formautofill.xml</a></li>
<li><a href='#' data-index=15>organizer.xml</a></li>
<li><a href='#' data-index=16>autocomplete.xml</a></li>
<li><a href='#' data-index=17>browser.xml</a></li>
<li><a href='#' data-index=18>button.xml</a></li>
<li><a href='#' data-index=19>checkbox.xml</a></li>
<li><a href='#' data-index=20>colorpicker.xml</a></li>
<li><a href='#' data-index=21>datetimebox.xml</a></li>
<li><a href='#' data-index=22>datetimepicker.xml</a></li>
<li><a href='#' data-index=23>datetimepopup.xml</a></li>
<li><a href='#' data-index=24>dialog.xml</a></li>
<li><a href='#' data-index=25>editor.xml</a></li>
<li><a href='#' data-index=26>expander.xml</a></li>
<li><a href='#' data-index=27>filefield.xml</a></li>
<li><a href='#' data-index=28>findbar.xml</a></li>
<li><a href='#' data-index=29>general.xml</a></li>
<li><a href='#' data-index=30>groupbox.xml</a></li>
<li><a href='#' data-index=31>listbox.xml</a></li>
<li><a href='#' data-index=32>menu.xml</a></li>
<li><a href='#' data-index=33>menulist.xml</a></li>
<li><a href='#' data-index=34>notification.xml</a></li>
<li><a href='#' data-index=35>numberbox.xml</a></li>
<li><a href='#' data-index=36>optionsDialog.xml</a></li>
<li><a href='#' data-index=37>popup.xml</a></li>
<li><a href='#' data-index=38>preferences.xml</a></li>
<li><a href='#' data-index=39>progressmeter.xml</a></li>
<li><a href='#' data-index=40>radio.xml</a></li>
<li><a href='#' data-index=41>remote-browser.xml</a></li>
<li><a href='#' data-index=42>resizer.xml</a></li>
<li><a href='#' data-index=43>richlistbox.xml</a></li>
<li><a href='#' data-index=44>scale.xml</a></li>
<li><a href='#' data-index=45>scrollbar.xml</a></li>
<li><a href='#' data-index=46>scrollbox.xml</a></li>
<li><a href='#' data-index=47>spinbuttons.xml</a></li>
<li><a href='#' data-index=48>splitter.xml</a></li>
<li><a href='#' data-index=49>stringbundle.xml</a></li>
<li><a href='#' data-index=50>tabbox.xml</a></li>
<li><a href='#' data-index=51>text.xml</a></li>
<li><a href='#' data-index=52>textbox.xml</a></li>
<li><a href='#' data-index=53>toolbar.xml</a></li>
<li><a href='#' data-index=54>toolbarbutton.xml</a></li>
<li><a href='#' data-index=55>tree.xml</a></li>
<li><a href='#' data-index=56>videocontrols.xml</a></li>
<li><a href='#' data-index=57>wizard.xml</a></li>
    </ul>
    <textarea>
    <?xml version="1.0"?>

<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!-- eslint-env mozilla/browser-window -->

<bindings id="tabBrowserBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="tabbrowser">
    <resources>
      <stylesheet src="chrome://browser/content/tabbrowser.css"/>
    </resources>

    <content>
      <xul:tabbox anonid="tabbox" class="tabbrowser-tabbox"
                  flex="1" eventnode="document" xbl:inherits="tabcontainer"
                  onselect="if (event.target.localName == 'tabpanels') this.parentNode.updateCurrentBrowser();">
        <xul:tabpanels flex="1" class="plain" selectedIndex="0" anonid="panelcontainer">
          <xul:notificationbox flex="1" notificationside="top">
            <xul:hbox flex="1" class="browserSidebarContainer">
              <xul:vbox flex="1" class="browserContainer">
                <xul:stack flex="1" class="browserStack" anonid="browserStack">
                  <xul:browser anonid="initialBrowser" type="content" message="true" messagemanagergroup="browsers"
                               primary="true" blank="true"
                               xbl:inherits="tooltip=contenttooltip,contextmenu=contentcontextmenu,autocompletepopup,selectmenulist,datetimepicker"/>
                </xul:stack>
              </xul:vbox>
            </xul:hbox>
          </xul:notificationbox>
        </xul:tabpanels>
      </xul:tabbox>
      <children/>
    </content>
    <implementation implements="nsIDOMEventListener, nsIMessageListener, nsIObserver">

      <property name="tabContextMenu" readonly="true"
                onget="return this.tabContainer.contextMenu;"/>

      <field name="tabContainer" readonly="true">
        document.getElementById(this.getAttribute("tabcontainer"));
      </field>
      <field name="tabs" readonly="true">
        this.tabContainer.childNodes;
      </field>

      <property name="visibleTabs" readonly="true">
        <getter><![CDATA[
          if (!this._visibleTabs)
            this._visibleTabs = Array.filter(this.tabs,
                                             tab => !tab.hidden && !tab.closing);
          return this._visibleTabs;
        ]]></getter>
      </property>

      <field name="closingTabsEnum" readonly="true">({ ALL: 0, OTHER: 1, TO_END: 2 });</field>

      <field name="_visibleTabs">null</field>

      <field name="mURIFixup" readonly="true">
        Components.classes["@mozilla.org/docshell/urifixup;1"]
                  .getService(Components.interfaces.nsIURIFixup);
      </field>
      <field name="_unifiedComplete" readonly="true">
         Components.classes["@mozilla.org/autocomplete/search;1?name=unifiedcomplete"]
                   .getService(Components.interfaces.mozIPlacesAutoComplete);
      </field>
      <field name="mTabBox" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "tabbox");
      </field>
      <field name="mPanelContainer" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "panelcontainer");
      </field>
      <field name="mCurrentTab">
        null
      </field>
      <field name="_lastRelatedTabMap">
        new WeakMap();
      </field>
      <field name="mCurrentBrowser">
        null
      </field>
      <field name="mProgressListeners">
        []
      </field>
      <field name="mTabsProgressListeners">
        []
      </field>
      <field name="_tabListeners">
        new Map()
      </field>
      <field name="_tabFilters">
        new Map()
      </field>
      <field name="mIsBusy">
        false
      </field>
      <field name="_outerWindowIDBrowserMap">
        new Map();
      </field>
      <field name="arrowKeysShouldWrap" readonly="true">
        AppConstants == "macosx";
      </field>

      <field name="_autoScrollPopup">
        null
      </field>

      <field name="_previewMode">
        false
      </field>

      <field name="_lastFindValue">
        ""
      </field>

      <field name="_contentWaitingCount">
        0
      </field>

      <field name="tabAnimationsInProgress">
        0
      </field>

      <property name="_numPinnedTabs" readonly="true">
        <getter><![CDATA[
          for (var i = 0; i < this.tabs.length; i++) {
            if (!this.tabs[i].pinned)
              break;
          }
          return i;
        ]]></getter>
      </property>

      <property name="popupAnchor" readonly="true">
        <getter><![CDATA[
        if (this.mCurrentTab._popupAnchor) {
          return this.mCurrentTab._popupAnchor;
        }
        let stack = this.mCurrentBrowser.parentNode;
        // Create an anchor for the popup
        const NS_XUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
        let popupAnchor = document.createElementNS(NS_XUL, "hbox");
        popupAnchor.className = "popup-anchor";
        popupAnchor.hidden = true;
        stack.appendChild(popupAnchor);
        return this.mCurrentTab._popupAnchor = popupAnchor;
        ]]></getter>
      </property>

      <method name="isFindBarInitialized">
        <parameter name="aTab"/>
        <body><![CDATA[
          return (aTab || this.selectedTab)._findBar != undefined;
        ]]></body>
      </method>

      <method name="getFindBar">
        <parameter name="aTab"/>
        <body><![CDATA[
          if (!aTab)
            aTab = this.selectedTab;

          if (aTab._findBar)
            return aTab._findBar;

          let findBar = document.createElementNS(this.namespaceURI, "findbar");
          let browser = this.getBrowserForTab(aTab);
          let browserContainer = this.getBrowserContainer(browser);
          browserContainer.appendChild(findBar);

          // Force a style flush to ensure that our binding is attached.
          findBar.clientTop;

          findBar.browser = browser;
          findBar._findField.value = this._lastFindValue;

          aTab._findBar = findBar;

          let event = document.createEvent("Events");
          event.initEvent("TabFindInitialized", true, false);
          aTab.dispatchEvent(event);

          return findBar;
        ]]></body>
      </method>

      <method name="getStatusPanel">
        <body><![CDATA[
          if (!this._statusPanel) {
            this._statusPanel = document.createElementNS(this.namespaceURI, "statuspanel");
            this._statusPanel.setAttribute("inactive", "true");
            this._statusPanel.setAttribute("layer", "true");
            this._appendStatusPanel();
          }
          return this._statusPanel;
        ]]></body>
      </method>

      <method name="_appendStatusPanel">
        <body><![CDATA[
          if (this._statusPanel) {
            let browser = this.selectedBrowser;
            let browserContainer = this.getBrowserContainer(browser);
            browserContainer.insertBefore(this._statusPanel, browser.parentNode.nextSibling);
          }
        ]]></body>
      </method>

      <method name="_setCloseKeyState">
        <parameter name="aEnabled"/>
        <body><![CDATA[
          let keyClose = document.getElementById("key_close");
          let closeKeyEnabled = keyClose.getAttribute("disabled") != "true";
          if (closeKeyEnabled == aEnabled)
            return;

          if (aEnabled)
            keyClose.removeAttribute("disabled");
          else
            keyClose.setAttribute("disabled", "true");

          // We also want to remove the keyboard shortcut from the file menu
          // when the shortcut is disabled, and bring it back when it's
          // renabled.
          //
          // Fixing bug 630826 could make that happen automatically.
          // Fixing bug 630830 could avoid the ugly hack below.

          let closeMenuItem = document.getElementById("menu_close");
          let parentPopup = closeMenuItem.parentNode;
          let nextItem = closeMenuItem.nextSibling;
          let clonedItem = closeMenuItem.cloneNode(true);

          parentPopup.removeChild(closeMenuItem);

          if (aEnabled)
            clonedItem.setAttribute("key", "key_close");
          else
            clonedItem.removeAttribute("key");

          parentPopup.insertBefore(clonedItem, nextItem);
        ]]></body>
      </method>

      <method name="pinTab">
        <parameter name="aTab"/>
        <body><![CDATA[
          if (aTab.pinned)
            return;

          if (aTab.hidden)
            this.showTab(aTab);

          this.moveTabTo(aTab, this._numPinnedTabs);
          aTab.setAttribute("pinned", "true");
          this.tabContainer._unlockTabSizing();
          this.tabContainer._positionPinnedTabs();
          this.tabContainer.adjustTabstrip();

          this.getBrowserForTab(aTab).messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: true })

          if (aTab.selected)
            this._setCloseKeyState(false);

          let event = document.createEvent("Events");
          event.initEvent("TabPinned", true, false);
          aTab.dispatchEvent(event);
        ]]></body>
      </method>

      <method name="unpinTab">
        <parameter name="aTab"/>
        <body><![CDATA[
          if (!aTab.pinned)
            return;

          this.moveTabTo(aTab, this._numPinnedTabs - 1);
          aTab.removeAttribute("pinned");
          aTab.style.marginInlineStart = "";
          this.tabContainer._unlockTabSizing();
          this.tabContainer._positionPinnedTabs();
          this.tabContainer.adjustTabstrip();

          this.getBrowserForTab(aTab).messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: false })

          if (aTab.selected)
            this._setCloseKeyState(true);

          let event = document.createEvent("Events");
          event.initEvent("TabUnpinned", true, false);
          aTab.dispatchEvent(event);
        ]]></body>
      </method>

      <method name="previewTab">
        <parameter name="aTab"/>
        <parameter name="aCallback"/>
        <body>
          <![CDATA[
            let currentTab = this.selectedTab;
            try {
              // Suppress focus, ownership and selected tab changes
              this._previewMode = true;
              this.selectedTab = aTab;
              aCallback();
            } finally {
              this.selectedTab = currentTab;
              this._previewMode = false;
            }
          ]]>
        </body>
      </method>

      <method name="getBrowserAtIndex">
        <parameter name="aIndex"/>
        <body>
          <![CDATA[
            return this.browsers[aIndex];
          ]]>
        </body>
      </method>

      <method name="getBrowserIndexForDocument">
        <parameter name="aDocument"/>
        <body>
          <![CDATA[
            var tab = this._getTabForContentWindow(aDocument.defaultView);
            return tab ? tab._tPos : -1;
          ]]>
        </body>
      </method>

      <method name="getBrowserForDocument">
        <parameter name="aDocument"/>
        <body>
          <![CDATA[
            var tab = this._getTabForContentWindow(aDocument.defaultView);
            return tab ? tab.linkedBrowser : null;
          ]]>
        </body>
      </method>

      <method name="getBrowserForContentWindow">
        <parameter name="aWindow"/>
        <body>
          <![CDATA[
            var tab = this._getTabForContentWindow(aWindow);
            return tab ? tab.linkedBrowser : null;
          ]]>
        </body>
      </method>

      <method name="getBrowserForOuterWindowID">
        <parameter name="aID"/>
        <body>
          <![CDATA[
            return this._outerWindowIDBrowserMap.get(aID);
          ]]>
        </body>
      </method>

      <method name="_getTabForContentWindow">
        <parameter name="aWindow"/>
        <body>
        <![CDATA[
          // When not using remote browsers, we can take a fast path by getting
          // directly from the content window to the browser without looping
          // over all browsers.
          if (!gMultiProcessBrowser) {
            let browser = aWindow.QueryInterface(Ci.nsIInterfaceRequestor)
                                 .getInterface(Ci.nsIWebNavigation)
                                 .QueryInterface(Ci.nsIDocShell)
                                 .chromeEventHandler;
            return this.getTabForBrowser(browser);
          }

          for (let i = 0; i < this.browsers.length; i++) {
            // NB: We use contentWindowAsCPOW so that this code works both
            // for remote browsers as well. aWindow may be a CPOW.
            if (this.browsers[i].contentWindowAsCPOW == aWindow)
              return this.tabs[i];
          }
          return null;
        ]]>
        </body>
      </method>

      <!-- Binding from browser to tab -->
      <field name="_tabForBrowser" readonly="true">
      <![CDATA[
        new WeakMap();
      ]]>
      </field>

      <method name="getTabForBrowser">
        <parameter name="aBrowser"/>
        <body>
        <![CDATA[
          return this._tabForBrowser.get(aBrowser);
        ]]>
        </body>
      </method>

      <method name="getNotificationBox">
        <parameter name="aBrowser"/>
        <body>
          <![CDATA[
            return this.getSidebarContainer(aBrowser).parentNode;
          ]]>
        </body>
      </method>

      <method name="getSidebarContainer">
        <parameter name="aBrowser"/>
        <body>
          <![CDATA[
            return this.getBrowserContainer(aBrowser).parentNode;
          ]]>
        </body>
      </method>

      <method name="getBrowserContainer">
        <parameter name="aBrowser"/>
        <body>
          <![CDATA[
            return (aBrowser || this.mCurrentBrowser).parentNode.parentNode;
          ]]>
        </body>
      </method>

      <method name="getTabModalPromptBox">
        <parameter name="aBrowser"/>
        <body>
          <![CDATA[
            let browser = (aBrowser || this.mCurrentBrowser);
            if (!browser.tabModalPromptBox) {
              browser.tabModalPromptBox = new TabModalPromptBox(browser);
            }
            return browser.tabModalPromptBox;
          ]]>
        </body>
      </method>

      <method name="getTabFromAudioEvent">
        <parameter name="aEvent"/>
        <body>
        <![CDATA[
          if (!Services.prefs.getBoolPref("browser.tabs.showAudioPlayingIcon") ||
              !aEvent.isTrusted) {
            return null;
          }

          var browser = aEvent.originalTarget;
          var tab = this.getTabForBrowser(browser);
          return tab;
        ]]>
        </body>
      </method>

      <method name="_callProgressListeners">
        <parameter name="aBrowser"/>
        <parameter name="aMethod"/>
        <parameter name="aArguments"/>
        <parameter name="aCallGlobalListeners"/>
        <parameter name="aCallTabsListeners"/>
        <body><![CDATA[
          var rv = true;

          function callListeners(listeners, args) {
            for (let p of listeners) {
              if (aMethod in p) {
                try {
                  if (!p[aMethod].apply(p, args))
                    rv = false;
                } catch (e) {
                  // don't inhibit other listeners
                  Components.utils.reportError(e);
                }
              }
            }
          }

          if (!aBrowser)
            aBrowser = this.mCurrentBrowser;

          if (aCallGlobalListeners != false &&
              aBrowser == this.mCurrentBrowser) {
            callListeners(this.mProgressListeners, aArguments);
          }

          if (aCallTabsListeners != false) {
            aArguments.unshift(aBrowser);

            callListeners(this.mTabsProgressListeners, aArguments);
          }

          return rv;
        ]]></body>
      </method>

      <!-- Determine if a URI is an about: page pointing to a local resource. -->
      <method name="_isLocalAboutURI">
        <parameter name="aURI"/>
        <parameter name="aResolvedURI"/>
        <body><![CDATA[
          if (!aURI.schemeIs("about")) {
            return false;
          }

          // Specially handle about:blank as local
          if (aURI.pathQueryRef === "blank") {
            return true;
          }

          try {
            // Use the passed in resolvedURI if we have one
            const resolvedURI = aResolvedURI || Services.io.newChannelFromURI2(
              aURI,
              null, // loadingNode
              Services.scriptSecurityManager.getSystemPrincipal(), // loadingPrincipal
              null, // triggeringPrincipal
              Ci.nsILoadInfo.SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL, // securityFlags
              Ci.nsIContentPolicy.TYPE_OTHER // contentPolicyType
            ).URI;
            return resolvedURI.schemeIs("jar") || resolvedURI.schemeIs("file");
          } catch (ex) {
            // aURI might be invalid.
            return false;
          }
        ]]></body>
      </method>

      <!-- A web progress listener object definition for a given tab. -->
      <method name="mTabProgressListener">
        <parameter name="aTab"/>
        <parameter name="aBrowser"/>
        <parameter name="aStartsBlank"/>
        <parameter name="aWasPreloadedBrowser"/>
        <parameter name="aOrigStateFlags"/>
        <body>
        <![CDATA[
          let stateFlags = aOrigStateFlags || 0;
          // Initialize mStateFlags to non-zero e.g. when creating a progress
          // listener for preloaded browsers as there was no progress listener
          // around when the content started loading. If the content didn't
          // quite finish loading yet, mStateFlags will very soon be overridden
          // with the correct value and end up at STATE_STOP again.
          if (aWasPreloadedBrowser) {
            stateFlags = Ci.nsIWebProgressListener.STATE_STOP |
                         Ci.nsIWebProgressListener.STATE_IS_REQUEST;
          }

          return ({
            mTabBrowser: this,
            mTab: aTab,
            mBrowser: aBrowser,
            mBlank: aStartsBlank,

            // cache flags for correct status UI update after tab switching
            mStateFlags: stateFlags,
            mStatus: 0,
            mMessage: "",
            mTotalProgress: 0,

            // count of open requests (should always be 0 or 1)
            mRequestCount: 0,

            destroy() {
              delete this.mTab;
              delete this.mBrowser;
              delete this.mTabBrowser;
            },

            _callProgressListeners() {
              Array.unshift(arguments, this.mBrowser);
              return this.mTabBrowser._callProgressListeners.apply(this.mTabBrowser, arguments);
            },

            _shouldShowProgress(aRequest) {
              if (this.mBlank)
                return false;

              // Don't show progress indicators in tabs for about: URIs
              // pointing to local resources.
              if ((aRequest instanceof Ci.nsIChannel) &&
                  this.mTabBrowser._isLocalAboutURI(aRequest.originalURI, aRequest.URI)) {
                return false;
              }

              return true;
            },

            _isForInitialAboutBlank(aWebProgress, aStateFlags, aLocation) {
              if (!this.mBlank || !aWebProgress.isTopLevel) {
                return false;
              }

              // If the state has STATE_STOP, and no requests were in flight, then this
              // must be the initial "stop" for the initial about:blank document.
              const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
              if (aStateFlags & nsIWebProgressListener.STATE_STOP &&
                  this.mRequestCount == 0 &&
                  !aLocation) {
                return true;
              }

              let location = aLocation ? aLocation.spec : "";
              return location == "about:blank";
            },

            _syncThrobberAnimations() {
              const originalTab = this.mTab;
              BrowserUtils.promiseLayoutFlushed(this.mTab.ownerDocument, "style", () => {
                if (!originalTab.parentNode) {
                  return;
                }

                const animations =
                  Array.from(originalTab.parentNode.getElementsByTagName("tab"))
                  .map(tab => {
                    const throbber =
                      document.getAnonymousElementByAttribute(tab, "anonid", "tab-throbber");
                    return throbber ? throbber.getAnimations({ subtree: true }) : [];
                  })
                  .reduce((a, b) => a.concat(b))
                  .filter(anim =>
                    anim instanceof CSSAnimation &&
                    (anim.animationName === "tab-throbber-animation" ||
                     anim.animationName === "tab-throbber-animation-rtl") &&
                    (anim.playState === "running" || anim.playState === "pending"));

                // Synchronize with the oldest running animation, if any.
                const firstStartTime = Math.min(
                  ...animations.map(anim => anim.startTime === null ? Infinity : anim.startTime)
                );
                if (firstStartTime === Infinity) {
                  return;
                }
                requestAnimationFrame(() => {
                  for (let animation of animations) {
                    // If |animation| has been cancelled since this rAF callback
                    // was scheduled we don't want to set its startTime since
                    // that would restart it. We check for a cancelled animation
                    // by looking for a null currentTime rather than checking
                    // the playState, since reading the playState of
                    // a CSSAnimation object will flush style.
                    if (animation.currentTime !== null) {
                      animation.startTime = firstStartTime;
                    }
                  }
                });
              });
            },

            onProgressChange(aWebProgress, aRequest,
                             aCurSelfProgress, aMaxSelfProgress,
                             aCurTotalProgress, aMaxTotalProgress) {
              this.mTotalProgress = aMaxTotalProgress ? aCurTotalProgress / aMaxTotalProgress : 0;

              if (!this._shouldShowProgress(aRequest))
                return;

              if (this.mTotalProgress && this.mTab.hasAttribute("busy"))
                this.mTab.setAttribute("progress", "true");

              this._callProgressListeners("onProgressChange",
                                          [aWebProgress, aRequest,
                                           aCurSelfProgress, aMaxSelfProgress,
                                           aCurTotalProgress, aMaxTotalProgress]);
            },

            onProgressChange64(aWebProgress, aRequest,
                               aCurSelfProgress, aMaxSelfProgress,
                               aCurTotalProgress, aMaxTotalProgress) {
              return this.onProgressChange(aWebProgress, aRequest,
                aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress,
                aMaxTotalProgress);
            },

            onStateChange(aWebProgress, aRequest, aStateFlags, aStatus) {
              if (!aRequest)
                return;

              const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
              const nsIChannel = Components.interfaces.nsIChannel;
              let location, originalLocation;
              try {
                aRequest.QueryInterface(nsIChannel)
                location = aRequest.URI;
                originalLocation = aRequest.originalURI;
              } catch (ex) {}

              let ignoreBlank = this._isForInitialAboutBlank(aWebProgress, aStateFlags,
                                                             location);

              // If we were ignoring some messages about the initial about:blank, and we
              // got the STATE_STOP for it, we'll want to pay attention to those messages
              // from here forward. Similarly, if we conclude that this state change
              // is one that we shouldn't be ignoring, then stop ignoring.
              if ((ignoreBlank &&
                   aStateFlags & nsIWebProgressListener.STATE_STOP &&
                   aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) ||
                  !ignoreBlank && this.mBlank) {
                this.mBlank = false;
              }

              if (aStateFlags & nsIWebProgressListener.STATE_START) {
                this.mRequestCount++;
              } else if (aStateFlags & nsIWebProgressListener.STATE_STOP) {
                const NS_ERROR_UNKNOWN_HOST = 2152398878;
                if (--this.mRequestCount > 0 && aStatus == NS_ERROR_UNKNOWN_HOST) {
                  // to prevent bug 235825: wait for the request handled
                  // by the automatic keyword resolver
                  return;
                }
                // since we (try to) only handle STATE_STOP of the last request,
                // the count of open requests should now be 0
                this.mRequestCount = 0;
              }

              if (aStateFlags & nsIWebProgressListener.STATE_START &&
                  aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
                if (aWebProgress.isTopLevel) {
                  // Need to use originalLocation rather than location because things
                  // like about:home and about:privatebrowsing arrive with nsIRequest
                  // pointing to their resolved jar: or file: URIs.
                  if (!(originalLocation && gInitialPages.includes(originalLocation.spec) &&
                        originalLocation != "about:blank" &&
                        this.mBrowser.initialPageLoadedFromURLBar != originalLocation.spec &&
                        this.mBrowser.currentURI && this.mBrowser.currentURI.spec == "about:blank")) {
                    // Indicating that we started a load will allow the location
                    // bar to be cleared when the load finishes.
                    // In order to not overwrite user-typed content, we avoid it
                    // (see if condition above) in a very specific case:
                    // If the load is of an 'initial' page (e.g. about:privatebrowsing,
                    // about:newtab, etc.), was not explicitly typed in the location
                    // bar by the user, is not about:blank (because about:blank can be
                    // loaded by websites under their principal), and the current
                    // page in the browser is about:blank (indicating it is a newly
                    // created or re-created browser, e.g. because it just switched
                    // remoteness or is a new tab/window).
                    this.mBrowser.urlbarChangeTracker.startedLoad();
                  }
                  delete this.mBrowser.initialPageLoadedFromURLBar;
                  // If the browser is loading it must not be crashed anymore
                  this.mTab.removeAttribute("crashed");
                }

                if (this._shouldShowProgress(aRequest)) {
                  if (!(aStateFlags & nsIWebProgressListener.STATE_RESTORING) &&
                      aWebProgress && aWebProgress.isTopLevel) {
                    this.mTab.setAttribute("busy", "true");
                    this.mTab._notselectedsinceload = !this.mTab.selected;
                    this._syncThrobberAnimations();
                  }

                  if (this.mTab.selected) {
                    this.mTabBrowser.mIsBusy = true;
                  }
                }
              } else if (aStateFlags & nsIWebProgressListener.STATE_STOP &&
                         aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {

                if (this.mTab.hasAttribute("busy")) {
                  this.mTab.removeAttribute("busy");

                  // Only animate the "burst" indicating the page has loaded if
                  // the top-level page is the one that finished loading.
                  if (aWebProgress.isTopLevel && !aWebProgress.isLoadingDocument &&
                      Components.isSuccessCode(aStatus) &&
                      !this.mTabBrowser.tabAnimationsInProgress &&
                      Services.prefs.getBoolPref("toolkit.cosmeticAnimations.enabled")) {
                    if (this.mTab._notselectedsinceload) {
                      this.mTab.setAttribute("notselectedsinceload", "true");
                    } else {
                      this.mTab.removeAttribute("notselectedsinceload");
                    }

                    this.mTab.setAttribute("bursting", "true");
                  }

                  this.mTabBrowser._tabAttrModified(this.mTab, ["busy"]);
                  if (!this.mTab.selected)
                    this.mTab.setAttribute("unread", "true");
                }
                this.mTab.removeAttribute("progress");

                if (aWebProgress.isTopLevel) {
                  let isSuccessful = Components.isSuccessCode(aStatus);
                  if (!isSuccessful && !isTabEmpty(this.mTab)) {
                    // Restore the current document's location in case the
                    // request was stopped (possibly from a content script)
                    // before the location changed.

                    this.mBrowser.userTypedValue = null;

                    let inLoadURI = this.mBrowser.inLoadURI;
                    if (this.mTab.selected && gURLBar && !inLoadURI) {
                      URLBarSetURI();
                    }
                  } else if (isSuccessful) {
                    this.mBrowser.urlbarChangeTracker.finishedLoad();
                  }

                  if (!this.mBrowser.mIconURL) {
                    this.mTabBrowser.useDefaultIcon(this.mTab);
                  }
                }

                // For keyword URIs clear the user typed value since they will be changed into real URIs
                if (location.scheme == "keyword")
                  this.mBrowser.userTypedValue = null;

                if (this.mTab.selected)
                  this.mTabBrowser.mIsBusy = false;
              }

              if (ignoreBlank) {
                this._callProgressListeners("onUpdateCurrentBrowser",
                                            [aStateFlags, aStatus, "", 0],
                                            true, false);
              } else {
                this._callProgressListeners("onStateChange",
                                            [aWebProgress, aRequest, aStateFlags, aStatus],
                                            true, false);
              }

              this._callProgressListeners("onStateChange",
                                          [aWebProgress, aRequest, aStateFlags, aStatus],
                                          false);

              if (aStateFlags & (nsIWebProgressListener.STATE_START |
                                 nsIWebProgressListener.STATE_STOP)) {
                // reset cached temporary values at beginning and end
                this.mMessage = "";
                this.mTotalProgress = 0;
              }
              this.mStateFlags = aStateFlags;
              this.mStatus = aStatus;
            },

            onLocationChange(aWebProgress, aRequest, aLocation,
                             aFlags) {
              // OnLocationChange is called for both the top-level content
              // and the subframes.
              let topLevel = aWebProgress.isTopLevel;

              if (topLevel) {
                let isSameDocument =
                  !!(aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_SAME_DOCUMENT);
                // We need to clear the typed value
                // if the document failed to load, to make sure the urlbar reflects the
                // failed URI (particularly for SSL errors). However, don't clear the value
                // if the error page's URI is about:blank, because that causes complete
                // loss of urlbar contents for invalid URI errors (see bug 867957).
                // Another reason to clear the userTypedValue is if this was an anchor
                // navigation initiated by the user.
                if (this.mBrowser.didStartLoadSinceLastUserTyping() ||
                    ((aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_ERROR_PAGE) &&
                     aLocation.spec != "about:blank") ||
                    (isSameDocument && this.mBrowser.inLoadURI)) {
                  this.mBrowser.userTypedValue = null;
                }

                // If the browser was playing audio, we should remove the playing state.
                if (this.mTab.hasAttribute("soundplaying") && !isSameDocument) {
                  clearTimeout(this.mTab._soundPlayingAttrRemovalTimer);
                  this.mTab._soundPlayingAttrRemovalTimer = 0;
                  this.mTab.removeAttribute("soundplaying");
                  this.mTabBrowser._tabAttrModified(this.mTab, ["soundplaying"]);
                }

                // If the browser was previously muted, we should restore the muted state.
                if (this.mTab.hasAttribute("muted")) {
                  this.mTab.linkedBrowser.mute();
                }

                if (this.mTabBrowser.isFindBarInitialized(this.mTab)) {
                  let findBar = this.mTabBrowser.getFindBar(this.mTab);

                  // Close the Find toolbar if we're in old-style TAF mode
                  if (findBar.findMode != findBar.FIND_NORMAL) {
                    findBar.close();
                  }
                }

                this.mTabBrowser.setTabTitle(this.mTab);

                // Don't clear the favicon if this tab is in the pending
                // state, as SessionStore will have set the icon for us even
                // though we're pointed at an about:blank. Also don't clear it
                // if onLocationChange was triggered by a pushState or a
                // replaceState (bug 550565) or a hash change (bug 408415).
                if (!this.mTab.hasAttribute("pending") &&
                    aWebProgress.isLoadingDocument &&
                    !isSameDocument) {
                  this.mBrowser.mIconURL = null;
                }

                let userContextId = this.mBrowser.getAttribute("usercontextid") || 0;
                if (this.mBrowser.registeredOpenURI) {
                  this.mTabBrowser._unifiedComplete
                                  .unregisterOpenPage(this.mBrowser.registeredOpenURI,
                                                      userContextId);
                  delete this.mBrowser.registeredOpenURI;
                }
                // Tabs in private windows aren't registered as "Open" so
                // that they don't appear as switch-to-tab candidates.
                if (!isBlankPageURL(aLocation.spec) &&
                    (!PrivateBrowsingUtils.isWindowPrivate(window) ||
                    PrivateBrowsingUtils.permanentPrivateBrowsing)) {
                  this.mTabBrowser._unifiedComplete
                                  .registerOpenPage(aLocation, userContextId);
                  this.mBrowser.registeredOpenURI = aLocation;
                }
              }

              if (!this.mBlank) {
                this._callProgressListeners("onLocationChange",
                                            [aWebProgress, aRequest, aLocation,
                                             aFlags]);
              }

              if (topLevel) {
                this.mBrowser.lastURI = aLocation;
                this.mBrowser.lastLocationChange = Date.now();
              }
            },

            onStatusChange(aWebProgress, aRequest, aStatus, aMessage) {
              if (this.mBlank)
                return;

              this._callProgressListeners("onStatusChange",
                                          [aWebProgress, aRequest, aStatus, aMessage]);

              this.mMessage = aMessage;
            },

            onSecurityChange(aWebProgress, aRequest, aState) {
              this._callProgressListeners("onSecurityChange",
                                          [aWebProgress, aRequest, aState]);
            },

            onRefreshAttempted(aWebProgress, aURI, aDelay, aSameURI) {
              return this._callProgressListeners("onRefreshAttempted",
                                                 [aWebProgress, aURI, aDelay, aSameURI]);
            },

            QueryInterface(aIID) {
              if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                  aIID.equals(Components.interfaces.nsIWebProgressListener2) ||
                  aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                  aIID.equals(Components.interfaces.nsISupports))
                return this;
              throw Components.results.NS_NOINTERFACE;
            }
          });
        ]]>
        </body>
      </method>

      <field name="serializationHelper">
        Cc["@mozilla.org/network/serialization-helper;1"]
          .getService(Ci.nsISerializationHelper);
      </field>

      <field name="mIconLoadingPrincipal">
        null
      </field>

      <method name="storeIcon">
        <parameter name="aBrowser"/>
        <parameter name="aURI"/>
        <parameter name="aLoadingPrincipal"/>
        <parameter name="aRequestContextID"/>
        <body>
          <![CDATA[
          try {
            if (!(aURI instanceof Ci.nsIURI)) {
              aURI = makeURI(aURI);
            }
            PlacesUIUtils.loadFavicon(aBrowser, aLoadingPrincipal, aURI, aRequestContextID);
          } catch (ex) {
            Components.utils.reportError(ex);
          }
        ]]>
        </body>
      </method>

      <method name="setIcon">
        <parameter name="aTab"/>
        <parameter name="aURI"/>
        <parameter name="aLoadingPrincipal"/>
        <parameter name="aRequestContextID"/>
        <body>
          <![CDATA[
            let browser = this.getBrowserForTab(aTab);
            browser.mIconURL = aURI instanceof Ci.nsIURI ? aURI.spec : aURI;
            let loadingPrincipal = aLoadingPrincipal ||
                                   Services.scriptSecurityManager.getSystemPrincipal();
            let requestContextID = aRequestContextID || 0;
            let sizedIconUrl = browser.mIconURL || "";
            if (sizedIconUrl != aTab.getAttribute("image")) {
              if (sizedIconUrl) {
                if (!browser.mIconLoadingPrincipal ||
                    !browser.mIconLoadingPrincipal.equals(loadingPrincipal)) {
                  aTab.setAttribute("iconloadingprincipal",
                    this.serializationHelper.serializeToString(loadingPrincipal));
                  aTab.setAttribute("requestcontextid", requestContextID);
                  browser.mIconLoadingPrincipal = loadingPrincipal;
                }
                aTab.setAttribute("image", sizedIconUrl);
              } else {
                aTab.removeAttribute("iconloadingprincipal");
                delete browser.mIconLoadingPrincipal;
                aTab.removeAttribute("image");
              }
              this._tabAttrModified(aTab, ["image"]);
            }

            this._callProgressListeners(browser, "onLinkIconAvailable", [browser.mIconURL]);
          ]]>
        </body>
      </method>

      <method name="getIcon">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            let browser = aTab ? this.getBrowserForTab(aTab) : this.selectedBrowser;
            return browser.mIconURL;
          ]]>
        </body>
      </method>

      <method name="setPageInfo">
        <parameter name="aURL"/>
        <parameter name="aDescription"/>
        <parameter name="aPreviewImage"/>
        <body>
          <![CDATA[
            if (aURL) {
              let pageInfo = {url: aURL, description: aDescription, previewImageURL: aPreviewImage}
              PlacesUtils.history.update(pageInfo).catch(Components.utils.reportError);
            }
          ]]>
        </body>
      </method>

      <method name="shouldLoadFavIcon">
        <parameter name="aURI"/>
        <body>
          <![CDATA[
            return (aURI &&
                    Services.prefs.getBoolPref("browser.chrome.site_icons") &&
                    Services.prefs.getBoolPref("browser.chrome.favicons") &&
                    ("schemeIs" in aURI) && (aURI.schemeIs("http") || aURI.schemeIs("https")));
          ]]>
        </body>
      </method>

      <method name="useDefaultIcon">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            let browser = this.getBrowserForTab(aTab);
            let documentURI = browser.documentURI;
            let requestContextID = browser.contentRequestContextID;
            let loadingPrincipal = browser.contentPrincipal;
            let icon = null;

            if (browser.imageDocument) {
              if (Services.prefs.getBoolPref("browser.chrome.site_icons")) {
                let sz = Services.prefs.getIntPref("browser.chrome.image_icons.max_size");
                if (browser.imageDocument.width <= sz &&
                    browser.imageDocument.height <= sz) {
                  // Don't try to store the icon in Places, regardless it would
                  // be skipped (see Bug 403651).
                  icon = browser.currentURI;
                }
              }
            }

            // Use documentURIObject in the check for shouldLoadFavIcon so that we
            // do the right thing with about:-style error pages.  Bug 453442
            if (!icon && this.shouldLoadFavIcon(documentURI)) {
              let url = documentURI.prePath + "/favicon.ico";
              if (!this.isFailedIcon(url)) {
                icon = url;
                this.storeIcon(browser, icon, loadingPrincipal, requestContextID);
              }
            }

            this.setIcon(aTab, icon, loadingPrincipal, requestContextID);
          ]]>
        </body>
      </method>

      <method name="isFailedIcon">
        <parameter name="aURI"/>
        <body>
          <![CDATA[
            if (!(aURI instanceof Ci.nsIURI))
              aURI = makeURI(aURI);
            return PlacesUtils.favicons.isFailedFavicon(aURI);
          ]]>
        </body>
      </method>

      <method name="getWindowTitleForBrowser">
        <parameter name="aBrowser"/>
        <body>
          <![CDATA[
            var newTitle = "";
            var docElement = this.ownerDocument.documentElement;
            var sep = docElement.getAttribute("titlemenuseparator");
            let tab = this.getTabForBrowser(aBrowser);
            let docTitle;

            if (tab._labelIsContentTitle) {
              // Strip out any null bytes in the content title, since the
              // underlying widget implementations of nsWindow::SetTitle pass
              // null-terminated strings to system APIs.
              docTitle = tab.getAttribute("label").replace(/\0/g, "");
            }

            if (!docTitle)
              docTitle = docElement.getAttribute("titledefault");

            var modifier = docElement.getAttribute("titlemodifier");
            if (docTitle) {
              newTitle += docElement.getAttribute("titlepreface");
              newTitle += docTitle;
              if (modifier)
                newTitle += sep;
            }
            newTitle += modifier;

            // If location bar is hidden and the URL type supports a host,
            // add the scheme and host to the title to prevent spoofing.
            // XXX https://bugzilla.mozilla.org/show_bug.cgi?id=22183#c239
            try {
              if (docElement.getAttribute("chromehidden").includes("location")) {
                var uri = this.mURIFixup.createExposableURI(
                            aBrowser.currentURI);
                if (uri.scheme == "about")
                  newTitle = uri.spec + sep + newTitle;
                else
                  newTitle = uri.prePath + sep + newTitle;
              }
            } catch (e) {}

            return newTitle;
          ]]>
        </body>
      </method>

      <method name="updateTitlebar">
        <body>
          <![CDATA[
            this.ownerDocument.title = this.getWindowTitleForBrowser(this.mCurrentBrowser);
          ]]>
        </body>
      </method>

      <!-- Holds a unique ID for the tab change that's currently being timed.
           Used to make sure that multiple, rapid tab switches do not try to
           create overlapping timers. -->
      <field name="_tabSwitchID">null</field>

      <method name="updateCurrentBrowser">
        <parameter name="aForceUpdate"/>
        <body>
          <![CDATA[
            var newBrowser = this.getBrowserAtIndex(this.tabContainer.selectedIndex);
            if (this.mCurrentBrowser == newBrowser && !aForceUpdate)
              return;

            if (!aForceUpdate) {
              document.commandDispatcher.lock();

              TelemetryStopwatch.start("FX_TAB_SWITCH_UPDATE_MS");
              if (!gMultiProcessBrowser) {
                // old way of measuring tab paint which is not valid with e10s.
                // Waiting until the next MozAfterPaint ensures that we capture
                // the time it takes to paint, upload the textures to the compositor,
                // and then composite.
                if (this._tabSwitchID) {
                  TelemetryStopwatch.cancel("FX_TAB_SWITCH_TOTAL_MS");
                }

                let tabSwitchID = Symbol();

                TelemetryStopwatch.start("FX_TAB_SWITCH_TOTAL_MS");
                this._tabSwitchID = tabSwitchID;

                let onMozAfterPaint = () => {
                  if (this._tabSwitchID === tabSwitchID) {
                    TelemetryStopwatch.finish("FX_TAB_SWITCH_TOTAL_MS");
                    this._tabSwitchID = null;
                  }
                  window.removeEventListener("MozAfterPaint", onMozAfterPaint);
                }
                window.addEventListener("MozAfterPaint", onMozAfterPaint);
              }
            }

            var oldTab = this.mCurrentTab;

            // Preview mode should not reset the owner
            if (!this._previewMode && !oldTab.selected)
              oldTab.owner = null;

            let lastRelatedTab = this._lastRelatedTabMap.get(oldTab);
            if (lastRelatedTab) {
              if (!lastRelatedTab.selected)
                lastRelatedTab.owner = null;
            }
            this._lastRelatedTabMap = new WeakMap();

            var oldBrowser = this.mCurrentBrowser;

            if (!gMultiProcessBrowser) {
              oldBrowser.removeAttribute("primary");
              oldBrowser.docShellIsActive = false;
              newBrowser.setAttribute("primary", "true");
              newBrowser.docShellIsActive =
                (window.windowState != window.STATE_MINIMIZED &&
                 !window.isFullyOccluded);
            }

            var updateBlockedPopups = false;
            if ((oldBrowser.blockedPopups && !newBrowser.blockedPopups) ||
                (!oldBrowser.blockedPopups && newBrowser.blockedPopups))
              updateBlockedPopups = true;

            this.mCurrentBrowser = newBrowser;
            this.mCurrentTab = this.tabContainer.selectedItem;
            this.showTab(this.mCurrentTab);

            gURLBar.setAttribute("switchingtabs", "true");
            window.addEventListener("MozAfterPaint", function() {
              gURLBar.removeAttribute("switchingtabs");
            }, {once: true});

            this._appendStatusPanel();

            if (updateBlockedPopups)
              this.mCurrentBrowser.updateBlockedPopups();

            // Update the URL bar.
            var loc = this.mCurrentBrowser.currentURI;

            var webProgress = this.mCurrentBrowser.webProgress;
            var securityUI = this.mCurrentBrowser.securityUI;

            this._callProgressListeners(null, "onLocationChange",
                                        [webProgress, null, loc, 0], true,
                                        false);

            if (securityUI) {
              // Include the true final argument to indicate that this event is
              // simulated (instead of being observed by the webProgressListener).
              this._callProgressListeners(null, "onSecurityChange",
                                          [webProgress, null, securityUI.state, true],
                                          true, false);
            }

            var listener = this._tabListeners.get(this.mCurrentTab);
            if (listener && listener.mStateFlags) {
              this._callProgressListeners(null, "onUpdateCurrentBrowser",
                                          [listener.mStateFlags, listener.mStatus,
                                           listener.mMessage, listener.mTotalProgress],
                                          true, false);
            }

            if (!this._previewMode) {
              this.mCurrentTab.updateLastAccessed();
              this.mCurrentTab.removeAttribute("unread");
              oldTab.updateLastAccessed();

              let oldFindBar = oldTab._findBar;
              if (oldFindBar &&
                  oldFindBar.findMode == oldFindBar.FIND_NORMAL &&
                  !oldFindBar.hidden)
                this._lastFindValue = oldFindBar._findField.value;

              this.updateTitlebar();

              this.mCurrentTab.removeAttribute("titlechanged");
              this.mCurrentTab.removeAttribute("attention");

              // The tab has been selected, it's not unselected anymore.
              // (1) Call the current tab's finishUnselectedTabHoverTimer()
              //     to save a telemetry record.
              // (2) Call the current browser's unselectedTabHover() with false
              //     to dispatch an event.
              this.mCurrentTab.finishUnselectedTabHoverTimer();
              this.mCurrentBrowser.unselectedTabHover(false);
            }

            // If the new tab is busy, and our current state is not busy, then
            // we need to fire a start to all progress listeners.
            const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
            if (this.mCurrentTab.hasAttribute("busy") && !this.mIsBusy) {
              this.mIsBusy = true;
              this._callProgressListeners(null, "onStateChange",
                                          [webProgress, null,
                                           nsIWebProgressListener.STATE_START |
                                           nsIWebProgressListener.STATE_IS_NETWORK, 0],
                                          true, false);
            }

            // If the new tab is not busy, and our current state is busy, then
            // we need to fire a stop to all progress listeners.
            if (!this.mCurrentTab.hasAttribute("busy") && this.mIsBusy) {
              this.mIsBusy = false;
              this._callProgressListeners(null, "onStateChange",
                                          [webProgress, null,
                                           nsIWebProgressListener.STATE_STOP |
                                           nsIWebProgressListener.STATE_IS_NETWORK, 0],
                                          true, false);
            }

            this._setCloseKeyState(!this.mCurrentTab.pinned);

            // TabSelect events are suppressed during preview mode to avoid confusing extensions and other bits of code
            // that might rely upon the other changes suppressed.
            // Focus is suppressed in the event that the main browser window is minimized - focusing a tab would restore the window
            if (!this._previewMode) {
              // We've selected the new tab, so go ahead and notify listeners.
              let event = new CustomEvent("TabSelect", {
                bubbles: true,
                cancelable: false,
                detail: {
                  previousTab: oldTab
                }
              });
              this.mCurrentTab.dispatchEvent(event);

              this._tabAttrModified(oldTab, ["selected"]);
              this._tabAttrModified(this.mCurrentTab, ["selected"]);

              if (oldBrowser != newBrowser &&
                  oldBrowser.getInPermitUnload) {
                oldBrowser.getInPermitUnload(inPermitUnload => {
                  if (!inPermitUnload) {
                    return;
                  }
                  // Since the user is switching away from a tab that has
                  // a beforeunload prompt active, we remove the prompt.
                  // This prevents confusing user flows like the following:
                  //   1. User attempts to close Firefox
                  //   2. User switches tabs (ingoring a beforeunload prompt)
                  //   3. User returns to tab, presses "Leave page"
                  let promptBox = this.getTabModalPromptBox(oldBrowser);
                  let prompts = promptBox.listPrompts();
                  // There might not be any prompts here if the tab was closed
                  // while in an onbeforeunload prompt, which will have
                  // destroyed aforementioned prompt already, so check there's
                  // something to remove, first:
                  if (prompts.length) {
                    // NB: This code assumes that the beforeunload prompt
                    //     is the top-most prompt on the tab.
                    prompts[prompts.length - 1].abortPrompt();
                  }
                });
              }

              if (!gMultiProcessBrowser) {
                this._adjustFocusBeforeTabSwitch(oldTab, this.mCurrentTab);
                this._adjustFocusAfterTabSwitch(this.mCurrentTab);
              }
            }

            updateUserContextUIIndicator();
            gIdentityHandler.updateSharingIndicator();

            this.tabContainer._setPositionalAttributes();

            if (!gMultiProcessBrowser) {
              document.commandDispatcher.unlock();

              let event = new CustomEvent("TabSwitchDone", {
                bubbles: true,
                cancelable: true
              });
              this.dispatchEvent(event);
            }

            if (!aForceUpdate)
              TelemetryStopwatch.finish("FX_TAB_SWITCH_UPDATE_MS");
          ]]>
        </body>
      </method>

      <method name="_adjustFocusBeforeTabSwitch">
        <parameter name="oldTab"/>
        <parameter name="newTab"/>
        <body><![CDATA[
          if (this._previewMode) {
            return;
          }

          let oldBrowser = oldTab.linkedBrowser;
          let newBrowser = newTab.linkedBrowser;

          oldBrowser._urlbarFocused = (gURLBar && gURLBar.focused);

          if (this.isFindBarInitialized(oldTab)) {
            let findBar = this.getFindBar(oldTab);
            oldTab._findBarFocused = (!findBar.hidden &&
              findBar._findField.getAttribute("focused") == "true");
          }

          let activeEl = document.activeElement;
          // If focus is on the old tab, move it to the new tab.
          if (activeEl == oldTab) {
            newTab.focus();
          } else if (gMultiProcessBrowser && activeEl != newBrowser && activeEl != newTab) {
            // In e10s, if focus isn't already in the tabstrip or on the new browser,
            // and the new browser's previous focus wasn't in the url bar but focus is
            // there now, we need to adjust focus further.
            let keepFocusOnUrlBar = newBrowser &&
                                    newBrowser._urlbarFocused &&
                                    gURLBar &&
                                    gURLBar.focused;
            if (!keepFocusOnUrlBar) {
              // Clear focus so that _adjustFocusAfterTabSwitch can detect if
              // some element has been focused and respect that.
              document.activeElement.blur();
            }
          }
        ]]></body>
      </method>

      <method name="_adjustFocusAfterTabSwitch">
        <parameter name="newTab"/>
        <body><![CDATA[
        // Don't steal focus from the tab bar.
        if (document.activeElement == newTab)
          return;

        let newBrowser = this.getBrowserForTab(newTab);

        // If there's a tabmodal prompt showing, focus it.
        if (newBrowser.hasAttribute("tabmodalPromptShowing")) {
          let XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          let prompts = newBrowser.parentNode.getElementsByTagNameNS(XUL_NS, "tabmodalprompt");
          let prompt = prompts[prompts.length - 1];
          prompt.Dialog.setDefaultFocus();
          return;
        }

        // Focus the location bar if it was previously focused for that tab.
        // In full screen mode, only bother making the location bar visible
        // if the tab is a blank one.
        if (newBrowser._urlbarFocused && gURLBar) {
          // Explicitly close the popup if the URL bar retains focus
          gURLBar.closePopup();

          // If the user happened to type into the URL bar for this browser
          // by the time we got here, focusing will cause the text to be
          // selected which could cause them to overwrite what they've
          // already typed in.
          if (gURLBar.focused && newBrowser.userTypedValue) {
            return;
          }

          if (!window.fullScreen || isTabEmpty(newTab)) {
            focusAndSelectUrlBar();
            return;
          }
        }

        // Focus the find bar if it was previously focused for that tab.
        if (gFindBarInitialized && !gFindBar.hidden &&
            this.selectedTab._findBarFocused) {
          gFindBar._findField.focus();
          return;
        }

        // Don't focus the content area if something has been focused after the
        // tab switch was initiated.
        if (gMultiProcessBrowser &&
            document.activeElement != document.documentElement)
          return;

        // We're now committed to focusing the content area.
        let fm = Services.focus;
        let focusFlags = fm.FLAG_NOSCROLL;

        if (!gMultiProcessBrowser) {
          let newFocusedElement = fm.getFocusedElementForWindow(window.content, true, {});

          // for anchors, use FLAG_SHOWRING so that it is clear what link was
          // last clicked when switching back to that tab
          if (newFocusedElement &&
              (newFocusedElement instanceof HTMLAnchorElement ||
               newFocusedElement.getAttributeNS("http://www.w3.org/1999/xlink", "type") == "simple"))
            focusFlags |= fm.FLAG_SHOWRING;
        }

        fm.setFocus(newBrowser, focusFlags);
        ]]></body>
      </method>

      <method name="_tabAttrModified">
        <parameter name="aTab"/>
        <parameter name="aChanged"/>
        <body><![CDATA[
          if (aTab.closing)
            return;

          let event = new CustomEvent("TabAttrModified", {
            bubbles: true,
            cancelable: false,
            detail: {
              changed: aChanged,
            }
          });
          aTab.dispatchEvent(event);
        ]]></body>
      </method>

      <method name="setBrowserSharing">
        <parameter name="aBrowser"/>
        <parameter name="aState"/>
        <body><![CDATA[
          let tab = this.getTabForBrowser(aBrowser);
          if (!tab)
            return;

          let sharing;
          if (aState.screen) {
            sharing = "screen";
          } else if (aState.camera) {
            sharing = "camera";
          } else if (aState.microphone) {
            sharing = "microphone";
          }

          if (sharing) {
            tab.setAttribute("sharing", sharing);
            tab._sharingState = aState;
          } else {
            tab.removeAttribute("sharing");
            tab._sharingState = null;
          }
          this._tabAttrModified(tab, ["sharing"]);

          if (aBrowser == this.mCurrentBrowser)
            gIdentityHandler.updateSharingIndicator();
        ]]></body>
      </method>


      <!-- TODO: remove after 57, once we know add-ons can no longer use it. -->
      <method name="setTabTitleLoading">
        <parameter name="aTab"/>
        <body/>
      </method>

      <method name="setInitialTabTitle">
        <parameter name="aTab"/>
        <parameter name="aTitle"/>
        <parameter name="aOptions"/>
        <body><![CDATA[
          if (aTitle) {
            if (!aTab.getAttribute("label")) {
              aTab._labelIsInitialTitle = true;
            }

            this._setTabLabel(aTab, aTitle, aOptions);
          }
        ]]></body>
      </method>

      <method name="setTabTitle">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            var browser = this.getBrowserForTab(aTab);
            var title = browser.contentTitle;

            // Don't replace an initially set label with the URL while the tab
            // is loading.
            if (aTab._labelIsInitialTitle) {
              if (!title) {
                return false;
              }
              delete aTab._labelIsInitialTitle;
            }

            let isContentTitle = false;
            if (title) {
              isContentTitle = true;
            } else if (aTab.hasAttribute("customizemode")) {
              let brandBundle = document.getElementById("bundle_brand");
              let brandShortName = brandBundle.getString("brandShortName");
              title = gNavigatorBundle.getFormattedString("customizeMode.tabTitle",
                                                          [ brandShortName ]);
              isContentTitle = true;
            } else {
              if (browser.currentURI.displaySpec) {
                try {
                  title = this.mURIFixup.createExposableURI(browser.currentURI).displaySpec;
                } catch (ex) {
                  title = browser.currentURI.displaySpec;
                }
              }

              if (title && !isBlankPageURL(title)) {
                // At this point, we now have a URI.
                // Let's try to unescape it using a character set
                // in case the URI is not ASCII.
                try {
                  var characterSet = browser.characterSet;
                  const textToSubURI = Components.classes["@mozilla.org/intl/texttosuburi;1"]
                                                 .getService(Components.interfaces.nsITextToSubURI);
                  title = textToSubURI.unEscapeNonAsciiURI(characterSet, title);
                  // If it's a long data: URI that uses base64 encoding, truncate to
                  // a reasonable length rather than trying to display the entire thing.
                  // We can't shorten arbitrary URIs like this, as bidi etc might mean
                  // we need the trailing characters for display. But a base64-encoded
                  // data-URI is plain ASCII, so this is OK for tab-title display.
                  // (See bug 1408854.)
                  if (title.length > 500 && title.match(/^data:[^,]+;base64,/)) {
                    title = title.substring(0, 500) + "\u2026";
                  }
                } catch (ex) { /* Do nothing. */ }
              } else {
                // Still no title? Fall back to our untitled string.
                title = gTabBrowserBundle.GetStringFromName("tabs.emptyTabTitle");
              }
            }

            return this._setTabLabel(aTab, title, { isContentTitle });
          ]]>
        </body>
      </method>

      <method name="_setTabLabel">
        <parameter name="aTab"/>
        <parameter name="aLabel"/>
        <parameter name="aOptions"/>
        <body>
          <![CDATA[
            if (!aLabel) {
              return false;
            }

            aTab._fullLabel = aLabel;

            aOptions = aOptions || {};
            if (!aOptions.isContentTitle) {
              // Remove protocol and "www."
              if (!("_regex_shortenURLForTabLabel" in this)) {
                this._regex_shortenURLForTabLabel = /^[^:]+:\/\/(?:www\.)?/;
              }
              aLabel = aLabel.replace(this._regex_shortenURLForTabLabel, "");
            }

            aTab._labelIsContentTitle = aOptions.isContentTitle;

            if (aTab.getAttribute("label") == aLabel) {
              return false;
            }

            let dwu = window.QueryInterface(Ci.nsIInterfaceRequestor)
                            .getInterface(Ci.nsIDOMWindowUtils);
            let isRTL = dwu.getDirectionFromText(aLabel) == Ci.nsIDOMWindowUtils.DIRECTION_RTL;

            aTab.setAttribute("label", aLabel);
            aTab.setAttribute("labeldirection", isRTL ? "rtl" : "ltr");

            // Dispatch TabAttrModified event unless we're setting the label
            // before the TabOpen event was dispatched.
            if (!aOptions.beforeTabOpen) {
              this._tabAttrModified(aTab, ["label"]);
            }

            if (aTab.selected) {
              this.updateTitlebar();
            }

            return true;
          ]]>
        </body>
      </method>

      <method name="loadOneTab">
        <parameter name="aURI"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aPostData"/>
        <parameter name="aLoadInBackground"/>
        <parameter name="aAllowThirdPartyFixup"/>
        <body>
          <![CDATA[
            var aTriggeringPrincipal;
            var aReferrerPolicy;
            var aFromExternal;
            var aRelatedToCurrent;
            var aAllowMixedContent;
            var aSkipAnimation;
            var aForceNotRemote;
            var aPreferredRemoteType;
            var aNoReferrer;
            var aUserContextId;
            var aSameProcessAsFrameLoader;
            var aOriginPrincipal;
            var aOpener;
            var aOpenerBrowser;
            var aIsPrerendered;
            var aCreateLazyBrowser;
            var aNextTabParentId;
            var aFocusUrlBar;
            var aName;
            if (arguments.length == 2 &&
                typeof arguments[1] == "object" &&
                !(arguments[1] instanceof Ci.nsIURI)) {
              let params = arguments[1];
              aTriggeringPrincipal      = params.triggeringPrincipal
              aReferrerURI              = params.referrerURI;
              aReferrerPolicy           = params.referrerPolicy;
              aCharset                  = params.charset;
              aPostData                 = params.postData;
              aLoadInBackground         = params.inBackground;
              aAllowThirdPartyFixup     = params.allowThirdPartyFixup;
              aFromExternal             = params.fromExternal;
              aRelatedToCurrent         = params.relatedToCurrent;
              aAllowMixedContent        = params.allowMixedContent;
              aSkipAnimation            = params.skipAnimation;
              aForceNotRemote           = params.forceNotRemote;
              aPreferredRemoteType      = params.preferredRemoteType;
              aNoReferrer               = params.noReferrer;
              aUserContextId            = params.userContextId;
              aSameProcessAsFrameLoader = params.sameProcessAsFrameLoader;
              aOriginPrincipal          = params.originPrincipal;
              aOpener                   = params.opener;
              aOpenerBrowser            = params.openerBrowser;
              aIsPrerendered            = params.isPrerendered;
              aCreateLazyBrowser        = params.createLazyBrowser;
              aNextTabParentId          = params.nextTabParentId;
              aFocusUrlBar              = params.focusUrlBar;
              aName                     = params.name;
            }

            var bgLoad = (aLoadInBackground != null) ? aLoadInBackground :
                         Services.prefs.getBoolPref("browser.tabs.loadInBackground");
            var owner = bgLoad ? null : this.selectedTab;

            var tab = this.addTab(aURI, {
                                  triggeringPrincipal: aTriggeringPrincipal,
                                  referrerURI: aReferrerURI,
                                  referrerPolicy: aReferrerPolicy,
                                  charset: aCharset,
                                  postData: aPostData,
                                  ownerTab: owner,
                                  allowThirdPartyFixup: aAllowThirdPartyFixup,
                                  fromExternal: aFromExternal,
                                  relatedToCurrent: aRelatedToCurrent,
                                  skipAnimation: aSkipAnimation,
                                  allowMixedContent: aAllowMixedContent,
                                  forceNotRemote: aForceNotRemote,
                                  createLazyBrowser: aCreateLazyBrowser,
                                  preferredRemoteType: aPreferredRemoteType,
                                  noReferrer: aNoReferrer,
                                  userContextId: aUserContextId,
                                  originPrincipal: aOriginPrincipal,
                                  sameProcessAsFrameLoader: aSameProcessAsFrameLoader,
                                  opener: aOpener,
                                  openerBrowser: aOpenerBrowser,
                                  isPrerendered: aIsPrerendered,
                                  nextTabParentId: aNextTabParentId,
                                  focusUrlBar: aFocusUrlBar,
                                  name: aName });
            if (!bgLoad)
              this.selectedTab = tab;

            return tab;
         ]]>
        </body>
      </method>

      <method name="loadTabs">
        <parameter name="aURIs"/>
        <parameter name="aLoadInBackground"/>
        <parameter name="aReplace"/>
        <body><![CDATA[
          let aTriggeringPrincipal;
          let aAllowThirdPartyFixup;
          let aTargetTab;
          let aNewIndex = -1;
          let aPostDatas = [];
          let aUserContextId;
          if (arguments.length == 2 &&
              typeof arguments[1] == "object") {
            let params = arguments[1];
            aLoadInBackground     = params.inBackground;
            aReplace              = params.replace;
            aAllowThirdPartyFixup = params.allowThirdPartyFixup;
            aTargetTab            = params.targetTab;
            aNewIndex             = typeof params.newIndex === "number" ?
                                    params.newIndex : aNewIndex;
            aPostDatas            = params.postDatas || aPostDatas;
            aUserContextId        = params.userContextId;
            aTriggeringPrincipal  = params.triggeringPrincipal;
          }

          if (!aURIs.length)
            return;

          // The tab selected after this new tab is closed (i.e. the new tab's
          // "owner") is the next adjacent tab (i.e. not the previously viewed tab)
          // when several urls are opened here (i.e. closing the first should select
          // the next of many URLs opened) or if the pref to have UI links opened in
          // the background is set (i.e. the link is not being opened modally)
          //
          // i.e.
          //    Number of URLs    Load UI Links in BG       Focus Last Viewed?
          //    == 1              false                     YES
          //    == 1              true                      NO
          //    > 1               false/true                NO
          var multiple = aURIs.length > 1;
          var owner = multiple || aLoadInBackground ? null : this.selectedTab;
          var firstTabAdded = null;
          var targetTabIndex = -1;

          if (aReplace) {
            let browser;
            if (aTargetTab) {
              browser = this.getBrowserForTab(aTargetTab);
              targetTabIndex = aTargetTab._tPos;
            } else {
              browser = this.mCurrentBrowser;
              targetTabIndex = this.tabContainer.selectedIndex;
            }
            let flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
            if (aAllowThirdPartyFixup) {
              flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP |
                       Ci.nsIWebNavigation.LOAD_FLAGS_FIXUP_SCHEME_TYPOS;
            }
            try {
              browser.loadURIWithFlags(aURIs[0], {
                flags, postData: aPostDatas[0],
                triggeringPrincipal: aTriggeringPrincipal,
              });
            } catch (e) {
              // Ignore failure in case a URI is wrong, so we can continue
              // opening the next ones.
            }
          } else {
            firstTabAdded = this.addTab(aURIs[0], {
              ownerTab: owner,
              skipAnimation: multiple,
              allowThirdPartyFixup: aAllowThirdPartyFixup,
              postData: aPostDatas[0],
              userContextId: aUserContextId,
              triggeringPrincipal: aTriggeringPrincipal,
            });
            if (aNewIndex !== -1) {
              this.moveTabTo(firstTabAdded, aNewIndex);
              targetTabIndex = firstTabAdded._tPos;
            }
          }

          let tabNum = targetTabIndex;
          for (let i = 1; i < aURIs.length; ++i) {
            let tab = this.addTab(aURIs[i], {
              skipAnimation: true,
              allowThirdPartyFixup: aAllowThirdPartyFixup,
              postData: aPostDatas[i],
              userContextId: aUserContextId,
              triggeringPrincipal: aTriggeringPrincipal,
            });
            if (targetTabIndex !== -1)
              this.moveTabTo(tab, ++tabNum);
          }

          if (firstTabAdded && !aLoadInBackground) {
            this.selectedTab = firstTabAdded;
          }
        ]]></body>
      </method>

      <method name="updateBrowserRemoteness">
        <parameter name="aBrowser"/>
        <parameter name="aShouldBeRemote"/>
        <parameter name="aOptions"/>
        <body>
          <![CDATA[
            aOptions = aOptions || {};
            let isRemote = aBrowser.getAttribute("remote") == "true";

            if (!gMultiProcessBrowser && aShouldBeRemote) {
              throw new Error("Cannot switch to remote browser in a window " +
                              "without the remote tabs load context.");
            }

            // Default values for remoteType
            if (!aOptions.remoteType) {
              aOptions.remoteType = aShouldBeRemote ? E10SUtils.DEFAULT_REMOTE_TYPE : E10SUtils.NOT_REMOTE;
            }

            // If we are passed an opener, we must be making the browser non-remote, and
            // if the browser is _currently_ non-remote, we need the openers to match,
            // because it is already too late to change it.
            if (aOptions.opener) {
              if (aShouldBeRemote) {
                throw new Error("Cannot set an opener on a browser which should be remote!");
              }
              if (!isRemote && aBrowser.contentWindow.opener != aOptions.opener) {
                throw new Error("Cannot change opener on an already non-remote browser!");
              }
            }

            // Abort if we're not going to change anything
            let currentRemoteType = aBrowser.getAttribute("remoteType");
            if (isRemote == aShouldBeRemote && !aOptions.newFrameloader &&
                (!isRemote || currentRemoteType == aOptions.remoteType)) {
              return false;
            }

            let tab = this.getTabForBrowser(aBrowser);
            // aBrowser needs to be inserted now if it hasn't been already.
            this._insertBrowser(tab);

            let evt = document.createEvent("Events");
            evt.initEvent("BeforeTabRemotenessChange", true, false);
            tab.dispatchEvent(evt);

            let wasActive = document.activeElement == aBrowser;

            // Unmap the old outerWindowID.
            this._outerWindowIDBrowserMap.delete(aBrowser.outerWindowID);

            // Unhook our progress listener.
            let filter = this._tabFilters.get(tab);
            let listener = this._tabListeners.get(tab);
            aBrowser.webProgress.removeProgressListener(filter);
            filter.removeProgressListener(listener);

            // We'll be creating a new listener, so destroy the old one.
            listener.destroy();

            let oldUserTypedValue = aBrowser.userTypedValue;
            let hadStartedLoad = aBrowser.didStartLoadSinceLastUserTyping();

            // Make sure the browser is destroyed so it unregisters from observer notifications
            aBrowser.destroy();

            // Make sure to restore the original droppedLinkHandler and
            // sameProcessAsFrameLoader.
            let droppedLinkHandler = aBrowser.droppedLinkHandler;
            let sameProcessAsFrameLoader = aBrowser.sameProcessAsFrameLoader;

            // Change the "remote" attribute.
            let parent = aBrowser.parentNode;
            parent.removeChild(aBrowser);
            if (aShouldBeRemote) {
              aBrowser.setAttribute("remote", "true");
              aBrowser.setAttribute("remoteType", aOptions.remoteType);
            } else {
              aBrowser.setAttribute("remote", "false");
              aBrowser.removeAttribute("remoteType");
            }

            // NB: This works with the hack in the browser constructor that
            // turns this normal property into a field.
            if (aOptions.sameProcessAsFrameLoader) {
              // Always set sameProcessAsFrameLoader when passed in aOptions.
              aBrowser.sameProcessAsFrameLoader = aOptions.sameProcessAsFrameLoader;
            } else if (!aShouldBeRemote || currentRemoteType == aOptions.remoteType) {
              // Only copy existing sameProcessAsFrameLoader when not switching
              // remote type otherwise it would stop the switch.
              aBrowser.sameProcessAsFrameLoader = sameProcessAsFrameLoader;
            }

            if (aOptions.opener) {
              // Set the opener window on the browser, such that when the frame
              // loader is created the opener is set correctly.
              aBrowser.presetOpenerWindow(aOptions.opener);
            }

            parent.appendChild(aBrowser);

            aBrowser.userTypedValue = oldUserTypedValue;
            if (hadStartedLoad) {
              aBrowser.urlbarChangeTracker.startedLoad();
            }

            aBrowser.droppedLinkHandler = droppedLinkHandler;

            // Switching a browser's remoteness will create a new frameLoader.
            // As frameLoaders start out with an active docShell we have to
            // deactivate it if this is not the selected tab's browser or the
            // browser window is minimized.
            aBrowser.docShellIsActive = this.shouldActivateDocShell(aBrowser);

            // Create a new tab progress listener for the new browser we just injected,
            // since tab progress listeners have logic for handling the initial about:blank
            // load
            listener = this.mTabProgressListener(tab, aBrowser, true, false);
            this._tabListeners.set(tab, listener);
            filter.addProgressListener(listener, Ci.nsIWebProgress.NOTIFY_ALL);

            // Restore the progress listener.
            aBrowser.webProgress.addProgressListener(filter, Ci.nsIWebProgress.NOTIFY_ALL);

            // Restore the securityUI state.
            let securityUI = aBrowser.securityUI;
            let state = securityUI ? securityUI.state
                                   : Ci.nsIWebProgressListener.STATE_IS_INSECURE;
            // Include the true final argument to indicate that this event is
            // simulated (instead of being observed by the webProgressListener).
            this._callProgressListeners(aBrowser, "onSecurityChange",
                                        [aBrowser.webProgress, null, state, true],
                                        true, false);

            if (aShouldBeRemote) {
              // Switching the browser to be remote will connect to a new child
              // process so the browser can no longer be considered to be
              // crashed.
              tab.removeAttribute("crashed");
            } else {
              aBrowser.messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: tab.pinned })

              // Register the new outerWindowID.
              this._outerWindowIDBrowserMap.set(aBrowser.outerWindowID, aBrowser);
            }

            if (wasActive)
              aBrowser.focus();

            // If the findbar has been initialised, reset its browser reference.
            if (this.isFindBarInitialized(tab)) {
              this.getFindBar(tab).browser = aBrowser;
            }

            evt = document.createEvent("Events");
            evt.initEvent("TabRemotenessChange", true, false);
            tab.dispatchEvent(evt);

            return true;
          ]]>
        </body>
      </method>

      <method name="updateBrowserRemotenessByURL">
        <parameter name="aBrowser"/>
        <parameter name="aURL"/>
        <parameter name="aOptions"/>
        <body>
          <![CDATA[
            aOptions = aOptions || {};

            if (!gMultiProcessBrowser)
              return this.updateBrowserRemoteness(aBrowser, false);

            let currentRemoteType = aBrowser.getAttribute("remoteType") || null;

            aOptions.remoteType =
              E10SUtils.getRemoteTypeForURI(aURL,
                                            gMultiProcessBrowser,
                                            currentRemoteType,
                                            aBrowser.currentURI);

            // If this URL can't load in the current browser then flip it to the
            // correct type.
            if (currentRemoteType != aOptions.remoteType ||
                aOptions.newFrameloader) {
              let remote = aOptions.remoteType != E10SUtils.NOT_REMOTE;
              return this.updateBrowserRemoteness(aBrowser, remote, aOptions);
            }

            return false;
          ]]>
        </body>
      </method>

      <method name="removePreloadedBrowser">
        <body>
          <![CDATA[
            if (!this._isPreloadingEnabled()) {
              return;
            }

            let browser = this._getPreloadedBrowser();

            if (browser) {
              browser.remove();
            }
          ]]>
        </body>
      </method>

      <field name="_preloadedBrowser">null</field>
      <method name="_getPreloadedBrowser">
        <body>
          <![CDATA[
            if (!this._isPreloadingEnabled()) {
              return null;
            }

            // The preloaded browser might be null.
            let browser = this._preloadedBrowser;

            // Consume the browser.
            this._preloadedBrowser = null;

            // Attach the nsIFormFillController now that we know the browser
            // will be used. If we do that before and the preloaded browser
            // won't be consumed until shutdown then we leak a docShell.
            // Also, we do not need to take care of attaching nsIFormFillControllers
            // in the case that the browser is remote, as remote browsers take
            // care of that themselves.
            if (browser && this.hasAttribute("autocompletepopup")) {
              browser.setAttribute("autocompletepopup", this.getAttribute("autocompletepopup"));
            }

            return browser;
          ]]>
        </body>
      </method>

      <method name="_isPreloadingEnabled">
        <body>
          <![CDATA[
            // Preloading for the newtab page is enabled when the pref is true
            // and the URL is "about:newtab". We do not support preloading for
            // custom newtab URLs.
            return Services.prefs.getBoolPref("browser.newtab.preload") &&
                   !aboutNewTabService.overridden;
          ]]>
        </body>
      </method>

      <method name="_createPreloadBrowser">
        <body>
          <![CDATA[
            // Do nothing if we have a preloaded browser already
            // or preloading of newtab pages is disabled.
            if (this._preloadedBrowser || !this._isPreloadingEnabled()) {
              return;
            }

            let remoteType =
              E10SUtils.getRemoteTypeForURI(BROWSER_NEW_TAB_URL,
                                            gMultiProcessBrowser);
            let browser = this._createBrowser({isPreloadBrowser: true, remoteType});
            this._preloadedBrowser = browser;

            let notificationbox = this.getNotificationBox(browser);
            this.mPanelContainer.appendChild(notificationbox);

            if (remoteType != E10SUtils.NOT_REMOTE) {
              // For remote browsers, we need to make sure that the webProgress is
              // instantiated, otherwise the parent won't get informed about the state
              // of the preloaded browser until it gets attached to a tab.
              browser.webProgress;
            }

            browser.loadURI(BROWSER_NEW_TAB_URL);
            browser.docShellIsActive = false;

            // Make sure the preloaded browser is loaded with desired zoom level
            let tabURI = Services.io.newURI(BROWSER_NEW_TAB_URL);
            FullZoom.onLocationChange(tabURI, false, browser);
          ]]>
        </body>
      </method>

      <method name="_createBrowser">
        <parameter name="aParams"/>
        <body>
          <![CDATA[
            // Supported parameters:
            // userContextId, remote, remoteType, isPreloadBrowser,
            // uriIsAboutBlank, sameProcessAsFrameLoader, isPrerendered

            const NS_XUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";

            let b = document.createElementNS(NS_XUL, "browser");
            b.permanentKey = {};
            b.setAttribute("type", "content");
            b.setAttribute("message", "true");
            b.setAttribute("messagemanagergroup", "browsers");
            b.setAttribute("contextmenu", this.getAttribute("contentcontextmenu"));
            b.setAttribute("tooltip", this.getAttribute("contenttooltip"));

            if (aParams.isPrerendered) {
              b.setAttribute("prerendered", "true");
            }

            if (aParams.userContextId) {
              b.setAttribute("usercontextid", aParams.userContextId);
            }

            // remote parameter used by some addons, use default in this case.
            if (aParams.remote && !aParams.remoteType) {
              aParams.remoteType = E10SUtils.DEFAULT_REMOTE_TYPE;
            }

            if (aParams.remoteType) {
              b.setAttribute("remoteType", aParams.remoteType);
              b.setAttribute("remote", "true");
            }

            if (aParams.openerWindow) {
              if (aParams.remoteType) {
                throw new Error("Cannot set opener window on a remote browser!");
              }
              b.presetOpenerWindow(aParams.openerWindow);
            }

            if (!aParams.isPreloadBrowser && this.hasAttribute("autocompletepopup")) {
              b.setAttribute("autocompletepopup", this.getAttribute("autocompletepopup"));
            }

            if (aParams.isPreloadBrowser) {
              b.setAttribute("isPreloadBrowser", "true");
            }

            if (this.hasAttribute("selectmenulist"))
              b.setAttribute("selectmenulist", this.getAttribute("selectmenulist"));

            if (this.hasAttribute("datetimepicker")) {
              b.setAttribute("datetimepicker", this.getAttribute("datetimepicker"));
            }

            b.setAttribute("autoscrollpopup", this._autoScrollPopup.id);

            if (aParams.nextTabParentId) {
              if (!aParams.remoteType) {
                throw new Error("Cannot have nextTabParentId without a remoteType");
              }
              // Gecko is going to read this attribute and use it.
              b.setAttribute("nextTabParentId", aParams.nextTabParentId.toString());
            }

            if (aParams.sameProcessAsFrameLoader) {
              b.sameProcessAsFrameLoader = aParams.sameProcessAsFrameLoader;
            }

            // This will be used by gecko to control the name of the opened
            // window.
            if (aParams.name) {
              // XXX: The `name` property is special in HTML and XUL. Should
              // we use a different attribute name for this?
              b.setAttribute("name", aParams.name);
            }

            // Create the browserStack container
            var stack = document.createElementNS(NS_XUL, "stack");
            stack.className = "browserStack";
            stack.appendChild(b);
            stack.setAttribute("flex", "1");

            // Create the browserContainer
            var browserContainer = document.createElementNS(NS_XUL, "vbox");
            browserContainer.className = "browserContainer";
            browserContainer.appendChild(stack);
            browserContainer.setAttribute("flex", "1");

            // Create the sidebar container
            var browserSidebarContainer = document.createElementNS(NS_XUL,
                                                                   "hbox");
            browserSidebarContainer.className = "browserSidebarContainer";
            browserSidebarContainer.appendChild(browserContainer);
            browserSidebarContainer.setAttribute("flex", "1");

            // Add the Message and the Browser to the box
            var notificationbox = document.createElementNS(NS_XUL,
                                                           "notificationbox");
            notificationbox.setAttribute("flex", "1");
            notificationbox.setAttribute("notificationside", "top");
            notificationbox.appendChild(browserSidebarContainer);

            // Prevent the superfluous initial load of a blank document
            // if we're going to load something other than about:blank.
            if (!aParams.uriIsAboutBlank) {
              b.setAttribute("nodefaultsrc", "true");
            }

            return b;
          ]]>
        </body>
      </method>

      <!--
        `_createLazyBrowser` will define properties on the unbound lazy browser
        which correspond to properties defined in XBL which will be bound to
        the browser when it is inserted into the document.  If any of these
        properties are accessed by consumers, `_insertBrowser` is called and
        the browser is inserted to ensure that things don't break.  This list
        provides the names of properties that may be called while the browser
        is in its unbound (lazy) state.
      -->
      <field name="_browserBindingProperties">[
        "canGoBack", "canGoForward", "goBack", "goForward", "permitUnload",
        "reload", "reloadWithFlags", "stop", "loadURI", "loadURIWithFlags",
        "goHome", "homePage", "gotoIndex", "currentURI", "documentURI",
        "preferences", "imageDocument", "isRemoteBrowser", "messageManager",
        "getTabBrowser", "finder", "fastFind", "sessionHistory", "contentTitle",
        "characterSet", "fullZoom", "textZoom", "webProgress",
        "addProgressListener", "removeProgressListener", "audioPlaybackStarted",
        "audioPlaybackStopped", "pauseMedia", "stopMedia",
        "resumeMedia", "mute", "unmute", "blockedPopups", "lastURI",
        "purgeSessionHistory", "stopScroll", "startScroll",
        "userTypedValue", "userTypedClear", "mediaBlocked",
        "didStartLoadSinceLastUserTyping"
      ]</field>

      <method name="_createLazyBrowser">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            let browser = aTab.linkedBrowser;

            let names = this._browserBindingProperties;

            for (let i = 0; i < names.length; i++) {
              let name = names[i];
              let getter;
              let setter;
              switch (name) {
                case "audioMuted":
                  getter = () => false;
                  break;
                case "contentTitle":
                  getter = () => SessionStore.getLazyTabValue(aTab, "title");
                  break;
                case "currentURI":
                  getter = () => {
                    let url = SessionStore.getLazyTabValue(aTab, "url");
                    return Services.io.newURI(url);
                  };
                  break;
                case "didStartLoadSinceLastUserTyping":
                  getter = () => () => false;
                  break;
                case "fullZoom":
                case "textZoom":
                  getter = () => 1;
                  break;
                case "getTabBrowser":
                  getter = () => () => this;
                  break;
                case "isRemoteBrowser":
                  getter = () => browser.getAttribute("remote") == "true";
                  break;
                case "permitUnload":
                  getter = () => () => ({ permitUnload: true, timedOut: false });
                  break;
                case "reload":
                case "reloadWithFlags":
                  getter = () =>
                    params => {
                      // Wait for load handler to be instantiated before
                      // initializing the reload.
                      aTab.addEventListener("SSTabRestoring", () => {
                        browser[name](params);
                      }, { once: true });
                      gBrowser._insertBrowser(aTab);
                    };
                  break;
                case "resumeMedia":
                  getter = () =>
                    () => {
                      // No need to insert a browser, so we just call the browser's
                      // method.
                      aTab.addEventListener("SSTabRestoring", () => {
                        browser[name]();
                      }, { once: true });
                    };
                  break;
                case "userTypedValue":
                case "userTypedClear":
                case "mediaBlocked":
                  getter = () => SessionStore.getLazyTabValue(aTab, name);
                  break;
                default:
                  getter = () => {
                    if (AppConstants.NIGHTLY_BUILD) {
                      let message =
                        `[bug 1345098] Lazy browser prematurely inserted via '${name}' property access:\n`
                      console.log(message + new Error().stack);
                    }
                    this._insertBrowser(aTab);
                    return browser[name];
                  };
                  setter = value => {
                    if (AppConstants.NIGHTLY_BUILD) {
                      let message =
                        `[bug 1345098] Lazy browser prematurely inserted via '${name}' property access:\n`
                      console.log(message + new Error().stack);
                    }
                    this._insertBrowser(aTab);
                    return browser[name] = value;
                  };
              }
              Object.defineProperty(browser, name, {
                get: getter,
                set: setter,
                configurable: true,
                enumerable: true
              });
            }
          ]]>
        </body>
      </method>

      <method name="_insertBrowser">
        <parameter name="aTab"/>
        <parameter name="aInsertedOnTabCreation"/>
        <body>
          <![CDATA[
            "use strict";

            // If browser is already inserted or window is closed don't do anything.
            if (aTab.linkedPanel || window.closed) {
              return;
            }

            let browser = aTab.linkedBrowser;

            // If browser is a lazy browser, delete the substitute properties.
            if (this._browserBindingProperties[0] in browser) {
              for (let name of this._browserBindingProperties) {
                delete browser[name];
              }
            }

            let { uriIsAboutBlank, remoteType, usingPreloadedContent } =
                    aTab._browserParams;
            delete aTab._browserParams;

            let notificationbox = this.getNotificationBox(browser);
            let uniqueId = this._generateUniquePanelID();
            notificationbox.id = uniqueId;
            aTab.linkedPanel = uniqueId;

            // Inject the <browser> into the DOM if necessary.
            if (!notificationbox.parentNode) {
              // NB: this appendChild call causes us to run constructors for the
              // browser element, which fires off a bunch of notifications. Some
              // of those notifications can cause code to run that inspects our
              // state, so it is important that the tab element is fully
              // initialized by this point.
              this.mPanelContainer.appendChild(notificationbox);
            }

            // wire up a progress listener for the new browser object.
            let tabListener = this.mTabProgressListener(aTab, browser, uriIsAboutBlank, usingPreloadedContent);
            const filter = Cc["@mozilla.org/appshell/component/browser-status-filter;1"]
                                     .createInstance(Ci.nsIWebProgress);
            filter.addProgressListener(tabListener, Ci.nsIWebProgress.NOTIFY_ALL);
            browser.webProgress.addProgressListener(filter, Ci.nsIWebProgress.NOTIFY_ALL);
            this._tabListeners.set(aTab, tabListener);
            this._tabFilters.set(aTab, filter);

            browser.droppedLinkHandler = handleDroppedLink;

            // We start our browsers out as inactive, and then maintain
            // activeness in the tab switcher.
            browser.docShellIsActive = false;

            // When addTab() is called with an URL that is not "about:blank" we
            // set the "nodefaultsrc" attribute that prevents a frameLoader
            // from being created as soon as the linked <browser> is inserted
            // into the DOM. We thus have to register the new outerWindowID
            // for non-remote browsers after we have called browser.loadURI().
            if (remoteType == E10SUtils.NOT_REMOTE) {
              this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
            }

            var evt = new CustomEvent("TabBrowserInserted",
              { bubbles: true, detail: { insertedOnTabCreation: aInsertedOnTabCreation } });
            aTab.dispatchEvent(evt);
          ]]>
        </body>
      </method>

      <method name="discardBrowser">
        <parameter name="aBrowser"/>
        <body>
          <![CDATA[
            "use strict";

            let tab = this.getTabForBrowser(aBrowser);

            if (!tab ||
                tab.selected ||
                tab.closing ||
                this._windowIsClosing ||
                !aBrowser.isConnected ||
                !aBrowser.isRemoteBrowser ||
                aBrowser.frameLoader.tabParent.hasBeforeUnload) {
              return;
            }

            // Set browser parameters for when browser is restored.  Also remove
            // listeners and set up lazy restore data in SessionStore. This must
            // be done before aBrowser is destroyed and removed from the document.
            tab._browserParams = { uriIsAboutBlank: aBrowser.currentURI.spec == "about:blank",
                                   remoteType: aBrowser.remoteType,
                                   usingPreloadedContent: false };

            SessionStore.resetBrowserToLazyState(tab);

            this._outerWindowIDBrowserMap.delete(aBrowser.outerWindowID);

            // Remove the tab's filter and progress listener.
            let filter = this._tabFilters.get(tab);
            let listener = this._tabListeners.get(tab);
            aBrowser.webProgress.removeProgressListener(filter);
            filter.removeProgressListener(listener);
            listener.destroy();

            this._tabListeners.delete(tab);
            this._tabFilters.delete(tab);

            aBrowser.destroy();

            let notificationbox = this.getNotificationBox(aBrowser);
            this.mPanelContainer.removeChild(notificationbox);
            tab.removeAttribute("linkedpanel");

            this._createLazyBrowser(tab);
          ]]>
        </body>
      </method>

      <method name="addTab">
        <parameter name="aURI"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aPostData"/>
        <parameter name="aOwner"/>
        <parameter name="aAllowThirdPartyFixup"/>
        <body>
          <![CDATA[
            "use strict";

            const NS_XUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
            var aTriggeringPrincipal;
            var aReferrerPolicy;
            var aFromExternal;
            var aRelatedToCurrent;
            var aSkipAnimation;
            var aAllowMixedContent;
            var aForceNotRemote;
            var aPreferredRemoteType;
            var aNoReferrer;
            var aUserContextId;
            var aEventDetail;
            var aSameProcessAsFrameLoader;
            var aOriginPrincipal;
            var aDisallowInheritPrincipal;
            var aOpener;
            var aOpenerBrowser;
            var aIsPrerendered;
            var aCreateLazyBrowser;
            var aSkipBackgroundNotify;
            var aNextTabParentId;
            var aNoInitialLabel;
            var aFocusUrlBar;
            var aName;
            if (arguments.length == 2 &&
                typeof arguments[1] == "object" &&
                !(arguments[1] instanceof Ci.nsIURI)) {
              let params = arguments[1];
              aTriggeringPrincipal      = params.triggeringPrincipal;
              aReferrerURI              = params.referrerURI;
              aReferrerPolicy           = params.referrerPolicy;
              aCharset                  = params.charset;
              aPostData                 = params.postData;
              aOwner                    = params.ownerTab;
              aAllowThirdPartyFixup     = params.allowThirdPartyFixup;
              aFromExternal             = params.fromExternal;
              aRelatedToCurrent         = params.relatedToCurrent;
              aSkipAnimation            = params.skipAnimation;
              aAllowMixedContent        = params.allowMixedContent;
              aForceNotRemote           = params.forceNotRemote;
              aPreferredRemoteType      = params.preferredRemoteType;
              aNoReferrer               = params.noReferrer;
              aUserContextId            = params.userContextId;
              aEventDetail              = params.eventDetail;
              aSameProcessAsFrameLoader = params.sameProcessAsFrameLoader;
              aOriginPrincipal          = params.originPrincipal;
              aDisallowInheritPrincipal = params.disallowInheritPrincipal;
              aOpener                   = params.opener;
              aOpenerBrowser            = params.openerBrowser;
              aIsPrerendered            = params.isPrerendered;
              aCreateLazyBrowser        = params.createLazyBrowser;
              aSkipBackgroundNotify     = params.skipBackgroundNotify;
              aNextTabParentId          = params.nextTabParentId;
              aNoInitialLabel           = params.noInitialLabel;
              aFocusUrlBar              = params.focusUrlBar;
              aName                     = params.name;
            }

            // if we're adding tabs, we're past interrupt mode, ditch the owner
            if (this.mCurrentTab.owner)
              this.mCurrentTab.owner = null;

            // Find the tab that opened this one, if any. This is used for
            // determining positioning, and inherited attributes such as the
            // user context ID.
            //
            // If we have a browser opener (which is usually the browser
            // element from a remote window.open() call), use that.
            //
            // Otherwise, if the tab is related to the current tab (e.g.,
            // because it was opened by a link click), use the selected tab as
            // the owner. If aReferrerURI is set, and we don't have an
            // explicit relatedToCurrent arg, we assume that the tab is
            // related to the current tab, since aReferrerURI is null or
            // undefined if the tab is opened from an external application or
            // bookmark (i.e. somewhere other than an existing tab).
            let relatedToCurrent = aRelatedToCurrent == null ? !!aReferrerURI : aRelatedToCurrent;
            let openerTab = ((aOpenerBrowser && this.getTabForBrowser(aOpenerBrowser)) ||
                             (relatedToCurrent && this.selectedTab));

            var t = document.createElementNS(NS_XUL, "tab");

            t.openerTab = openerTab;

            aURI = aURI || "about:blank";
            let aURIObject = null;
            try {
              aURIObject = Services.io.newURI(aURI);
            } catch (ex) { /* we'll try to fix up this URL later */ }

            let lazyBrowserURI;
            if (aCreateLazyBrowser && aURI != "about:blank") {
              lazyBrowserURI = aURIObject;
              aURI = "about:blank";
            }

            var uriIsAboutBlank = aURI == "about:blank";

            if (!aNoInitialLabel) {
              if (isBlankPageURL(aURI)) {
                t.setAttribute("label", gTabBrowserBundle.GetStringFromName("tabs.emptyTabTitle"));
              } else {
                // Set URL as label so that the tab isn't empty initially.
                this.setInitialTabTitle(t, aURI, { beforeTabOpen: true });
              }
            }

            if (aIsPrerendered) {
              t.setAttribute("hidden", "true");
            }

            // Related tab inherits current tab's user context unless a different
            // usercontextid is specified
            if (aUserContextId == null && openerTab) {
              aUserContextId = openerTab.getAttribute("usercontextid") || 0;
            }

            if (aUserContextId) {
              t.setAttribute("usercontextid", aUserContextId);
              ContextualIdentityService.setTabStyle(t);
            }

            t.setAttribute("onerror", "this.removeAttribute('image');");

            if (aSkipBackgroundNotify) {
              t.setAttribute("skipbackgroundnotify", true);
            }

            t.className = "tabbrowser-tab";

            this.tabContainer._unlockTabSizing();

            // When overflowing, new tabs are scrolled into view smoothly, which
            // doesn't go well together with the width transition. So we skip the
            // transition in that case.
            let animate = !aSkipAnimation &&
                          this.tabContainer.getAttribute("overflow") != "true" &&
                          this.animationsEnabled;
            if (!animate) {
              t.setAttribute("fadein", "true");

              // Call _handleNewTab asynchronously as it needs to know if the
              // new tab is selected.
              setTimeout(function(tabContainer) {
                tabContainer._handleNewTab(t);
              }, 0, this.tabContainer);
            }

            // invalidate cache
            this._visibleTabs = null;

            this.tabContainer.appendChild(t);

            let usingPreloadedContent = false;
            let b;

            try {
              // If this new tab is owned by another, assert that relationship
              if (aOwner)
                t.owner = aOwner;

              var position = this.tabs.length - 1;
              t._tPos = position;
              this.tabContainer._setPositionalAttributes();

              this.tabContainer.updateVisibility();

              // If we don't have a preferred remote type, and we have a remote
              // opener, use the opener's remote type.
              if (!aPreferredRemoteType && aOpenerBrowser) {
                aPreferredRemoteType = aOpenerBrowser.remoteType;
              }

              // If URI is about:blank and we don't have a preferred remote type,
              // then we need to use the referrer, if we have one, to get the
              // correct remote type for the new tab.
              if (uriIsAboutBlank && !aPreferredRemoteType && aReferrerURI) {
                aPreferredRemoteType =
                  E10SUtils.getRemoteTypeForURI(aReferrerURI.spec,
                                                gMultiProcessBrowser);
              }

              let remoteType =
                aForceNotRemote ? E10SUtils.NOT_REMOTE
                : E10SUtils.getRemoteTypeForURI(aURI, gMultiProcessBrowser,
                                                aPreferredRemoteType);

              // If we open a new tab with the newtab URL in the default
              // userContext, check if there is a preloaded browser ready.
              // Private windows are not included because both the label and the
              // icon for the tab would be set incorrectly (see bug 1195981).
              if (aURI == BROWSER_NEW_TAB_URL &&
                  !aUserContextId &&
                  !PrivateBrowsingUtils.isWindowPrivate(window)) {
                b = this._getPreloadedBrowser();
                if (b) {
                  usingPreloadedContent = true;
                }
              }

              if (!b) {
                // No preloaded browser found, create one.
                b = this._createBrowser({ remoteType,
                                          uriIsAboutBlank,
                                          userContextId: aUserContextId,
                                          sameProcessAsFrameLoader: aSameProcessAsFrameLoader,
                                          openerWindow: aOpener,
                                          isPrerendered: aIsPrerendered,
                                          nextTabParentId: aNextTabParentId,
                                          name: aName });
              }

              t.linkedBrowser = b;

              if (aFocusUrlBar) {
                b._urlbarFocused = true;
              }

              this._tabForBrowser.set(b, t);
              t.permanentKey = b.permanentKey;
              t._browserParams = { uriIsAboutBlank,
                                   remoteType,
                                   usingPreloadedContent };

              // If the caller opts in, create a lazy browser.
              if (aCreateLazyBrowser) {
                this._createLazyBrowser(t);

                if (lazyBrowserURI) {
                  // Lazy browser must be explicitly registered so tab will appear as
                  // a switch-to-tab candidate in autocomplete.
                  this._unifiedComplete.registerOpenPage(lazyBrowserURI, aUserContextId);
                  b.registeredOpenURI = lazyBrowserURI;
                }
              } else {
                this._insertBrowser(t, true);
              }
            } catch (e) {
              Cu.reportError("Failed to create tab");
              Cu.reportError(e);
              t.remove();
              if (t.linkedBrowser) {
                this._tabFilters.delete(t);
                this._tabListeners.delete(t);
                let notificationbox = this.getNotificationBox(t.linkedBrowser);
                notificationbox.remove();
              }
              throw e;
            }

            // Dispatch a new tab notification.  We do this once we're
            // entirely done, so that things are in a consistent state
            // even if the event listener opens or closes tabs.
            var detail = aEventDetail || {};
            var evt = new CustomEvent("TabOpen", { bubbles: true, detail });
            t.dispatchEvent(evt);

            if (!usingPreloadedContent && aOriginPrincipal && aURI) {
              let {URI_INHERITS_SECURITY_CONTEXT} = Ci.nsIProtocolHandler;
              // Unless we know for sure we're not inheriting principals,
              // force the about:blank viewer to have the right principal:
              if (!aURIObject ||
                  (doGetProtocolFlags(aURIObject) & URI_INHERITS_SECURITY_CONTEXT)) {
                b.createAboutBlankContentViewer(aOriginPrincipal);
              }
            }

            // If we didn't swap docShells with a preloaded browser
            // then let's just continue loading the page normally.
            if (!usingPreloadedContent && (!uriIsAboutBlank || aDisallowInheritPrincipal)) {
              // pretend the user typed this so it'll be available till
              // the document successfully loads
              if (aURI && gInitialPages.indexOf(aURI) == -1)
                b.userTypedValue = aURI;

              let flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
              if (aAllowThirdPartyFixup) {
                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;
                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_FIXUP_SCHEME_TYPOS;
              }
              if (aFromExternal)
                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_FROM_EXTERNAL;
              if (aAllowMixedContent)
                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_MIXED_CONTENT;
              if (aDisallowInheritPrincipal)
                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL;
              try {
                b.loadURIWithFlags(aURI, {
                  flags,
                  triggeringPrincipal: aTriggeringPrincipal,
                  referrerURI: aNoReferrer ? null : aReferrerURI,
                  referrerPolicy: aReferrerPolicy,
                  charset: aCharset,
                  postData: aPostData,
                });
              } catch (ex) {
                Cu.reportError(ex);
              }
            }

            // If we're opening a tab related to the an existing tab, move it
            // to a position after that tab.
            if (openerTab &&
                Services.prefs.getBoolPref("browser.tabs.insertRelatedAfterCurrent")) {

              let lastRelatedTab = this._lastRelatedTabMap.get(openerTab);
              let newTabPos = (lastRelatedTab || openerTab)._tPos + 1;
              if (lastRelatedTab)
                lastRelatedTab.owner = null;
              else
                t.owner = openerTab;
              this.moveTabTo(t, newTabPos, true);
              this._lastRelatedTabMap.set(openerTab, t);
            }

            // This field is updated regardless if we actually animate
            // since it's important that we keep this count correct in all cases.
            this.tabAnimationsInProgress++;

            if (animate) {
              requestAnimationFrame(function() {
                // kick the animation off
                t.setAttribute("fadein", "true");
              });
            }

            return t;
          ]]>
        </body>
      </method>

      <method name="warnAboutClosingTabs">
      <parameter name="aCloseTabs"/>
      <parameter name="aTab"/>
      <body>
        <![CDATA[
          var tabsToClose;
          switch (aCloseTabs) {
            case this.closingTabsEnum.ALL:
              tabsToClose = this.tabs.length - this._removingTabs.length -
                            gBrowser._numPinnedTabs;
              break;
            case this.closingTabsEnum.OTHER:
              tabsToClose = this.visibleTabs.length - 1 - gBrowser._numPinnedTabs;
              break;
            case this.closingTabsEnum.TO_END:
              if (!aTab)
                throw new Error("Required argument missing: aTab");

              tabsToClose = this.getTabsToTheEndFrom(aTab).length;
              break;
            default:
              throw new Error("Invalid argument: " + aCloseTabs);
          }

          if (tabsToClose <= 1)
            return true;

          const pref = aCloseTabs == this.closingTabsEnum.ALL ?
                       "browser.tabs.warnOnClose" : "browser.tabs.warnOnCloseOtherTabs";
          var shouldPrompt = Services.prefs.getBoolPref(pref);
          if (!shouldPrompt)
            return true;

          var ps = Services.prompt;

          // default to true: if it were false, we wouldn't get this far
          var warnOnClose = { value: true };

          // focus the window before prompting.
          // this will raise any minimized window, which will
          // make it obvious which window the prompt is for and will
          // solve the problem of windows "obscuring" the prompt.
          // see bug #350299 for more details
          window.focus();
          var warningMessage =
            PluralForm.get(tabsToClose, gTabBrowserBundle.GetStringFromName("tabs.closeWarningMultiple"))
                      .replace("#1", tabsToClose);
          var buttonPressed =
            ps.confirmEx(window,
                         gTabBrowserBundle.GetStringFromName("tabs.closeWarningTitle"),
                         warningMessage,
                         (ps.BUTTON_TITLE_IS_STRING * ps.BUTTON_POS_0)
                         + (ps.BUTTON_TITLE_CANCEL * ps.BUTTON_POS_1),
                         gTabBrowserBundle.GetStringFromName("tabs.closeButtonMultiple"),
                         null, null,
                         aCloseTabs == this.closingTabsEnum.ALL ?
                           gTabBrowserBundle.GetStringFromName("tabs.closeWarningPromptMe") : null,
                         warnOnClose);
          var reallyClose = (buttonPressed == 0);

          // don't set the pref unless they press OK and it's false
          if (aCloseTabs == this.closingTabsEnum.ALL && reallyClose && !warnOnClose.value)
            Services.prefs.setBoolPref(pref, false);

          return reallyClose;
        ]]>
      </body>
      </method>

      <method name="getTabsToTheEndFrom">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            var tabsToEnd = [];
            let tabs = this.visibleTabs;
            for (let i = tabs.length - 1; tabs[i] != aTab && i >= 0; --i) {
              tabsToEnd.push(tabs[i]);
            }
            return tabsToEnd;
          ]]>
        </body>
      </method>

      <method name="removeTabsToTheEndFrom">
        <parameter name="aTab"/>
        <parameter name="aParams"/>
        <body>
          <![CDATA[
            if (!this.warnAboutClosingTabs(this.closingTabsEnum.TO_END, aTab))
              return;

            let removeTab = tab => {
              // Avoid changing the selected browser several times.
              if (tab.selected)
                this.selectedTab = aTab;

              this.removeTab(tab, aParams);
            };

            let tabs = this.getTabsToTheEndFrom(aTab);
            let tabsWithBeforeUnload = [];
            for (let i = tabs.length - 1; i >= 0; --i) {
              let tab = tabs[i];
              if (this._hasBeforeUnload(tab))
                tabsWithBeforeUnload.push(tab);
              else
                removeTab(tab);
            }
            tabsWithBeforeUnload.forEach(removeTab);
          ]]>
        </body>
      </method>

      <method name="removeAllTabsBut">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            if (aTab.pinned ||
                !this.warnAboutClosingTabs(this.closingTabsEnum.OTHER))
              return;

            let tabs = this.visibleTabs.reverse();
            this.selectedTab = aTab;

            let tabsWithBeforeUnload = [];
            for (let i = tabs.length - 1; i >= 0; --i) {
              let tab = tabs[i];
              if (tab != aTab && !tab.pinned) {
                if (this._hasBeforeUnload(tab))
                  tabsWithBeforeUnload.push(tab)
                else
                  this.removeTab(tab, {animate: true});
              }
            }
            for (let tab of tabsWithBeforeUnload) {
              this.removeTab(tab, {animate: true});
            }
          ]]>
        </body>
      </method>

      <method name="removeCurrentTab">
        <parameter name="aParams"/>
        <body>
          <![CDATA[
            this.removeTab(this.mCurrentTab, aParams);
          ]]>
        </body>
      </method>

      <field name="_removingTabs">
        []
      </field>

      <method name="removeTab">
        <parameter name="aTab"/>
        <parameter name="aParams"/>
        <body>
          <![CDATA[
            if (aParams) {
              var animate = aParams.animate;
              var byMouse = aParams.byMouse;
              var skipPermitUnload = aParams.skipPermitUnload;
            }

            // Telemetry stopwatches may already be running if removeTab gets
            // called again for an already closing tab.
            if (!TelemetryStopwatch.running("FX_TAB_CLOSE_TIME_ANIM_MS", aTab) &&
                !TelemetryStopwatch.running("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab)) {
              // Speculatevely start both stopwatches now. We'll cancel one of
              // the two later depending on whether we're animating.
              TelemetryStopwatch.start("FX_TAB_CLOSE_TIME_ANIM_MS", aTab);
              TelemetryStopwatch.start("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab);
            }
            window.maybeRecordAbandonmentTelemetry(aTab, "tabClosed");

            // Handle requests for synchronously removing an already
            // asynchronously closing tab.
            if (!animate &&
                aTab.closing) {
              this._endRemoveTab(aTab);
              return;
            }

            var isLastTab = (this.tabs.length - this._removingTabs.length == 1);

            if (!this._beginRemoveTab(aTab, null, null, true, skipPermitUnload)) {
              TelemetryStopwatch.cancel("FX_TAB_CLOSE_TIME_ANIM_MS", aTab);
              TelemetryStopwatch.cancel("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab);
              return;
            }

            if (!aTab.pinned && !aTab.hidden && aTab._fullyOpen && byMouse)
              this.tabContainer._lockTabSizing(aTab);
            else
              this.tabContainer._unlockTabSizing();

            if (!animate /* the caller didn't opt in */ ||
                isLastTab ||
                aTab.pinned ||
                aTab.hidden ||
                this._removingTabs.length > 3 /* don't want lots of concurrent animations */ ||
                aTab.getAttribute("fadein") != "true" /* fade-in transition hasn't been triggered yet */ ||
                window.getComputedStyle(aTab).maxWidth == "0.1px" /* fade-in transition hasn't moved yet */ ||
                !this.animationsEnabled) {
              // We're not animating, so we can cancel the animation stopwatch.
              TelemetryStopwatch.cancel("FX_TAB_CLOSE_TIME_ANIM_MS", aTab);
              this._endRemoveTab(aTab);
              return;
            }

            // We're animating, so we can cancel the non-animation stopwatch.
            TelemetryStopwatch.cancel("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab);

            aTab.style.maxWidth = ""; // ensure that fade-out transition happens
            aTab.removeAttribute("fadein");
            aTab.removeAttribute("bursting");

            setTimeout(function(tab, tabbrowser) {
              if (tab.parentNode &&
                  window.getComputedStyle(tab).maxWidth == "0.1px") {
                NS_ASSERT(false, "Giving up waiting for the tab closing animation to finish (bug 608589)");
                tabbrowser._endRemoveTab(tab);
              }
            }, 3000, aTab, this);
          ]]>
        </body>
      </method>

      <!-- Tab close requests are ignored if the window is closing anyway,
           e.g. when holding Ctrl+W. -->
      <field name="_windowIsClosing">
        false
      </field>

      <method name="_hasBeforeUnload">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            let browser = aTab.linkedBrowser;
            return browser.isRemoteBrowser && browser.frameLoader &&
                   browser.frameLoader.tabParent &&
                   browser.frameLoader.tabParent.hasBeforeUnload;
          ]]>
        </body>
      </method>

      <method name="_beginRemoveTab">
        <parameter name="aTab"/>
        <parameter name="aAdoptedByTab"/>
        <parameter name="aCloseWindowWithLastTab"/>
        <parameter name="aCloseWindowFastpath"/>
        <parameter name="aSkipPermitUnload"/>
        <body>
          <![CDATA[
            if (aTab.closing ||
                this._windowIsClosing)
              return false;

            var browser = this.getBrowserForTab(aTab);
            if (!aSkipPermitUnload && !aAdoptedByTab &&
                aTab.linkedPanel && !aTab._pendingPermitUnload &&
                (!browser.isRemoteBrowser || this._hasBeforeUnload(aTab))) {
              TelemetryStopwatch.start("FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS", aTab);

              // We need to block while calling permitUnload() because it
              // processes the event queue and may lead to another removeTab()
              // call before permitUnload() returns.
              aTab._pendingPermitUnload = true;
              let {permitUnload, timedOut} = browser.permitUnload();
              delete aTab._pendingPermitUnload;

              TelemetryStopwatch.finish("FX_TAB_CLOSE_PERMIT_UNLOAD_TIME_MS", aTab);

              // If we were closed during onbeforeunload, we return false now
              // so we don't (try to) close the same tab again. Of course, we
              // also stop if the unload was cancelled by the user:
              if (aTab.closing || (!timedOut && !permitUnload)) {
                return false;
              }
            }

            this._blurTab(aTab);

            var closeWindow = false;
            var newTab = false;
            if (this.tabs.length - this._removingTabs.length == 1) {
              closeWindow = aCloseWindowWithLastTab != null ? aCloseWindowWithLastTab :
                            !window.toolbar.visible ||
                              Services.prefs.getBoolPref("browser.tabs.closeWindowWithLastTab");

              if (closeWindow) {
                // We've already called beforeunload on all the relevant tabs if we get here,
                // so avoid calling it again:
                window.skipNextCanClose = true;
              }

              // Closing the tab and replacing it with a blank one is notably slower
              // than closing the window right away. If the caller opts in, take
              // the fast path.
              if (closeWindow &&
                  aCloseWindowFastpath &&
                  this._removingTabs.length == 0) {
                // This call actually closes the window, unless the user
                // cancels the operation.  We are finished here in both cases.
                this._windowIsClosing = window.closeWindow(true, window.warnAboutClosingWindow);
                return false;
              }

              newTab = true;
            }
            aTab._endRemoveArgs = [closeWindow, newTab];

            // swapBrowsersAndCloseOther will take care of closing the window without animation.
            if (closeWindow && aAdoptedByTab) {
              // Remove the tab's filter to avoid leaking.
              if (aTab.linkedPanel) {
                this._tabFilters.delete(aTab);
              }
              return true;
            }

            if (!aTab._fullyOpen) {
              // If the opening tab animation hasn't finished before we start closing the
              // tab, decrement the animation count since _handleNewTab will not get called.
              this.tabAnimationsInProgress--;
            }

            this.tabAnimationsInProgress++;

            // Mute audio immediately to improve perceived speed of tab closure.
            if (!aAdoptedByTab && aTab.hasAttribute("soundplaying")) {
              // Don't persist the muted state as this wasn't a user action.
              // This lets undo-close-tab return it to an unmuted state.
              aTab.linkedBrowser.mute(true);
            }

            aTab.closing = true;
            this._removingTabs.push(aTab);
            this._visibleTabs = null; // invalidate cache

            // Invalidate hovered tab state tracking for this closing tab.
            if (this.tabContainer._hoveredTab == aTab)
              aTab._mouseleave();

            if (newTab)
              this.addTab(BROWSER_NEW_TAB_URL, {skipAnimation: true});
            else
              this.tabContainer.updateVisibility();

            // We're committed to closing the tab now.
            // Dispatch a notification.
            // We dispatch it before any teardown so that event listeners can
            // inspect the tab that's about to close.
            var evt = new CustomEvent("TabClose", { bubbles: true, detail: { adoptedBy: aAdoptedByTab } });
            aTab.dispatchEvent(evt);

            if (aTab.linkedPanel) {
              if (!aAdoptedByTab && !gMultiProcessBrowser) {
                // Prevent this tab from showing further dialogs, since we're closing it
                var windowUtils = browser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor).
                                  getInterface(Ci.nsIDOMWindowUtils);
                windowUtils.disableDialogs();
              }

              // Remove the tab's filter and progress listener.
              const filter = this._tabFilters.get(aTab);

              browser.webProgress.removeProgressListener(filter);

              const listener = this._tabListeners.get(aTab);
              filter.removeProgressListener(listener);
              listener.destroy();
            }

            if (browser.registeredOpenURI && !aAdoptedByTab) {
              this._unifiedComplete.unregisterOpenPage(browser.registeredOpenURI,
                                                       browser.getAttribute("usercontextid") || 0);
              delete browser.registeredOpenURI;
            }

            // We are no longer the primary content area.
            browser.removeAttribute("primary");

            // Remove this tab as the owner of any other tabs, since it's going away.
            for (let tab of this.tabs) {
              if ("owner" in tab && tab.owner == aTab)
                // |tab| is a child of the tab we're removing, make it an orphan
                tab.owner = null;
            }

            return true;
          ]]>
        </body>
      </method>

      <method name="_endRemoveTab">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            if (!aTab || !aTab._endRemoveArgs)
              return;

            var [aCloseWindow, aNewTab] = aTab._endRemoveArgs;
            aTab._endRemoveArgs = null;

            if (this._windowIsClosing) {
              aCloseWindow = false;
              aNewTab = false;
            }

            this.tabAnimationsInProgress--;

            this._lastRelatedTabMap = new WeakMap();

            // update the UI early for responsiveness
            aTab.collapsed = true;
            this._blurTab(aTab);

            this._removingTabs.splice(this._removingTabs.indexOf(aTab), 1);

            if (aCloseWindow) {
              this._windowIsClosing = true;
              while (this._removingTabs.length)
                this._endRemoveTab(this._removingTabs[0]);
            } else if (!this._windowIsClosing) {
              if (aNewTab)
                focusAndSelectUrlBar();

              // workaround for bug 345399
              this.tabContainer.mTabstrip._updateScrollButtonsDisabledState();
            }

            // We're going to remove the tab and the browser now.
            this._tabFilters.delete(aTab);
            this._tabListeners.delete(aTab);

            var browser = this.getBrowserForTab(aTab);

            if (aTab.linkedPanel) {
              this._outerWindowIDBrowserMap.delete(browser.outerWindowID);

              // Because of the way XBL works (fields just set JS
              // properties on the element) and the code we have in place
              // to preserve the JS objects for any elements that have
              // JS properties set on them, the browser element won't be
              // destroyed until the document goes away.  So we force a
              // cleanup ourselves.
              // This has to happen before we remove the child so that the
              // XBL implementation of nsIObserver still works.
              browser.destroy();
            }

            var wasPinned = aTab.pinned;

            // Remove the tab ...
            this.tabContainer.removeChild(aTab);

            // ... and fix up the _tPos properties immediately.
            for (let i = aTab._tPos; i < this.tabs.length; i++)
              this.tabs[i]._tPos = i;

            if (!this._windowIsClosing) {
              if (wasPinned)
                this.tabContainer._positionPinnedTabs();

              // update tab close buttons state
              this.tabContainer.adjustTabstrip();

              setTimeout(function(tabs) {
                tabs._lastTabClosedByMouse = false;
              }, 0, this.tabContainer);
            }

            // update tab positional properties and attributes
            this.selectedTab._selected = true;
            this.tabContainer._setPositionalAttributes();

            // Removing the panel requires fixing up selectedPanel immediately
            // (see below), which would be hindered by the potentially expensive
            // browser removal. So we remove the browser and the panel in two
            // steps.

            var panel = this.getNotificationBox(browser);

            // In the multi-process case, it's possible an asynchronous tab switch
            // is still underway. If so, then it's possible that the last visible
            // browser is the one we're in the process of removing. There's the
            // risk of displaying preloaded browsers that are at the end of the
            // deck if we remove the browser before the switch is complete, so
            // we alert the switcher in order to show a spinner instead.
            if (this._switcher) {
              this._switcher.onTabRemoved(aTab);
            }

            // This will unload the document. An unload handler could remove
            // dependant tabs, so it's important that the tabbrowser is now in
            // a consistent state (tab removed, tab positions updated, etc.).
            browser.remove();

            // Release the browser in case something is erroneously holding a
            // reference to the tab after its removal.
            this._tabForBrowser.delete(aTab.linkedBrowser);
            aTab.linkedBrowser = null;

            panel.remove();

            // closeWindow might wait an arbitrary length of time if we're supposed
            // to warn about closing the window, so we'll just stop the tab close
            // stopwatches here instead.
            TelemetryStopwatch.finish("FX_TAB_CLOSE_TIME_ANIM_MS", aTab,
                                      true /* aCanceledOkay */);
            TelemetryStopwatch.finish("FX_TAB_CLOSE_TIME_NO_ANIM_MS", aTab,
                                      true /* aCanceledOkay */);

            if (aCloseWindow)
              this._windowIsClosing = closeWindow(true, window.warnAboutClosingWindow);
          ]]>
        </body>
      </method>

      <method name="_blurTab">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            if (!aTab.selected)
              return;

            if (aTab.owner &&
                !aTab.owner.hidden &&
                !aTab.owner.closing &&
                Services.prefs.getBoolPref("browser.tabs.selectOwnerOnClose")) {
              this.selectedTab = aTab.owner;
              return;
            }

            // Switch to a visible tab unless there aren't any others remaining
            let remainingTabs = this.visibleTabs;
            let numTabs = remainingTabs.length;
            if (numTabs == 0 || numTabs == 1 && remainingTabs[0] == aTab) {
              remainingTabs = Array.filter(this.tabs, function(tab) {
                return !tab.closing;
              }, this);
            }

            // Try to find a remaining tab that comes after the given tab
            var tab = aTab;
            do {
              tab = tab.nextSibling;
            } while (tab && remainingTabs.indexOf(tab) == -1);

            if (!tab) {
              tab = aTab;

              do {
                tab = tab.previousSibling;
              } while (tab && remainingTabs.indexOf(tab) == -1);
            }

            this.selectedTab = tab;
          ]]>
        </body>
      </method>

      <method name="swapBrowsersAndCloseOther">
        <parameter name="aOurTab"/>
        <parameter name="aOtherTab"/>
        <body>
          <![CDATA[
            // Do not allow transfering a private tab to a non-private window
            // and vice versa.
            if (PrivateBrowsingUtils.isWindowPrivate(window) !=
                PrivateBrowsingUtils.isWindowPrivate(aOtherTab.ownerGlobal))
              return;

            let ourBrowser = this.getBrowserForTab(aOurTab);
            let otherBrowser = aOtherTab.linkedBrowser;

            // Can't swap between chrome and content processes.
            if (ourBrowser.isRemoteBrowser != otherBrowser.isRemoteBrowser)
              return;

            // Keep the userContextId if set on other browser
            if (otherBrowser.hasAttribute("usercontextid")) {
              ourBrowser.setAttribute("usercontextid", otherBrowser.getAttribute("usercontextid"));
            }

            // That's gBrowser for the other window, not the tab's browser!
            var remoteBrowser = aOtherTab.ownerGlobal.gBrowser;
            var isPending = aOtherTab.hasAttribute("pending");

            let otherTabListener = remoteBrowser._tabListeners.get(aOtherTab);
            let stateFlags = otherTabListener.mStateFlags;

            // Expedite the removal of the icon if it was already scheduled.
            if (aOtherTab._soundPlayingAttrRemovalTimer) {
              clearTimeout(aOtherTab._soundPlayingAttrRemovalTimer);
              aOtherTab._soundPlayingAttrRemovalTimer = 0;
              aOtherTab.removeAttribute("soundplaying");
              remoteBrowser._tabAttrModified(aOtherTab, ["soundplaying"]);
            }

            // First, start teardown of the other browser.  Make sure to not
            // fire the beforeunload event in the process.  Close the other
            // window if this was its last tab.
            if (!remoteBrowser._beginRemoveTab(aOtherTab, aOurTab, true))
              return;

            // If this is the last tab of the window, hide the window
            // immediately without animation before the docshell swap, to avoid
            // about:blank being painted.
            let [closeWindow] = aOtherTab._endRemoveArgs;
            if (closeWindow) {
              let win = aOtherTab.ownerGlobal;
              let dwu = win.QueryInterface(Ci.nsIInterfaceRequestor)
                           .getInterface(Ci.nsIDOMWindowUtils);
              dwu.suppressAnimation(true);
              // Only suppressing window animations isn't enough to avoid
              // an empty content area being painted.
              let baseWin = win.QueryInterface(Ci.nsIInterfaceRequestor)
                               .getInterface(Ci.nsIDocShell)
                               .QueryInterface(Ci.nsIDocShellTreeItem)
                               .treeOwner
                               .QueryInterface(Ci.nsIBaseWindow);
              baseWin.visibility = false;
            }

            let modifiedAttrs = [];
            if (aOtherTab.hasAttribute("muted")) {
              aOurTab.setAttribute("muted", "true");
              aOurTab.muteReason = aOtherTab.muteReason;
              ourBrowser.mute();
              modifiedAttrs.push("muted");
            }
            if (aOtherTab.hasAttribute("soundplaying")) {
              aOurTab.setAttribute("soundplaying", "true");
              modifiedAttrs.push("soundplaying");
            }
            if (aOtherTab.hasAttribute("usercontextid")) {
              aOurTab.setUserContextId(aOtherTab.getAttribute("usercontextid"));
              modifiedAttrs.push("usercontextid");
            }
            if (aOtherTab.hasAttribute("sharing")) {
              aOurTab.setAttribute("sharing", aOtherTab.getAttribute("sharing"));
              modifiedAttrs.push("sharing");
              aOurTab._sharingState = aOtherTab._sharingState;
              webrtcUI.swapBrowserForNotification(otherBrowser, ourBrowser);
            }

            SitePermissions.copyTemporaryPermissions(otherBrowser, ourBrowser);

            // If the other tab is pending (i.e. has not been restored, yet)
            // then do not switch docShells but retrieve the other tab's state
            // and apply it to our tab.
            if (isPending) {
              SessionStore.setTabState(aOurTab, SessionStore.getTabState(aOtherTab));

              // Make sure to unregister any open URIs.
              this._swapRegisteredOpenURIs(ourBrowser, otherBrowser);
            } else {
              // Workarounds for bug 458697
              // Icon might have been set on DOMLinkAdded, don't override that.
              if (!ourBrowser.mIconURL && otherBrowser.mIconURL)
                this.setIcon(aOurTab, otherBrowser.mIconURL, otherBrowser.contentPrincipal, otherBrowser.contentRequestContextID);
              var isBusy = aOtherTab.hasAttribute("busy");
              if (isBusy) {
                aOurTab.setAttribute("busy", "true");
                modifiedAttrs.push("busy");
                if (aOurTab.selected)
                  this.mIsBusy = true;
              }

              this._swapBrowserDocShells(aOurTab, otherBrowser, Ci.nsIBrowser.SWAP_DEFAULT, stateFlags);
            }

            // Unregister the previously opened URI
            if (otherBrowser.registeredOpenURI) {
              this._unifiedComplete.unregisterOpenPage(otherBrowser.registeredOpenURI,
                                                       otherBrowser.getAttribute("usercontextid") || 0);
              delete otherBrowser.registeredOpenURI;
            }

            // Handle findbar data (if any)
            let otherFindBar = aOtherTab._findBar;
            if (otherFindBar &&
                otherFindBar.findMode == otherFindBar.FIND_NORMAL) {
              let ourFindBar = this.getFindBar(aOurTab);
              ourFindBar._findField.value = otherFindBar._findField.value;
              if (!otherFindBar.hidden)
                ourFindBar.onFindCommand();
            }

            // Finish tearing down the tab that's going away.
            if (closeWindow) {
              aOtherTab.ownerGlobal.close();
            } else {
              remoteBrowser._endRemoveTab(aOtherTab);
            }

            this.setTabTitle(aOurTab);

            // If the tab was already selected (this happpens in the scenario
            // of replaceTabWithWindow), notify onLocationChange, etc.
            if (aOurTab.selected)
              this.updateCurrentBrowser(true);

            if (modifiedAttrs.length) {
              this._tabAttrModified(aOurTab, modifiedAttrs);
            }
          ]]>
        </body>
      </method>

      <method name="swapBrowsers">
        <parameter name="aOurTab"/>
        <parameter name="aOtherTab"/>
        <parameter name="aFlags"/>
        <body>
          <![CDATA[
            let otherBrowser = aOtherTab.linkedBrowser;
            let otherTabBrowser = otherBrowser.getTabBrowser();

            // We aren't closing the other tab so, we also need to swap its tablisteners.
            let filter = otherTabBrowser._tabFilters.get(aOtherTab);
            let tabListener = otherTabBrowser._tabListeners.get(aOtherTab);
            otherBrowser.webProgress.removeProgressListener(filter);
            filter.removeProgressListener(tabListener);

            // Perform the docshell swap through the common mechanism.
            this._swapBrowserDocShells(aOurTab, otherBrowser, aFlags);

            // Restore the listeners for the swapped in tab.
            tabListener = otherTabBrowser.mTabProgressListener(aOtherTab, otherBrowser, false, false);
            otherTabBrowser._tabListeners.set(aOtherTab, tabListener);

            const notifyAll = Ci.nsIWebProgress.NOTIFY_ALL;
            filter.addProgressListener(tabListener, notifyAll);
            otherBrowser.webProgress.addProgressListener(filter, notifyAll);
          ]]>
        </body>
      </method>

      <method name="_swapBrowserDocShells">
        <parameter name="aOurTab"/>
        <parameter name="aOtherBrowser"/>
        <parameter name="aFlags"/>
        <parameter name="aStateFlags"/>
        <body>
          <![CDATA[
            // aOurTab's browser needs to be inserted now if it hasn't already.
            this._insertBrowser(aOurTab);

            // Unhook our progress listener
            const filter = this._tabFilters.get(aOurTab);
            let tabListener = this._tabListeners.get(aOurTab);
            let ourBrowser = this.getBrowserForTab(aOurTab);
            ourBrowser.webProgress.removeProgressListener(filter);
            filter.removeProgressListener(tabListener);

            // Make sure to unregister any open URIs.
            this._swapRegisteredOpenURIs(ourBrowser, aOtherBrowser);

            // Unmap old outerWindowIDs.
            this._outerWindowIDBrowserMap.delete(ourBrowser.outerWindowID);
            let remoteBrowser = aOtherBrowser.ownerGlobal.gBrowser;
            if (remoteBrowser) {
              remoteBrowser._outerWindowIDBrowserMap.delete(aOtherBrowser.outerWindowID);
            }

            // If switcher is active, it will intercept swap events and
            // react as needed.
            if (!this._switcher) {
              aOtherBrowser.docShellIsActive = this.shouldActivateDocShell(ourBrowser);
            }

            // Swap the docshells
            ourBrowser.swapDocShells(aOtherBrowser);

            if (ourBrowser.isRemoteBrowser) {
              // Switch outerWindowIDs for remote browsers.
              let ourOuterWindowID = ourBrowser._outerWindowID;
              ourBrowser._outerWindowID = aOtherBrowser._outerWindowID;
              aOtherBrowser._outerWindowID = ourOuterWindowID;
            }

            // Register new outerWindowIDs.
            this._outerWindowIDBrowserMap.set(ourBrowser.outerWindowID, ourBrowser);
            if (remoteBrowser) {
              remoteBrowser._outerWindowIDBrowserMap.set(aOtherBrowser.outerWindowID, aOtherBrowser);
            }

            if (!(aFlags & Ci.nsIBrowser.SWAP_KEEP_PERMANENT_KEY)) {
              // Swap permanentKey properties.
              let ourPermanentKey = ourBrowser.permanentKey;
              ourBrowser.permanentKey = aOtherBrowser.permanentKey;
              aOtherBrowser.permanentKey = ourPermanentKey;
              aOurTab.permanentKey = ourBrowser.permanentKey;
              if (remoteBrowser) {
                let otherTab = remoteBrowser.getTabForBrowser(aOtherBrowser);
                if (otherTab) {
                  otherTab.permanentKey = aOtherBrowser.permanentKey;
                }
              }
            }

            // Restore the progress listener
            tabListener = this.mTabProgressListener(aOurTab, ourBrowser, false, false,
                                                    aStateFlags);
            this._tabListeners.set(aOurTab, tabListener);

            const notifyAll = Ci.nsIWebProgress.NOTIFY_ALL;
            filter.addProgressListener(tabListener, notifyAll);
            ourBrowser.webProgress.addProgressListener(filter, notifyAll);
          ]]>
        </body>
      </method>

      <method name="_swapRegisteredOpenURIs">
        <parameter name="aOurBrowser"/>
        <parameter name="aOtherBrowser"/>
        <body>
          <![CDATA[
            // Swap the registeredOpenURI properties of the two browsers
            let tmp = aOurBrowser.registeredOpenURI;
            delete aOurBrowser.registeredOpenURI;
            if (aOtherBrowser.registeredOpenURI) {
              aOurBrowser.registeredOpenURI = aOtherBrowser.registeredOpenURI;
              delete aOtherBrowser.registeredOpenURI;
            }
            if (tmp) {
              aOtherBrowser.registeredOpenURI = tmp;
            }
          ]]>
        </body>
      </method>

      <method name="reloadAllTabs">
        <body>
          <![CDATA[
            let tabs = this.visibleTabs;
            let l = tabs.length;
            for (var i = 0; i < l; i++) {
              try {
                this.getBrowserForTab(tabs[i]).reload();
              } catch (e) {
                // ignore failure to reload so others will be reloaded
              }
            }
          ]]>
        </body>
      </method>

      <method name="reloadTab">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            let browser = this.getBrowserForTab(aTab);
            // Reset temporary permissions on the current tab. This is done here
            // because we only want to reset permissions on user reload.
            SitePermissions.clearTemporaryPermissions(browser);
            browser.reload();
          ]]>
        </body>
      </method>

      <method name="addProgressListener">
        <parameter name="aListener"/>
        <body>
          <![CDATA[
            if (arguments.length != 1) {
              Components.utils.reportError("gBrowser.addProgressListener was " +
                                           "called with a second argument, " +
                                           "which is not supported. See bug " +
                                           "608628. Call stack: " + new Error().stack);
            }

            this.mProgressListeners.push(aListener);
          ]]>
        </body>
      </method>

      <method name="removeProgressListener">
        <parameter name="aListener"/>
        <body>
          <![CDATA[
            this.mProgressListeners =
              this.mProgressListeners.filter(l => l != aListener);
         ]]>
        </body>
      </method>

      <method name="addTabsProgressListener">
        <parameter name="aListener"/>
        <body>
          this.mTabsProgressListeners.push(aListener);
        </body>
      </method>

      <method name="removeTabsProgressListener">
        <parameter name="aListener"/>
        <body>
        <![CDATA[
          this.mTabsProgressListeners =
            this.mTabsProgressListeners.filter(l => l != aListener);
        ]]>
        </body>
      </method>

      <method name="getBrowserForTab">
        <parameter name="aTab"/>
        <body>
        <![CDATA[
          return aTab.linkedBrowser;
        ]]>
        </body>
      </method>

      <method name="showOnlyTheseTabs">
        <parameter name="aTabs"/>
        <body>
        <![CDATA[
          for (let tab of this.tabs) {
            if (aTabs.indexOf(tab) == -1)
              this.hideTab(tab);
            else
              this.showTab(tab);
          }

          this.tabContainer._handleTabSelect(true);
        ]]>
        </body>
      </method>

      <method name="showTab">
        <parameter name="aTab"/>
        <body>
        <![CDATA[
          if (aTab.hidden) {
            aTab.removeAttribute("hidden");
            this._visibleTabs = null; // invalidate cache

            this.tabContainer.adjustTabstrip();

            this.tabContainer._setPositionalAttributes();

            let event = document.createEvent("Events");
            event.initEvent("TabShow", true, false);
            aTab.dispatchEvent(event);
          }
        ]]>
        </body>
      </method>

      <method name="hideTab">
        <parameter name="aTab"/>
        <body>
        <![CDATA[
          if (!aTab.hidden && !aTab.pinned && !aTab.selected &&
              !aTab.closing) {
            aTab.setAttribute("hidden", "true");
            this._visibleTabs = null; // invalidate cache

            this.tabContainer.adjustTabstrip();

            this.tabContainer._setPositionalAttributes();

            let event = document.createEvent("Events");
            event.initEvent("TabHide", true, false);
            aTab.dispatchEvent(event);
          }
        ]]>
        </body>
      </method>

      <method name="selectTabAtIndex">
        <parameter name="aIndex"/>
        <parameter name="aEvent"/>
        <body>
        <![CDATA[
          let tabs = this.visibleTabs;

          // count backwards for aIndex < 0
          if (aIndex < 0) {
            aIndex += tabs.length;
            // clamp at index 0 if still negative.
            if (aIndex < 0)
              aIndex = 0;
          } else if (aIndex >= tabs.length) {
            // clamp at right-most tab if out of range.
            aIndex = tabs.length - 1;
          }

          this.selectedTab = tabs[aIndex];

          if (aEvent) {
            aEvent.preventDefault();
            aEvent.stopPropagation();
          }
        ]]>
        </body>
      </method>

      <property name="selectedTab">
        <getter>
          return this.mCurrentTab;
        </getter>
        <setter>
          <![CDATA[
          if (gNavToolbox.collapsed && !this._allowTabChange) {
            return this.mTabBox.selectedTab;
          }
          // Update the tab
          this.mTabBox.selectedTab = val;
          return val;
          ]]>
        </setter>
      </property>

      <property name="selectedBrowser"
                onget="return this.mCurrentBrowser;"
                readonly="true"/>

      <field name="browsers" readonly="true">
        <![CDATA[
          // This defines a proxy which allows us to access browsers by
          // index without actually creating a full array of browsers.
          new Proxy([], {
            has: (target, name) => {
              if (typeof name == "string" && Number.isInteger(parseInt(name))) {
                return (name in this.tabs);
              }
              return false;
            },
            get: (target, name) => {
              if (name == "length") {
                return this.tabs.length;
              }
              if (typeof name == "string" && Number.isInteger(parseInt(name))) {
                if (!(name in this.tabs)) {
                  return undefined;
                }
                return this.tabs[name].linkedBrowser;
              }
              return target[name];
            }
          });
        ]]>
      </field>

      <!-- Moves a tab to a new browser window, unless it's already the only tab
           in the current window, in which case this will do nothing. -->
      <method name="replaceTabWithWindow">
        <parameter name="aTab"/>
        <parameter name="aOptions"/>
        <body>
          <![CDATA[
            if (this.tabs.length == 1)
              return null;

            var options = "chrome,dialog=no,all";
            for (var name in aOptions)
              options += "," + name + "=" + aOptions[name];

            // Play the tab closing animation to give immediate feedback while
            // waiting for the new window to appear.
            // content area when the docshells are swapped.
            if (this.animationsEnabled) {
              aTab.style.maxWidth = ""; // ensure that fade-out transition happens
              aTab.removeAttribute("fadein");
            }

            // tell a new window to take the "dropped" tab
            return window.openDialog(getBrowserURL(), "_blank", options, aTab);
          ]]>
        </body>
      </method>

      <method name="moveTabTo">
        <parameter name="aTab"/>
        <parameter name="aIndex"/>
        <parameter name="aKeepRelatedTabs"/>
        <body>
        <![CDATA[
          var oldPosition = aTab._tPos;
          if (oldPosition == aIndex)
            return;

          // Don't allow mixing pinned and unpinned tabs.
          if (aTab.pinned)
            aIndex = Math.min(aIndex, this._numPinnedTabs - 1);
          else
            aIndex = Math.max(aIndex, this._numPinnedTabs);
          if (oldPosition == aIndex)
            return;

          if (!aKeepRelatedTabs) {
            this._lastRelatedTabMap = new WeakMap();
          }

          let wasFocused = (document.activeElement == this.mCurrentTab);

          aIndex = aIndex < aTab._tPos ? aIndex : aIndex + 1;

          // invalidate cache
          this._visibleTabs = null;

          // use .item() instead of [] because dragging to the end of the strip goes out of
          // bounds: .item() returns null (so it acts like appendChild), but [] throws
          this.tabContainer.insertBefore(aTab, this.tabs.item(aIndex));

          for (let i = 0; i < this.tabs.length; i++) {
            this.tabs[i]._tPos = i;
            this.tabs[i]._selected = false;
          }

          // If we're in the midst of an async tab switch while calling
          // moveTabTo, we can get into a case where _visuallySelected
          // is set to true on two different tabs.
          //
          // What we want to do in moveTabTo is to remove logical selection
          // from all tabs, and then re-add logical selection to mCurrentTab
          // (and visual selection as well if we're not running with e10s, which
          // setting _selected will do automatically).
          //
          // If we're running with e10s, then the visual selection will not
          // be changed, which is fine, since if we weren't in the midst of a
          // tab switch, the previously visually selected tab should still be
          // correct, and if we are in the midst of a tab switch, then the async
          // tab switcher will set the visually selected tab once the tab switch
          // has completed.
          this.mCurrentTab._selected = true;

          if (wasFocused)
            this.mCurrentTab.focus();

          this.tabContainer._handleTabSelect(true);

          if (aTab.pinned)
            this.tabContainer._positionPinnedTabs();

          this.tabContainer._setPositionalAttributes();

          var evt = document.createEvent("UIEvents");
          evt.initUIEvent("TabMove", true, false, window, oldPosition);
          aTab.dispatchEvent(evt);
        ]]>
        </body>
      </method>

      <method name="moveTabForward">
        <body>
          <![CDATA[
            let nextTab = this.mCurrentTab.nextSibling;
            while (nextTab && nextTab.hidden)
              nextTab = nextTab.nextSibling;

            if (nextTab)
              this.moveTabTo(this.mCurrentTab, nextTab._tPos);
            else if (this.arrowKeysShouldWrap)
              this.moveTabToStart();
          ]]>
        </body>
      </method>

      <!-- Adopts a tab from another browser window, and inserts it at aIndex -->
      <method name="adoptTab">
        <parameter name="aTab"/>
        <parameter name="aIndex"/>
        <parameter name="aSelectTab"/>
        <body>
        <![CDATA[
          // Swap the dropped tab with a new one we create and then close
          // it in the other window (making it seem to have moved between
          // windows). We also ensure that the tab we create to swap into has
          // the same remote type and process as the one we're swapping in.
          // This makes sure we don't get a short-lived process for the new tab.
          let linkedBrowser = aTab.linkedBrowser;
          let params = { eventDetail: { adoptedTab: aTab },
                         preferredRemoteType: linkedBrowser.remoteType,
                         sameProcessAsFrameLoader: linkedBrowser.frameLoader,
                         skipAnimation: true };
          if (aTab.hasAttribute("usercontextid")) {
            // new tab must have the same usercontextid as the old one
            params.userContextId = aTab.getAttribute("usercontextid");
          }
          let newTab = this.addTab("about:blank", params);
          let newBrowser = this.getBrowserForTab(newTab);

          // Stop the about:blank load.
          newBrowser.stop();
          // Make sure it has a docshell.
          newBrowser.docShell;

          let numPinned = this._numPinnedTabs;
          if (aIndex < numPinned || (aTab.pinned && aIndex == numPinned)) {
            this.pinTab(newTab);
          }

          this.moveTabTo(newTab, aIndex);

          // We need to select the tab before calling swapBrowsersAndCloseOther
          // so that window.content in chrome windows points to the right tab
          // when pagehide/show events are fired. This is no longer necessary
          // for any exiting browser code, but it may be necessary for add-on
          // compatibility.
          if (aSelectTab) {
            this.selectedTab = newTab;
          }

          aTab.parentNode._finishAnimateTabMove();
          this.swapBrowsersAndCloseOther(newTab, aTab);

          if (aSelectTab) {
            // Call updateCurrentBrowser to make sure the URL bar is up to date
            // for our new tab after we've done swapBrowsersAndCloseOther.
            this.updateCurrentBrowser(true);
          }

          return newTab;
        ]]>
        </body>
      </method>


      <method name="moveTabBackward">
        <body>
          <![CDATA[
            let previousTab = this.mCurrentTab.previousSibling;
            while (previousTab && previousTab.hidden)
              previousTab = previousTab.previousSibling;

            if (previousTab)
              this.moveTabTo(this.mCurrentTab, previousTab._tPos);
            else if (this.arrowKeysShouldWrap)
              this.moveTabToEnd();
          ]]>
        </body>
      </method>

      <method name="moveTabToStart">
        <body>
          <![CDATA[
            var tabPos = this.mCurrentTab._tPos;
            if (tabPos > 0)
              this.moveTabTo(this.mCurrentTab, 0);
          ]]>
        </body>
      </method>

      <method name="moveTabToEnd">
        <body>
          <![CDATA[
            var tabPos = this.mCurrentTab._tPos;
            if (tabPos < this.browsers.length - 1)
              this.moveTabTo(this.mCurrentTab, this.browsers.length - 1);
          ]]>
        </body>
      </method>

      <method name="moveTabOver">
        <parameter name="aEvent"/>
        <body>
          <![CDATA[
            var direction = window.getComputedStyle(this.parentNode).direction;
            if ((direction == "ltr" && aEvent.keyCode == KeyEvent.DOM_VK_RIGHT) ||
                (direction == "rtl" && aEvent.keyCode == KeyEvent.DOM_VK_LEFT))
              this.moveTabForward();
            else
              this.moveTabBackward();
          ]]>
        </body>
      </method>

      <method name="duplicateTab">
        <parameter name="aTab"/><!-- can be from a different window as well -->
        <parameter name="aRestoreTabImmediately"/><!-- can defer loading of the tab contents -->
        <body>
          <![CDATA[
            return SessionStore.duplicateTab(window, aTab, 0, aRestoreTabImmediately);
          ]]>
        </body>
      </method>

      <!--
        List of browsers whose docshells must be active in order for print preview
        to work.
      -->
      <field name="_printPreviewBrowsers">
        new Set()
      </field>

      <method name="activateBrowserForPrintPreview">
        <parameter name="aBrowser"/>
        <body>
          <![CDATA[
            this._printPreviewBrowsers.add(aBrowser);
            if (this._switcher) {
              this._switcher.activateBrowserForPrintPreview(aBrowser);
            }
            aBrowser.docShellIsActive = true;
          ]]>
        </body>
      </method>

      <method name="deactivatePrintPreviewBrowsers">
        <body>
          <![CDATA[
            let browsers = this._printPreviewBrowsers;
            this._printPreviewBrowsers = new Set();
            for (let browser of browsers) {
              browser.docShellIsActive = this.shouldActivateDocShell(browser);
            }
          ]]>
        </body>
      </method>

      <!--
        Returns true if a given browser's docshell should be active.
      -->
      <method name="shouldActivateDocShell">
        <parameter name="aBrowser"/>
        <body>
          <![CDATA[
            if (this._switcher) {
              return this._switcher.shouldActivateDocShell(aBrowser);
            }
            return (aBrowser == this.selectedBrowser &&
                    window.windowState != window.STATE_MINIMIZED &&
                    !window.isFullyOccluded) ||
                   this._printPreviewBrowsers.has(aBrowser);
          ]]>
        </body>
      </method>

      <!--
        The tab switcher is responsible for asynchronously switching
        tabs in e10s. It waits until the new tab is ready (i.e., the
        layer tree is available) before switching to it. Then it
        unloads the layer tree for the old tab.

        The tab switcher is a state machine. For each tab, it
        maintains state about whether the layer tree for the tab is
        available, being loaded, being unloaded, or unavailable. It
        also keeps track of the tab currently being displayed, the tab
        it's trying to load, and the tab the user has asked to switch
        to. The switcher object is created upon tab switch. It is
        released when there are no pending tabs to load or unload.

        The following general principles have guided the design:

        1. We only request one layer tree at a time. If the user
        switches to a different tab while waiting, we don't request
        the new layer tree until the old tab has loaded or timed out.

        2. If loading the layers for a tab times out, we show the
        spinner and possibly request the layer tree for another tab if
        the user has requested one.

        3. We discard layer trees on a delay. This way, if the user is
        switching among the same tabs frequently, we don't continually
        load the same tabs.

        It's important that we always show either the spinner or a tab
        whose layers are available. Otherwise the compositor will draw
        an entirely black frame, which is very jarring. To ensure this
        never happens when switching away from a tab, we assume the
        old tab might still be drawn until a MozAfterPaint event
        occurs. Because layout and compositing happen asynchronously,
        we don't have any other way of knowing when the switch
        actually takes place. Therefore, we don't unload the old tab
        until the next MozAfterPaint event.
      -->
      <field name="_switcher">null</field>
      <method name="_getSwitcher">
        <body><![CDATA[
          if (this._switcher) {
            return this._switcher;
          }

          let switcher = {
            // How long to wait for a tab's layers to load. After this
            // time elapses, we're free to put up the spinner and start
            // trying to load a different tab.
            TAB_SWITCH_TIMEOUT: 400 /* ms */,

            // When the user hasn't switched tabs for this long, we unload
            // layers for all tabs that aren't in use.
            UNLOAD_DELAY: 300 /* ms */,

            // The next three tabs form the principal state variables.
            // See the assertions in postActions for their invariants.

            // Tab the user requested most recently.
            requestedTab: this.selectedTab,

            // Tab we're currently trying to load.
            loadingTab: null,

            // We show this tab in case the requestedTab hasn't loaded yet.
            lastVisibleTab: this.selectedTab,

            // Auxilliary state variables:

            visibleTab: this.selectedTab,   // Tab that's on screen.
            spinnerTab: null,               // Tab showing a spinner.
            blankTab: null,                 // Tab showing blank.
            originalTab: this.selectedTab,  // Tab that we started on.

            tabbrowser: this,  // Reference to gBrowser.
            loadTimer: null,   // TAB_SWITCH_TIMEOUT nsITimer instance.
            unloadTimer: null, // UNLOAD_DELAY nsITimer instance.

            // Map from tabs to STATE_* (below).
            tabState: new Map(),

            // True if we're in the midst of switching tabs.
            switchInProgress: false,

            // Keep an exact list of content processes (tabParent) in which
            // we're actively suppressing the display port. This gives a robust
            // way to make sure we don't forget to un-suppress.
            activeSuppressDisplayport: new Set(),

            // Set of tabs that might be visible right now. We maintain
            // this set because we can't be sure when a tab is actually
            // drawn. A tab is added to this set when we ask to make it
            // visible. All tabs but the most recently shown tab are
            // removed from the set upon MozAfterPaint.
            maybeVisibleTabs: new Set([this.selectedTab]),

            // This holds onto the set of tabs that we've been asked to warm up.
            // This is used only for Telemetry and logging, and (in order to not
            // over-complicate the async tab switcher any further) has nothing to do
            // with how warmed tabs are loaded and unloaded.
            warmingTabs: new WeakSet(),

            STATE_UNLOADED: 0,
            STATE_LOADING: 1,
            STATE_LOADED: 2,
            STATE_UNLOADING: 3,

            // re-entrancy guard:
            _processing: false,

            // Wraps nsITimer. Must not use the vanilla setTimeout and
            // clearTimeout, because they will be blocked by nsIPromptService
            // dialogs.
            setTimer(callback, timeout) {
              let event = {
                notify: callback
              };

              var timer = Cc["@mozilla.org/timer;1"]
                .createInstance(Components.interfaces.nsITimer);
              timer.initWithCallback(event, timeout, Ci.nsITimer.TYPE_ONE_SHOT);
              return timer;
            },

            clearTimer(timer) {
              timer.cancel();
            },

            getTabState(tab) {
              let state = this.tabState.get(tab);
              if (state === undefined) {
                return this.STATE_UNLOADED;
              }
              return state;
            },

            setTabStateNoAction(tab, state) {
              if (state == this.STATE_UNLOADED) {
                this.tabState.delete(tab);
              } else {
                this.tabState.set(tab, state);
              }
            },

            setTabState(tab, state) {
              this.setTabStateNoAction(tab, state);

              let browser = tab.linkedBrowser;
              let {tabParent} = browser.frameLoader;
              if (state == this.STATE_LOADING) {
                this.assert(!this.minimizedOrFullyOccluded);
                browser.docShellIsActive = true;
                if (!tabParent) {
                  this.onLayersReady(browser);
                }
              } else if (state == this.STATE_UNLOADING) {
                this.unwarmTab(tab);
                browser.docShellIsActive = false;
                if (!tabParent) {
                  this.onLayersCleared(browser);
                }
              }

              if (!tab.linkedBrowser.isRemoteBrowser) {
                // setTabState is potentially re-entrant in the non-remote case,
                // so we must re-get the state for this assertion.
                let nonRemoteState = this.getTabState(tab);
                // Non-remote tabs can never stay in the STATE_LOADING
                // or STATE_UNLOADING states. By the time this function
                // exits, a non-remote tab must be in STATE_LOADED or
                // STATE_UNLOADED, since the painting and the layer
                // upload happen synchronously.
                this.assert(nonRemoteState == this.STATE_UNLOADED ||
                            nonRemoteState == this.STATE_LOADED);
              }
            },

            get minimizedOrFullyOccluded() {
              return window.windowState == window.STATE_MINIMIZED ||
                     window.isFullyOccluded;
            },

            init() {
              this.log("START");

              // If we minimized the window before the switcher was activated,
              // we might have set  the preserveLayers flag for the current
              // browser. Let's clear it.
              this.tabbrowser.mCurrentBrowser.preserveLayers(false);

              window.addEventListener("MozAfterPaint", this);
              window.addEventListener("MozLayerTreeReady", this);
              window.addEventListener("MozLayerTreeCleared", this);
              window.addEventListener("TabRemotenessChange", this);
              window.addEventListener("sizemodechange", this);
              window.addEventListener("occlusionstatechange", this);
              window.addEventListener("SwapDocShells", this, true);
              window.addEventListener("EndSwapDocShells", this, true);

              let tab = this.requestedTab;
              let browser = tab.linkedBrowser;
              let tabIsLoaded = !browser.isRemoteBrowser ||
                                browser.frameLoader.tabParent.hasPresented;

              if (!this.minimizedOrFullyOccluded) {
                this.log("Initial tab is loaded?: " + tabIsLoaded);
                this.setTabState(tab, tabIsLoaded ? this.STATE_LOADED
                                                  : this.STATE_LOADING);
              }
            },

            destroy() {
              if (this.unloadTimer) {
                this.clearTimer(this.unloadTimer);
                this.unloadTimer = null;
              }
              if (this.loadTimer) {
                this.clearTimer(this.loadTimer);
                this.loadTimer = null;
              }

              window.removeEventListener("MozAfterPaint", this);
              window.removeEventListener("MozLayerTreeReady", this);
              window.removeEventListener("MozLayerTreeCleared", this);
              window.removeEventListener("TabRemotenessChange", this);
              window.removeEventListener("sizemodechange", this);
              window.removeEventListener("occlusionstatechange", this);
              window.removeEventListener("SwapDocShells", this, true);
              window.removeEventListener("EndSwapDocShells", this, true);

              this.tabbrowser._switcher = null;

              this.activeSuppressDisplayport.forEach(function(tabParent) {
                tabParent.suppressDisplayport(false);
              });
              this.activeSuppressDisplayport.clear();
            },

            finish() {
              this.log("FINISH");

              this.assert(this.tabbrowser._switcher);
              this.assert(this.tabbrowser._switcher === this);
              this.assert(!this.spinnerTab);
              this.assert(!this.blankTab);
              this.assert(!this.loadTimer);
              this.assert(!this.loadingTab);
              this.assert(this.lastVisibleTab === this.requestedTab);
              this.assert(this.minimizedOrFullyOccluded ||
                          this.getTabState(this.requestedTab) == this.STATE_LOADED);

              this.destroy();

              let toBrowser = this.requestedTab.linkedBrowser;
              toBrowser.setAttribute("primary", "true");

              let fromBrowser = this.originalTab.linkedBrowser;
              // It's possible that the tab we're switching from closed
              // before we were able to finalize, in which case, fromBrowser
              // doesn't exist.
              if (fromBrowser) {
                fromBrowser.removeAttribute("primary");
              }

              document.commandDispatcher.unlock();

              let event = new CustomEvent("TabSwitchDone", {
                bubbles: true,
                cancelable: true
              });
              this.tabbrowser.dispatchEvent(event);
            },

            // This function is called after all the main state changes to
            // make sure we display the right tab.
            updateDisplay() {
              let requestedTabState = this.getTabState(this.requestedTab);
              let requestedBrowser = this.requestedTab.linkedBrowser;

              // It is often more desirable to show a blank tab when appropriate than
              // the tab switch spinner - especially since the spinner is usually
              // preceded by a perceived lag of TAB_SWITCH_TIMEOUT ms in the
              // tab switch. We can hide this lag, and hide the time being spent
              // constructing TabChild's, layer trees, etc, by showing a blank
              // tab instead and focusing it immediately.
              let shouldBeBlank = false;
              if (requestedBrowser.isRemoteBrowser) {
                // If a tab is remote and the window is not minimized, we can show a
                // blank tab instead of a spinner in the following cases:
                //
                // 1. The tab has just crashed, and we haven't started showing the
                //    tab crashed page yet (in this case, the TabParent is null)
                // 2. The tab has never presented, and has not finished loading
                //    a non-local-about: page.
                //
                // For (2), "finished loading a non-local-about: page" is
                // determined by the busy state on the tab element and checking
                // if the loaded URI is local.
                let hasSufficientlyLoaded =
                  !this.requestedTab.hasAttribute("busy") &&
                  !this.tabbrowser._isLocalAboutURI(requestedBrowser.currentURI);

                let fl = requestedBrowser.frameLoader;
                shouldBeBlank = !this.minimizedOrFullyOccluded &&
                                (!fl.tabParent ||
                                 (!hasSufficientlyLoaded && !fl.tabParent.hasPresented));
              }

              this.log("Tab should be blank: " + shouldBeBlank);
              this.log("Requested tab is remote?: " + requestedBrowser.isRemoteBrowser);

              // Figure out which tab we actually want visible right now.
              let showTab = null;
              if (requestedTabState != this.STATE_LOADED &&
                  this.lastVisibleTab && this.loadTimer && !shouldBeBlank) {
                // If we can't show the requestedTab, and lastVisibleTab is
                // available, show it.
                showTab = this.lastVisibleTab;
              } else {
                // Show the requested tab. If it's not available, we'll show the spinner or a blank tab.
                showTab = this.requestedTab;
              }

              // First, let's deal with blank tabs, which we show instead
              // of the spinner when the tab is not currently set up
              // properly in the content process.
              if (!shouldBeBlank && this.blankTab) {
                this.blankTab.linkedBrowser.removeAttribute("blank");
                this.blankTab = null;
              } else if (shouldBeBlank && this.blankTab !== showTab) {
                if (this.blankTab) {
                  this.blankTab.linkedBrowser.removeAttribute("blank");
                }
                this.blankTab = showTab;
                this.blankTab.linkedBrowser.setAttribute("blank", "true");
              }

              // Show or hide the spinner as needed.
              let needSpinner = this.getTabState(showTab) != this.STATE_LOADED &&
                                !this.minimizedOrFullyOccluded &&
                                !shouldBeBlank;

              if (!needSpinner && this.spinnerTab) {
                this.spinnerHidden();
                this.tabbrowser.removeAttribute("pendingpaint");
                this.spinnerTab.linkedBrowser.removeAttribute("pendingpaint");
                this.spinnerTab = null;
              } else if (needSpinner && this.spinnerTab !== showTab) {
                if (this.spinnerTab) {
                  this.spinnerTab.linkedBrowser.removeAttribute("pendingpaint");
                } else {
                  this.spinnerDisplayed();
                }
                this.spinnerTab = showTab;
                this.tabbrowser.setAttribute("pendingpaint", "true");
                this.spinnerTab.linkedBrowser.setAttribute("pendingpaint", "true");
              }

              // Switch to the tab we've decided to make visible.
              if (this.visibleTab !== showTab) {
                this.tabbrowser._adjustFocusBeforeTabSwitch(this.visibleTab, showTab);
                this.visibleTab = showTab;

                this.maybeVisibleTabs.add(showTab);

                let tabs = this.tabbrowser.mTabBox.tabs;
                let tabPanel = this.tabbrowser.mPanelContainer;
                let showPanel = tabs.getRelatedElement(showTab);
                let index = Array.indexOf(tabPanel.childNodes, showPanel);
                if (index != -1) {
                  this.log(`Switch to tab ${index} - ${this.tinfo(showTab)}`);
                  tabPanel.setAttribute("selectedIndex", index);
                  if (showTab === this.requestedTab) {
                    if (this._requestingTab) {
                      /*
                       * If _requestingTab is set, that means that we're switching the
                       * visibility of the tab synchronously, and we need to wait for
                       * the "select" event before shifting focus so that
                       * _adjustFocusAfterTabSwitch runs with the right information for
                       * the tab switch.
                       */
                      this.tabbrowser.addEventListener("select", () => {
                        this.tabbrowser._adjustFocusAfterTabSwitch(showTab);
                      }, {once: true});
                    } else {
                      this.tabbrowser._adjustFocusAfterTabSwitch(showTab);
                    }
                  }
                }

                // This doesn't necessarily exist if we're a new window and haven't switched tabs yet
                if (this.lastVisibleTab)
                  this.lastVisibleTab._visuallySelected = false;

                this.visibleTab._visuallySelected = true;
              }

              this.lastVisibleTab = this.visibleTab;
            },

            assert(cond) {
              if (!cond) {
                dump("Assertion failure\n" + Error().stack);

                // Don't break a user's browser if an assertion fails.
                if (AppConstants.DEBUG) {
                  throw new Error("Assertion failure");
                }
              }
            },

            // We've decided to try to load requestedTab.
            loadRequestedTab() {
              this.assert(!this.loadTimer);
              this.assert(!this.minimizedOrFullyOccluded);

              // loadingTab can be non-null here if we timed out loading the current tab.
              // In that case we just overwrite it with a different tab; it's had its chance.
              this.loadingTab = this.requestedTab;
              this.log("Loading tab " + this.tinfo(this.loadingTab));

              this.loadTimer = this.setTimer(() => this.onLoadTimeout(), this.TAB_SWITCH_TIMEOUT);
              this.setTabState(this.requestedTab, this.STATE_LOADING);
            },

            // This function runs before every event. It fixes up the state
            // to account for closed tabs.
            preActions() {
              this.assert(this.tabbrowser._switcher);
              this.assert(this.tabbrowser._switcher === this);

              for (let [tab, ] of this.tabState) {
                if (!tab.linkedBrowser) {
                  this.tabState.delete(tab);
                  this.unwarmTab(tab);
                }
              }

              if (this.lastVisibleTab && !this.lastVisibleTab.linkedBrowser) {
                this.lastVisibleTab = null;
              }
              if (this.blankTab && !this.blankTab.linkedBrowser) {
                this.blankTab = null;
              }
              if (this.spinnerTab && !this.spinnerTab.linkedBrowser) {
                this.spinnerHidden();
                this.spinnerTab = null;
              }
              if (this.loadingTab && !this.loadingTab.linkedBrowser) {
                this.loadingTab = null;
                this.clearTimer(this.loadTimer);
                this.loadTimer = null;
              }
            },

            // This code runs after we've responded to an event or requested a new
            // tab. It's expected that we've already updated all the principal
            // state variables. This function takes care of updating any auxilliary
            // state.
            postActions() {
              // Once we finish loading loadingTab, we null it out. So the state should
              // always be LOADING.
              this.assert(!this.loadingTab ||
                          this.getTabState(this.loadingTab) == this.STATE_LOADING);

              // We guarantee that loadingTab is non-null iff loadTimer is non-null. So
              // the timer is set only when we're loading something.
              this.assert(!this.loadTimer || this.loadingTab);
              this.assert(!this.loadingTab || this.loadTimer);

              // If we're switching to a non-remote tab, there's no need to wait
              // for it to send layers to the compositor, as this will happen
              // synchronously. Clearing this here means that in the next step,
              // we can load the non-remote browser immediately.
              if (!this.requestedTab.linkedBrowser.isRemoteBrowser) {
                this.loadingTab = null;
                if (this.loadTimer) {
                  this.clearTimer(this.loadTimer);
                  this.loadTimer = null;
                }
              }

              // If we're not loading anything, try loading the requested tab.
              let requestedState = this.getTabState(this.requestedTab);
              if (!this.loadTimer && !this.minimizedOrFullyOccluded &&
                  (requestedState == this.STATE_UNLOADED ||
                   requestedState == this.STATE_UNLOADING)) {
                this.loadRequestedTab();
              }

              // See how many tabs still have work to do.
              let numPending = 0;
              let numWarming = 0;
              for (let [tab, state] of this.tabState) {
                // Skip print preview browsers since they shouldn't affect tab switching.
                if (this.tabbrowser._printPreviewBrowsers.has(tab.linkedBrowser)) {
                  continue;
                }

                if (state == this.STATE_LOADED && tab !== this.requestedTab) {
                  numPending++;

                  if (tab !== this.visibleTab) {
                    numWarming++;
                  }
                }
                if (state == this.STATE_LOADING || state == this.STATE_UNLOADING) {
                  numPending++;
                }
              }

              this.updateDisplay();

              // It's possible for updateDisplay to trigger one of our own event
              // handlers, which might cause finish() to already have been called.
              // Check for that before calling finish() again.
              if (!this.tabbrowser._switcher) {
                return;
              }

              this.maybeFinishTabSwitch();

              if (numWarming > this.tabbrowser.tabWarmingMax) {
                this.logState("Hit tabWarmingMax");
                if (this.unloadTimer) {
                  this.clearTimer(this.unloadTimer);
                }
                this.unloadNonRequiredTabs();
              }

              if (numPending == 0) {
                this.finish();
              }

              this.logState("done");
            },

            // Fires when we're ready to unload unused tabs.
            onUnloadTimeout() {
              this.logState("onUnloadTimeout");
              this.preActions();
              this.unloadTimer = null;

              this.unloadNonRequiredTabs();

              this.postActions();
            },

            // If there are any non-visible and non-requested tabs in
            // STATE_LOADED, sets them to STATE_UNLOADING. Also queues
            // up the unloadTimer to run onUnloadTimeout if there are still
            // tabs in the process of unloading.
            unloadNonRequiredTabs() {
              this.warmingTabs = new WeakSet();
              let numPending = 0;

              // Unload any tabs that can be unloaded.
              for (let [tab, state] of this.tabState) {
                if (this.tabbrowser._printPreviewBrowsers.has(tab.linkedBrowser)) {
                  continue;
                }

                if (state == this.STATE_LOADED &&
                    !this.maybeVisibleTabs.has(tab) &&
                    tab !== this.lastVisibleTab &&
                    tab !== this.loadingTab &&
                    tab !== this.requestedTab) {
                  this.setTabState(tab, this.STATE_UNLOADING);
                }

                if (state != this.STATE_UNLOADED && tab !== this.requestedTab) {
                  numPending++;
                }
              }

              if (numPending) {
                // Keep the timer going since there may be more tabs to unload.
                this.unloadTimer = this.setTimer(() => this.onUnloadTimeout(), this.UNLOAD_DELAY);
              }
            },

            // Fires when an ongoing load has taken too long.
            onLoadTimeout() {
              this.logState("onLoadTimeout");
              this.preActions();
              this.loadTimer = null;
              this.loadingTab = null;
              this.postActions();
            },

            // Fires when the layers become available for a tab.
            onLayersReady(browser) {
              let tab = this.tabbrowser.getTabForBrowser(browser);
              this.logState(`onLayersReady(${tab._tPos}, ${browser.isRemoteBrowser})`);

              this.assert(this.getTabState(tab) == this.STATE_LOADING ||
                          this.getTabState(tab) == this.STATE_LOADED);
              this.setTabState(tab, this.STATE_LOADED);

              if (this.loadingTab === tab) {
                this.clearTimer(this.loadTimer);
                this.loadTimer = null;
                this.loadingTab = null;
              }
            },

            // Fires when we paint the screen. Any tab switches we initiated
            // previously are done, so there's no need to keep the old layers
            // around.
            onPaint() {
              this.maybeVisibleTabs.clear();
            },

            // Called when we're done clearing the layers for a tab.
            onLayersCleared(browser) {
              let tab = this.tabbrowser.getTabForBrowser(browser);
              if (tab) {
                this.logState(`onLayersCleared(${tab._tPos})`);
                this.assert(this.getTabState(tab) == this.STATE_UNLOADING ||
                            this.getTabState(tab) == this.STATE_UNLOADED);
                this.setTabState(tab, this.STATE_UNLOADED);
              }
            },

            // Called when a tab switches from remote to non-remote. In this case
            // a MozLayerTreeReady notification that we requested may never fire,
            // so we need to simulate it.
            onRemotenessChange(tab) {
              this.logState(`onRemotenessChange(${tab._tPos}, ${tab.linkedBrowser.isRemoteBrowser})`);
              if (!tab.linkedBrowser.isRemoteBrowser) {
                if (this.getTabState(tab) == this.STATE_LOADING) {
                  this.onLayersReady(tab.linkedBrowser);
                } else if (this.getTabState(tab) == this.STATE_UNLOADING) {
                  this.onLayersCleared(tab.linkedBrowser);
                }
              } else if (this.getTabState(tab) == this.STATE_LOADED) {
                // A tab just changed from non-remote to remote, which means
                // that it's gone back into the STATE_LOADING state until
                // it sends up a layer tree.
                this.setTabState(tab, this.STATE_LOADING);
              }
            },

            // Called when a tab has been removed, and the browser node is
            // about to be removed from the DOM.
            onTabRemoved(tab) {
              if (this.lastVisibleTab == tab) {
                // The browser that was being presented to the user is
                // going to be removed during this tick of the event loop.
                // This will cause us to show a tab spinner instead.
                this.preActions();
                this.lastVisibleTab = null;
                this.postActions();
              }
            },

            onSizeModeOrOcclusionStateChange() {
              if (this.minimizedOrFullyOccluded) {
                for (let [tab, state] of this.tabState) {
                  // Skip print preview browsers since they shouldn't affect tab switching.
                  if (this.tabbrowser._printPreviewBrowsers.has(tab.linkedBrowser)) {
                    continue;
                  }

                  if (state == this.STATE_LOADING || state == this.STATE_LOADED) {
                    this.setTabState(tab, this.STATE_UNLOADING);
                  }
                }
                if (this.loadTimer) {
                  this.clearTimer(this.loadTimer);
                  this.loadTimer = null;
                }
                this.loadingTab = null;
              } else {
                // Do nothing. We'll automatically start loading the requested tab in
                // postActions.
              }
            },

            onSwapDocShells(ourBrowser, otherBrowser) {
              // This event fires before the swap. ourBrowser is from
              // our window. We save the state of otherBrowser since ourBrowser
              // needs to take on that state at the end of the swap.

              let otherTabbrowser = otherBrowser.ownerGlobal.gBrowser;
              let otherState;
              if (otherTabbrowser && otherTabbrowser._switcher) {
                let otherTab = otherTabbrowser.getTabForBrowser(otherBrowser);
                let otherSwitcher = otherTabbrowser._switcher;
                otherState = otherSwitcher.getTabState(otherTab);
              } else {
                otherState = (otherBrowser.docShellIsActive
                              ? this.STATE_LOADED
                              : this.STATE_UNLOADED);
              }

              if (!this.swapMap) {
                this.swapMap = new WeakMap();
              }
              this.swapMap.set(otherBrowser, {
                state: otherState,
              });
            },

            onEndSwapDocShells(ourBrowser, otherBrowser) {
              // The swap has happened. We reset the loadingTab in
              // case it has been swapped. We also set ourBrowser's state
              // to whatever otherBrowser's state was before the swap.

              if (this.loadTimer) {
                // Clearing the load timer means that we will
                // immediately display a spinner if ourBrowser isn't
                // ready yet. Typically it will already be ready
                // though. If it's not, we're probably in a new window,
                // in which case we have no other tabs to display anyway.
                this.clearTimer(this.loadTimer);
                this.loadTimer = null;
              }
              this.loadingTab = null;

              let { state: otherState } = this.swapMap.get(otherBrowser);

              this.swapMap.delete(otherBrowser);

              let ourTab = this.tabbrowser.getTabForBrowser(ourBrowser);
              if (ourTab) {
                this.setTabStateNoAction(ourTab, otherState);
              }
            },

            shouldActivateDocShell(browser) {
              let tab = this.tabbrowser.getTabForBrowser(browser);
              let state = this.getTabState(tab);
              return state == this.STATE_LOADING || state == this.STATE_LOADED;
            },

            activateBrowserForPrintPreview(browser) {
              let tab = this.tabbrowser.getTabForBrowser(browser);
              this.setTabState(tab, this.STATE_LOADING);
            },

            canWarmTab(tab) {
              if (!this.tabbrowser.tabWarmingEnabled) {
                return false;
              }

              // If the tab is not yet inserted, closing, not remote,
              // crashed, already visible, or already requested, warming
              // up the tab makes no sense.
              if (this.minimizedOrFullyOccluded ||
                  !tab.linkedPanel ||
                  tab.closing ||
                  !tab.linkedBrowser.isRemoteBrowser ||
                  !tab.linkedBrowser.frameLoader.tabParent) {
                return false;
              }

              // Similarly, if the tab is already in STATE_LOADING or
              // STATE_LOADED somehow, there's no point in trying to
              // warm it up.
              let state = this.getTabState(tab);
              if (state === this.STATE_LOADING ||
                  state === this.STATE_LOADED) {
                return false;
              }

              return true;
            },

            unwarmTab(tab) {
              this.warmingTabs.delete(tab);
            },

            warmupTab(tab) {
              if (!this.canWarmTab(tab)) {
                return;
              }

              this.logState("warmupTab " + this.tinfo(tab));

              this.warmingTabs.add(tab);
              this.setTabState(tab, this.STATE_LOADING);
              this.suppressDisplayPortAndQueueUnload(tab,
                this.tabbrowser.tabWarmingUnloadDelay);
            },

            // Called when the user asks to switch to a given tab.
            requestTab(tab) {
              if (tab === this.requestedTab) {
                return;
              }

              if (this.tabbrowser.tabWarmingEnabled) {
                let warmingState = "disqualified";

                if (this.warmingTabs.has(tab)) {
                  let tabState = this.getTabState(tab);
                  if (tabState == this.STATE_LOADING) {
                    warmingState = "stillLoading";
                  } else if (tabState == this.STATE_LOADED) {
                    warmingState = "loaded";
                  }
                } else if (this.canWarmTab(tab)) {
                  warmingState = "notWarmed";
                }

                Services.telemetry
                        .getHistogramById("FX_TAB_SWITCH_REQUEST_TAB_WARMING_STATE")
                        .add(warmingState);

                this.unwarmTab(tab);
              }

              this._requestingTab = true;
              this.logState("requestTab " + this.tinfo(tab));
              this.startTabSwitch();

              this.requestedTab = tab;

              this.suppressDisplayPortAndQueueUnload(this.requestedTab, this.UNLOAD_DELAY);
              this._requestingTab = false;
            },

            suppressDisplayPortAndQueueUnload(tab, unloadTimeout) {
              let browser = tab.linkedBrowser;
              let fl = browser.frameLoader;

              if (fl && fl.tabParent && !this.activeSuppressDisplayport.has(fl.tabParent)) {
                fl.tabParent.suppressDisplayport(true);
                this.activeSuppressDisplayport.add(fl.tabParent);
              }

              this.preActions();

              if (this.unloadTimer) {
                this.clearTimer(this.unloadTimer);
              }
              this.unloadTimer = this.setTimer(() => this.onUnloadTimeout(), unloadTimeout);

              this.postActions();
            },

            handleEvent(event, delayed = false) {
              if (this._processing) {
                this.setTimer(() => this.handleEvent(event, true), 0);
                return;
              }
              if (delayed && this.tabbrowser._switcher != this) {
                // if we delayed processing this event, we might be out of date, in which
                // case we drop the delayed events
                return;
              }
              this._processing = true;
              this.preActions();

              if (event.type == "MozLayerTreeReady") {
                this.onLayersReady(event.originalTarget);
              } if (event.type == "MozAfterPaint") {
                this.onPaint();
              } else if (event.type == "MozLayerTreeCleared") {
                this.onLayersCleared(event.originalTarget);
              } else if (event.type == "TabRemotenessChange") {
                this.onRemotenessChange(event.target);
              } else if (event.type == "sizemodechange" ||
                         event.type == "occlusionstatechange") {
                this.onSizeModeOrOcclusionStateChange();
              } else if (event.type == "SwapDocShells") {
                this.onSwapDocShells(event.originalTarget, event.detail);
              } else if (event.type == "EndSwapDocShells") {
                this.onEndSwapDocShells(event.originalTarget, event.detail);
              }

              this.postActions();
              this._processing = false;
            },

            /*
             * Telemetry and Profiler related helpers for recording tab switch
             * timing.
             */

            startTabSwitch() {
              TelemetryStopwatch.cancel("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
              TelemetryStopwatch.start("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
              this.addMarker("AsyncTabSwitch:Start");
              this.switchInProgress = true;
            },

            /**
             * Something has occurred that might mean that we've completed
             * the tab switch (layers are ready, paints are done, spinners
             * are hidden). This checks to make sure all conditions are
             * satisfied, and then records the tab switch as finished.
             */
            maybeFinishTabSwitch() {
              if (this.switchInProgress && this.requestedTab &&
                  (this.getTabState(this.requestedTab) == this.STATE_LOADED ||
                   this.requestedTab === this.blankTab)) {
                // After this point the tab has switched from the content thread's point of view.
                // The changes will be visible after the next refresh driver tick + composite.
                let time = TelemetryStopwatch.timeElapsed("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
                if (time != -1) {
                  TelemetryStopwatch.finish("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
                  this.log("DEBUG: tab switch time = " + time);
                  this.addMarker("AsyncTabSwitch:Finish");
                }
                this.switchInProgress = false;
              }
            },

            spinnerDisplayed() {
              this.assert(!this.spinnerTab);
              let browser = this.requestedTab.linkedBrowser;
              this.assert(browser.isRemoteBrowser);
              TelemetryStopwatch.start("FX_TAB_SWITCH_SPINNER_VISIBLE_MS", window);
              // We have a second, similar probe for capturing recordings of
              // when the spinner is displayed for very long periods.
              TelemetryStopwatch.start("FX_TAB_SWITCH_SPINNER_VISIBLE_LONG_MS", window);
              this.addMarker("AsyncTabSwitch:SpinnerShown");
            },

            spinnerHidden() {
              this.assert(this.spinnerTab);
              this.log("DEBUG: spinner time = " +
                       TelemetryStopwatch.timeElapsed("FX_TAB_SWITCH_SPINNER_VISIBLE_MS", window));
              TelemetryStopwatch.finish("FX_TAB_SWITCH_SPINNER_VISIBLE_MS", window);
              TelemetryStopwatch.finish("FX_TAB_SWITCH_SPINNER_VISIBLE_LONG_MS", window);
              this.addMarker("AsyncTabSwitch:SpinnerHidden");
              // we do not get a onPaint after displaying the spinner
            },

            addMarker(marker) {
              if (Services.profiler) {
                Services.profiler.AddMarker(marker);
              }
            },

            /*
             * Debug related logging for switcher.
             */

            _useDumpForLogging: false,
            _logInit: false,

            logging() {
              if (this._useDumpForLogging)
                return true;
              if (this._logInit)
                return this._shouldLog;
              let result = Services.prefs.getBoolPref("browser.tabs.remote.logSwitchTiming", false);
              this._shouldLog = result;
              this._logInit = true;
              return this._shouldLog;
            },

            tinfo(tab) {
              if (tab) {
                return tab._tPos + "(" + tab.linkedBrowser.currentURI.spec + ")";
              }
              return "null";
            },

            log(s) {
              if (!this.logging())
                return;
              if (this._useDumpForLogging) {
                dump(s + "\n");
              } else {
                Services.console.logStringMessage(s);
              }
            },

            logState(prefix) {
              if (!this.logging())
                return;

              let accum = prefix + " ";
              for (let i = 0; i < this.tabbrowser.tabs.length; i++) {
                let tab = this.tabbrowser.tabs[i];
                let state = this.getTabState(tab);
                let isWarming = this.warmingTabs.has(tab);

                accum += i + ":";
                if (tab === this.lastVisibleTab) accum += "V";
                if (tab === this.loadingTab) accum += "L";
                if (tab === this.requestedTab) accum += "R";
                if (tab === this.blankTab) accum += "B";
                if (isWarming) accum += "(W)";
                if (state == this.STATE_LOADED) accum += "(+)";
                if (state == this.STATE_LOADING) accum += "(+?)";
                if (state == this.STATE_UNLOADED) accum += "(-)";
                if (state == this.STATE_UNLOADING) accum += "(-?)";
                accum += " ";
              }
              if (this._useDumpForLogging) {
                dump(accum + "\n");
              } else {
                Services.console.logStringMessage(accum);
              }
            },
          };
          this._switcher = switcher;
          switcher.init();
          return switcher;
        ]]></body>
      </method>

      <method name="warmupTab">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            if (gMultiProcessBrowser) {
              this._getSwitcher().warmupTab(aTab);
            }
          ]]>
        </body>
      </method>

      <!-- BEGIN FORWARDED BROWSER PROPERTIES.  IF YOU ADD A PROPERTY TO THE BROWSER ELEMENT
           MAKE SURE TO ADD IT HERE AS WELL. -->
      <property name="canGoBack"
                onget="return this.mCurrentBrowser.canGoBack;"
                readonly="true"/>

      <property name="canGoForward"
                onget="return this.mCurrentBrowser.canGoForward;"
                readonly="true"/>

      <method name="goBack">
        <body>
          <![CDATA[
            return this.mCurrentBrowser.goBack();
          ]]>
        </body>
      </method>

      <method name="goForward">
        <body>
          <![CDATA[
            return this.mCurrentBrowser.goForward();
          ]]>
        </body>
      </method>

      <method name="reload">
        <body>
          <![CDATA[
            return this.mCurrentBrowser.reload();
          ]]>
        </body>
      </method>

      <method name="reloadWithFlags">
        <parameter name="aFlags"/>
        <body>
          <![CDATA[
            return this.mCurrentBrowser.reloadWithFlags(aFlags);
          ]]>
        </body>
      </method>

      <method name="stop">
        <body>
          <![CDATA[
            return this.mCurrentBrowser.stop();
          ]]>
        </body>
      </method>

      <!-- throws exception for unknown schemes -->
      <method name="loadURI">
        <parameter name="aURI"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <body>
          <![CDATA[
            return this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);
          ]]>
        </body>
      </method>

      <!-- throws exception for unknown schemes -->
      <method name="loadURIWithFlags">
        <parameter name="aURI"/>
        <parameter name="aFlags"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aPostData"/>
        <body>
          <![CDATA[
            // Note - the callee understands both:
            // (a) loadURIWithFlags(aURI, aFlags, ...)
            // (b) loadURIWithFlags(aURI, { flags: aFlags, ... })
            // Forwarding it as (a) here actually supports both (a) and (b),
            // so you can call us either way too.
            return this.mCurrentBrowser.loadURIWithFlags(aURI, aFlags, aReferrerURI, aCharset, aPostData);
          ]]>
        </body>
      </method>

      <method name="goHome">
        <body>
          <![CDATA[
            return this.mCurrentBrowser.goHome();
          ]]>
        </body>
      </method>

      <property name="homePage">
        <getter>
          <![CDATA[
            return this.mCurrentBrowser.homePage;
          ]]>
        </getter>
        <setter>
          <![CDATA[
            this.mCurrentBrowser.homePage = val;
            return val;
          ]]>
        </setter>
      </property>

      <method name="gotoIndex">
        <parameter name="aIndex"/>
        <body>
          <![CDATA[
            return this.mCurrentBrowser.gotoIndex(aIndex);
          ]]>
        </body>
      </method>

      <property name="currentURI"
                onget="return this.mCurrentBrowser.currentURI;"
                readonly="true"/>

      <property name="finder"
                onget="return this.mCurrentBrowser.finder"
                readonly="true"/>

      <property name="docShell"
                onget="return this.mCurrentBrowser.docShell"
                readonly="true"/>

      <property name="webNavigation"
                onget="return this.mCurrentBrowser.webNavigation"
                readonly="true"/>

      <property name="webBrowserFind"
                readonly="true"
                onget="return this.mCurrentBrowser.webBrowserFind"/>

      <property name="webProgress"
                readonly="true"
                onget="return this.mCurrentBrowser.webProgress"/>

      <property name="contentWindow"
                readonly="true"
                onget="return this.mCurrentBrowser.contentWindow"/>

      <property name="contentWindowAsCPOW"
                readonly="true"
                onget="return this.mCurrentBrowser.contentWindowAsCPOW"/>

      <property name="sessionHistory"
                onget="return this.mCurrentBrowser.sessionHistory;"
                readonly="true"/>

      <property name="markupDocumentViewer"
                onget="return this.mCurrentBrowser.markupDocumentViewer;"
                readonly="true"/>

      <property name="contentViewerEdit"
                onget="return this.mCurrentBrowser.contentViewerEdit;"
                readonly="true"/>

      <property name="contentDocument"
                onget="return this.mCurrentBrowser.contentDocument;"
                readonly="true"/>

      <property name="contentDocumentAsCPOW"
                onget="return this.mCurrentBrowser.contentDocumentAsCPOW;"
                readonly="true"/>

      <property name="contentTitle"
                onget="return this.mCurrentBrowser.contentTitle;"
                readonly="true"/>

      <property name="contentPrincipal"
                onget="return this.mCurrentBrowser.contentPrincipal;"
                readonly="true"/>

      <property name="securityUI"
                onget="return this.mCurrentBrowser.securityUI;"
                readonly="true"/>

      <property name="fullZoom"
                onget="return this.mCurrentBrowser.fullZoom;"
                onset="this.mCurrentBrowser.fullZoom = val;"/>

      <property name="textZoom"
                onget="return this.mCurrentBrowser.textZoom;"
                onset="this.mCurrentBrowser.textZoom = val;"/>

      <property name="isSyntheticDocument"
                onget="return this.mCurrentBrowser.isSyntheticDocument;"
                readonly="true"/>

      <method name="_handleKeyDownEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          if (!aEvent.isTrusted) {
            // Don't let untrusted events mess with tabs.
            return;
          }

          if (aEvent.altKey)
            return;

          // Don't check if the event was already consumed because tab
          // navigation should always work for better user experience.

          if (aEvent.ctrlKey && aEvent.shiftKey && !aEvent.metaKey) {
            switch (aEvent.keyCode) {
              case aEvent.DOM_VK_PAGE_UP:
                this.moveTabBackward();
                aEvent.preventDefault();
                return;
              case aEvent.DOM_VK_PAGE_DOWN:
                this.moveTabForward();
                aEvent.preventDefault();
                return;
            }
          }

          if (AppConstants.platform != "macosx") {
            if (aEvent.ctrlKey && !aEvent.shiftKey && !aEvent.metaKey &&
                aEvent.keyCode == KeyEvent.DOM_VK_F4 &&
                !this.mCurrentTab.pinned) {
              this.removeCurrentTab({animate: true});
              aEvent.preventDefault();
            }
          }
        ]]></body>
      </method>

      <method name="_handleKeyPressEventMac">
        <parameter name="aEvent"/>
        <body><![CDATA[
          if (!aEvent.isTrusted) {
            // Don't let untrusted events mess with tabs.
            return;
          }

          if (aEvent.altKey)
            return;

          if (AppConstants.platform == "macosx") {
            if (!aEvent.metaKey)
              return;

            var offset = 1;
            switch (aEvent.charCode) {
              case "}".charCodeAt(0):
                offset = -1;
              case "{".charCodeAt(0):
                if (window.getComputedStyle(this).direction == "ltr")
                  offset *= -1;
                this.tabContainer.advanceSelectedTab(offset, true);
                aEvent.preventDefault();
            }
          }
        ]]></body>
      </method>

      <property name="userTypedValue"
                onget="return this.mCurrentBrowser.userTypedValue;"
                onset="return this.mCurrentBrowser.userTypedValue = val;"/>

      <method name="createTooltip">
        <parameter name="event"/>
        <body><![CDATA[
          event.stopPropagation();
          var tab = document.tooltipNode;
          if (tab.localName != "tab") {
            event.preventDefault();
            return;
          }

          let stringWithShortcut = (stringId, keyElemId) => {
            let keyElem = document.getElementById(keyElemId);
            let shortcut = ShortcutUtils.prettifyShortcut(keyElem);
            return gTabBrowserBundle.formatStringFromName(stringId, [shortcut], 1);
          };

          var label;
          if (tab.mOverCloseButton) {
            label = tab.selected ?
                    stringWithShortcut("tabs.closeSelectedTab.tooltip", "key_close") :
                    gTabBrowserBundle.GetStringFromName("tabs.closeTab.tooltip");
          } else if (tab._overPlayingIcon) {
            let stringID;
            if (tab.selected) {
              stringID = tab.linkedBrowser.audioMuted ?
                "tabs.unmuteAudio.tooltip" :
                "tabs.muteAudio.tooltip";
              label = stringWithShortcut(stringID, "key_toggleMute");
            } else {
              if (tab.hasAttribute("activemedia-blocked")) {
                stringID = "tabs.unblockAudio.tooltip";
              } else {
                stringID = tab.linkedBrowser.audioMuted ?
                  "tabs.unmuteAudio.background.tooltip" :
                  "tabs.muteAudio.background.tooltip";
              }

              label = gTabBrowserBundle.GetStringFromName(stringID);
            }
          } else {
            label = tab._fullLabel || tab.getAttribute("label");
            if (AppConstants.NIGHTLY_BUILD &&
                tab.linkedBrowser &&
                tab.linkedBrowser.isRemoteBrowser &&
                tab.linkedBrowser.frameLoader) {
              label += " (pid " + tab.linkedBrowser.frameLoader.tabParent.osPid + ")";
            }
            if (tab.userContextId) {
              label = gTabBrowserBundle.formatStringFromName("tabs.containers.tooltip", [label, ContextualIdentityService.getUserContextLabel(tab.userContextId)], 2);
            }
          }

          event.target.setAttribute("label", label);
        ]]></body>
      </method>

      <method name="handleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          switch (aEvent.type) {
            case "keydown":
              this._handleKeyDownEvent(aEvent);
              break;
            case "keypress":
              this._handleKeyPressEventMac(aEvent);
              break;
            case "sizemodechange":
            case "occlusionstatechange":
              if (aEvent.target == window && !this._switcher) {
                this.mCurrentBrowser.preserveLayers(
                  window.windowState == window.STATE_MINIMIZED || window.isFullyOccluded);
                this.mCurrentBrowser.docShellIsActive = this.shouldActivateDocShell(this.mCurrentBrowser);
              }
              break;
          }
        ]]></body>
      </method>

      <method name="receiveMessage">
        <parameter name="aMessage"/>
        <body><![CDATA[
          let data = aMessage.data;
          let browser = aMessage.target;

          switch (aMessage.name) {
            case "DOMTitleChanged": {
              let tab = this.getTabForBrowser(browser);
              if (!tab || tab.hasAttribute("pending"))
                return undefined;
              let titleChanged = this.setTabTitle(tab);
              if (titleChanged && !tab.selected && !tab.hasAttribute("busy"))
                tab.setAttribute("titlechanged", "true");
              break;
            }
            case "DOMWindowClose": {
              if (this.tabs.length == 1) {
                // We already did PermitUnload in the content process
                // for this tab (the only one in the window). So we don't
                // need to do it again for any tabs.
                window.skipNextCanClose = true;
                window.close();
                return undefined;
              }

              let tab = this.getTabForBrowser(browser);
              if (tab) {
                // Skip running PermitUnload since it already happened in
                // the content process.
                this.removeTab(tab, {skipPermitUnload: true});
              }
              break;
            }
            case "contextmenu": {
              openContextMenu(aMessage);
              break;
            }
            case "DOMWindowFocus": {
              let tab = this.getTabForBrowser(browser);
              if (!tab)
                return undefined;
              this.selectedTab = tab;
              window.focus();
              break;
            }
            case "Browser:Init": {
              let tab = this.getTabForBrowser(browser);
              if (!tab)
                return undefined;

              this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
              browser.messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: tab.pinned })
              break;
            }
            case "Browser:WindowCreated": {
              let tab = this.getTabForBrowser(browser);
              if (tab && data.userContextId) {
                ContextualIdentityService.telemetry(data.userContextId);
                tab.setUserContextId(data.userContextId);
              }

              // We don't want to update the container icon and identifier if
              // this is not the selected browser.
              if (browser == gBrowser.selectedBrowser) {
                updateUserContextUIIndicator();
              }

              break;
            }
            case "Findbar:Keypress": {
              let tab = this.getTabForBrowser(browser);
              // If the find bar for this tab is not yet alive, only initialize
              // it if there's a possibility FindAsYouType will be used.
              // There's no point in doing it for most random keypresses.
              if (!this.isFindBarInitialized(tab) &&
                data.shouldFastFind) {
                let shouldFastFind = this._findAsYouType;
                if (!shouldFastFind) {
                  // Please keep in sync with toolkit/content/widgets/findbar.xml
                  const FAYT_LINKS_KEY = "'";
                  const FAYT_TEXT_KEY = "/";
                  let charCode = data.fakeEvent.charCode;
                  let key = charCode ? String.fromCharCode(charCode) : null;
                  shouldFastFind = key == FAYT_LINKS_KEY || key == FAYT_TEXT_KEY;
                }
                if (shouldFastFind) {
                  // Make sure we return the result.
                  return this.getFindBar(tab).receiveMessage(aMessage);
                }
              }
              break;
            }
            case "RefreshBlocker:Blocked": {
              // The data object is expected to contain the following properties:
              //  - URI (string)
              //     The URI that a page is attempting to refresh or redirect to.
              //  - delay (int)
              //     The delay (in milliseconds) before the page was going to
              //     reload or redirect.
              //  - sameURI (bool)
              //     true if we're refreshing the page. false if we're redirecting.
              //  - outerWindowID (int)
              //     The outerWindowID of the frame that requested the refresh or
              //     redirect.

              let brandBundle = document.getElementById("bundle_brand");
              let brandShortName = brandBundle.getString("brandShortName");
              let message =
                gNavigatorBundle.getFormattedString("refreshBlocked." +
                                                    (data.sameURI ? "refreshLabel"
                                                                  : "redirectLabel"),
                                                    [brandShortName]);

              let notificationBox = this.getNotificationBox(browser);
              let notification = notificationBox.getNotificationWithValue("refresh-blocked");

              if (notification) {
                notification.label = message;
              } else {
                let refreshButtonText =
                  gNavigatorBundle.getString("refreshBlocked.goButton");
                let refreshButtonAccesskey =
                  gNavigatorBundle.getString("refreshBlocked.goButton.accesskey");

                let buttons = [{
                  label: refreshButtonText,
                  accessKey: refreshButtonAccesskey,
                  callback() {
                    if (browser.messageManager) {
                      browser.messageManager.sendAsyncMessage("RefreshBlocker:Refresh", data);
                    }
                  }
                }];

                notificationBox.appendNotification(message, "refresh-blocked",
                                                   "chrome://browser/skin/notification-icons/popup.svg",
                                                   notificationBox.PRIORITY_INFO_MEDIUM,
                                                   buttons);
              }
              break;
            }

            case "Prerender:Request": {
              let sendCancelPrerendering = () => {
                browser.frameloader.messageManager.
                  sendAsyncMessage("Prerender:Canceled", { id: data.id });
              };

              let tab = this.getTabForBrowser(browser);
              if (!tab) {
                // No tab?
                sendCancelPrerendering();
                break;
              }

              if (tab.hidden) {
                // Skip prerender on hidden tab.
                sendCancelPrerendering();
                break;
              }

              if (browser.canGoForward) {
                // Skip prerender on history navigation as we don't support it
                // yet. Remove this check once bug 1323650 is implemented.
                sendCancelPrerendering();
                break;
              }

              if (!data.href) {
                // If we don't have data.href, loadOneTab will load about:blank
                // which is meaningless for prerendering.
                sendCancelPrerendering();
                break;
              }

              let groupedSHistory = browser.frameLoader.ensureGroupedSHistory();

              let newTab = this.loadOneTab(data.href, {
                referrerURI: (data.referrer ? makeURI(data.referrer) : null),
                referrerPolicy: Ci.nsIHttpChannel.REFERRER_POLICY_UNSET,
                postData: null,
                allowThirdPartyFixup: true,
                relatedToCurrent: true,
                isPrerendered: true,
                triggeringPrincipal: Utils.deserializePrincipal(data.triggeringPrincipal),
              });
              let partialSHistory = newTab.linkedBrowser.frameLoader.partialSHistory;
              groupedSHistory.addPrerenderingPartialSHistory(partialSHistory, data.id);
              break;
            }

            case "Prerender:Cancel": {
              let groupedSHistory = browser.frameLoader.groupedSHistory;
              if (groupedSHistory) {
                groupedSHistory.cancelPrerendering(data.id);
              }
              break;
            }

            case "Prerender:Swap": {
              let frameloader = browser.frameLoader;
              let groupedSHistory = browser.frameLoader.groupedSHistory;
              if (groupedSHistory) {
                groupedSHistory.activatePrerendering(data.id).then(
                  () => frameloader.messageManager.sendAsyncMessage("Prerender:Swapped", data),
                  () => frameloader.messageManager.sendAsyncMessage("Prerender:Canceled", data),
                );
              }
              break;
            }

          }
          return undefined;
        ]]></body>
      </method>

      <method name="observe">
        <parameter name="aSubject"/>
        <parameter name="aTopic"/>
        <parameter name="aData"/>
        <body><![CDATA[
          switch (aTopic) {
            case "contextual-identity-updated": {
              for (let tab of this.tabs) {
                if (tab.getAttribute("usercontextid") == aData) {
                  ContextualIdentityService.setTabStyle(tab);
                }
              }
              break;
            }
            case "nsPref:changed": {
              // This is the only pref observed.
              this._findAsYouType = Services.prefs.getBoolPref("accessibility.typeaheadfind");
              break;
            }
          }
        ]]></body>
      </method>

      <method name="_updateNewTabVisibility">
        <body><![CDATA[
          let sib = this.tabContainer.nextElementSibling;
          while (sib && sib.hidden) {
            sib = sib.nextElementSibling;
          }
          const kAttr = "hasadjacentnewtabbutton";
          if (sib && sib.id == "new-tab-button") {
            this.tabContainer.setAttribute(kAttr, "true");
          } else {
            this.tabContainer.removeAttribute(kAttr);
          }
        ]]></body>
      </method>

      <method name="onWidgetAfterDOMChange">
        <parameter name="aNode"/>
        <parameter name="aNextNode"/>
        <parameter name="aContainer"/>
        <body><![CDATA[
          if (aContainer.ownerDocument == document &&
              aContainer.id == "TabsToolbar") {
            this._updateNewTabVisibility();
          }
        ]]></body>
      </method>
      <method name="onAreaNodeRegistered">
        <parameter name="aArea"/>
        <parameter name="aContainer"/>
        <body><![CDATA[
          if (aContainer.ownerDocument == document &&
              aArea == "TabsToolbar") {
            this._updateNewTabVisibility();
          }
        ]]></body>
      </method>
      <method name="onAreaReset">
        <parameter name="aArea"/>
        <parameter name="aContainer"/>
        <body><![CDATA[
          this.onAreaNodeRegistered(aArea, aContainer);
        ]]></body>
      </method>

      <field name="_tabMinWidthLimit">50</field>
      <property name="tabMinWidth">
        <setter><![CDATA[
          let root = document.documentElement;
          root.style.setProperty("--tab-min-width", val + "px");
          return val;
        ]]></setter>
      </property>

      <constructor>
        <![CDATA[
          this.mCurrentBrowser = document.getAnonymousElementByAttribute(this, "anonid", "initialBrowser");
          this.mCurrentBrowser.permanentKey = {};

          CustomizableUI.addListener(this);
          this._updateNewTabVisibility();

          Services.obs.addObserver(this, "contextual-identity-updated");

          this.mCurrentTab = this.tabContainer.firstChild;
          const nsIEventListenerService =
            Components.interfaces.nsIEventListenerService;
          let els = Components.classes["@mozilla.org/eventlistenerservice;1"]
                              .getService(nsIEventListenerService);
          els.addSystemEventListener(document, "keydown", this, false);
          if (AppConstants.platform == "macosx") {
            els.addSystemEventListener(document, "keypress", this, false);
          }
          window.addEventListener("sizemodechange", this);
          window.addEventListener("occlusionstatechange", this);

          var uniqueId = this._generateUniquePanelID();
          this.mPanelContainer.childNodes[0].id = uniqueId;
          this.mCurrentTab.linkedPanel = uniqueId;
          this.mCurrentTab.permanentKey = this.mCurrentBrowser.permanentKey;
          this.mCurrentTab._tPos = 0;
          this.mCurrentTab._fullyOpen = true;
          this.mCurrentTab.linkedBrowser = this.mCurrentBrowser;
          this._tabForBrowser.set(this.mCurrentBrowser, this.mCurrentTab);

          // set up the shared autoscroll popup
          this._autoScrollPopup = this.mCurrentBrowser._createAutoScrollPopup();
          this._autoScrollPopup.id = "autoscroller";
          this.appendChild(this._autoScrollPopup);
          this.mCurrentBrowser.setAttribute("autoscrollpopup", this._autoScrollPopup.id);
          this.mCurrentBrowser.droppedLinkHandler = handleDroppedLink;

          // Hook up the event listeners to the first browser
          var tabListener = this.mTabProgressListener(this.mCurrentTab, this.mCurrentBrowser, true, false);
          const nsIWebProgress = Components.interfaces.nsIWebProgress;
          const filter = Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
                                   .createInstance(nsIWebProgress);
          filter.addProgressListener(tabListener, nsIWebProgress.NOTIFY_ALL);
          this._tabListeners.set(this.mCurrentTab, tabListener);
          this._tabFilters.set(this.mCurrentTab, filter);
          this.webProgress.addProgressListener(filter, nsIWebProgress.NOTIFY_ALL);

          if (Services.prefs.getBoolPref("browser.display.use_system_colors"))
            this.style.backgroundColor = "-moz-default-background-color";

          let messageManager = window.getGroupMessageManager("browsers");

          let remote = window.QueryInterface(Ci.nsIInterfaceRequestor)
            .getInterface(Ci.nsIWebNavigation)
            .QueryInterface(Ci.nsILoadContext)
            .useRemoteTabs;
          if (remote) {
            messageManager.addMessageListener("DOMTitleChanged", this);
            messageManager.addMessageListener("DOMWindowClose", this);
            window.messageManager.addMessageListener("contextmenu", this);
            messageManager.addMessageListener("Browser:Init", this);

            // If this window has remote tabs, switch to our tabpanels fork
            // which does asynchronous tab switching.
            this.mPanelContainer.classList.add("tabbrowser-tabpanels");
          } else {
            this._outerWindowIDBrowserMap.set(this.mCurrentBrowser.outerWindowID,
                                              this.mCurrentBrowser);
          }
          messageManager.addMessageListener("DOMWindowFocus", this);
          messageManager.addMessageListener("RefreshBlocker:Blocked", this);
          messageManager.addMessageListener("Browser:WindowCreated", this);

          // To correctly handle keypresses for potential FindAsYouType, while
          // the tab's find bar is not yet initialized.
          this._findAsYouType = Services.prefs.getBoolPref("accessibility.typeaheadfind");
          Services.prefs.addObserver("accessibility.typeaheadfind", this);
          messageManager.addMessageListener("Findbar:Keypress", this);

          // Add listeners for prerender messages
          messageManager.addMessageListener("Prerender:Request", this);
          messageManager.addMessageListener("Prerender:Cancel", this);
          messageManager.addMessageListener("Prerender:Swap", this);

          XPCOMUtils.defineLazyPreferenceGetter(this, "animationsEnabled",
                                                "toolkit.cosmeticAnimations.enabled", true);
          XPCOMUtils.defineLazyPreferenceGetter(this, "tabWarmingEnabled",
                                                "browser.tabs.remote.warmup.enabled", false);
          XPCOMUtils.defineLazyPreferenceGetter(this, "tabWarmingMax",
                                                "browser.tabs.remote.warmup.maxTabs", 3);
          XPCOMUtils.defineLazyPreferenceGetter(this, "tabWarmingUnloadDelay" /* ms */,
                                                "browser.tabs.remote.warmup.unloadDelayMs", 2000);
          XPCOMUtils.defineLazyPreferenceGetter(this, "tabMinWidthPref",
                                                "browser.tabs.tabMinWidth", this._tabMinWidthLimit,
            (pref, prevValue, newValue) => this.tabMinWidth = newValue,
            newValue => Math.max(newValue, this._tabMinWidthLimit),
          );

          this.tabMinWidth = this.tabMinWidthPref;
        ]]>
      </constructor>

      <method name="_generateUniquePanelID">
        <body><![CDATA[
          if (!this._uniquePanelIDCounter) {
            this._uniquePanelIDCounter = 0;
          }

          let outerID = window.QueryInterface(Ci.nsIInterfaceRequestor)
                              .getInterface(Ci.nsIDOMWindowUtils)
                              .outerWindowID;

          // We want panel IDs to be globally unique, that's why we include the
          // window ID. We switched to a monotonic counter as Date.now() lead
          // to random failures because of colliding IDs.
          return "panel-" + outerID + "-" + (++this._uniquePanelIDCounter);
        ]]></body>
      </method>

      <destructor>
        <![CDATA[
          Services.obs.removeObserver(this, "contextual-identity-updated");

          CustomizableUI.removeListener(this);

          for (let tab of this.tabs) {
            let browser = tab.linkedBrowser;
            if (browser.registeredOpenURI) {
              this._unifiedComplete.unregisterOpenPage(browser.registeredOpenURI,
                                                       browser.getAttribute("usercontextid") || 0);
              delete browser.registeredOpenURI;
            }

            let filter = this._tabFilters.get(tab);
            if (filter) {
              browser.webProgress.removeProgressListener(filter);

              let listener = this._tabListeners.get(tab);
              if (listener) {
                filter.removeProgressListener(listener);
                listener.destroy();
              }

              this._tabFilters.delete(tab);
              this._tabListeners.delete(tab);
            }
          }
          const nsIEventListenerService =
            Components.interfaces.nsIEventListenerService;
          let els = Components.classes["@mozilla.org/eventlistenerservice;1"]
                              .getService(nsIEventListenerService);
          els.removeSystemEventListener(document, "keydown", this, false);
          if (AppConstants.platform == "macosx") {
            els.removeSystemEventListener(document, "keypress", this, false);
          }
          window.removeEventListener("sizemodechange", this);
          window.removeEventListener("occlusionstatechange", this);

          if (gMultiProcessBrowser) {
            let messageManager = window.getGroupMessageManager("browsers");
            messageManager.removeMessageListener("DOMTitleChanged", this);
            window.messageManager.removeMessageListener("contextmenu", this);

            if (this._switcher) {
              this._switcher.destroy();
            }
          }

          Services.prefs.removeObserver("accessibility.typeaheadfind", this);
        ]]>
      </destructor>

      <field name="_soundPlayingAttrRemovalTimer">0</field>
      <field name="_hoverTabTimer">null</field>
    </implementation>

    <handlers>
      <handler event="DOMWindowClose" phase="capturing">
        <![CDATA[
          if (!event.isTrusted)
            return;

          if (this.tabs.length == 1) {
            // We already did PermitUnload in nsGlobalWindow::Close
            // for this tab. There are no other tabs we need to do
            // PermitUnload for.
            window.skipNextCanClose = true;
            return;
          }

          var tab = this._getTabForContentWindow(event.target);
          if (tab) {
            // Skip running PermitUnload since it already happened.
            this.removeTab(tab, {skipPermitUnload: true});
            event.preventDefault();
          }
        ]]>
      </handler>
      <handler event="DOMWillOpenModalDialog" phase="capturing">
        <![CDATA[
          if (!event.isTrusted)
            return;

          let targetIsWindow = event.target instanceof Window;

          // We're about to open a modal dialog, so figure out for which tab:
          // If this is a same-process modal dialog, then we're given its DOM
          // window as the event's target. For remote dialogs, we're given the
          // browser, but that's in the originalTarget and not the target,
          // because it's across the tabbrowser's XBL boundary.
          let tabForEvent = targetIsWindow ?
                            this._getTabForContentWindow(event.target.top) :
                            this.getTabForBrowser(event.originalTarget);

          // Focus window for beforeunload dialog so it is seen but don't
          // steal focus from other applications.
          if (event.detail &&
              event.detail.tabPrompt &&
              event.detail.inPermitUnload &&
              Services.focus.activeWindow)
            window.focus();

          // Don't need to act if the tab is already selected or if there isn't
          // a tab for the event (e.g. for the webextensions options_ui remote
          // browsers embedded in the "about:addons" page):
          if (!tabForEvent || tabForEvent.selected)
            return;

          // We always switch tabs for beforeunload tab-modal prompts.
          if (event.detail &&
              event.detail.tabPrompt &&
              !event.detail.inPermitUnload) {
            let docPrincipal = targetIsWindow ? event.target.document.nodePrincipal : null;
            // At least one of these should/will be non-null:
            let promptPrincipal = event.detail.promptPrincipal || docPrincipal ||
                                  tabForEvent.linkedBrowser.contentPrincipal;
            // For null principals, we bail immediately and don't show the checkbox:
            if (!promptPrincipal || promptPrincipal.isNullPrincipal) {
              tabForEvent.setAttribute("attention", "true");
              return;
            }

            // For non-system/expanded principals, we bail and show the checkbox
            if (promptPrincipal.URI &&
                !Services.scriptSecurityManager.isSystemPrincipal(promptPrincipal)) {
              let permission = Services.perms.testPermissionFromPrincipal(promptPrincipal,
                                                                          "focus-tab-by-prompt");
              if (permission != Services.perms.ALLOW_ACTION) {
                // Tell the prompt box we want to show the user a checkbox:
                let tabPrompt = this.getTabModalPromptBox(tabForEvent.linkedBrowser);
                tabPrompt.onNextPromptShowAllowFocusCheckboxFor(promptPrincipal);
                tabForEvent.setAttribute("attention", "true");
                return;
              }
            }
            // ... so system and expanded principals, as well as permitted "normal"
            // URI-based principals, always get to steal focus for the tab when prompting.
          }

          // If permissions/origins dictate so, bring tab to the front.
          this.selectedTab = tabForEvent;
        ]]>
      </handler>
      <handler event="DOMTitleChanged">
        <![CDATA[
          if (!event.isTrusted)
            return;

          var contentWin = event.target.defaultView;
          if (contentWin != contentWin.top)
            return;

          var tab = this._getTabForContentWindow(contentWin);
          if (!tab || tab.hasAttribute("pending"))
            return;

          var titleChanged = this.setTabTitle(tab);
          if (titleChanged && !tab.selected && !tab.hasAttribute("busy"))
            tab.setAttribute("titlechanged", "true");
        ]]>
      </handler>
      <handler event="oop-browser-crashed">
        <![CDATA[
          if (!event.isTrusted)
            return;

          let browser = event.originalTarget;

          // Preloaded browsers do not actually have any tabs. If one crashes,
          // it should be released and removed.
          if (browser === this._preloadedBrowser) {
            this.removePreloadedBrowser();
            return;
          }

          let icon = browser.mIconURL;
          let tab = this.getTabForBrowser(browser);

          if (this.selectedBrowser == browser) {
            TabCrashHandler.onSelectedBrowserCrash(browser);
          } else {
            this.updateBrowserRemoteness(browser, false);
            SessionStore.reviveCrashedTab(tab);
          }

          tab.removeAttribute("soundplaying");
          this.setIcon(tab, icon, browser.contentPrincipal, browser.contentRequestContextID);
        ]]>
      </handler>
      <handler event="DOMAudioPlaybackStarted">
        <![CDATA[
          var tab = this.getTabFromAudioEvent(event)
          if (!tab) {
            return;
          }

          clearTimeout(tab._soundPlayingAttrRemovalTimer);
          tab._soundPlayingAttrRemovalTimer = 0;

          let modifiedAttrs = [];
          if (tab.hasAttribute("soundplaying-scheduledremoval")) {
            tab.removeAttribute("soundplaying-scheduledremoval");
            modifiedAttrs.push("soundplaying-scheduledremoval");
          }

          if (!tab.hasAttribute("soundplaying")) {
            tab.setAttribute("soundplaying", true);
            modifiedAttrs.push("soundplaying");
          }

          if (modifiedAttrs.length) {
            // Flush style so that the opacity takes effect immediately, in
            // case the media is stopped before the style flushes naturally.
            getComputedStyle(tab).opacity;
          }

          this._tabAttrModified(tab, modifiedAttrs);
        ]]>
      </handler>
      <handler event="DOMAudioPlaybackStopped">
        <![CDATA[
          var tab = this.getTabFromAudioEvent(event)
          if (!tab) {
            return;
          }

          if (tab.hasAttribute("soundplaying")) {
            let removalDelay = Services.prefs.getIntPref("browser.tabs.delayHidingAudioPlayingIconMS");

            tab.style.setProperty("--soundplaying-removal-delay", `${removalDelay - 300}ms`);
            tab.setAttribute("soundplaying-scheduledremoval", "true");
            this._tabAttrModified(tab, ["soundplaying-scheduledremoval"]);

            tab._soundPlayingAttrRemovalTimer = setTimeout(() => {
              tab.removeAttribute("soundplaying-scheduledremoval");
              tab.removeAttribute("soundplaying");
              this._tabAttrModified(tab, ["soundplaying", "soundplaying-scheduledremoval"]);
            }, removalDelay);
          }
        ]]>
      </handler>
      <handler event="DOMAudioPlaybackBlockStarted">
        <![CDATA[
          var tab = this.getTabFromAudioEvent(event)
          if (!tab) {
            return;
          }

          if (!tab.hasAttribute("activemedia-blocked")) {
            tab.setAttribute("activemedia-blocked", true);
            this._tabAttrModified(tab, ["activemedia-blocked"]);
            tab.startMediaBlockTimer();
          }
        ]]>
      </handler>
      <handler event="DOMAudioPlaybackBlockStopped">
        <![CDATA[
          var tab = this.getTabFromAudioEvent(event)
          if (!tab) {
            return;
          }

          if (tab.hasAttribute("activemedia-blocked")) {
            tab.removeAttribute("activemedia-blocked");
            this._tabAttrModified(tab, ["activemedia-blocked"]);
            let hist = Services.telemetry.getHistogramById("TAB_AUDIO_INDICATOR_USED");
            hist.add(2 /* unblockByVisitingTab */);
            tab.finishMediaBlockTimer();
          }
        ]]>
      </handler>
    </handlers>
  </binding>

  <binding id="tabbrowser-arrowscrollbox" extends="chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll">
    <implementation>
      <!-- Override scrollbox.xml method, since our scrollbox's children are
           inherited from the binding parent -->
      <method name="_getScrollableElements">
        <body><![CDATA[
          return Array.filter(document.getBindingParent(this).childNodes,
                              this._canScrollToElement, this);
        ]]></body>
      </method>
      <method name="_canScrollToElement">
        <parameter name="tab"/>
        <body><![CDATA[
          return !tab.pinned && !tab.hidden;
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="underflow" phase="capturing"><![CDATA[
        if (event.originalTarget != this._scrollbox)
          return;

        // Ignore vertical events
        if (event.detail == 0)
          return;

        var tabs = document.getBindingParent(this);
        tabs.removeAttribute("overflow");

        if (tabs._lastTabClosedByMouse)
          tabs._expandSpacerBy(this._scrollButtonDown.clientWidth);

        for (let tab of Array.from(tabs.tabbrowser._removingTabs))
          tabs.tabbrowser.removeTab(tab);

        tabs._positionPinnedTabs();
      ]]></handler>
      <handler event="overflow"><![CDATA[
        if (event.originalTarget != this._scrollbox)
          return;

        // Ignore vertical events
        if (event.detail == 0)
          return;

        var tabs = document.getBindingParent(this);
        tabs.setAttribute("overflow", "true");
        tabs._positionPinnedTabs();
        tabs._handleTabSelect(true);
      ]]></handler>
    </handlers>
  </binding>

  <binding id="tabbrowser-tabs"
           extends="chrome://global/content/bindings/tabbox.xml#tabs">
    <resources>
      <stylesheet src="chrome://browser/content/tabbrowser.css"/>
    </resources>

    <content>
      <xul:hbox class="tab-drop-indicator-box">
        <xul:image class="tab-drop-indicator" anonid="tab-drop-indicator" collapsed="true"/>
      </xul:hbox>
      <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1"
                          style="min-width: 1px;"
                          class="tabbrowser-arrowscrollbox">
<!--
 This is a hack to circumvent bug 472020, otherwise the tabs show up on the
 right of the newtab button.
-->
        <children includes="tab"/>
<!--
  This is to ensure anything extensions put here will go before the newtab
  button, necessary due to the previous hack.
-->
        <children/>
        <xul:toolbarbutton class="tabs-newtab-button toolbarbutton-1"
                           anonid="tabs-newtab-button"
                           command="cmd_newNavigatorTab"
                           onclick="checkForMiddleClick(this, event);"
                           tooltip="dynamic-shortcut-tooltip"/>
        <xul:hbox class="restore-tabs-button-wrapper"
                  anonid="restore-tabs-button-wrapper">
          <xul:toolbarbutton anonid="restore-tabs-button"
                             class="restore-tabs-button"
                             onclick="SessionStore.restoreLastSession();"/>
        </xul:hbox>

        <xul:spacer class="closing-tabs-spacer" anonid="closing-tabs-spacer"
                    style="width: 0;"/>
      </xul:arrowscrollbox>
    </content>

    <implementation implements="nsIDOMEventListener, nsIObserver">
      <constructor>
        <![CDATA[
          this.mTabClipWidth = Services.prefs.getIntPref("browser.tabs.tabClipWidth");

          let { restoreTabsButton } = this;
          restoreTabsButton.setAttribute("label", gTabBrowserBundle.GetStringFromName("tabs.restoreLastTabs"));

          var tab = this.firstChild;
          tab.label = gTabBrowserBundle.GetStringFromName("tabs.emptyTabTitle");
          tab.setAttribute("onerror", "this.removeAttribute('image');");

          window.addEventListener("resize", this);
          window.addEventListener("load", this);

          Services.prefs.addObserver("privacy.userContext", this);
          this.observe(null, "nsPref:changed", "privacy.userContext.enabled");

          this._setPositionalAttributes();
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
          Services.prefs.removeObserver("privacy.userContext", this);
        ]]>
      </destructor>

      <field name="tabbrowser" readonly="true">
        document.getElementById(this.getAttribute("tabbrowser"));
      </field>

      <field name="tabbox" readonly="true">
        this.tabbrowser.mTabBox;
      </field>

      <field name="contextMenu" readonly="true">
        document.getElementById("tabContextMenu");
      </field>

      <field name="mTabstripWidth">0</field>

      <field name="mTabstrip">
        document.getAnonymousElementByAttribute(this, "anonid", "arrowscrollbox");
      </field>

      <field name="_firstTab">null</field>
      <field name="_lastTab">null</field>
      <field name="_beforeSelectedTab">null</field>
      <field name="_beforeHoveredTab">null</field>
      <field name="_afterHoveredTab">null</field>
      <field name="_hoveredTab">null</field>
      <field name="restoreTabsButton">
        document.getAnonymousElementByAttribute(this, "anonid", "restore-tabs-button");
      </field>
      <field name="_restoreTabsButtonWrapperWidth">0</field>
      <field name="windowUtils">
        window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
      </field>

      <property name="restoreTabsButtonWrapperWidth" readonly="true">
        <getter>
          if (!this._restoreTabsButtonWrapperWidth) {
            this._restoreTabsButtonWrapperWidth = this.windowUtils
              .getBoundsWithoutFlushing(this.restoreTabsButton.parentNode)
              .width;
          }
          return this._restoreTabsButtonWrapperWidth;
        </getter>
      </property>

      <method name="updateSessionRestoreVisibility">
        <body><![CDATA[
          let {restoreTabsButton, restoreTabsButtonWrapperWidth, windowUtils, mTabstripWidth} = this;
          let restoreTabsButtonWrapper = restoreTabsButton.parentNode;

          if (!restoreTabsButtonWrapper.getAttribute("session-exists")) {
            restoreTabsButtonWrapper.removeAttribute("shown");
            return;
          }

          let newTabButton = document.getAnonymousElementByAttribute(
            this, "anonid", "tabs-newtab-button");

          // If there are no pinned tabs it will multiply by 0 and result in 0
          let pinnedTabsWidth = windowUtils.getBoundsWithoutFlushing(this.firstChild).width * this._lastNumPinned;

          let numUnpinnedTabs = this.childNodes.length - this._lastNumPinned;
          let unpinnedTabsWidth = windowUtils.getBoundsWithoutFlushing(this.lastChild).width * numUnpinnedTabs;

          let tabbarUsedSpace = pinnedTabsWidth + unpinnedTabsWidth
            + windowUtils.getBoundsWithoutFlushing(newTabButton).width;

          // Subtract the elements' widths from the available space to ensure
          // that showing the restoreTabsButton won't cause any overflow.
          if ((mTabstripWidth - tabbarUsedSpace) > restoreTabsButtonWrapperWidth) {
            restoreTabsButtonWrapper.setAttribute("shown", "true");
          } else {
            restoreTabsButtonWrapper.removeAttribute("shown");
          }
        ]]></body>
      </method>

      <method name="observe">
        <parameter name="aSubject"/>
        <parameter name="aTopic"/>
        <parameter name="aData"/>
        <body><![CDATA[
          switch (aTopic) {
            case "nsPref:changed":
              // This is has to deal with changes in
              // privacy.userContext.enabled and
              // privacy.userContext.longPressBehavior.
              let containersEnabled = Services.prefs.getBoolPref("privacy.userContext.enabled")
                                        && !PrivateBrowsingUtils.isWindowPrivate(window);

              // This pref won't change so often, so just recreate the menu.
              let longPressBehavior = Services.prefs.getIntPref("privacy.userContext.longPressBehavior");

              // If longPressBehavior pref is set to 0 (or any invalid value)
              // long press menu is disabled.
              if (containersEnabled && (longPressBehavior <= 0 || longPressBehavior > 2)) {
                containersEnabled = false;
              }

              const newTab = document.getElementById("new-tab-button");
              const newTab2 = document.getAnonymousElementByAttribute(this, "anonid", "tabs-newtab-button")

              for (let parent of [newTab, newTab2]) {
                if (!parent)
                  continue;

                gClickAndHoldListenersOnElement.remove(parent);
                parent.removeAttribute("type");
                if (parent.firstChild) {
                  parent.firstChild.remove();
                }

                if (containersEnabled) {
                  let popup = document.createElementNS(
                                "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
                                "menupopup");
                  if (parent.id) {
                    popup.id = "newtab-popup";
                  } else {
                    popup.setAttribute("anonid", "newtab-popup");
                  }
                  popup.className = "new-tab-popup";
                  popup.setAttribute("position", "after_end");
                  parent.appendChild(popup);

                  // longPressBehavior == 2 means that the menu is shown after X
                  // millisecs. Otherwise, with 1, the menu is open immediatelly.
                  if (longPressBehavior == 2) {
                    gClickAndHoldListenersOnElement.add(parent);
                  }

                  parent.setAttribute("type", "menu");
                }
              }

              break;
          }
        ]]></body>
      </method>

      <property name="_isCustomizing" readonly="true">
        <getter><![CDATA[
          return document.documentElement.getAttribute("customizing") == "true";
        ]]></getter>
      </property>

      <method name="_setPositionalAttributes">
        <body><![CDATA[
          let visibleTabs = this.tabbrowser.visibleTabs;

          if (!visibleTabs.length)
            return;

          let selectedIndex = visibleTabs.indexOf(this.selectedItem);

          if (this._beforeSelectedTab) {
            this._beforeSelectedTab.removeAttribute("beforeselected-visible");
          }

          if (this.selectedItem.closing || selectedIndex == 0) {
            this._beforeSelectedTab = null;
          } else {
            this._beforeSelectedTab = visibleTabs[selectedIndex - 1];
            this._beforeSelectedTab.setAttribute("beforeselected-visible",
                                                 "true");
          }

          if (this._firstTab)
            this._firstTab.removeAttribute("first-visible-tab");
          this._firstTab = visibleTabs[0];
          this._firstTab.setAttribute("first-visible-tab", "true");
          if (this._lastTab)
            this._lastTab.removeAttribute("last-visible-tab");
          this._lastTab = visibleTabs[visibleTabs.length - 1];
          this._lastTab.setAttribute("last-visible-tab", "true");

          let hoveredTab = this._hoveredTab;
          if (hoveredTab) {
            hoveredTab._mouseleave();
          }
          hoveredTab = this.querySelector("tab:hover");
          if (hoveredTab) {
            hoveredTab._mouseenter();
          }
        ]]></body>
      </method>

      <field name="_blockDblClick">false</field>

      <field name="_tabDropIndicator">
        document.getAnonymousElementByAttribute(this, "anonid", "tab-drop-indicator");
      </field>

      <field name="_dragOverDelay">350</field>
      <field name="_dragTime">0</field>

      <field name="_container" readonly="true"><![CDATA[
        this.parentNode && this.parentNode.localName == "toolbar" ? this.parentNode : this;
      ]]></field>

      <field name="_propagatedVisibilityOnce">false</field>

      <property name="visible"
                onget="return !this._container.collapsed;">
        <setter><![CDATA[
          if (val == this.visible &&
              this._propagatedVisibilityOnce)
            return val;

          this._container.collapsed = !val;

          this._propagateVisibility();
          this._propagatedVisibilityOnce = true;

          return val;
        ]]></setter>
      </property>

      <method name="_propagateVisibility">
        <body><![CDATA[
          let visible = this.visible;

          document.getElementById("menu_closeWindow").hidden = !visible;
          document.getElementById("menu_close").setAttribute("label",
            gTabBrowserBundle.GetStringFromName(visible ? "tabs.closeTab" : "tabs.close"));

          TabsInTitlebar.allowedBy("tabs-visible", visible);
        ]]></body>
      </method>

      <method name="updateVisibility">
        <body><![CDATA[
          if (this.childNodes.length - this.tabbrowser._removingTabs.length == 1)
            this.visible = window.toolbar.visible;
          else
            this.visible = true;
        ]]></body>
      </method>

      <field name="_closeButtonsUpdatePending">false</field>
      <method name="adjustTabstrip">
        <body><![CDATA[
          // If we're overflowing, tabs are at their minimum widths.
          if (this.getAttribute("overflow") == "true") {
            this.setAttribute("closebuttons", "activetab");
            return;
          }

          if (this._closeButtonsUpdatePending) {
            return;
          }
          this._closeButtonsUpdatePending = true;

          // Wait until after the next paint to get current layout data from
          // getBoundsWithoutFlushing.
          window.requestAnimationFrame(() => {
            window.requestAnimationFrame(() => {
              this._closeButtonsUpdatePending = false;

              // The scrollbox may have started overflowing since we checked
              // overflow earlier, so check again.
              if (this.getAttribute("overflow") == "true") {
                this.setAttribute("closebuttons", "activetab");
                return;
              }

              // Check if tab widths are below the threshold where we want to
              // remove close buttons from background tabs so that people don't
              // accidentally close tabs by selecting them.
              let rect = ele => {
                return window.QueryInterface(Ci.nsIInterfaceRequestor)
                             .getInterface(Ci.nsIDOMWindowUtils)
                             .getBoundsWithoutFlushing(ele);
              };
              let tab = this.tabbrowser.visibleTabs[this.tabbrowser._numPinnedTabs];
              if (tab && rect(tab).width <= this.mTabClipWidth) {
                this.setAttribute("closebuttons", "activetab");
              } else {
                this.removeAttribute("closebuttons");
              }
            });
          });
        ]]></body>
      </method>

      <method name="_handleTabSelect">
        <parameter name="aInstant"/>
        <body><![CDATA[
          if (this.getAttribute("overflow") == "true")
            this.mTabstrip.ensureElementIsVisible(this.selectedItem, aInstant);

          this.selectedItem._notselectedsinceload = false;
        ]]></body>
      </method>

      <field name="_closingTabsSpacer">
        document.getAnonymousElementByAttribute(this, "anonid", "closing-tabs-spacer");
      </field>

      <field name="_tabDefaultMaxWidth">NaN</field>
      <field name="_lastTabClosedByMouse">false</field>
      <field name="_hasTabTempMaxWidth">false</field>

      <!-- Try to keep the active tab's close button under the mouse cursor -->
      <method name="_lockTabSizing">
        <parameter name="aTab"/>
        <body><![CDATA[
          var tabs = this.tabbrowser.visibleTabs;
          if (!tabs.length)
            return;

          var isEndTab = (aTab._tPos > tabs[tabs.length - 1]._tPos);
          var tabWidth = aTab.getBoundingClientRect().width;

          if (!this._tabDefaultMaxWidth)
            this._tabDefaultMaxWidth =
              parseFloat(window.getComputedStyle(aTab).maxWidth);
          this._lastTabClosedByMouse = true;

          if (this.getAttribute("overflow") == "true") {
            // Don't need to do anything if we're in overflow mode and aren't scrolled
            // all the way to the right, or if we're closing the last tab.
            if (isEndTab || !this.mTabstrip._scrollButtonDown.disabled)
              return;

            // If the tab has an owner that will become the active tab, the owner will
            // be to the left of it, so we actually want the left tab to slide over.
            // This can't be done as easily in non-overflow mode, so we don't bother.
            if (aTab.owner)
              return;

            this._expandSpacerBy(tabWidth);
          } else { // non-overflow mode
            // Locking is neither in effect nor needed, so let tabs expand normally.
            if (isEndTab && !this._hasTabTempMaxWidth)
              return;

            let numPinned = this.tabbrowser._numPinnedTabs;
            // Force tabs to stay the same width, unless we're closing the last tab,
            // which case we need to let them expand just enough so that the overall
            // tabbar width is the same.
            if (isEndTab) {
              let numNormalTabs = tabs.length - numPinned;
              tabWidth = tabWidth * (numNormalTabs + 1) / numNormalTabs;
              if (tabWidth > this._tabDefaultMaxWidth)
                tabWidth = this._tabDefaultMaxWidth;
            }
            tabWidth += "px";
            for (let i = numPinned; i < tabs.length; i++) {
              let tab = tabs[i];
              tab.style.setProperty("max-width", tabWidth, "important");
              if (!isEndTab) { // keep tabs the same width
                tab.style.transition = "none";
                tab.clientTop; // flush styles to skip animation; see bug 649247
                tab.style.transition = "";
              }
            }
            this._hasTabTempMaxWidth = true;
            this.tabbrowser.addEventListener("mousemove", this);
            window.addEventListener("mouseout", this);
          }
        ]]></body>
      </method>

      <method name="_expandSpacerBy">
        <parameter name="pixels"/>
        <body><![CDATA[
          let spacer = this._closingTabsSpacer;
          spacer.style.width = parseFloat(spacer.style.width) + pixels + "px";
          this.setAttribute("using-closing-tabs-spacer", "true");
          this.tabbrowser.addEventListener("mousemove", this);
          window.addEventListener("mouseout", this);
        ]]></body>
      </method>

      <method name="_unlockTabSizing">
        <body><![CDATA[
          this.tabbrowser.removeEventListener("mousemove", this);
          window.removeEventListener("mouseout", this);

          if (this._hasTabTempMaxWidth) {
            this._hasTabTempMaxWidth = false;
            let tabs = this.tabbrowser.visibleTabs;
            for (let i = 0; i < tabs.length; i++)
              tabs[i].style.maxWidth = "";
          }

          if (this.hasAttribute("using-closing-tabs-spacer")) {
            this.removeAttribute("using-closing-tabs-spacer");
            this._closingTabsSpacer.style.width = 0;
          }
        ]]></body>
      </method>

      <field name="_lastNumPinned">0</field>
      <field name="_pinnedTabsLayoutCache">null</field>
      <method name="_positionPinnedTabs">
        <body><![CDATA[
          var numPinned = this.tabbrowser._numPinnedTabs;
          var doPosition = this.getAttribute("overflow") == "true" &&
                           numPinned > 0;

          if (doPosition) {
            this.setAttribute("positionpinnedtabs", "true");

            let layoutData = this._pinnedTabsLayoutCache;
            if (!layoutData) {
              let tabstrip = this.mTabstrip;
              layoutData = this._pinnedTabsLayoutCache = {
                pinnedTabWidth: this.childNodes[0].getBoundingClientRect().width,
                scrollButtonWidth: tabstrip._scrollButtonDown.getBoundingClientRect().width
              };
            }

            let width = 0;
            for (let i = numPinned - 1; i >= 0; i--) {
              let tab = this.childNodes[i];
              width += layoutData.pinnedTabWidth;
              tab.style.marginInlineStart = -(width + layoutData.scrollButtonWidth) + "px";
            }
            this.style.paddingInlineStart = width + "px";
          } else {
            this.removeAttribute("positionpinnedtabs");

            for (let i = 0; i < numPinned; i++) {
              let tab = this.childNodes[i];
              tab.style.marginInlineStart = "";
            }

            this.style.paddingInlineStart = "";
          }

          if (this._lastNumPinned != numPinned) {
            this._lastNumPinned = numPinned;
            this._handleTabSelect(true);
          }
        ]]></body>
      </method>

      <method name="_animateTabMove">
        <parameter name="event"/>
        <body><![CDATA[
          let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);

          if (this.getAttribute("movingtab") != "true") {
            this.setAttribute("movingtab", "true");
            this.parentNode.setAttribute("movingtab", "true");
            this.selectedItem = draggedTab;
          }

          if (!("animLastScreenX" in draggedTab._dragData))
            draggedTab._dragData.animLastScreenX = draggedTab._dragData.screenX;

          let screenX = event.screenX;
          if (screenX == draggedTab._dragData.animLastScreenX)
            return;

          draggedTab._dragData.animLastScreenX = screenX;

          let rtl = (window.getComputedStyle(this).direction == "rtl");
          let pinned = draggedTab.pinned;
          let numPinned = this.tabbrowser._numPinnedTabs;
          let tabs = this.tabbrowser.visibleTabs
                                    .slice(pinned ? 0 : numPinned,
                                           pinned ? numPinned : undefined);
          if (rtl)
            tabs.reverse();
          let tabWidth = draggedTab.getBoundingClientRect().width;
          draggedTab._dragData.tabWidth = tabWidth;

          // Move the dragged tab based on the mouse position.

          let leftTab = tabs[0];
          let rightTab = tabs[tabs.length - 1];
          let tabScreenX = draggedTab.boxObject.screenX;
          let translateX = screenX - draggedTab._dragData.screenX;
          if (!pinned)
            translateX += this.mTabstrip._scrollbox.scrollLeft - draggedTab._dragData.scrollX;
          let leftBound = leftTab.boxObject.screenX - tabScreenX;
          let rightBound = (rightTab.boxObject.screenX + rightTab.boxObject.width) -
                           (tabScreenX + tabWidth);
          translateX = Math.max(translateX, leftBound);
          translateX = Math.min(translateX, rightBound);
          draggedTab.style.transform = "translateX(" + translateX + "px)";
          draggedTab._dragData.translateX = translateX;

          // Determine what tab we're dragging over.
          // * Point of reference is the center of the dragged tab. If that
          //   point touches a background tab, the dragged tab would take that
          //   tab's position when dropped.
          // * We're doing a binary search in order to reduce the amount of
          //   tabs we need to check.

          let tabCenter = tabScreenX + translateX + tabWidth / 2;
          let newIndex = -1;
          let oldIndex = "animDropIndex" in draggedTab._dragData ?
                         draggedTab._dragData.animDropIndex : draggedTab._tPos;
          let low = 0;
          let high = tabs.length - 1;
          while (low <= high) {
            let mid = Math.floor((low + high) / 2);
            if (tabs[mid] == draggedTab &&
                ++mid > high)
              break;
            let boxObject = tabs[mid].boxObject;
            screenX = boxObject.screenX + getTabShift(tabs[mid], oldIndex);
            if (screenX > tabCenter) {
              high = mid - 1;
            } else if (screenX + boxObject.width < tabCenter) {
              low = mid + 1;
            } else {
              newIndex = tabs[mid]._tPos;
              break;
            }
          }
          if (newIndex >= oldIndex)
            newIndex++;
          if (newIndex < 0 || newIndex == oldIndex)
            return;
          draggedTab._dragData.animDropIndex = newIndex;

          // Shift background tabs to leave a gap where the dragged tab
          // would currently be dropped.

          for (let tab of tabs) {
            if (tab != draggedTab) {
              let shift = getTabShift(tab, newIndex);
              tab.style.transform = shift ? "translateX(" + shift + "px)" : "";
            }
          }

          function getTabShift(tab, dropIndex) {
            if (tab._tPos < draggedTab._tPos && tab._tPos >= dropIndex)
              return rtl ? -tabWidth : tabWidth;
            if (tab._tPos > draggedTab._tPos && tab._tPos < dropIndex)
              return rtl ? tabWidth : -tabWidth;
            return 0;
          }
        ]]></body>
      </method>

      <method name="_finishAnimateTabMove">
        <body><![CDATA[
          if (this.getAttribute("movingtab") != "true")
            return;

          for (let tab of this.tabbrowser.visibleTabs)
            tab.style.transform = "";

          this.removeAttribute("movingtab");
          this.parentNode.removeAttribute("movingtab");

          this._handleTabSelect();
        ]]></body>
      </method>

      <method name="handleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          switch (aEvent.type) {
            case "load":
              this.updateVisibility();
              TabsInTitlebar.init();
              break;
            case "resize":
              if (aEvent.target != window)
                break;

              TabsInTitlebar.updateAppearance();

              var width = this.mTabstrip.boxObject.width;
              if (width != this.mTabstripWidth) {
                this.adjustTabstrip();
                this._handleTabSelect(true);
                this.mTabstripWidth = width;
                this.updateSessionRestoreVisibility();
              }
              break;
            case "mouseout":
              // If the "related target" (the node to which the pointer went) is not
              // a child of the current document, the mouse just left the window.
              let relatedTarget = aEvent.relatedTarget;
              if (relatedTarget && relatedTarget.ownerDocument == document)
                break;
            case "mousemove":
              if (document.getElementById("tabContextMenu").state != "open")
                this._unlockTabSizing();
              break;
          }
        ]]></body>
      </method>

      <field name="_animateElement">
        this.mTabstrip._scrollButtonDown;
      </field>

      <method name="_notifyBackgroundTab">
        <parameter name="aTab"/>
        <body><![CDATA[
          if (aTab.pinned || aTab.hidden)
            return;

          var scrollRect = this.mTabstrip.scrollClientRect;
          var tab = aTab.getBoundingClientRect();

          // DOMRect left/right properties are immutable.
          tab = {left: tab.left, right: tab.right};

          // Is the new tab already completely visible?
          if (scrollRect.left <= tab.left && tab.right <= scrollRect.right)
            return;

          if (this.mTabstrip.smoothScroll) {
            let selected = !this.selectedItem.pinned &&
                           this.selectedItem.getBoundingClientRect();

            // Can we make both the new tab and the selected tab completely visible?
            if (!selected ||
                Math.max(tab.right - selected.left, selected.right - tab.left) <=
                  scrollRect.width) {
              this.mTabstrip.ensureElementIsVisible(aTab);
              return;
            }

            this.mTabstrip.scrollByPixels(this.mTabstrip._isRTLScrollbox ?
                                          selected.right - scrollRect.right :
                                          selected.left - scrollRect.left);
          }

          if (!this._animateElement.hasAttribute("highlight")) {
            this._animateElement.setAttribute("highlight", "true");
            setTimeout(function(ele) {
              ele.removeAttribute("highlight");
            }, 150, this._animateElement);
          }
        ]]></body>
      </method>

      <method name="_getDragTargetTab">
        <parameter name="event"/>
        <parameter name="isLink"/>
        <body><![CDATA[
          let tab = event.target.localName == "tab" ? event.target : null;
          if (tab && isLink) {
            let boxObject = tab.boxObject;
            if (event.screenX < boxObject.screenX + boxObject.width * .25 ||
                event.screenX > boxObject.screenX + boxObject.width * .75)
              return null;
          }
          return tab;
        ]]></body>
      </method>

      <method name="_getDropIndex">
        <parameter name="event"/>
        <parameter name="isLink"/>
        <body><![CDATA[
          var tabs = this.childNodes;
          var tab = this._getDragTargetTab(event, isLink);
          if (window.getComputedStyle(this).direction == "ltr") {
            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
              if (event.screenX < tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
                return i;
          } else {
            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
              if (event.screenX > tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
                return i;
          }
          return tabs.length;
        ]]></body>
      </method>

      <method name="_getDropEffectForTabDrag">
        <parameter name="event"/>
        <body><![CDATA[
          var dt = event.dataTransfer;
          if (dt.mozItemCount == 1) {
            var types = dt.mozTypesAt(0);
            // tabs are always added as the first type
            if (types[0] == TAB_DROP_TYPE) {
              let sourceNode = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
              if (sourceNode instanceof XULElement &&
                  sourceNode.localName == "tab" &&
                  sourceNode.ownerGlobal.isChromeWindow &&
                  sourceNode.ownerDocument.documentElement.getAttribute("windowtype") == "navigator:browser" &&
                  sourceNode.ownerGlobal.gBrowser.tabContainer == sourceNode.parentNode) {
                // Do not allow transfering a private tab to a non-private window
                // and vice versa.
                if (PrivateBrowsingUtils.isWindowPrivate(window) !=
                    PrivateBrowsingUtils.isWindowPrivate(sourceNode.ownerGlobal))
                  return "none";

                if (window.gMultiProcessBrowser !=
                    sourceNode.ownerGlobal.gMultiProcessBrowser)
                  return "none";

                return dt.dropEffect == "copy" ? "copy" : "move";
              }
            }
          }

          if (browserDragAndDrop.canDropLink(event)) {
            return "link";
          }
          return "none";
        ]]></body>
      </method>

      <method name="_handleNewTab">
        <parameter name="tab"/>
        <body><![CDATA[
          if (tab.parentNode != this)
            return;
          tab._fullyOpen = true;
          this.tabbrowser.tabAnimationsInProgress--;

          this.adjustTabstrip();

          if (tab.getAttribute("selected") == "true") {
            this._handleTabSelect();
          } else if (!tab.hasAttribute("skipbackgroundnotify")) {
            this._notifyBackgroundTab(tab);
          }

          // XXXmano: this is a temporary workaround for bug 345399
          // We need to manually update the scroll buttons disabled state
          // if a tab was inserted to the overflow area or removed from it
          // without any scrolling and when the tabbar has already
          // overflowed.
          this.mTabstrip._updateScrollButtonsDisabledState();

          // Preload the next about:newtab if there isn't one already.
          this.tabbrowser._createPreloadBrowser();
        ]]></body>
      </method>

      <method name="_canAdvanceToTab">
        <parameter name="aTab"/>
        <body>
        <![CDATA[
          return !aTab.closing;
        ]]>
        </body>
      </method>

      <method name="getRelatedElement">
        <parameter name="aTab"/>
        <body>
        <![CDATA[
          if (!aTab)
            return null;
          // If the tab's browser is lazy, we need to `_insertBrowser` in order
          // to have a linkedPanel.  This will also serve to bind the browser
          // and make it ready to use when the tab is selected.
          this.tabbrowser._insertBrowser(aTab);
          return document.getElementById(aTab.linkedPanel);
        ]]>
        </body>
      </method>
    </implementation>

    <handlers>
      <handler event="TabSelect" action="this._handleTabSelect();"/>

      <handler event="transitionend"><![CDATA[
        if (event.propertyName != "max-width")
          return;

        var tab = event.target;

        if (tab.getAttribute("fadein") == "true") {
          if (tab._fullyOpen)
            this.adjustTabstrip();
          else
            this._handleNewTab(tab);
        } else if (tab.closing) {
          this.tabbrowser._endRemoveTab(tab);
        }
      ]]></handler>

      <handler event="dblclick"><![CDATA[
        // When the tabbar has an unified appearance with the titlebar
        // and menubar, a double-click in it should have the same behavior
        // as double-clicking the titlebar
        if (TabsInTitlebar.enabled || this.parentNode._dragBindingAlive)
          return;

        if (event.button != 0 ||
            event.originalTarget.localName != "box")
          return;

        // See hack note in the tabbrowser-close-tab-button binding
        if (!this._blockDblClick)
          BrowserOpenTab();

        event.preventDefault();
      ]]></handler>

      <handler event="click" button="0" phase="capturing"><![CDATA[
        /* Catches extra clicks meant for the in-tab close button.
         * Placed here to avoid leaking (a temporary handler added from the
         * in-tab close button binding would close over the tab and leak it
         * until the handler itself was removed). (bug 897751)
         *
         * The only sequence in which a second click event (i.e. dblclik)
         * can be dispatched on an in-tab close button is when it is shown
         * after the first click (i.e. the first click event was dispatched
         * on the tab). This happens when we show the close button only on
         * the active tab. (bug 352021)
         * The only sequence in which a third click event can be dispatched
         * on an in-tab close button is when the tab was opened with a
         * double click on the tabbar. (bug 378344)
         * In both cases, it is most likely that the close button area has
         * been accidentally clicked, therefore we do not close the tab.
         *
         * We don't want to ignore processing of more than one click event,
         * though, since the user might actually be repeatedly clicking to
         * close many tabs at once.
         */
        let target = event.originalTarget;
        if (target.classList.contains("tab-close-button")) {
          // We preemptively set this to allow the closing-multiple-tabs-
          // in-a-row case.
          if (this._blockDblClick) {
            target._ignoredCloseButtonClicks = true;
          } else if (event.detail > 1 && !target._ignoredCloseButtonClicks) {
            target._ignoredCloseButtonClicks = true;
            event.stopPropagation();
            return;
          } else {
            // Reset the "ignored click" flag
            target._ignoredCloseButtonClicks = false;
          }
        }

        /* Protects from close-tab-button errant doubleclick:
         * Since we're removing the event target, if the user
         * double-clicks the button, the dblclick event will be dispatched
         * with the tabbar as its event target (and explicit/originalTarget),
         * which treats that as a mouse gesture for opening a new tab.
         * In this context, we're manually blocking the dblclick event
         * (see tabbrowser-close-tab-button dblclick handler).
         */
        if (this._blockDblClick) {
          if (!("_clickedTabBarOnce" in this)) {
            this._clickedTabBarOnce = true;
            return;
          }
          delete this._clickedTabBarOnce;
          this._blockDblClick = false;
        }
      ]]></handler>

      <handler event="click"><![CDATA[
        if (event.button != 1)
          return;

        if (event.target.localName == "tab") {
          this.tabbrowser.removeTab(event.target, {animate: true,
                byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE});
        } else if (event.originalTarget.localName == "box") {
          // The user middleclicked an open space on the tabstrip. This could
          // be because they intend to open a new tab, but it could also be
          // because they just removed a tab and they now middleclicked on the
          // resulting space while that tab is closing. In that case, we don't
          // want to open a tab. So if we're removing one or more tabs, and
          // the tab click is before the end of the last visible tab, we do
          // nothing.
          if (this.tabbrowser._removingTabs.length) {
            let visibleTabs = this.tabbrowser.visibleTabs;
            let ltr = (window.getComputedStyle(this).direction == "ltr");
            let lastTab = visibleTabs[visibleTabs.length - 1];
            let endOfTab = lastTab.getBoundingClientRect()[ltr ? "right" : "left"];
            if ((ltr && event.clientX > endOfTab) ||
                (!ltr && event.clientX < endOfTab)) {
              BrowserOpenTab();
            }
          } else {
            BrowserOpenTab();
          }
        } else {
          return;
        }

        event.stopPropagation();
      ]]></handler>

      <handler event="keydown" group="system"><![CDATA[
        if (event.altKey || event.shiftKey)
          return;

        let wrongModifiers;
        if (AppConstants.platform == "macosx") {
          wrongModifiers = !event.metaKey;
        } else {
          wrongModifiers = !event.ctrlKey || event.metaKey;
        }

        if (wrongModifiers)
          return;

        // Don't check if the event was already consumed because tab navigation
        // should work always for better user experience.

        switch (event.keyCode) {
          case KeyEvent.DOM_VK_UP:
            this.tabbrowser.moveTabBackward();
            break;
          case KeyEvent.DOM_VK_DOWN:
            this.tabbrowser.moveTabForward();
            break;
          case KeyEvent.DOM_VK_RIGHT:
          case KeyEvent.DOM_VK_LEFT:
            this.tabbrowser.moveTabOver(event);
            break;
          case KeyEvent.DOM_VK_HOME:
            this.tabbrowser.moveTabToStart();
            break;
          case KeyEvent.DOM_VK_END:
            this.tabbrowser.moveTabToEnd();
            break;
          default:
            // Consume the keydown event for the above keyboard
            // shortcuts only.
            return;
        }
        event.preventDefault();
      ]]></handler>

      <handler event="dragstart"><![CDATA[
        var tab = this._getDragTargetTab(event, false);
        if (!tab || this._isCustomizing)
          return;

        let dt = event.dataTransfer;
        dt.mozSetDataAt(TAB_DROP_TYPE, tab, 0);
        let browser = tab.linkedBrowser;

        // We must not set text/x-moz-url or text/plain data here,
        // otherwise trying to deatch the tab by dropping it on the desktop
        // may result in an "internet shortcut"
        dt.mozSetDataAt("text/x-moz-text-internal", browser.currentURI.spec, 0);

        // Set the cursor to an arrow during tab drags.
        dt.mozCursor = "default";

        // Set the tab as the source of the drag, which ensures we have a stable
        // node to deliver the `dragend` event.  See bug 1345473.
        dt.addElement(tab);

        // Create a canvas to which we capture the current tab.
        // Until canvas is HiDPI-aware (bug 780362), we need to scale the desired
        // canvas size (in CSS pixels) to the window's backing resolution in order
        // to get a full-resolution drag image for use on HiDPI displays.
        let windowUtils = window.getInterface(Ci.nsIDOMWindowUtils);
        let scale = windowUtils.screenPixelsPerCSSPixel / windowUtils.fullZoom;
        let canvas = this._dndCanvas;
        if (!canvas) {
          this._dndCanvas = canvas =
            document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
          canvas.style.width = "100%";
          canvas.style.height = "100%";
          canvas.mozOpaque = true;
        }

        canvas.width = 160 * scale;
        canvas.height = 90 * scale;
        let toDrag = canvas;
        let dragImageOffset = -16;
        if (gMultiProcessBrowser) {
          var context = canvas.getContext("2d");
          context.fillStyle = "white";
          context.fillRect(0, 0, canvas.width, canvas.height);

          let captureListener;
          let platform = AppConstants.platform;
          // On Windows and Mac we can update the drag image during a drag
          // using updateDragImage. On Linux, we can use a panel.
          if (platform == "win" || platform == "macosx") {
            captureListener = function() {
              dt.updateDragImage(canvas, dragImageOffset, dragImageOffset);
            }
          } else {
            // Create a panel to use it in setDragImage
            // which will tell xul to render a panel that follows
            // the pointer while a dnd session is on.
            if (!this._dndPanel) {
              this._dndCanvas = canvas;
              this._dndPanel = document.createElement("panel");
              this._dndPanel.className = "dragfeedback-tab";
              this._dndPanel.setAttribute("type", "drag");
              let wrapper = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
              wrapper.style.width = "160px";
              wrapper.style.height = "90px";
              wrapper.appendChild(canvas);
              this._dndPanel.appendChild(wrapper);
              document.documentElement.appendChild(this._dndPanel);
            }
            toDrag = this._dndPanel;
          }
          // PageThumb is async with e10s but that's fine
          // since we can update the image during the dnd.
          PageThumbs.captureToCanvas(browser, canvas, captureListener);
        } else {
          // For the non e10s case we can just use PageThumbs
          // sync, so let's use the canvas for setDragImage.
          PageThumbs.captureToCanvas(browser, canvas);
          dragImageOffset = dragImageOffset * scale;
        }
        dt.setDragImage(toDrag, dragImageOffset, dragImageOffset);

        // _dragData.offsetX/Y give the coordinates that the mouse should be
        // positioned relative to the corner of the new window created upon
        // dragend such that the mouse appears to have the same position
        // relative to the corner of the dragged tab.
        function clientX(ele) {
          return ele.getBoundingClientRect().left;
        }
        let tabOffsetX = clientX(tab) - clientX(this);
        tab._dragData = {
          offsetX: event.screenX - window.screenX - tabOffsetX,
          offsetY: event.screenY - window.screenY,
          scrollX: this.mTabstrip._scrollbox.scrollLeft,
          screenX: event.screenX
        };

        event.stopPropagation();
      ]]></handler>

      <handler event="dragover"><![CDATA[
        var effects = this._getDropEffectForTabDrag(event);

        var ind = this._tabDropIndicator;
        if (effects == "" || effects == "none") {
          ind.collapsed = true;
          return;
        }
        event.preventDefault();
        event.stopPropagation();

        var tabStrip = this.mTabstrip;
        var ltr = (window.getComputedStyle(this).direction == "ltr");

        // autoscroll the tab strip if we drag over the scroll
        // buttons, even if we aren't dragging a tab, but then
        // return to avoid drawing the drop indicator
        var pixelsToScroll = 0;
        if (this.getAttribute("overflow") == "true") {
          var targetAnonid = event.originalTarget.getAttribute("anonid");
          switch (targetAnonid) {
            case "scrollbutton-up":
              pixelsToScroll = tabStrip.scrollIncrement * -1;
              break;
            case "scrollbutton-down":
              pixelsToScroll = tabStrip.scrollIncrement;
              break;
          }
          if (pixelsToScroll)
            tabStrip.scrollByPixels((ltr ? 1 : -1) * pixelsToScroll, true);
        }

        if (effects == "move" &&
            this == event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0).parentNode) {
          ind.collapsed = true;
          this._animateTabMove(event);
          return;
        }

        this._finishAnimateTabMove();

        if (effects == "link") {
          let tab = this._getDragTargetTab(event, true);
          if (tab) {
            if (!this._dragTime)
              this._dragTime = Date.now();
            if (Date.now() >= this._dragTime + this._dragOverDelay)
              this.selectedItem = tab;
            ind.collapsed = true;
            return;
          }
        }

        var rect = tabStrip.getBoundingClientRect();
        var newMargin;
        if (pixelsToScroll) {
          // if we are scrolling, put the drop indicator at the edge
          // so that it doesn't jump while scrolling
          let scrollRect = tabStrip.scrollClientRect;
          let minMargin = scrollRect.left - rect.left;
          let maxMargin = Math.min(minMargin + scrollRect.width,
                                   scrollRect.right);
          if (!ltr)
            [minMargin, maxMargin] = [this.clientWidth - maxMargin,
                                      this.clientWidth - minMargin];
          newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;
        } else {
          let newIndex = this._getDropIndex(event, effects == "link");
          if (newIndex == this.childNodes.length) {
            let tabRect = this.childNodes[newIndex - 1].getBoundingClientRect();
            if (ltr)
              newMargin = tabRect.right - rect.left;
            else
              newMargin = rect.right - tabRect.left;
          } else {
            let tabRect = this.childNodes[newIndex].getBoundingClientRect();
            if (ltr)
              newMargin = tabRect.left - rect.left;
            else
              newMargin = rect.right - tabRect.right;
          }
        }

        ind.collapsed = false;

        newMargin += ind.clientWidth / 2;
        if (!ltr)
          newMargin *= -1;

        ind.style.transform = "translate(" + Math.round(newMargin) + "px)";
        ind.style.marginInlineStart = (-ind.clientWidth) + "px";
      ]]></handler>

      <handler event="drop"><![CDATA[
        var dt = event.dataTransfer;
        var dropEffect = dt.dropEffect;
        var draggedTab;
        if (dt.mozTypesAt(0)[0] == TAB_DROP_TYPE) { // tab copy or move
          draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
          // not our drop then
          if (!draggedTab)
            return;
        }

        this._tabDropIndicator.collapsed = true;
        event.stopPropagation();
        if (draggedTab && dropEffect == "copy") {
          // copy the dropped tab (wherever it's from)
          let newIndex = this._getDropIndex(event, false);
          let newTab = this.tabbrowser.duplicateTab(draggedTab);
          this.tabbrowser.moveTabTo(newTab, newIndex);
          if (draggedTab.parentNode != this || event.shiftKey)
            this.selectedItem = newTab;
        } else if (draggedTab && draggedTab.parentNode == this) {
          let oldTranslateX = draggedTab._dragData.translateX;
          let tabWidth = draggedTab._dragData.tabWidth;
          let translateOffset = oldTranslateX % tabWidth;
          let newTranslateX = oldTranslateX - translateOffset;
          if (oldTranslateX > 0 && translateOffset > tabWidth / 2) {
            newTranslateX += tabWidth;
          } else if (oldTranslateX < 0 && -translateOffset > tabWidth / 2) {
            newTranslateX -= tabWidth;
          }

          let dropIndex = "animDropIndex" in draggedTab._dragData &&
                          draggedTab._dragData.animDropIndex;
          if (dropIndex && dropIndex > draggedTab._tPos)
            dropIndex--;

          let animate = this.tabbrowser.animationsEnabled;
          if (oldTranslateX && oldTranslateX != newTranslateX && animate) {
            draggedTab.setAttribute("tabdrop-samewindow", "true");
            draggedTab.style.transform = "translateX(" + newTranslateX + "px)";
            let onTransitionEnd = transitionendEvent => {
              if (transitionendEvent.propertyName != "transform" ||
                  transitionendEvent.originalTarget != draggedTab) {
                return;
              }
              draggedTab.removeEventListener("transitionend", onTransitionEnd);

              draggedTab.removeAttribute("tabdrop-samewindow");

              this._finishAnimateTabMove();
              if (dropIndex !== false)
                this.tabbrowser.moveTabTo(draggedTab, dropIndex);
            }
            draggedTab.addEventListener("transitionend", onTransitionEnd);
          } else {
            this._finishAnimateTabMove();
            if (dropIndex !== false)
              this.tabbrowser.moveTabTo(draggedTab, dropIndex);
          }
        } else if (draggedTab) {
          let newIndex = this._getDropIndex(event, false);
          this.tabbrowser.adoptTab(draggedTab, newIndex, true);
        } else {
          // Pass true to disallow dropping javascript: or data: urls
          let links;
          try {
            links = browserDragAndDrop.dropLinks(event, true);
          } catch (ex) {}

          if (!links || links.length === 0)
            return;

          let inBackground = Services.prefs.getBoolPref("browser.tabs.loadInBackground");

          if (event.shiftKey)
            inBackground = !inBackground;

          let targetTab = this._getDragTargetTab(event, true);
          let userContextId = this.selectedItem.getAttribute("usercontextid");
          let replace = !!targetTab;
          let newIndex = this._getDropIndex(event, true);
          let urls = links.map(link => link.url);

          let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(event);
          this.tabbrowser.loadTabs(urls, {
            inBackground,
            replace,
            allowThirdPartyFixup: true,
            targetTab,
            newIndex,
            userContextId,
            triggeringPrincipal,
          });
        }

        if (draggedTab) {
          delete draggedTab._dragData;
        }
      ]]></handler>

      <handler event="dragend"><![CDATA[
        var dt = event.dataTransfer;
        var draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);

        // Prevent this code from running if a tabdrop animation is
        // running since calling _finishAnimateTabMove would clear
        // any CSS transition that is running.
        if (draggedTab.hasAttribute("tabdrop-samewindow"))
          return;

        this._finishAnimateTabMove();

        if (dt.mozUserCancelled || dt.dropEffect != "none" || this._isCustomizing) {
          delete draggedTab._dragData;
          return;
        }

        // Disable detach within the browser toolbox
        var eX = event.screenX;
        var eY = event.screenY;
        var wX = window.screenX;
        // check if the drop point is horizontally within the window
        if (eX > wX && eX < (wX + window.outerWidth)) {
          let bo = this.mTabstrip.boxObject;
          // also avoid detaching if the the tab was dropped too close to
          // the tabbar (half a tab)
          let endScreenY = bo.screenY + 1.5 * bo.height;
          if (eY < endScreenY && eY > window.screenY)
            return;
        }

        // screen.availLeft et. al. only check the screen that this window is on,
        // but we want to look at the screen the tab is being dropped onto.
        var screen = Cc["@mozilla.org/gfx/screenmanager;1"]
                       .getService(Ci.nsIScreenManager)
                       .screenForRect(eX, eY, 1, 1);
        var fullX = {}, fullY = {}, fullWidth = {}, fullHeight = {};
        var availX = {}, availY = {}, availWidth = {}, availHeight = {};
        // get full screen rect and available rect, both in desktop pix
        screen.GetRectDisplayPix(fullX, fullY, fullWidth, fullHeight);
        screen.GetAvailRectDisplayPix(availX, availY, availWidth, availHeight);

        // scale factor to convert desktop pixels to CSS px
        var scaleFactor =
          screen.contentsScaleFactor / screen.defaultCSSScaleFactor;
        // synchronize CSS-px top-left coordinates with the screen's desktop-px
        // coordinates, to ensure uniqueness across multiple screens
        // (compare the equivalent adjustments in nsGlobalWindow::GetScreenXY()
        // and related methods)
        availX.value = (availX.value - fullX.value) * scaleFactor + fullX.value;
        availY.value = (availY.value - fullY.value) * scaleFactor + fullY.value;
        availWidth.value *= scaleFactor;
        availHeight.value *= scaleFactor;

        // ensure new window entirely within screen
        var winWidth = Math.min(window.outerWidth, availWidth.value);
        var winHeight = Math.min(window.outerHeight, availHeight.value);
        var left = Math.min(Math.max(eX - draggedTab._dragData.offsetX, availX.value),
                            availX.value + availWidth.value - winWidth);
        var top = Math.min(Math.max(eY - draggedTab._dragData.offsetY, availY.value),
                           availY.value + availHeight.value - winHeight);

        delete draggedTab._dragData;

        if (this.tabbrowser.tabs.length == 1) {
          // resize _before_ move to ensure the window fits the new screen.  if
          // the window is too large for its screen, the window manager may do
          // automatic repositioning.
          window.resizeTo(winWidth, winHeight);
          window.moveTo(left, top);
          window.focus();
        } else {
          let props = { screenX: left, screenY: top, suppressanimation: 1 };
          if (AppConstants.platform != "win") {
            props.outerWidth = winWidth;
            props.outerHeight = winHeight;
          }
          this.tabbrowser.replaceTabWithWindow(draggedTab, props);
        }
        event.stopPropagation();
      ]]></handler>

      <handler event="dragexit"><![CDATA[
        this._dragTime = 0;

        // This does not work at all (see bug 458613)
        var target = event.relatedTarget;
        while (target && target != this)
          target = target.parentNode;
        if (target)
          return;

        this._tabDropIndicator.collapsed = true;
        event.stopPropagation();
      ]]></handler>
    </handlers>
  </binding>

  <!-- close-tab-button binding
       This binding relies on the structure of the tabbrowser binding.
       Therefore it should only be used as a child of the tab or the tabs
       element (in both cases, when they are anonymous nodes of <tabbrowser>).
  -->
  <binding id="tabbrowser-close-tab-button"
           extends="chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton-image">
    <handlers>
      <handler event="click" button="0"><![CDATA[
        var bindingParent = document.getBindingParent(this);
        var tabContainer = bindingParent.parentNode;
        tabContainer.tabbrowser.removeTab(bindingParent, {animate: true,
                byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE});
        // This enables double-click protection for the tab container
        // (see tabbrowser-tabs 'click' handler).
        tabContainer._blockDblClick = true;
      ]]></handler>

      <handler event="dblclick" button="0" phase="capturing">
        // for the one-close-button case
        event.stopPropagation();
      </handler>

      <handler event="dragstart">
        event.stopPropagation();
      </handler>
    </handlers>
  </binding>

  <binding id="tabbrowser-tab" display="xul:hbox"
           extends="chrome://global/content/bindings/tabbox.xml#tab">
    <resources>
      <stylesheet src="chrome://browser/content/tabbrowser.css"/>
    </resources>

    <content context="tabContextMenu">
      <xul:stack class="tab-stack" flex="1">
        <xul:vbox xbl:inherits="selected=visuallyselected,fadein"
                  class="tab-background">
          <xul:hbox xbl:inherits="selected=visuallyselected"
                    class="tab-line"/>
          <xul:spacer flex="1"/>
          <xul:hbox class="tab-bottom-line"/>
        </xul:vbox>
        <xul:hbox xbl:inherits="pinned,bursting,notselectedsinceload"
                  anonid="tab-loading-burst"
                  class="tab-loading-burst"/>
        <xul:hbox xbl:inherits="pinned,selected=visuallyselected,titlechanged,attention"
                  class="tab-content" align="center">
          <xul:hbox xbl:inherits="fadein,pinned,busy,progress,selected=visuallyselected"
                    anonid="tab-throbber"
                    class="tab-throbber"
                    layer="true"/>
          <xul:image xbl:inherits="src=image,triggeringprincipal=iconloadingprincipal,requestcontextid,fadein,pinned,selected=visuallyselected,busy,crashed,sharing"
                     anonid="tab-icon-image"
                     class="tab-icon-image"
                     validate="never"
                     role="presentation"/>
          <xul:image xbl:inherits="sharing,selected=visuallyselected,pinned"
                     anonid="sharing-icon"
                     class="tab-sharing-icon-overlay"
                     role="presentation"/>
          <xul:image xbl:inherits="crashed,busy,soundplaying,soundplaying-scheduledremoval,pinned,muted,blocked,selected=visuallyselected,activemedia-blocked"
                     anonid="overlay-icon"
                     class="tab-icon-overlay"
                     role="presentation"/>
          <xul:hbox class="tab-label-container"
                    xbl:inherits="pinned,selected=visuallyselected,labeldirection"
                    onoverflow="this.setAttribute('textoverflow', 'true');"
                    onunderflow="this.removeAttribute('textoverflow');"
                    flex="1">
            <xul:label class="tab-text tab-label"
                       xbl:inherits="xbl:text=label,accesskey,fadein,pinned,selected=visuallyselected,attention"
                       role="presentation"/>
          </xul:hbox>
          <xul:image xbl:inherits="soundplaying,soundplaying-scheduledremoval,pinned,muted,blocked,selected=visuallyselected,activemedia-blocked"
                     anonid="soundplaying-icon"
                     class="tab-icon-sound"
                     role="presentation"/>
          <xul:toolbarbutton anonid="close-button"
                             xbl:inherits="fadein,pinned,selected=visuallyselected"
                             class="tab-close-button close-icon"/>
        </xul:hbox>
      </xul:stack>
    </content>

    <implementation>
      <constructor><![CDATA[
        if (!("_lastAccessed" in this)) {
          this.updateLastAccessed();
        }
      ]]></constructor>

      <property name="_visuallySelected">
        <setter>
          <![CDATA[
          if (val)
            this.setAttribute("visuallyselected", "true");
          else
            this.removeAttribute("visuallyselected");
          this.parentNode.tabbrowser._tabAttrModified(this, ["visuallyselected"]);

          this._setPositionAttributes(val);

          return val;
          ]]>
        </setter>
      </property>

      <property name="_selected">
        <setter>
          <![CDATA[
          // in e10s we want to only pseudo-select a tab before its rendering is done, so that
          // the rest of the system knows that the tab is selected, but we don't want to update its
          // visual status to selected until after we receive confirmation that its content has painted.
          if (val)
            this.setAttribute("selected", "true");
          else
            this.removeAttribute("selected");

          // If we're non-e10s we should update the visual selection as well at the same time,
          // *or* if we're e10s and the visually selected tab isn't changing, in which case the
          // tab switcher code won't run and update anything else (like the before- and after-
          // selected attributes).
          if (!gMultiProcessBrowser || (val && this.hasAttribute("visuallyselected"))) {
            this._visuallySelected = val;
          }

          return val;
        ]]>
        </setter>
      </property>

      <property name="pinned" readonly="true">
        <getter>
          return this.getAttribute("pinned") == "true";
        </getter>
      </property>
      <property name="hidden" readonly="true">
        <getter>
          return this.getAttribute("hidden") == "true";
        </getter>
      </property>
      <property name="muted" readonly="true">
        <getter>
          return this.getAttribute("muted") == "true";
        </getter>
      </property>
      <!--
      Describes how the tab ended up in this mute state. May be any of:

       - undefined: The tabs mute state has never changed.
       - null: The mute state was last changed through the UI.
       - Any string: The ID was changed through an extension API. The string
                     must be the ID of the extension which changed it.
      -->
      <field name="muteReason">undefined</field>

      <property name="userContextId" readonly="true">
        <getter>
          return this.hasAttribute("usercontextid")
                   ? parseInt(this.getAttribute("usercontextid"))
                   : 0;
        </getter>
      </property>

      <property name="soundPlaying" readonly="true">
        <getter>
          return this.getAttribute("soundplaying") == "true";
        </getter>
      </property>

      <property name="activeMediaBlocked" readonly="true">
        <getter>
          return this.getAttribute("activemedia-blocked") == "true";
        </getter>
      </property>

      <property name="lastAccessed">
        <getter>
          return this._lastAccessed == Infinity ? Date.now() : this._lastAccessed;
        </getter>
      </property>
      <method name="updateLastAccessed">
        <parameter name="aDate"/>
        <body><![CDATA[
          this._lastAccessed = this.selected ? Infinity : (aDate || Date.now());
        ]]></body>
      </method>

      <field name="mOverCloseButton">false</field>
      <property name="_overPlayingIcon" readonly="true">
        <getter><![CDATA[
          let iconVisible = this.hasAttribute("soundplaying") ||
                            this.hasAttribute("muted") ||
                            this.hasAttribute("activemedia-blocked");
          let soundPlayingIcon =
            document.getAnonymousElementByAttribute(this, "anonid", "soundplaying-icon");
          let overlayIcon =
            document.getAnonymousElementByAttribute(this, "anonid", "overlay-icon");

          return soundPlayingIcon && soundPlayingIcon.matches(":hover") ||
                 (overlayIcon && overlayIcon.matches(":hover") && iconVisible);
        ]]></getter>
      </property>
      <field name="mCorrespondingMenuitem">null</field>

      <!--
      While it would make sense to track this in a field, the field will get nuked
      once the node is gone from the DOM, which causes us to think the tab is not
      closed, which causes us to make wrong decisions. So we use an expando instead.
      <field name="closing">false</field>
      -->

      <method name="_mouseenter">
        <body><![CDATA[
          if (this.hidden || this.closing)
            return;

          let tabContainer = this.parentNode;
          let visibleTabs = tabContainer.tabbrowser.visibleTabs;
          let tabIndex = visibleTabs.indexOf(this);

          if (this.selected)
            tabContainer._handleTabSelect();

          if (tabIndex == 0) {
            tabContainer._beforeHoveredTab = null;
          } else {
            let candidate = visibleTabs[tabIndex - 1];
            if (!candidate.selected) {
              tabContainer._beforeHoveredTab = candidate;
              candidate.setAttribute("beforehovered", "true");
            }
          }

          if (tabIndex == visibleTabs.length - 1) {
            tabContainer._afterHoveredTab = null;
          } else {
            let candidate = visibleTabs[tabIndex + 1];
            if (!candidate.selected) {
              tabContainer._afterHoveredTab = candidate;
              candidate.setAttribute("afterhovered", "true");
            }
          }

          tabContainer._hoveredTab = this;
          if (this.linkedPanel && !this.selected) {
            this.linkedBrowser.unselectedTabHover(true);
            this.startUnselectedTabHoverTimer();
          }

          // Prepare connection to host beforehand.
          SessionStore.speculativeConnectOnTabHover(this);
          tabContainer.tabbrowser.warmupTab(this);
        ]]></body>
      </method>

      <method name="_mouseleave">
        <body><![CDATA[
          let tabContainer = this.parentNode;
          if (tabContainer._beforeHoveredTab) {
            tabContainer._beforeHoveredTab.removeAttribute("beforehovered");
            tabContainer._beforeHoveredTab = null;
          }
          if (tabContainer._afterHoveredTab) {
            tabContainer._afterHoveredTab.removeAttribute("afterhovered");
            tabContainer._afterHoveredTab = null;
          }

          tabContainer._hoveredTab = null;
          if (this.linkedPanel && !this.selected) {
            this.linkedBrowser.unselectedTabHover(false);
            this.cancelUnselectedTabHoverTimer();
          }
        ]]></body>
      </method>

      <method name="startUnselectedTabHoverTimer">
        <body><![CDATA[
          // Only record data when we need to.
          if (!this.linkedBrowser.shouldHandleUnselectedTabHover) {
            return;
          }

          if (!TelemetryStopwatch.running("HOVER_UNTIL_UNSELECTED_TAB_OPENED", this)) {
            TelemetryStopwatch.start("HOVER_UNTIL_UNSELECTED_TAB_OPENED", this);
          }

          if (this._hoverTabTimer) {
            clearTimeout(this._hoverTabTimer);
            this._hoverTabTimer = null;
          }
        ]]></body>
      </method>

      <method name="cancelUnselectedTabHoverTimer">
        <body><![CDATA[
          // Since we're listening "mouseout" event, instead of "mouseleave".
          // Every time the cursor is moving from the tab to its child node (icon),
          // it would dispatch "mouseout"(for tab) first and then dispatch
          // "mouseover" (for icon, eg: close button, speaker icon) soon.
          // It causes we would cancel present TelemetryStopwatch immediately
          // when cursor is moving on the icon, and then start a new one.
          // In order to avoid this situation, we could delay cancellation and
          // remove it if we get "mouseover" within very short period.
          this._hoverTabTimer = setTimeout(() => {
            if (TelemetryStopwatch.running("HOVER_UNTIL_UNSELECTED_TAB_OPENED", this)) {
              TelemetryStopwatch.cancel("HOVER_UNTIL_UNSELECTED_TAB_OPENED", this);
            }
          }, 100);
        ]]></body>
      </method>

      <method name="finishUnselectedTabHoverTimer">
        <body><![CDATA[
          // Stop timer when the tab is opened.
          if (TelemetryStopwatch.running("HOVER_UNTIL_UNSELECTED_TAB_OPENED", this)) {
            TelemetryStopwatch.finish("HOVER_UNTIL_UNSELECTED_TAB_OPENED", this);
          }
        ]]></body>
      </method>

      <method name="startMediaBlockTimer">
        <body><![CDATA[
          TelemetryStopwatch.start("TAB_MEDIA_BLOCKING_TIME_MS", this);
        ]]></body>
      </method>

       <method name="finishMediaBlockTimer">
        <body><![CDATA[
          TelemetryStopwatch.finish("TAB_MEDIA_BLOCKING_TIME_MS", this);
        ]]></body>
      </method>

      <method name="toggleMuteAudio">
        <parameter name="aMuteReason"/>
        <body>
        <![CDATA[
          // Do not attempt to toggle mute state if browser is lazy.
          if (!this.linkedPanel) {
            return;
          }

          let tabContainer = this.parentNode;
          let browser = this.linkedBrowser;
          let modifiedAttrs = [];
          let hist = Services.telemetry.getHistogramById("TAB_AUDIO_INDICATOR_USED");

          if (this.hasAttribute("activemedia-blocked")) {
            this.removeAttribute("activemedia-blocked");
            modifiedAttrs.push("activemedia-blocked");

            browser.resumeMedia();
            hist.add(3 /* unblockByClickingIcon */);
            this.finishMediaBlockTimer();
          } else {
            if (browser.audioMuted) {
              browser.unmute();
              this.removeAttribute("muted");
              BrowserUITelemetry.countTabMutingEvent("unmute", aMuteReason);
              hist.add(1 /* unmute */);
            } else {
              browser.mute();
              this.setAttribute("muted", "true");
              BrowserUITelemetry.countTabMutingEvent("mute", aMuteReason);
              hist.add(0 /* mute */);
            }
            this.muteReason = aMuteReason || null;
            modifiedAttrs.push("muted");
          }
          tabContainer.tabbrowser._tabAttrModified(this, modifiedAttrs);
        ]]>
        </body>
      </method>

      <method name="setUserContextId">
        <parameter name="aUserContextId"/>
        <body>
        <![CDATA[
          if (aUserContextId) {
            if (this.linkedBrowser) {
              this.linkedBrowser.setAttribute("usercontextid", aUserContextId);
            }
            this.setAttribute("usercontextid", aUserContextId);
          } else {
            if (this.linkedBrowser) {
              this.linkedBrowser.removeAttribute("usercontextid");
            }
            this.removeAttribute("usercontextid");
          }

          ContextualIdentityService.setTabStyle(this);
        ]]>
        </body>
      </method>
    </implementation>

    <handlers>
      <handler event="mouseover"><![CDATA[
        let anonid = event.originalTarget.getAttribute("anonid");
        if (anonid == "close-button")
          this.mOverCloseButton = true;

        this._mouseenter();
      ]]></handler>
      <handler event="mouseout"><![CDATA[
        let anonid = event.originalTarget.getAttribute("anonid");
        if (anonid == "close-button")
          this.mOverCloseButton = false;

        this._mouseleave();
      ]]></handler>
      <handler event="dragstart" phase="capturing">
        this.style.MozUserFocus = "";
      </handler>
      <handler event="mousedown" phase="capturing">
      <![CDATA[
        if (this.selected) {
          this.style.MozUserFocus = "ignore";
        } else if (this.mOverCloseButton ||
                   this._overPlayingIcon) {
          // Prevent tabbox.xml from selecting the tab.
          event.stopPropagation();
        }
      ]]>
      </handler>
      <handler event="mouseup">
        this.style.MozUserFocus = "";
      </handler>
      <handler event="click">
      <![CDATA[
        if (event.button != 0) {
          return;
        }

        if (this._overPlayingIcon) {
          this.toggleMuteAudio();
        }
      ]]>
      </handler>
      <handler event="animationend">
      <![CDATA[
        let anonid = event.originalTarget.getAttribute("anonid");
        if (anonid == "tab-loading-burst") {
          this.removeAttribute("bursting");
        }
      ]]>
      </handler>
    </handlers>
  </binding>

  <binding id="tabbrowser-alltabs-popup"
           extends="chrome://global/content/bindings/popup.xml#popup">
    <implementation implements="nsIDOMEventListener">
      <method name="_tabOnAttrModified">
        <parameter name="aEvent"/>
        <body><![CDATA[
          var tab = aEvent.target;
          if (tab.mCorrespondingMenuitem)
            this._setMenuitemAttributes(tab.mCorrespondingMenuitem, tab);
        ]]></body>
      </method>

      <method name="_tabOnTabClose">
        <parameter name="aEvent"/>
        <body><![CDATA[
          var tab = aEvent.target;
          if (tab.mCorrespondingMenuitem)
            this.removeChild(tab.mCorrespondingMenuitem);
        ]]></body>
      </method>

      <method name="handleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          switch (aEvent.type) {
            case "TabAttrModified":
              this._tabOnAttrModified(aEvent);
              break;
            case "TabClose":
              this._tabOnTabClose(aEvent);
              break;
          }
        ]]></body>
      </method>

      <method name="_updateTabsVisibilityStatus">
        <body><![CDATA[
          var tabContainer = gBrowser.tabContainer;
          // We don't want menu item decoration unless there is overflow.
          if (tabContainer.getAttribute("overflow") != "true") {
            return;
          }

          let windowUtils = window.QueryInterface(Ci.nsIInterfaceRequestor)
                                  .getInterface(Ci.nsIDOMWindowUtils);
          let tabstripRect = windowUtils.getBoundsWithoutFlushing(tabContainer.mTabstrip);
          for (let menuitem of this.childNodes) {
            let curTab = menuitem.tab;
            if (!curTab) {
              // "Undo close tab", menuseparator, or entries put here by addons.
              continue;
            }
            let curTabRect = windowUtils.getBoundsWithoutFlushing(curTab);
            if (curTabRect.left >= tabstripRect.left &&
                curTabRect.right <= tabstripRect.right) {
              menuitem.setAttribute("tabIsVisible", "true");
            } else {
              menuitem.removeAttribute("tabIsVisible");
            }
          }
        ]]></body>
      </method>

      <method name="_createTabMenuItem">
        <parameter name="aTab"/>
        <body><![CDATA[
          var menuItem = document.createElementNS(
            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
            "menuitem");

          menuItem.setAttribute("class", "menuitem-iconic alltabs-item menuitem-with-favicon");

          this._setMenuitemAttributes(menuItem, aTab);

          aTab.mCorrespondingMenuitem = menuItem;
          menuItem.tab = aTab;

          this.appendChild(menuItem);
        ]]></body>
      </method>

      <method name="_setMenuitemAttributes">
        <parameter name="aMenuitem"/>
        <parameter name="aTab"/>
        <body><![CDATA[
          aMenuitem.setAttribute("label", aTab.label);
          aMenuitem.setAttribute("crop", "end");

          if (aTab.hasAttribute("busy")) {
            aMenuitem.setAttribute("busy", aTab.getAttribute("busy"));
            aMenuitem.removeAttribute("iconloadingprincipal");
            aMenuitem.removeAttribute("image");
          } else {
            aMenuitem.setAttribute("iconloadingprincipal", aTab.getAttribute("iconloadingprincipal"));
            aMenuitem.setAttribute("image", aTab.getAttribute("image"));
            aMenuitem.removeAttribute("busy");
          }

          if (aTab.hasAttribute("pending"))
            aMenuitem.setAttribute("pending", aTab.getAttribute("pending"));
          else
            aMenuitem.removeAttribute("pending");

          if (aTab.selected)
            aMenuitem.setAttribute("selected", "true");
          else
            aMenuitem.removeAttribute("selected");

          function addEndImage() {
            let endImage = document.createElement("image");
            endImage.setAttribute("class", "alltabs-endimage");
            let endImageContainer = document.createElement("hbox");
            endImageContainer.setAttribute("align", "center");
            endImageContainer.setAttribute("pack", "center");
            endImageContainer.appendChild(endImage);
            aMenuitem.appendChild(endImageContainer);
            return endImage;
          }

          if (aMenuitem.firstChild)
            aMenuitem.firstChild.remove();
          if (aTab.hasAttribute("muted"))
            addEndImage().setAttribute("muted", "true");
          else if (aTab.hasAttribute("soundplaying"))
            addEndImage().setAttribute("soundplaying", "true");
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="popupshowing">
      <![CDATA[
        if (event.target.getAttribute("id") == "alltabs_containersMenuTab") {
          createUserContextMenu(event, {useAccessKeys: false});
          return;
        }

        let containersEnabled = Services.prefs.getBoolPref("privacy.userContext.enabled");

        if (event.target.getAttribute("anonid") == "newtab-popup" ||
            event.target.id == "newtab-popup") {
          createUserContextMenu(event, {
            useAccessKeys: false,
            showDefaultTab: Services.prefs.getIntPref("privacy.userContext.longPressBehavior") == 1
          });
        } else {
          document.getElementById("alltabs-popup-separator-1").hidden = !containersEnabled;
          let containersTab = document.getElementById("alltabs_containersTab");

          containersTab.hidden = !containersEnabled;
          if (PrivateBrowsingUtils.isWindowPrivate(window)) {
            containersTab.setAttribute("disabled", "true");
          }

          document.getElementById("alltabs_undoCloseTab").disabled =
            SessionStore.getClosedTabCount(window) == 0;

          var tabcontainer = gBrowser.tabContainer;

          // Listen for changes in the tab bar.
          tabcontainer.addEventListener("TabAttrModified", this);
          tabcontainer.addEventListener("TabClose", this);

          let tabs = gBrowser.visibleTabs;
          for (var i = 0; i < tabs.length; i++) {
            if (!tabs[i].pinned)
              this._createTabMenuItem(tabs[i]);
          }
          this._updateTabsVisibilityStatus();
        }
      ]]></handler>

      <handler event="popuphidden">
      <![CDATA[
        if (event.target.getAttribute("id") == "alltabs_containersMenuTab") {
          return;
        }

        // clear out the menu popup and remove the listeners
        for (let i = this.childNodes.length - 1; i > 0; i--) {
          let menuItem = this.childNodes[i];
          if (menuItem.tab) {
            menuItem.tab.mCorrespondingMenuitem = null;
            this.removeChild(menuItem);
          }
          if (menuItem.hasAttribute("usercontextid")) {
            this.removeChild(menuItem);
          }
        }
        var tabcontainer = gBrowser.tabContainer;
        tabcontainer.removeEventListener("TabAttrModified", this);
        tabcontainer.removeEventListener("TabClose", this);
      ]]></handler>

      <handler event="DOMMenuItemActive">
      <![CDATA[
        var tab = event.target.tab;
        if (tab) {
          let overLink = tab.linkedBrowser.currentURI.displaySpec;
          if (overLink == "about:blank")
            overLink = "";
          XULBrowserWindow.setOverLink(overLink, null);
        }
      ]]></handler>

      <handler event="DOMMenuItemInactive">
      <![CDATA[
        XULBrowserWindow.setOverLink("", null);
      ]]></handler>

      <handler event="command"><![CDATA[
        if (event.target.tab) {
          if (gBrowser.selectedTab != event.target.tab) {
            gBrowser.selectedTab = event.target.tab;
          } else {
            gBrowser.tabContainer._handleTabSelect();
          }
        }
      ]]></handler>

    </handlers>
  </binding>

  <binding id="statuspanel" display="xul:hbox">
    <content>
      <xul:hbox class="statuspanel-inner">
        <xul:label class="statuspanel-label"
                   role="status"
                   aria-live="off"
                   xbl:inherits="value=label,crop,mirror"
                   flex="1"
                   crop="end"/>
      </xul:hbox>
    </content>

    <implementation implements="nsIDOMEventListener">
      <constructor><![CDATA[
        window.addEventListener("resize", this);
      ]]></constructor>

      <destructor><![CDATA[
        window.removeEventListener("resize", this);
        MousePosTracker.removeListener(this);
      ]]></destructor>

      <property name="label">
        <setter><![CDATA[
          if (!this.label) {
            this.removeAttribute("mirror");
            this.removeAttribute("sizelimit");
          }

          if (this.getAttribute("type") == "status" &&
              this.getAttribute("previoustype") == "status") {
            // Before updating the label, set the panel's current width as its
            // min-width to let the panel grow but not shrink and prevent
            // unnecessary flicker while loading pages. We only care about the
            // panel's width once it has been painted, so we can do this
            // without flushing layout.
            this.style.minWidth =
              window.QueryInterface(Ci.nsIInterfaceRequestor)
                    .getInterface(Ci.nsIDOMWindowUtils)
                    .getBoundsWithoutFlushing(this).width + "px";
          } else {
            this.style.minWidth = "";
          }

          if (val) {
            this.setAttribute("label", val);
            this.removeAttribute("inactive");
            this._mouseTargetRect = null;
            MousePosTracker.addListener(this);
          } else {
            this.setAttribute("inactive", "true");
            MousePosTracker.removeListener(this);
          }

          return val;
        ]]></setter>
        <getter>
          return this.hasAttribute("inactive") ? "" : this.getAttribute("label");
        </getter>
      </property>

      <method name="getMouseTargetRect">
        <body><![CDATA[
          if (!this._mouseTargetRect) {
            this._calcMouseTargetRect();
          }
          return this._mouseTargetRect;
        ]]></body>
      </method>

      <method name="onMouseEnter">
        <body>
          this._mirror();
        </body>
      </method>

      <method name="onMouseLeave">
        <body>
          this._mirror();
        </body>
      </method>

      <method name="handleEvent">
        <parameter name="event"/>
        <body><![CDATA[
          if (!this.label)
            return;

          switch (event.type) {
            case "resize":
              this._mouseTargetRect = null;
              break;
          }
        ]]></body>
      </method>

      <method name="_calcMouseTargetRect">
        <body><![CDATA[
          let container = this.parentNode;
          let alignRight = (getComputedStyle(container).direction == "rtl");
          let panelRect = this.getBoundingClientRect();
          let containerRect = container.getBoundingClientRect();

          this._mouseTargetRect = {
            top:    panelRect.top,
            bottom: panelRect.bottom,
            left:   alignRight ? containerRect.right - panelRect.width : containerRect.left,
            right:  alignRight ? containerRect.right : containerRect.left + panelRect.width
          };
        ]]></body>
      </method>

      <method name="_mirror">
        <body>
          if (this.hasAttribute("mirror"))
            this.removeAttribute("mirror");
          else
            this.setAttribute("mirror", "true");

          if (!this.hasAttribute("sizelimit")) {
            this.setAttribute("sizelimit", "true");
            this._mouseTargetRect = null;
          }
        </body>
      </method>
    </implementation>
  </binding>

  <binding id="tabbrowser-tabpanels"
           extends="chrome://global/content/bindings/tabbox.xml#tabpanels">
    <implementation>
      <field name="_selectedIndex">0</field>

      <property name="selectedIndex">
        <getter>
        <![CDATA[
          return this._selectedIndex;
        ]]>
        </getter>

        <setter>
        <![CDATA[
          if (val < 0 || val >= this.childNodes.length)
            return val;

          let toTab = this.getRelatedElement(this.childNodes[val]);

          gBrowser._getSwitcher().requestTab(toTab);

          var panel = this._selectedPanel;
          var newPanel = this.childNodes[val];
          this._selectedPanel = newPanel;
          if (this._selectedPanel != panel) {
            var event = document.createEvent("Events");
            event.initEvent("select", true, true);
            this.dispatchEvent(event);

            this._selectedIndex = val;
          }

          return val;
        ]]>
        </setter>
      </property>
    </implementation>
  </binding>

  <binding id="tabbrowser-browser"
           extends="chrome://global/content/bindings/browser.xml#browser">
    <implementation>
      <field name="tabModalPromptBox">null</field>

      <!-- throws exception for unknown schemes -->
      <method name="loadURIWithFlags">
        <parameter name="aURI"/>
        <parameter name="aFlags"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aPostData"/>
        <body>
          <![CDATA[
            var params = arguments[1];
            if (typeof(params) == "number") {
              params = {
                flags: aFlags,
                referrerURI: aReferrerURI,
                charset: aCharset,
                postData: aPostData,
              };
            }
            _loadURIWithFlags(this, aURI, params);
          ]]>
        </body>
      </method>
    </implementation>
  </binding>

  <binding id="tabbrowser-remote-browser"
           extends="chrome://global/content/bindings/remote-browser.xml#remote-browser">
    <implementation>
      <field name="tabModalPromptBox">null</field>

      <!-- throws exception for unknown schemes -->
      <method name="loadURIWithFlags">
        <parameter name="aURI"/>
        <parameter name="aFlags"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aPostData"/>
        <body>
          <![CDATA[
            var params = arguments[1];
            if (typeof(params) == "number") {
              params = {
                flags: aFlags,
                referrerURI: aReferrerURI,
                charset: aCharset,
                postData: aPostData,
              };
            }
            _loadURIWithFlags(this, aURI, params);
          ]]>
        </body>
      </method>
    </implementation>
  </binding>

</bindings>

    </textarea>
    <pre></pre>
  </div>
  </main>
    <script>
    function getJSForBinding(binding) {
  let js = [];
  let elementName = 'firefox-' + binding.attrs.id;
  let className = titleCase(elementName);
  let hasExtends = !!formatExtends(binding.attrs.extends);
  js.push(`class ${className} `);
  if (hasExtends) {
    js.push(`extends Firefox${formatExtends(binding.attrs.extends)} `);
  } else {
    js.push(`extends BaseElement `);
  }

  js.push('{')

  let childMarkup = [];
  let content = binding.find("content");
  if (content.length === 0) {
    content = binding.find("xbl:content");
  }
  if (content.length > 1) {
    throw "Unexpected second content field";
  } else if (content.length === 1) {
    function printChild(child) {
      let attrs = '';
      for (var attr in child.attrs) {
        attrs += ' ' + attr.replace('xbl:', '') + '="' + child.attrs[attr].replace('"', '\"').replace(/xbl\:/g, '') + '"';
      }
      let name = child.name === "label" ? 'firefox-text-label' : child.name;
      childMarkup.push(`<${name}${attrs}>`);
      child.children.forEach(printChild);
      childMarkup.push(`</${name}>`);
    }
    content[0].children.forEach(printChild);
  } else {
    console.log("No content for binding", binding.attrs.id);
  }

  if (binding.attrs.id == "checkbox-baseline") {
    childMarkup.unshift("<input type='checkbox' />")
  }

  var innerHTML = content.length ?
        "this.innerHTML = `" + childMarkup.join('\n') + "`;" :
        "";

  let xblconstructor = (binding.find("constructor") || [])[0];
  xblconstructor = xblconstructor ? `${xblconstructor.cdata || xblconstructor.value}` : '';
  // Or, try / catch since many components will fail when loaded in a tab due to chrome references
  // xblconstructor = xblconstructor ? `try { ${xblconstructor.cdata} } catch(e) { }` : '';

  let xbldestructor = (binding.find("destructor") || [])[0];
  xbldestructor = xbldestructor ? `${xbldestructor.cdata || xbldestructor.value}` : '';
  // Or, try / catch since many components will fail when loaded in a tab due to chrome references
  // xbldestructor = xbldestructor ? `try { ${xbldestructor.cdata} } catch(e) { }` : '';

  let handlers = [];
  // <handler>
  for (let handler of binding.find('handler')) {
    let capturing = handler.attrs.phase === "capturing" ? ", true" : "";
    handlers.push(`
      this.addEventListener("${handler.attrs.event}", (event) => {
        ${handler.cdata || handler.value || handler.attrs.action}
      }${capturing});
    `);
  }


  // <field>
  let fields = [];
  for (let field of binding.find('field')) {


    // Work around fields like _weekStart in the datepicker where the value is coming from a dtd.
    // Just print an empty string in that case.
    let data = (field.cdata || field.value || "").trim();
    if (data.startsWith("FROM-DTD")) {
      data = `"${data}"`
    }
    data = (data.length === 0) ? '""' : data;

    // Remove leading comments, which would cause the 'return' to be on a different line
    // than the expression.
    let comments = [];
    let expressions = data.split("\n");
    for (var i = 0; i < expressions.length; i++) {
      if (expressions[i].trim().startsWith("//")) {
        comments.push(expressions[i]);
      } else {
        expressions = expressions.slice(i);
        break;
      }
    }

    let setter = field.attrs.readonly ? '' :
    `set(val) {
        delete this.${field.attrs.name};
        return this.${field.attrs.name} = val;
    },`;

    fields.push(`Object.defineProperty(this, "${field.attrs.name}", {
      configurable: true,
      enumerable: true,
      get() {
        ${comments.join('\n')}
        delete this.${field.attrs.name};
        return this.${field.attrs.name} = ${expressions.join('\n')}
      },
      ${setter}
    })`);
  }

  js.push(`
    constructor() {
      super();
    }
    connectedCallback() {
      ${hasExtends ? 'super.connectedCallback()' : ''}
      ${innerHTML}
      ${fields.join('\n')}

      ${xblconstructor}

      ${handlers.join('\n')}
    }
    disconnectedCallback() {
      ${xbldestructor}
    }
  `);

  // <property>
  for (let property of binding.find('property')) {
    if (property.attrs.onset) {
      js.push(`
        set ${property.attrs.name}(val) {
          ${property.attrs.onset}
        }
      `);
    } else if(property.find('setter').length) {
      js.push(`
        set ${property.attrs.name}(val) {
          ${property.find('setter')[0].cdata || property.find('setter')[0].value}
        }
      `);
    }
    if (property.attrs.onget) {
      js.push(`
        get ${property.attrs.name}() {
          ${property.attrs.onget}
        }
      `);
    } else if(property.find('getter').length) {
      js.push(`
        get ${property.attrs.name}() {
          ${property.find('getter')[0].cdata || property.find('getter')[0].value}
        }
      `);
    }
  }

  // <method>
  for (let method of binding.find('method')) {
    js.push(`${method.attrs.name}(`);
    js.push(`${method.find('parameter').map(p => p.attrs.name).join(',')}`);
    js.push(`) {`);
    js.push(method.find('body')[0].cdata || method.find('body')[0].value);
    js.push(`}`);
  }

  js.push('}');

  js.push(`
    customElements.define("${elementName}", ${className});
  `)
  return js.join(' ');
}
    function titleCase(str) {
  return str[0].toUpperCase() + str.substr(1).replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
}
    function formatExtends(ext) {
  if (!ext || ext.startsWith("xul:")) {
    return null;
  }
  return titleCase(ext.split('#')[1]);
}

    var worker = new Worker("../static/prettier-worker.js");
    var textarea = document.querySelector("textarea");
    var pre = document.querySelector("pre");
    function createPreview() {
      var body = textarea.value;
      body = body.replace(/&([a-z0-9-]+);/gi, "FROM-DTD-$1"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2-$3"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2-$3-$4"); // Replace DTD entities
      var parsed = xmlom.parseString(body, {
        xmlns: true,
      });
      parsed.then(doc => {
        console.log(doc, doc.find("binding"));
        let js = doc.find("binding").map(binding => {
          return getJSForBinding(binding);
        }).join("\n");
        pre.textContent = "Parsing...";

        worker.postMessage({text: js});
        worker.addEventListener("message", function(message) {
          pre.textContent = message.data.formatted;
        }, {once: true});
      }).catch(e => {
        pre.textContent =  "Error parsing XML:\n" + e;
      });
    }
    textarea.addEventListener("input", createPreview);
    createPreview();

    document.querySelector("ul").addEventListener("click", function(e) {
      if (e.originalTarget.localName === "a") {
        e.preventDefault();
        textarea.value = files[e.originalTarget.dataset.index].body;
        createPreview();
      }
    });
    </script>
  </body>
  </html>
