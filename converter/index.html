
  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8">
    <title>XBL To Custom Element Converter</title>
    <link rel="stylesheet" href="../static/styles.css" />
    <script src="../static/xmlom.js"></script>
    <script src="../static/beautify.js"></script>
    <style>
    main {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
      width: 100vw;
      position: absolute;
      top: 0;
      left: 0;
    }
    #converter {
      font-family: monospace;
      display: grid;
      overflow: hidden;
      grid-template-columns: auto 1fr 1fr;
      grid-gap: 10px;
    }
    textarea, pre {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: monospace;
      font-size: 12px;
    }
    ul {
      min-width: 100px;
      margin: 0;
      padding: 0;
      overflow: scroll;
      font-size: smaller;
    }
    li {
      margin: 0;
      padding: 0;
      list-style: none;
      word-break: keep-all;
    }
    </style>
    <script>
      var files = [{"file":"urlbarBindings.xml","body":"<?xml version=\"1.0\"?>\n\n<!--\n-*- Mode: HTML -*-\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n-->\n\n<!DOCTYPE bindings [\n<!ENTITY % notificationDTD SYSTEM \"chrome://global/locale/notification.dtd\">\n%notificationDTD;\n<!ENTITY % browserDTD SYSTEM \"chrome://browser/locale/browser.dtd\">\n%browserDTD;\n<!ENTITY % brandDTD SYSTEM \"chrome://branding/locale/brand.dtd\">\n%brandDTD;\n]>\n\n<bindings id=\"urlbarBindings\" xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"urlbar\" extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content role=\"combobox\">\n      <children includes=\"box\"/>\n      <xul:moz-input-box anonid=\"moz-input-box\"\n                         tooltip=\"aHTMLTooltip\"\n                         class=\"urlbar-input-box\"\n                         flex=\"1\">\n        <children/>\n        <html:input anonid=\"scheme\"\n                    class=\"urlbar-scheme textbox-input\"\n                    required=\"required\"\n                    xbl:inherits=\"textoverflow,focused\"/>\n        <html:input anonid=\"input\"\n                    class=\"urlbar-input textbox-input\"\n                    aria-owns=\"urlbarView-results\"\n                    aria-controls=\"urlbarView-results\"\n                    aria-autocomplete=\"both\"\n                    allowevents=\"true\"\n                    inputmode=\"mozAwesomebar\"\n                    xbl:inherits=\"value,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,focused,textoverflow\"/>\n      </xul:moz-input-box>\n      <xul:image anonid=\"urlbar-go-button\"\n                 class=\"urlbar-go-button urlbar-icon\"\n                 onclick=\"gURLBar.handleCommand(event);\"\n                 tooltiptext=\"FROM-DTD.goEndCap.tooltip;\"\n                 xbl:inherits=\"pageproxystate,parentfocused=focused,usertyping\"/>\n      <xul:image anonid=\"historydropmarker\"\n                 class=\"urlbar-history-dropmarker urlbar-icon chromeclass-toolbar-additional\"\n                 tooltiptext=\"FROM-DTD.urlbar.openHistoryPopup.tooltip;\"\n                 allowevents=\"true\"\n                 xbl:inherits=\"open,parentfocused=focused,usertyping\"/>\n      <children includes=\"hbox\"/>\n    </content>\n  </binding>\n\n  <binding id=\"urlbar-rich-result-popup\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup\">\n\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\"\n             aria-owns=\"richlistbox\">\n      <xul:deck anonid=\"search-suggestions-notification\"\n                align=\"center\"\n                role=\"alert\"\n                selectedIndex=\"0\">\n        <!-- OPT-OUT -->\n        <xul:hbox flex=\"1\" align=\"center\" anonid=\"search-suggestions-opt-out\">\n          <xul:image class=\"ac-site-icon\" type=\"searchengine\"/>\n          <xul:hbox anonid=\"search-suggestions-hint-typing\">\n            <xul:description class=\"ac-title-text\">FROM-DTD.brandShortName;</xul:description>\n          </xul:hbox>\n          <xul:hbox anonid=\"search-suggestions-hint-box\" flex=\"1\">\n            <xul:description id=\"search-suggestions-hint\">\n              <html:span class=\"prefix\">&#x1f4a1; FROM-DTD.urlbar.searchSuggestionsNotification.hintPrefix;</html:span>\n              <html:span>FROM-DTD.urlbar.searchSuggestionsNotification.hint;</html:span>\n            </xul:description>\n          </xul:hbox>\n          <xul:label id=\"search-suggestions-change-settings\"\n                     is=\"text-link\"\n                     role=\"link\"\n\n                     value=\"FROM-DTD.urlbar.searchSuggestionsNotification.changeSettingsWin;\"\n                     accesskey=\"FROM-DTD.urlbar.searchSuggestionsNotification.changeSettingsWin.accesskey;\"\n\n                     onclick=\"openPreferences('paneSearch');\"\n                     control=\"search-suggestions-change-settings\"/>\n        </xul:hbox>\n      </xul:deck>\n      <xul:richlistbox anonid=\"richlistbox\" class=\"autocomplete-richlistbox\"\n                       flex=\"1\"/>\n      <xul:hbox anonid=\"footer\">\n        <children/>\n        <xul:hbox anonid=\"one-off-search-buttons\"\n                  class=\"search-one-offs\"\n                  compact=\"true\"\n                  includecurrentengine=\"true\"\n                  disabletab=\"true\"\n                  flex=\"1\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <!--\n        For performance reasons we want to limit the size of the text runs we\n        build and show to the user.\n      -->\n      <field name=\"textRunsMaxLen\">255</field>\n\n      <field name=\"_maxResults\">0</field>\n\n      <field name=\"_bundle\" readonly=\"true\">\n        Cc[\"@mozilla.org/intl/stringbundle;1\"].\n          getService(Ci.nsIStringBundleService).\n          createBundle(\"chrome://browser/locale/places/places.properties\");\n      </field>\n\n      <field name=\"searchSuggestionsNotification\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(\n          this, \"anonid\", \"search-suggestions-notification\"\n        );\n      </field>\n\n      <field name=\"footer\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"footer\");\n      </field>\n\n      <field name=\"shrinkDelay\" readonly=\"true\">\n        250\n      </field>\n\n      <field name=\"oneOffSearchButtons\" readonly=\"true\">\n        new SearchOneOffs(\n          document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                  \"one-off-search-buttons\"));\n      </field>\n\n      <field name=\"_overrideValue\">null</field>\n      <property name=\"overrideValue\"\n                onget=\"return this._overrideValue;\"\n                onset=\"this._overrideValue = val; return val;\"/>\n\n      <method name=\"onPopupClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.button == 2) {\n            // Ignore right-clicks.\n            return;\n          }\n          // Otherwise \"call super\" -- do what autocomplete-base-popup does.\n          this.input.controller.handleEnter(true, aEvent);\n        ]]></body>\n      </method>\n\n      <field name=\"_oneOffSearchesEnabledByReason\">new Map()</field>\n\n      <method name=\"toggleOneOffSearches\">\n        <parameter name=\"enable\"/>\n        <parameter name=\"reason\"/>\n        <body><![CDATA[\n          this._oneOffSearchesEnabledByReason.set(reason || \"runtime\", enable);\n          this._syncOneOffSearchesEnabled();\n        ]]></body>\n      </method>\n\n      <method name=\"_syncOneOffSearchesEnabled\">\n        <body><![CDATA[\n          // If the popup hasn't ever been opened yet, then don't actually do\n          // anything.  (The popup will still be hidden in that case.)  The\n          // input adds a popupshowing listener that will call this method back\n          // and lazily initialize the one-off buttons the first time the popup\n          // opens.  There are performance tests that fail if we don't do this.\n          if (this.hidden) {\n            return;\n          }\n\n          let enable = Array.from(this._oneOffSearchesEnabledByReason.values())\n                            .every(v => v);\n          if (enable) {\n            this.oneOffSearchButtons.telemetryOrigin = \"urlbar\";\n            this.oneOffSearchButtons.style.display = \"-moz-box\";\n            // Set .textbox first, since the popup setter will cause\n            // a _rebuild call that uses it.\n            this.oneOffSearchButtons.textbox = this.input;\n            this.oneOffSearchButtons.popup = this;\n          } else {\n            this.oneOffSearchButtons.telemetryOrigin = null;\n            this.oneOffSearchButtons.style.display = \"none\";\n            this.oneOffSearchButtons.textbox = null;\n            this.oneOffSearchButtons.popup = null;\n          }\n        ]]></body>\n      </method>\n\n      <property name=\"oneOffSearchesEnabled\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.oneOffSearchButtons.style.display != \"none\";\n        ]]></getter>\n      </property>\n\n      <!-- Override this so that navigating between items results in an item\n           always being selected. -->\n      <method name=\"getNextIndex\">\n        <parameter name=\"reverse\"/>\n        <parameter name=\"amount\"/>\n        <parameter name=\"index\"/>\n        <parameter name=\"maxRow\"/>\n        <body><![CDATA[\n          if (maxRow < 0)\n            return -1;\n\n          let newIndex = index + (reverse ? -1 : 1) * amount;\n\n          // We only want to wrap if navigation is in any direction by one item,\n          // otherwise we clamp to one end of the list.\n          // ie, hitting page-down will only cause is to wrap if we're already\n          // at one end of the list.\n\n          // Allow the selection to be removed if the first result is not a\n          // heuristic result.\n          if (!this._isFirstResultHeuristic) {\n            if (reverse && index == -1 || newIndex > maxRow && index != maxRow)\n              newIndex = maxRow;\n            else if (!reverse && index == -1 || newIndex < 0 && index != 0)\n              newIndex = 0;\n\n            if (newIndex < 0 && index == 0 || newIndex > maxRow && index == maxRow)\n              newIndex = -1;\n\n            return newIndex;\n          }\n\n          // Otherwise do not allow the selection to be removed.\n          if (newIndex < 0) {\n            newIndex = index > 0 ? 0 : maxRow;\n          } else if (newIndex > maxRow) {\n            newIndex = index < maxRow ? maxRow : 0;\n          }\n          return newIndex;\n        ]]></body>\n      </method>\n\n      <property name=\"_isFirstResultHeuristic\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            // The popup usually has a special \"heuristic\" first result (added\n            // by UnifiedComplete.js) that is automatically selected when the\n            // popup opens.\n            return this.input.mController.matchCount > 0 &&\n                   this.input.mController\n                             .getStyleAt(0)\n                             .split(/\\s+/).indexOf(\"heuristic\") > 0;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"maxResults\">\n        <getter>\n          <![CDATA[\n            if (!this._maxResults) {\n              this._maxResults = Services.prefs.getIntPref(\"browser.urlbar.maxRichResults\");\n            }\n            return this._maxResults;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            return this._maxResults = parseInt(val);\n          ]]>\n        </setter>\n      </property>\n\n      <!-- This is set either to undefined or to a new object containing\n           { start, end } margin values in pixels. These are used to align the\n           results to the input field. -->\n      <property name=\"margins\"\n                onget=\"return this._margins;\">\n        <setter>\n          <![CDATA[\n          this._margins = val;\n\n          if (val) {\n            /* eslint-disable no-multi-spaces */\n            let paddingInCSS =\n                3   // .autocomplete-richlistbox padding-left/right\n              + 6   // .ac-site-icon margin-inline-start\n              + 16  // .ac-site-icon width\n              + 6;  // .ac-site-icon margin-inline-end\n            /* eslint-enable no-multi-spaces */\n            let actualVal = Math.round(val.start) - paddingInCSS;\n            let actualValEnd = Math.round(val.end);\n            this.style.setProperty(\"--item-padding-start\", actualVal + \"px\");\n            this.style.setProperty(\"--item-padding-end\", actualValEnd + \"px\");\n          } else {\n            this.style.removeProperty(\"--item-padding-start\");\n            this.style.removeProperty(\"--item-padding-end\");\n          }\n\n          return val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          // initially the panel is hidden\n          // to avoid impacting startup / new window performance\n          aInput.popup.hidden = false;\n\n          this._openAutocompletePopup(aInput, aElement);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body><![CDATA[\n          if (this.mPopupOpen) {\n            return;\n          }\n\n          // Explicitly set the direction of the popup because automplete.xml\n          // expects this.\n          this.style.direction = (RTL_UI ? \"rtl\" : \"ltr\");\n\n          // Make the popup span the width of the window.  First, set its width.\n          let documentRect =\n            window.windowUtils\n                .getBoundsWithoutFlushing(window.document.documentElement);\n          let width = documentRect.right - documentRect.left;\n          this.setAttribute(\"width\", width);\n\n          // Now make its starting margin negative so that its leading edge\n          // aligns with the window border.\n          let elementRect =\n            window.windowUtils.getBoundsWithoutFlushing(aElement);\n          if (RTL_UI) {\n            let offset = elementRect.right - documentRect.right;\n            this.style.marginRight = offset + \"px\";\n          } else {\n            let offset = documentRect.left - elementRect.left;\n            this.style.marginLeft = offset + \"px\";\n          }\n\n          // Keep the popup items' site icons aligned with the urlbar's identity\n          // icon if it's not too far from the edge of the window.  We define\n          // \"too far\" as \"more than 30% of the window's width AND more than\n          // 250px\".  Do this *before* adding any items because when the new\n          // value of the margins are different from the previous value, over-\n          // and underflow must be handled for each item already in the popup.\n          let needsHandleOverUnderflow = false;\n          let boundToCheck = RTL_UI ? \"right\" : \"left\";\n          let inputRect = window.windowUtils.getBoundsWithoutFlushing(aInput);\n          let startOffset = Math.abs(inputRect[boundToCheck] - documentRect[boundToCheck]);\n          let alignSiteIcons = startOffset / width <= 0.3 || startOffset <= 250;\n          if (alignSiteIcons) {\n            // Calculate the end margin if we have a start margin.\n            let boundToCheckEnd = RTL_UI ? \"left\" : \"right\";\n            let endOffset = Math.abs(inputRect[boundToCheckEnd] -\n                                     documentRect[boundToCheckEnd]);\n            if (endOffset > startOffset * 2) {\n              // Provide more space when aligning would result in an unbalanced\n              // margin. This allows the location bar to be moved to the start\n              // of the navigation toolbar to reclaim space for results.\n              endOffset = startOffset;\n            }\n            let identityIcon = document.getElementById(\"identity-icon\");\n            let identityRect =\n              window.windowUtils.getBoundsWithoutFlushing(identityIcon);\n            let start = RTL_UI ?\n                        documentRect.right - identityRect.right :\n                        identityRect.left;\n            if (!this.margins || start != this.margins.start ||\n                                 endOffset != this.margins.end ||\n                                 width != this.margins.width) {\n              this.margins = { start, end: endOffset, width };\n              needsHandleOverUnderflow = true;\n            }\n          } else if (this.margins) {\n            // Reset the alignment so that the site icons are positioned\n            // according to whatever's in the CSS.\n            this.margins = undefined;\n            needsHandleOverUnderflow = true;\n          }\n\n          // Now that the margins have been set, start adding items (via\n          // _invalidate).\n          this.mInput = aInput;\n          this.input.controller.setInitiallySelectedIndex(this._isFirstResultHeuristic ? 0 : -1);\n          this.input.userSelectionBehavior = \"none\";\n          this._invalidate();\n\n          try {\n            let whichNotification = aInput.whichSearchSuggestionsNotification;\n            if (whichNotification != \"none\") {\n              // Update the impressions count on real popupshown, since there's\n              // no guarantee openPopup will be respected by the platform.\n              // Though, we must ensure the handled event is the expected one.\n              let impressionId = this._searchSuggestionsImpressionId = {};\n              this.addEventListener(\"popupshown\", () => {\n                if (this._searchSuggestionsImpressionId == impressionId)\n                  aInput.updateSearchSuggestionsNotificationImpressions(whichNotification);\n              }, {once: true});\n              this._showSearchSuggestionsNotification(whichNotification);\n            } else if (this.classList.contains(\"showSearchSuggestionsNotification\")) {\n              this._hideSearchSuggestionsNotification();\n            }\n          } catch (ex) {\n            // Not critical for the urlbar functionality, just report the error.\n            Cu.reportError(ex);\n          }\n\n          // Position the popup below the navbar.  To get the y-coordinate,\n          // which is an offset from the bottom of the input, subtract the\n          // bottom of the navbar from the buttom of the input.\n          let yOffset = Math.round(\n            window.windowUtils.getBoundsWithoutFlushing(document.getElementById(\"nav-bar\")).bottom -\n            window.windowUtils.getBoundsWithoutFlushing(aInput).bottom);\n\n          if (!this.richlistbox.suppressMenuItemEvent && this.richlistbox.currentItem) {\n            // The richlistbox fired a DOMMenuItemActive for accessibility,\n            // but because the popup isn't open yet, accessibility will ignore\n            // it. Therefore, fire it again once the popup opens.\n            this.addEventListener(\"popupshown\", () => {\n              this.richlistbox._fireEvent(this.richlistbox.currentItem,\n                \"DOMMenuItemActive\");\n            }, {once: true});\n          }\n\n          this.openPopup(aElement, \"after_start\", 0, yOffset, false, false);\n\n          // Do this immediately after we've requested the popup to open. This\n          // will cause sync reflows but prevents flickering.\n          if (needsHandleOverUnderflow) {\n            for (let item of this.richlistbox.children) {\n              item.handleOverUnderflow();\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"adjustHeight\">\n        <body>\n          <![CDATA[\n          // If we were going to shrink later, cancel that for now:\n          if (this._shrinkTimeout) {\n            clearTimeout(this._shrinkTimeout);\n            this._shrinkTimeout = null;\n          }\n          let lastRowCount = this._lastRowCount;\n          // Figure out how many rows to show\n          let rows = this.richlistbox.children;\n          this._lastRowCount = rows.length;\n          let numRows = Math.min(this.matchCount, this.maxRows, rows.length);\n\n          // If we're going from 0 to non-0 rows, we might need to remove\n          // the height attribute to allow the popup to size. The attribute\n          // is set from XUL popup management code.\n          if (!lastRowCount && rows.length) {\n            this.removeAttribute(\"height\");\n          }\n\n          // Default the height to 0 if we have no rows to show\n          let height = 0;\n          if (numRows) {\n            if (!this._rowHeight) {\n              window.promiseDocumentFlushed(() => {\n                if (window.closed) {\n                  return;\n                }\n                this._rowHeight = rows[0].getBoundingClientRect().height;\n                let style = window.getComputedStyle(this.richlistbox);\n\n                let paddingTop = parseInt(style.paddingTop) || 0;\n                let paddingBottom = parseInt(style.paddingBottom) || 0;\n                this._rlbPadding = paddingTop + paddingBottom;\n                // Then re-run - but don't dirty layout from inside this callback.\n                window.requestAnimationFrame(() => this.adjustHeight());\n              });\n              return;\n            }\n\n            // Calculate the height to have the first row to last row shown\n            height = (this._rowHeight * numRows) + this._rlbPadding;\n          }\n\n          let animate = this.getAttribute(\"dontanimate\") != \"true\";\n          let currentHeight =\n            parseFloat(this.richlistbox.getAttribute(\"height\"), 10) ||\n            parseFloat(this.richlistbox.style.height, 10) ||\n            0; // It's possible we get here when we haven't set height on the richlistbox\n               // yet, which means parseFloat will return NaN. It should return 0 instead.\n          if (height > currentHeight) {\n            // Grow immediately.\n            if (animate) {\n              this.richlistbox.removeAttribute(\"height\");\n              this.richlistbox.style.height = height + \"px\";\n            } else {\n              this.richlistbox.style.removeProperty(\"height\");\n              this.richlistbox.height = height;\n            }\n          } else if (height < currentHeight) { // Don't shrink if height matches exactly\n            // Delay shrinking to avoid flicker.\n            this._shrinkTimeout = setTimeout(() => {\n              this._collapseUnusedItems();\n              if (animate) {\n                this.richlistbox.removeAttribute(\"height\");\n                this.richlistbox.style.height = height + \"px\";\n              } else {\n                this.richlistbox.style.removeProperty(\"height\");\n                this.richlistbox.height = height;\n              }\n            }, this.shrinkDelay);\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_showSearchSuggestionsNotification\">\n        <parameter name=\"whichNotification\"/>\n        <body>\n          <![CDATA[\n          if (whichNotification == \"opt-out\") {\n            if (this.margins) {\n              this.searchSuggestionsNotification.style.paddingInlineStart =\n                this.margins.start + \"px\";\n            } else {\n              this.searchSuggestionsNotification.style.removeProperty(\"padding-inline-start\");\n            }\n\n            // We want to animate the opt-out hint only once.\n            if (!this._firstSearchSuggestionsNotification) {\n              this._firstSearchSuggestionsNotification = true;\n              this.searchSuggestionsNotification.setAttribute(\"animate\", \"true\");\n            }\n          }\n\n          this.searchSuggestionsNotification.setAttribute(\"aria-describedby\",\n                                                          \"search-suggestions-hint\");\n\n          // With the notification shown, the listbox's height can sometimes be\n          // too small when it's flexed, as it normally is.  Also, it can start\n          // out slightly scrolled down.  Both problems appear together, most\n          // often when the popup is very narrow and the notification's text\n          // must wrap.  Work around them by removing the flex.\n          //\n          // But without flexing the listbox, the listbox's height animation\n          // sometimes fails to complete, leaving the popup too tall.  Work\n          // around that problem by disabling the listbox animation.\n          this.richlistbox.flex = 0;\n          this.setAttribute(\"dontanimate\", \"true\");\n\n          this.classList.add(\"showSearchSuggestionsNotification\");\n          // Don't show the one-off buttons if we are showing onboarding and\n          // there's no result, since it would be ugly and pointless.\n          this.footer.collapsed = this.matchCount == 0;\n          this.input.tabScrolling = this.matchCount != 0;\n\n          // This event allows accessibility APIs to see the notification.\n          if (!this.popupOpen) {\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"AlertActive\", true, true);\n            this.searchSuggestionsNotification.dispatchEvent(event);\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_hideSearchSuggestionsNotification\">\n        <body>\n          <![CDATA[\n          this.classList.remove(\"showSearchSuggestionsNotification\");\n          this.richlistbox.flex = 1;\n          this.removeAttribute(\"dontanimate\");\n          this.searchSuggestionsNotification.removeAttribute(\"animate\");\n          if (this.matchCount) {\n            // Update popup height.\n            this._invalidate();\n          } else {\n            this.closePopup();\n          }\n          ]]>\n        </body>\n      </method>\n\n      <!-- This handles keypress changes to the selection among the one-off\n           search buttons and between the one-offs and the listbox.  It returns\n           true if the keypress was consumed and false if not. -->\n      <method name=\"handleKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          this.oneOffSearchButtons.handleKeyPress(aEvent, this.matchCount,\n                                                  !this._isFirstResultHeuristic,\n                                                  gBrowser.userTypedValue);\n          return aEvent.defaultPrevented && !aEvent.urlbarDeferred;\n        ]]></body>\n      </method>\n\n      <!-- This is called when a one-off is clicked and when \"search in new tab\"\n           is selected from a one-off context menu. -->\n      <method name=\"handleOneOffSearch\">\n        <parameter name=\"event\"/>\n        <parameter name=\"engine\"/>\n        <parameter name=\"where\"/>\n        <parameter name=\"params\"/>\n        <body><![CDATA[\n          this.input.handleCommand(event, where, params);\n        ]]></body>\n      </method>\n\n      <!-- Result listitems call this to determine which search engine they\n           should show in their labels and include in their url attributes. -->\n      <property name=\"overrideSearchEngineName\" readonly=\"true\">\n        <getter><![CDATA[\n          let button = this.oneOffSearchButtons.selectedButton;\n          return button && button.engine && button.engine.name;\n        ]]></getter>\n      </property>\n\n      <method name=\"createResultLabel\">\n        <parameter name=\"item\"/>\n        <parameter name=\"proposedLabel\"/>\n        <body>\n          <![CDATA[\n            let parts = [proposedLabel];\n\n            let action = this.input._parseActionUrl(item.getAttribute(\"url\"));\n            if (action) {\n              switch (action.type) {\n              case \"searchengine\":\n                parts = [\n                  action.params.searchSuggestion || action.params.searchQuery,\n                  action.params.engineName,\n                ];\n                break;\n              case \"switchtab\":\n              case \"remotetab\":\n                parts = [\n                  item.getAttribute(\"title\"),\n                  item.getAttribute(\"displayurl\"),\n                ];\n                break;\n              }\n            }\n\n            let types = item.getAttribute(\"type\").split(/\\s+/);\n            let type = types.find(t => t != \"action\" && t != \"heuristic\");\n            try {\n              // Some types intentionally do not map to strings, which is not\n              // an error.\n              parts.push(this._bundle.GetStringFromName(type + \"ResultLabel\"));\n            } catch (e) {}\n\n            return parts.filter(str => str).join(\" \");\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"onResultsAdded\">\n        <body>\n          <![CDATA[\n            // If nothing is selected yet, select the first result if it is a\n            // pre-selected \"heuristic\" result.  (See UnifiedComplete.js.)\n            let selectHeuristic =\n              this.selectedIndex == -1 && this._isFirstResultHeuristic;\n            if (selectHeuristic) {\n              this.input.controller.setInitiallySelectedIndex(0);\n            }\n\n            // If this is the heuristic result of a new search, format its\n            // search alias in the input or remove the formatting of the\n            // previous alias, as necessary.  We need to check selectHeuristic\n            // because the result may have already been added but only now is\n            // being selected, and we need to check gotResultForCurrentQuery\n            // because the result may be from the previous search and already\n            // selected and is now being reused.\n            if (selectHeuristic || !this.input.gotResultForCurrentQuery) {\n              this.input.formatValue();\n\n              // Also, hide the one-off search buttons if the user is using, or\n              // starting to use, an \"@engine\" search engine alias, or typed\n              // only the search restriction character.\n              let trimmedValue = this.input.value.trim();\n              this.toggleOneOffSearches(\n                trimmedValue[0] != \"@\" &&\n                (trimmedValue[0] != UrlbarTokenizer.RESTRICT.SEARCH ||\n                 trimmedValue.length != 1)\n              );\n            }\n\n            if (this.matchCount > 0) {\n              // If this is the first time we get the result from the current\n              // search and we are not in the private context, we can speculatively\n              // connect to the intended site as a performance optimization.\n              if (!this.input.gotResultForCurrentQuery &&\n                  !this.input.inPrivateContext) {\n                let firstStyle = this.input.mController.getStyleAt(0);\n                if (firstStyle.includes(\"autofill\")) {\n                  let uri = this.input.mController.getFinalCompleteValueAt(0);\n                  UrlbarUtils.setupSpeculativeConnection(uri, window);\n                } else if (firstStyle.includes(\"searchengine\") &&\n                          this.input.browserSearchSuggestEnabled &&\n                          this.input.urlbarSearchSuggestEnabled) {\n                  // Preconnect to the current search engine only if the search\n                  // suggestions are enabled.\n                  let engine = Services.search.defaultEngine;\n                  UrlbarUtils.setupSpeculativeConnection(engine, window);\n                }\n              }\n\n              // When a result is present the footer should always be visible.\n              this.footer.collapsed = false;\n            }\n\n            this.input.tabScrolling = true;\n            this.input.gotResultForCurrentQuery = true;\n            this.input.replaySafeDeferredKeyEvents();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_onSearchBegin\">\n        <body><![CDATA[\n          // Set the selected index to 0 (heuristic) until a result comes back\n          // and we can evaluate it better.\n          //\n          // This is required to properly manage delayed handleEnter:\n          // 1. if a search starts we set selectedIndex to 0 here, and it will\n          //    be updated by onResultsAdded. Since selectedIndex is 0,\n          //    handleEnter will delay the action if a result didn't arrive yet.\n          // 2. if a search doesn't start (for example if autocomplete is\n          //    disabled), this won't be called, and the selectedIndex will be\n          //    the default -1 value. Then handleEnter will know it should not\n          //    delay the action, cause a result wont't ever arrive.\n          this.input.controller.setInitiallySelectedIndex(0);\n\n          // Since we are starting a new search, reset the currently selected\n          // one-off button, to cover those cases where the oneoff buttons\n          // binding won't receive an actual DOM event. For example, a search\n          // could be started without an actual input event, and the popup may\n          // not have been closed from the previous search.\n          this.oneOffSearchButtons.selectedButton = null;\n        ]]></body>\n      </method>\n\n      <field name=\"_addonIframe\">null</field>\n      <field name=\"_addonIframeOwner\">null</field>\n      <field name=\"_addonIframeOverriddenFunctionsByName\">{}</field>\n\n      <!-- These methods must be overridden and properly handled by the API\n           runtime so that it doesn't break the popup.  If any of these methods\n           is not overridden, then initAddonIframe should throw. -->\n      <field name=\"_addonIframeOverrideFunctionNames\">[\n        \"_invalidate\",\n      ]</field>\n\n      <field name=\"_addonIframeHiddenAnonids\">[\n        \"search-suggestions-notification\",\n        \"richlistbox\",\n        \"one-off-search-buttons\",\n      ]</field>\n      <field name=\"_addonIframeHiddenDisplaysByAnonid\">{}</field>\n\n      <method name=\"initAddonIframe\">\n        <parameter name=\"owner\"/>\n        <parameter name=\"overrides\"/>\n        <body><![CDATA[\n          if (this._addonIframeOwner) {\n            // Another add-on has already requested the iframe.  Return null to\n            // signal to the calling add-on that it should not take over the\n            // popup.  First add-on wins for now.\n            return null;\n          }\n          // Make sure all overrides are provided before doing anything.\n          for (let name of this._addonIframeOverrideFunctionNames) {\n            if (typeof(overrides[name]) != \"function\") {\n              throw new Error(\n                \"Override for method '\" + name + \"' must be given\"\n              );\n            }\n          }\n          // OK, insert the iframe.\n          this._addonIframeOwner = owner;\n          this._addonIframe = this._makeAddonIframe();\n          this._addonIframeOverriddenFunctionsByName = {};\n          for (let name of this._addonIframeOverrideFunctionNames) {\n            this._addonIframeOverriddenFunctionsByName[name] = this[name];\n            this[name] = overrides[name];\n          }\n          return this._addonIframe;\n        ]]></body>\n      </method>\n\n      <method name=\"destroyAddonIframe\">\n        <parameter name=\"owner\"/>\n        <body><![CDATA[\n          if (this._addonIframeOwner != owner) {\n            throw new Error(\"You're not the iframe owner\");\n          }\n          this._addonIframeOwner = null;\n          this._addonIframe.remove();\n          this._addonIframe = null;\n          for (let anonid of this._addonIframeHiddenAnonids) {\n            let child = document.getAnonymousElementByAttribute(\n              this, \"anonid\", anonid\n            );\n            child.style.display =\n              this._addonIframeHiddenDisplaysByAnonid[anonid];\n          }\n          for (let name in this._addonIframeOverriddenFunctionsByName) {\n            this[name] = this._addonIframeOverriddenFunctionsByName[name];\n          }\n          this._addonIframeOverriddenFunctionsByName = {};\n        ]]></body>\n      </method>\n\n      <method name=\"_makeAddonIframe\">\n        <body><![CDATA[\n          this._addonIframeHiddenDisplaysByAnonid = {};\n          for (let anonid of this._addonIframeHiddenAnonids) {\n            let child = document.getAnonymousElementByAttribute(\n              this, \"anonid\", anonid\n            );\n            this._addonIframeHiddenDisplaysByAnonid[anonid] =\n              child.style.display;\n            child.style.display = \"none\";\n          }\n          let iframe = document.createXULElement(\"iframe\");\n          iframe.setAttribute(\"type\", \"content\");\n          iframe.setAttribute(\"flex\", \"1\");\n          iframe.style.transition = \"height 100ms\";\n          this.appendChild(iframe);\n          return iframe;\n        ]]></body>\n      </method>\n\n    </implementation>\n    <handlers>\n\n      <handler event=\"SelectedOneOffButtonChanged\"><![CDATA[\n        // Update all searchengine result items to use the newly selected\n        // engine.\n        for (let item of this.richlistbox.children) {\n          if (item.collapsed) {\n            break;\n          }\n          let url = item.getAttribute(\"url\");\n          if (url) {\n            let action = item._parseActionUrl(url);\n            if (action && action.type == \"searchengine\") {\n              item._adjustAcItem();\n            }\n          }\n        }\n\n        // If the selection moved from the results to the one-off settings\n        // button, then call formatValue to remove the formatting of the search\n        // alias in the input, if any.  In all other cases the alias formatting\n        // is removed when the input's value setter calls formatValue, but in\n        // this specific case, at the time that formatValue is called,\n        // oneOffSearchButtons.selectedButton is still null, so the formatting\n        // is not removed.  The settings button is selected right after that.\n        if (this.oneOffSearchButtons.selectedButton ==\n              this.oneOffSearchButtons.settingsButtonCompact &&\n            (!event.detail || !event.detail.previousSelectedButton)) {\n          this.input.formatValue();\n        }\n      ]]></handler>\n\n      <handler event=\"mousedown\"><![CDATA[\n        // Required to make the xul:label.text-link elements in the search\n        // suggestions notification work correctly when clicked on Linux.\n        // This is copied from the mousedown handler in\n        // browser-search-autocomplete-result-popup, which apparently had a\n        // similar problem.\n        event.preventDefault();\n\n        if (event.button == 2) {\n          // Right mouse button currently allows to select.\n          this.input.userSelectionBehavior = \"rightClick\";\n          // Ignore right-clicks.\n          return;\n        }\n\n        if (!UrlbarPrefs.get(\"speculativeConnect.enabled\")) {\n          return;\n        }\n\n        // Ensure the user is clicking on an url instead of other buttons\n        // on the popup.\n        let elt = event.originalTarget;\n        while (elt && elt.localName != \"richlistitem\" && elt != this) {\n          elt = elt.parentNode;\n        }\n        if (!elt || elt.localName != \"richlistitem\") {\n          return;\n        }\n        // The user might click on a ghost entry which was removed because of\n        // the coming new results.\n        if (this.input.controller.matchCount <= this.selectedIndex) {\n          return;\n        }\n\n        // Whitelist the cases that we want to speculative connect, and ignore\n        // other moz-action uris or fancy protocols.\n        // Note that it's likely we've speculatively connected to the first\n        // url because it is a heuristic \"autofill\" result (see bug 1348275).\n        // \"moz-action:searchengine\" is also the same case. (see bug 1355443)\n        // So we won't duplicate the effort here.\n        let url = this.input.controller.getFinalCompleteValueAt(this.selectedIndex);\n        if (url.startsWith(\"http\") && this.selectedIndex > 0) {\n          UrlbarUtils.setupSpeculativeConnection(url, window);\n        } else if (url.startsWith(\"moz-action:remotetab\")) {\n          let action = PlacesUtils.parseActionUrl(url);\n          if (action && action.params.url) {\n            UrlbarUtils.setupSpeculativeConnection(action.params.url, window);\n          }\n        }\n      ]]></handler>\n\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"menu.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- import-globals-from controller.js -->\n\n<bindings id=\"placesMenuBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"places-popup-base\"\n           extends=\"chrome://global/content/bindings/popup.xml#popup\">\n    <content>\n      <xul:hbox flex=\"1\">\n        <xul:vbox class=\"menupopup-drop-indicator-bar\" hidden=\"true\">\n          <xul:image class=\"menupopup-drop-indicator\" mousethrough=\"always\"/>\n        </xul:vbox>\n        <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                            smoothscroll=\"false\">\n          <children/>\n        </xul:arrowscrollbox>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n\n      <field name=\"AppConstants\" readonly=\"true\">\n        (ChromeUtils.import(\"resource://gre/modules/AppConstants.jsm\", {})).AppConstants;\n      </field>\n\n      <field name=\"_indicatorBar\">\n        document.getAnonymousElementByAttribute(this, \"class\",\n                                                \"menupopup-drop-indicator-bar\");\n      </field>\n\n      <field name=\"_scrollBox\">\n        document.getAnonymousElementByAttribute(this, \"class\",\n                                                \"popup-internal-box\");\n      </field>\n\n      <!-- This is the view that manage the popup -->\n      <field name=\"_rootView\">PlacesUIUtils.getViewForNode(this);</field>\n\n      <!-- Check if we should hide the drop indicator for the target -->\n      <method name=\"_hideDropIndicator\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let target = aEvent.target;\n\n          // Don't draw the drop indicator outside of markers or if current\n          // node is not a Places node.\n          let betweenMarkers =\n            (this._startMarker.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_FOLLOWING) &&\n            (this._endMarker.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_PRECEDING);\n\n          // Hide the dropmarker if current node is not a Places node.\n          return !(target && target._placesNode && betweenMarkers);\n        ]]></body>\n      </method>\n\n      <!-- This function returns information about where to drop when\n           dragging over this popup insertion point -->\n      <method name=\"_getDropPoint\">\n        <parameter name=\"aEvent\"/>\n          <body><![CDATA[\n            // Can't drop if the menu isn't a folder\n            let resultNode = this._placesNode;\n\n            if (!PlacesUtils.nodeIsFolder(resultNode) ||\n                this._rootView.controller.disallowInsertion(resultNode)) {\n              return null;\n            }\n\n            var dropPoint = { ip: null, folderElt: null };\n\n            // The element we are dragging over\n            let elt = aEvent.target;\n            if (elt.localName == \"menupopup\")\n              elt = elt.parentNode;\n\n            let eventY = aEvent.clientY;\n            let {y: eltY, height: eltHeight} = elt.getBoundingClientRect();\n\n            if (!elt._placesNode) {\n              // If we are dragging over a non places node drop at the end.\n              dropPoint.ip = new PlacesInsertionPoint({\n                parentId: PlacesUtils.getConcreteItemId(resultNode),\n                parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n              });\n              // We can set folderElt if we are dropping over a static menu that\n              // has an internal placespopup.\n              let isMenu = elt.localName == \"menu\" ||\n                 (elt.localName == \"toolbarbutton\" &&\n                  elt.getAttribute(\"type\") == \"menu\");\n              if (isMenu && elt.lastElementChild &&\n                  elt.lastElementChild.hasAttribute(\"placespopup\"))\n                dropPoint.folderElt = elt;\n              return dropPoint;\n            }\n\n            let tagName = PlacesUtils.nodeIsTagQuery(elt._placesNode) ?\n                            elt._placesNode.title : null;\n            if ((PlacesUtils.nodeIsFolder(elt._placesNode) &&\n                 !PlacesUIUtils.isFolderReadOnly(elt._placesNode)) ||\n                PlacesUtils.nodeIsTagQuery(elt._placesNode)) {\n              // This is a folder or a tag container.\n              if (eventY - eltY < eltHeight * 0.20) {\n                // If mouse is in the top part of the element, drop above folder.\n                dropPoint.ip = new PlacesInsertionPoint({\n                  parentId: PlacesUtils.getConcreteItemId(resultNode),\n                  parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n                  orientation: Ci.nsITreeView.DROP_BEFORE,\n                  tagName,\n                  dropNearNode: elt._placesNode,\n                });\n                return dropPoint;\n              } else if (eventY - eltY < eltHeight * 0.80) {\n                // If mouse is in the middle of the element, drop inside folder.\n                dropPoint.ip = new PlacesInsertionPoint({\n                  parentId: PlacesUtils.getConcreteItemId(elt._placesNode),\n                  parentGuid: PlacesUtils.getConcreteItemGuid(elt._placesNode),\n                  tagName,\n                });\n                dropPoint.folderElt = elt;\n                return dropPoint;\n              }\n            } else if (eventY - eltY <= eltHeight / 2) {\n              // This is a non-folder node or a readonly folder.\n              // If the mouse is above the middle, drop above this item.\n              dropPoint.ip = new PlacesInsertionPoint({\n                parentId: PlacesUtils.getConcreteItemId(resultNode),\n                parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n                orientation: Ci.nsITreeView.DROP_BEFORE,\n                tagName,\n                dropNearNode: elt._placesNode,\n              });\n              return dropPoint;\n            }\n\n            // Drop below the item.\n            dropPoint.ip = new PlacesInsertionPoint({\n              parentId: PlacesUtils.getConcreteItemId(resultNode),\n              parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n              orientation: Ci.nsITreeView.DROP_AFTER,\n              tagName,\n              dropNearNode: elt._placesNode,\n            });\n            return dropPoint;\n        ]]></body>\n      </method>\n\n      <!-- Sub-menus should be opened when the mouse drags over them, and closed\n           when the mouse drags off.  The overFolder object manages opening and\n           closing of folders when the mouse hovers. -->\n      <field name=\"_overFolder\"><![CDATA[({\n        _self: this,\n        _folder: {elt: null,\n                  openTimer: null,\n                  hoverTime: 350,\n                  closeTimer: null},\n        _closeMenuTimer: null,\n\n        get elt() {\n          return this._folder.elt;\n        },\n        set elt(val) {\n          return this._folder.elt = val;\n        },\n\n        get openTimer() {\n          return this._folder.openTimer;\n        },\n        set openTimer(val) {\n          return this._folder.openTimer = val;\n        },\n\n        get hoverTime() {\n          return this._folder.hoverTime;\n        },\n        set hoverTime(val) {\n          return this._folder.hoverTime = val;\n        },\n\n        get closeTimer() {\n          return this._folder.closeTimer;\n        },\n        set closeTimer(val) {\n          return this._folder.closeTimer = val;\n        },\n\n        get closeMenuTimer() {\n          return this._closeMenuTimer;\n        },\n        set closeMenuTimer(val) {\n          return this._closeMenuTimer = val;\n        },\n\n        setTimer: function OF__setTimer(aTime) {\n          var timer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n          timer.initWithCallback(this, aTime, timer.TYPE_ONE_SHOT);\n          return timer;\n        },\n\n        notify: function OF__notify(aTimer) {\n          // Function to process all timer notifications.\n\n          if (aTimer == this._folder.openTimer) {\n            // Timer to open a submenu that's being dragged over.\n            this._folder.elt.lastElementChild.setAttribute(\"autoopened\", \"true\");\n            this._folder.elt.lastElementChild.openPopup();\n            this._folder.openTimer = null;\n          } else if (aTimer == this._folder.closeTimer) {\n            // Timer to close a submenu that's been dragged off of.\n            // Only close the submenu if the mouse isn't being dragged over any\n            // of its child menus.\n            var draggingOverChild = PlacesControllerDragHelper\n                                    .draggingOverChildNode(this._folder.elt);\n            if (draggingOverChild)\n              this._folder.elt = null;\n            this.clear();\n\n            // Close any parent folders which aren't being dragged over.\n            // (This is necessary because of the above code that keeps a folder\n            // open while its children are being dragged over.)\n            if (!draggingOverChild)\n              this.closeParentMenus();\n          } else if (aTimer == this.closeMenuTimer) {\n            // Timer to close this menu after the drag exit.\n            var popup = this._self;\n            // if we are no more dragging we can leave the menu open to allow\n            // for better D&D bookmark organization\n            if (PlacesControllerDragHelper.getSession() &&\n                !PlacesControllerDragHelper.draggingOverChildNode(popup.parentNode)) {\n              popup.hidePopup();\n              // Close any parent menus that aren't being dragged over;\n              // otherwise they'll stay open because they couldn't close\n              // while this menu was being dragged over.\n              this.closeParentMenus();\n            }\n            this._closeMenuTimer = null;\n          }\n        },\n\n        //  Helper function to close all parent menus of this menu,\n        //  as long as none of the parent's children are currently being\n        //  dragged over.\n        closeParentMenus: function OF__closeParentMenus() {\n          var popup = this._self;\n          var parent = popup.parentNode;\n          while (parent) {\n            if (parent.localName == \"menupopup\" && parent._placesNode) {\n              if (PlacesControllerDragHelper.draggingOverChildNode(parent.parentNode))\n                break;\n              parent.hidePopup();\n            }\n            parent = parent.parentNode;\n          }\n        },\n\n        //  The mouse is no longer dragging over the stored menubutton.\n        //  Close the menubutton, clear out drag styles, and clear all\n        //  timers for opening/closing it.\n        clear: function OF__clear() {\n          if (this._folder.elt && this._folder.elt.lastElementChild) {\n            if (!this._folder.elt.lastElementChild.hasAttribute(\"dragover\"))\n              this._folder.elt.lastElementChild.hidePopup();\n            // remove menuactive style\n            this._folder.elt.removeAttribute(\"_moz-menuactive\");\n            this._folder.elt = null;\n          }\n          if (this._folder.openTimer) {\n            this._folder.openTimer.cancel();\n            this._folder.openTimer = null;\n          }\n          if (this._folder.closeTimer) {\n            this._folder.closeTimer.cancel();\n            this._folder.closeTimer = null;\n          }\n        },\n      })]]></field>\n\n      <method name=\"_cleanupDragDetails\">\n        <body><![CDATA[\n          // Called on dragend and drop.\n          PlacesControllerDragHelper.currentDropTarget = null;\n          this._rootView._draggedElt = null;\n          this.removeAttribute(\"dragover\");\n          this.removeAttribute(\"dragstart\");\n          this._indicatorBar.hidden = true;\n        ]]></body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"DOMMenuItemActive\"><![CDATA[\n        let elt = event.target;\n        if (elt.parentNode != this)\n          return;\n\n        if (this.AppConstants.platform === \"macosx\") {\n          // XXX: The following check is a temporary hack until bug 420033 is\n          // resolved.\n          let parentElt = elt.parent;\n          while (parentElt) {\n            if (parentElt.id == \"bookmarksMenuPopup\" ||\n                parentElt.id == \"goPopup\")\n              return;\n\n            parentElt = parentElt.parentNode;\n          }\n        }\n\n        if (window.XULBrowserWindow) {\n          let placesNode = elt._placesNode;\n\n          var linkURI;\n          if (placesNode && PlacesUtils.nodeIsURI(placesNode))\n            linkURI = placesNode.uri;\n          else if (elt.hasAttribute(\"targetURI\"))\n            linkURI = elt.getAttribute(\"targetURI\");\n\n          if (linkURI)\n            window.XULBrowserWindow.setOverLink(linkURI, null);\n        }\n      ]]></handler>\n\n      <handler event=\"DOMMenuItemInactive\"><![CDATA[\n        let elt = event.target;\n        if (elt.parentNode != this)\n          return;\n\n        if (window.XULBrowserWindow)\n          window.XULBrowserWindow.setOverLink(\"\", null);\n      ]]></handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        let elt = event.target;\n        if (!elt._placesNode)\n          return;\n\n        let draggedElt = elt._placesNode;\n\n        // Force a copy action if parent node is a query or we are dragging a\n        // not-removable node.\n        if (!this._rootView.controller.canMoveNode(draggedElt))\n          event.dataTransfer.effectAllowed = \"copyLink\";\n\n        // Activate the view and cache the dragged element.\n        this._rootView._draggedElt = draggedElt;\n        this._rootView.controller.setDataTransfer(event);\n        this.setAttribute(\"dragstart\", \"true\");\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"drop\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = event.target;\n\n        let dropPoint = this._getDropPoint(event);\n        if (dropPoint && dropPoint.ip) {\n          PlacesControllerDragHelper.onDrop(dropPoint.ip, event.dataTransfer)\n                                    .catch(Cu.reportError);\n          event.preventDefault();\n        }\n\n        this._cleanupDragDetails();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = event.target;\n        let dt = event.dataTransfer;\n\n        let dropPoint = this._getDropPoint(event);\n        if (!dropPoint || !dropPoint.ip ||\n            !PlacesControllerDragHelper.canDrop(dropPoint.ip, dt)) {\n          this._indicatorBar.hidden = true;\n          event.stopPropagation();\n          return;\n        }\n\n        // Mark this popup as being dragged over.\n        this.setAttribute(\"dragover\", \"true\");\n\n        if (dropPoint.folderElt) {\n          // We are dragging over a folder.\n          // _overFolder should take the care of opening it on a timer.\n          if (this._overFolder.elt &&\n              this._overFolder.elt != dropPoint.folderElt) {\n            // We are dragging over a new folder, let's clear old values\n            this._overFolder.clear();\n          }\n          if (!this._overFolder.elt) {\n            this._overFolder.elt = dropPoint.folderElt;\n            // Create the timer to open this folder.\n            this._overFolder.openTimer = this._overFolder\n                                             .setTimer(this._overFolder.hoverTime);\n          }\n          // Since we are dropping into a folder set the corresponding style.\n          dropPoint.folderElt.setAttribute(\"_moz-menuactive\", true);\n        } else {\n          // We are not dragging over a folder.\n          // Clear out old _overFolder information.\n          this._overFolder.clear();\n        }\n\n        // Autoscroll the popup strip if we drag over the scroll buttons.\n        let anonid = event.originalTarget.getAttribute(\"anonid\");\n        let scrollDir = 0;\n        if (anonid == \"scrollbutton-up\") {\n          scrollDir = -1;\n        } else if (anonid == \"scrollbutton-down\") {\n          scrollDir = 1;\n        }\n        if (scrollDir != 0) {\n          this._scrollBox.scrollByIndex(scrollDir, true);\n        }\n\n        // Check if we should hide the drop indicator for this target.\n        if (dropPoint.folderElt || this._hideDropIndicator(event)) {\n          this._indicatorBar.hidden = true;\n          event.preventDefault();\n          event.stopPropagation();\n          return;\n        }\n\n        // We should display the drop indicator relative to the arrowscrollbox.\n        let scrollRect = this._scrollBox.getBoundingClientRect();\n        let newMarginTop = 0;\n        if (scrollDir == 0) {\n          let elt = this.firstElementChild;\n          while (elt && event.screenY > elt.screenY +\n                                        elt.getBoundingClientRect().height / 2)\n            elt = elt.nextElementSibling;\n          newMarginTop = elt ? elt.screenY - this._scrollBox.screenY :\n                               scrollRect.height;\n        } else if (scrollDir == 1) {\n          newMarginTop = scrollRect.height;\n        }\n\n        // Set the new marginTop based on arrowscrollbox.\n        newMarginTop += scrollRect.y - this._scrollBox.getBoundingClientRect().y;\n        this._indicatorBar.firstElementChild.style.marginTop = newMarginTop + \"px\";\n        this._indicatorBar.hidden = false;\n\n        event.preventDefault();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragexit\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = null;\n        this.removeAttribute(\"dragover\");\n\n        // If we have not moved to a valid new target clear the drop indicator\n        // this happens when moving out of the popup.\n        let target = event.relatedTarget;\n        if (!target || !this.contains(target))\n          this._indicatorBar.hidden = true;\n\n        // Close any folder being hovered over\n        if (this._overFolder.elt) {\n          this._overFolder.closeTimer = this._overFolder\n                                            .setTimer(this._overFolder.hoverTime);\n        }\n\n        // The autoopened attribute is set when this folder was automatically\n        // opened after the user dragged over it.  If this attribute is set,\n        // auto-close the folder on drag exit.\n        // We should also try to close this popup if the drag has started\n        // from here, the timer will check if we are dragging over a child.\n        if (this.hasAttribute(\"autoopened\") ||\n            this.hasAttribute(\"dragstart\")) {\n          this._overFolder.closeMenuTimer = this._overFolder\n                                                .setTimer(this._overFolder.hoverTime);\n        }\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragend\"><![CDATA[\n        this._cleanupDragDetails();\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n  <!-- Most of this is copied from the arrowpanel binding in popup.xml -->\n  <binding id=\"places-popup-arrow\"\n           extends=\"chrome://browser/content/places/menu.xml#places-popup-base\">\n    <content flip=\"both\" side=\"top\" position=\"bottomcenter topright\">\n      <xul:vbox anonid=\"container\" class=\"panel-arrowcontainer\" flex=\"1\"\n               xbl:inherits=\"side,panelopen\">\n        <xul:box anonid=\"arrowbox\" class=\"panel-arrowbox\">\n          <xul:image anonid=\"arrow\" class=\"panel-arrow\" xbl:inherits=\"side\"/>\n        </xul:box>\n        <xul:box class=\"panel-arrowcontent\" xbl:inherits=\"side,align,dir,orient,pack\" flex=\"1\">\n          <xul:vbox class=\"menupopup-drop-indicator-bar\" hidden=\"true\">\n            <xul:image class=\"menupopup-drop-indicator\" mousethrough=\"always\"/>\n          </xul:vbox>\n          <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                              smoothscroll=\"false\">\n            <children/>\n          </xul:arrowscrollbox>\n        </xul:box>\n      </xul:vbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this.style.pointerEvents = \"none\";\n      ]]></constructor>\n      <method name=\"adjustArrowPosition\">\n        <body><![CDATA[\n          var arrow = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrow\");\n\n          var anchor = this.anchorNode;\n          if (!anchor) {\n            arrow.hidden = true;\n            return;\n          }\n\n          var container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n          var arrowbox = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\");\n\n          var position = this.alignmentPosition;\n          var offset = this.alignmentOffset;\n\n          this.setAttribute(\"arrowposition\", position);\n\n          // if this panel has a \"sliding\" arrow, we may have previously set margins...\n          arrowbox.style.removeProperty(\"transform\");\n          if (position.indexOf(\"start_\") == 0 || position.indexOf(\"end_\") == 0) {\n            container.orient = \"horizontal\";\n            arrowbox.orient = \"vertical\";\n            if (position.indexOf(\"_after\") > 0) {\n              arrowbox.pack = \"end\";\n            } else {\n              arrowbox.pack = \"start\";\n            }\n            arrowbox.style.transform = \"translate(0, \" + -offset + \"px)\";\n\n            // The assigned side stays the same regardless of direction.\n            let isRTL = this.matches(\":-moz-locale-dir(rtl)\");\n\n            if (position.indexOf(\"start_\") == 0) {\n              container.dir = \"reverse\";\n              this.setAttribute(\"side\", isRTL ? \"left\" : \"right\");\n            } else {\n              container.dir = \"\";\n              this.setAttribute(\"side\", isRTL ? \"right\" : \"left\");\n            }\n          } else if (position.indexOf(\"before_\") == 0 || position.indexOf(\"after_\") == 0) {\n            container.orient = \"\";\n            arrowbox.orient = \"\";\n            if (position.indexOf(\"_end\") > 0) {\n              arrowbox.pack = \"end\";\n            } else {\n              arrowbox.pack = \"start\";\n            }\n            arrowbox.style.transform = \"translate(\" + -offset + \"px, 0)\";\n\n            if (position.indexOf(\"before_\") == 0) {\n              container.dir = \"reverse\";\n              this.setAttribute(\"side\", \"bottom\");\n            } else {\n              container.dir = \"\";\n              this.setAttribute(\"side\", \"top\");\n            }\n          }\n\n          arrow.hidden = false;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\"><![CDATA[\n        this.adjustArrowPosition();\n        this.setAttribute(\"animate\", \"open\");\n      ]]></handler>\n      <handler event=\"popupshown\" phase=\"target\"><![CDATA[\n        this.setAttribute(\"panelopen\", \"true\");\n        let disablePointerEvents;\n        if (!this.hasAttribute(\"disablepointereventsfortransition\")) {\n          let container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n          let cs = getComputedStyle(container);\n          let transitionProp = cs.transitionProperty;\n          let transitionTime = parseFloat(cs.transitionDuration);\n          disablePointerEvents = (transitionProp.includes(\"transform\") ||\n                                  transitionProp == \"all\") &&\n                                 transitionTime > 0;\n          this.setAttribute(\"disablepointereventsfortransition\", disablePointerEvents);\n        } else {\n          disablePointerEvents = this.getAttribute(\"disablepointereventsfortransition\") == \"true\";\n        }\n        if (!disablePointerEvents) {\n          this.style.removeProperty(\"pointer-events\");\n        }\n      ]]></handler>\n      <handler event=\"transitionend\"><![CDATA[\n        if (event.originalTarget.getAttribute(\"anonid\") == \"container\" &&\n            (event.propertyName == \"transform\" || event.propertyName == \"-moz-window-transform\")) {\n          this.style.removeProperty(\"pointer-events\");\n        }\n      ]]></handler>\n      <handler event=\"popuphiding\" phase=\"target\"><![CDATA[\n        this.setAttribute(\"animate\", \"cancel\");\n      ]]></handler>\n      <handler event=\"popuphidden\" phase=\"target\"><![CDATA[\n        this.removeAttribute(\"panelopen\");\n        if (this.getAttribute(\"disablepointereventsfortransition\") == \"true\") {\n          this.style.pointerEvents = \"none\";\n        }\n        this.removeAttribute(\"animate\");\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"autocomplete.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"autocompleteBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"autocomplete\"\n           extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content sizetopopup=\"pref\">\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\">\n        <html:input anonid=\"input\" class=\"textbox-input\"\n                    allowevents=\"true\"\n                    autocomplete=\"off\"\n                    xbl:inherits=\"value,type=inputtype,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,mozactionhint\"/>\n      </xul:moz-input-box>\n      <xul:popupset anonid=\"popupset\" class=\"autocomplete-result-popupset\"/>\n    </content>\n\n    <implementation implements=\"nsIAutoCompleteInput, nsIDOMXULMenuListElement\">\n      <field name=\"mController\">null</field>\n      <field name=\"mSearchNames\">null</field>\n      <field name=\"mIgnoreInput\">false</field>\n      <field name=\"noRollupOnEmptySearch\">false</field>\n\n      <field name=\"_searchBeginHandler\">null</field>\n      <field name=\"_searchCompleteHandler\">null</field>\n      <field name=\"_textEnteredHandler\">null</field>\n      <field name=\"_textRevertedHandler\">null</field>\n\n      <constructor><![CDATA[\n        this.mController = Cc[\"@mozilla.org/autocomplete/controller;1\"].\n          getService(Ci.nsIAutoCompleteController);\n\n        this._searchBeginHandler = this.initEventHandler(\"searchbegin\");\n        this._searchCompleteHandler = this.initEventHandler(\"searchcomplete\");\n        this._textEnteredHandler = this.initEventHandler(\"textentered\");\n        this._textRevertedHandler = this.initEventHandler(\"textreverted\");\n      ]]></constructor>\n\n      <!-- =================== nsIAutoCompleteInput =================== -->\n\n      <field name=\"_popup\">null</field>\n      <property name=\"popup\" readonly=\"true\">\n        <getter><![CDATA[\n          // Memoize the result in a field rather than replacing this property,\n          // so that it can be reset along with the binding.\n          if (this._popup) {\n            return this._popup;\n          }\n\n          let popup = null;\n          let popupId = this.getAttribute(\"autocompletepopup\");\n          if (popupId) {\n            popup = document.getElementById(popupId);\n          }\n          if (!popup) {\n            popup = document.createXULElement(\"panel\", { is: \"autocomplete-richlistbox-popup\" });\n            popup.setAttribute(\"type\", \"autocomplete-richlistbox\");\n            popup.setAttribute(\"noautofocus\", \"true\");\n\n            let popupset = document.getAnonymousElementByAttribute(this, \"anonid\", \"popupset\");\n            popupset.appendChild(popup);\n          }\n          popup.mInput = this;\n\n          return this._popup = popup;\n        ]]></getter>\n      </property>\n      <property name=\"popupElement\" readonly=\"true\"\n                onget=\"return this.popup;\"/>\n\n      <property name=\"controller\" onget=\"return this.mController;\" readonly=\"true\"/>\n\n      <property name=\"popupOpen\"\n                onget=\"return this.popup.popupOpen;\"\n                onset=\"if (val) this.openPopup(); else this.closePopup();\"/>\n\n      <property name=\"disableAutoComplete\"\n                onset=\"this.setAttribute('disableautocomplete', val); return val;\"\n                onget=\"return this.getAttribute('disableautocomplete') == 'true';\"/>\n\n      <property name=\"completeDefaultIndex\"\n                onset=\"this.setAttribute('completedefaultindex', val); return val;\"\n                onget=\"return this.getAttribute('completedefaultindex') == 'true';\"/>\n\n      <property name=\"completeSelectedIndex\"\n                onset=\"this.setAttribute('completeselectedindex', val); return val;\"\n                onget=\"return this.getAttribute('completeselectedindex') == 'true';\"/>\n\n      <property name=\"forceComplete\"\n                onset=\"this.setAttribute('forcecomplete', val); return val;\"\n                onget=\"return this.getAttribute('forcecomplete') == 'true';\"/>\n\n      <property name=\"minResultsForPopup\"\n                onset=\"this.setAttribute('minresultsforpopup', val); return val;\"\n                onget=\"var m = parseInt(this.getAttribute('minresultsforpopup')); return isNaN(m) ? 1 : m;\"/>\n\n      <property name=\"timeout\"\n                onset=\"this.setAttribute('timeout', val); return val;\"\n                onget=\"var t = parseInt(this.getAttribute('timeout')); return isNaN(t) ? 50 : t;\"/>\n\n      <property name=\"searchParam\"\n                onget=\"return this.getAttribute('autocompletesearchparam') || '';\"\n                onset=\"this.setAttribute('autocompletesearchparam', val); return val;\"/>\n\n      <property name=\"searchCount\" readonly=\"true\"\n                onget=\"this.initSearchNames(); return this.mSearchNames.length;\"/>\n\n      <property name=\"PrivateBrowsingUtils\" readonly=\"true\">\n        <getter><![CDATA[\n          let module = {};\n          ChromeUtils.import(\"resource://gre/modules/PrivateBrowsingUtils.jsm\", module);\n          Object.defineProperty(this, \"PrivateBrowsingUtils\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: module.PrivateBrowsingUtils,\n          });\n          return module.PrivateBrowsingUtils;\n        ]]></getter>\n      </property>\n\n      <property name=\"inPrivateContext\" readonly=\"true\"\n                onget=\"return this.PrivateBrowsingUtils.isWindowPrivate(window);\"/>\n\n      <property name=\"noRollupOnCaretMove\" readonly=\"true\"\n                onget=\"return this.popup.getAttribute('norolluponanchor') == 'true'\"/>\n\n      <!-- This is the maximum number of drop-down rows we get when we\n            hit the drop marker beside fields that have it (like the URLbar).-->\n      <field name=\"maxDropMarkerRows\" readonly=\"true\">14</field>\n\n      <method name=\"getSearchAt\">\n        <parameter name=\"aIndex\"/>\n        <body><![CDATA[\n          this.initSearchNames();\n          return this.mSearchNames[aIndex];\n        ]]></body>\n      </method>\n\n      <method name=\"setTextValueWithReason\">\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aReason\"/>\n        <body><![CDATA[\n          if (aReason == Ci.nsIAutoCompleteInput\n                           .TEXTVALUE_REASON_COMPLETEDEFAULT) {\n            this._textValueSetByCompleteDefault = true;\n          }\n          this.textValue = aValue;\n          this._textValueSetByCompleteDefault = false;\n        ]]></body>\n      </method>\n\n      <property name=\"textValue\">\n        <getter><![CDATA[\n          if (typeof this.onBeforeTextValueGet == \"function\") {\n            let result = this.onBeforeTextValueGet();\n            if (result) {\n              return result.value;\n            }\n          }\n          return this.value;\n        ]]></getter>\n        <setter><![CDATA[\n          if (typeof this.onBeforeTextValueSet == \"function\" &&\n              !this._textValueSetByCompleteDefault) {\n            val = this.onBeforeTextValueSet(val);\n          }\n\n          // \"input\" event is automatically dispatched by the editor if\n          // necessary.\n          this._setValueInternal(val, true);\n\n          return this.value;\n        ]]></setter>\n      </property>\n\n      <method name=\"selectTextRange\">\n        <parameter name=\"aStartIndex\"/>\n        <parameter name=\"aEndIndex\"/>\n        <body><![CDATA[\n          this.inputField.setSelectionRange(aStartIndex, aEndIndex);\n        ]]></body>\n      </method>\n\n      <method name=\"onSearchBegin\">\n        <body><![CDATA[\n          if (this.popup && typeof this.popup.onSearchBegin == \"function\")\n            this.popup.onSearchBegin();\n          if (this._searchBeginHandler)\n            this._searchBeginHandler();\n        ]]></body>\n      </method>\n\n      <method name=\"onSearchComplete\">\n        <body><![CDATA[\n          if (this.mController.matchCount == 0)\n            this.setAttribute(\"nomatch\", \"true\");\n          else\n            this.removeAttribute(\"nomatch\");\n\n          if (this.ignoreBlurWhileSearching && !this.focused) {\n            this.handleEnter();\n            this.detachController();\n          }\n\n          if (this._searchCompleteHandler)\n            this._searchCompleteHandler();\n        ]]></body>\n      </method>\n\n      <method name=\"onTextEntered\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let rv = false;\n          if (this._textEnteredHandler) {\n            rv = this._textEnteredHandler(event);\n          }\n          return rv;\n        ]]></body>\n      </method>\n\n      <method name=\"onTextReverted\">\n        <body><![CDATA[\n          if (this._textRevertedHandler)\n            return this._textRevertedHandler();\n          return false;\n        ]]></body>\n      </method>\n\n      <!-- =================== nsIDOMXULMenuListElement =================== -->\n\n      <property name=\"editable\" readonly=\"true\"\n                onget=\"return true;\" />\n\n      <property name=\"crop\"\n                onset=\"this.setAttribute('crop',val); return val;\"\n                onget=\"return this.getAttribute('crop');\"/>\n\n      <property name=\"open\"\n                onget=\"return this.getAttribute('open') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.showHistoryPopup();\n          else\n            this.closePopup();\n        ]]></setter>\n      </property>\n\n      <!-- =================== PUBLIC MEMBERS =================== -->\n\n      <field name=\"valueIsTyped\">false</field>\n      <field name=\"_textValueSetByCompleteDefault\">false</field>\n      <property name=\"value\"\n                onset=\"return this._setValueInternal(val, false);\">\n        <getter><![CDATA[\n          if (typeof this.onBeforeValueGet == \"function\") {\n            var result = this.onBeforeValueGet();\n            if (result)\n              return result.value;\n          }\n          return this.inputField.value;\n        ]]></getter>\n      </property>\n\n      <property name=\"focused\" readonly=\"true\"\n                onget=\"return this.getAttribute('focused') == 'true';\"/>\n\n      <!-- maximum number of rows to display at a time -->\n      <property name=\"maxRows\"\n                onset=\"this.setAttribute('maxrows', val); return val;\"\n                onget=\"return parseInt(this.getAttribute('maxrows')) || 0;\"/>\n\n      <!-- option to allow scrolling through the list via the tab key, rather than\n           tab moving focus out of the textbox -->\n      <property name=\"tabScrolling\"\n                onset=\"this.setAttribute('tabscrolling', val); return val;\"\n                onget=\"return this.getAttribute('tabscrolling') == 'true';\"/>\n\n      <!-- option to completely ignore any blur events while searches are\n           still going on. -->\n      <property name=\"ignoreBlurWhileSearching\"\n                onset=\"this.setAttribute('ignoreblurwhilesearching', val); return val;\"\n                onget=\"return this.getAttribute('ignoreblurwhilesearching') == 'true';\"/>\n\n      <!-- option to highlight entries that don't have any matches -->\n      <property name=\"highlightNonMatches\"\n                onset=\"this.setAttribute('highlightnonmatches', val); return val;\"\n                onget=\"return this.getAttribute('highlightnonmatches') == 'true';\"/>\n\n      <!-- =================== PRIVATE MEMBERS =================== -->\n\n      <!-- ::::::::::::: autocomplete controller ::::::::::::: -->\n\n      <method name=\"attachController\">\n        <body><![CDATA[\n          this.mController.input = this;\n        ]]></body>\n      </method>\n\n      <method name=\"detachController\">\n        <body><![CDATA[\n          if (this.mController.input == this)\n            this.mController.input = null;\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: popup opening ::::::::::::: -->\n\n      <method name=\"openPopup\">\n        <body><![CDATA[\n          if (this.focused)\n            this.popup.openAutocompletePopup(this, this);\n        ]]></body>\n      </method>\n\n      <method name=\"closePopup\">\n        <body><![CDATA[\n          this.popup.closePopup();\n        ]]></body>\n      </method>\n\n      <method name=\"showHistoryPopup\">\n        <body><![CDATA[\n          // Store our \"normal\" maxRows on the popup, so that it can reset the\n          // value when the popup is hidden.\n          this.popup._normalMaxRows = this.maxRows;\n\n          // Increase our maxRows temporarily, since we want the dropdown to\n          // be bigger in this case. The popup's popupshowing/popuphiding\n          // handlers will take care of resetting this.\n          this.maxRows = this.maxDropMarkerRows;\n\n          // Ensure that we have focus.\n          if (!this.focused)\n            this.focus();\n          this.attachController();\n          this.mController.startSearch(\"\");\n        ]]></body>\n      </method>\n\n      <method name=\"toggleHistoryPopup\">\n        <body><![CDATA[\n          if (!this.popup.popupOpen)\n            this.showHistoryPopup();\n          else\n            this.closePopup();\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: event dispatching ::::::::::::: -->\n\n      <method name=\"initEventHandler\">\n        <parameter name=\"aEventType\"/>\n        <body><![CDATA[\n          let handlerString = this.getAttribute(\"on\" + aEventType);\n          if (handlerString) {\n            return (new Function(\"eventType\", \"param\", handlerString)).bind(this, aEventType);\n          }\n          return null;\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: key handling ::::::::::::: -->\n\n      <field name=\"_selectionDetails\">null</field>\n      <method name=\"onKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          return this.handleKeyPress(aEvent);\n        ]]></body>\n      </method>\n\n      <method name=\"handleKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aOptions\"/>\n        <body><![CDATA[\n          if (aEvent.target.localName != \"textbox\")\n            return true; // Let child buttons of autocomplete take input\n\n          // Re: urlbarDeferred, see the comment in urlbarBindings.xml.\n          if (aEvent.defaultPrevented && !aEvent.urlbarDeferred) {\n            return false;\n          }\n\n          const isMac = /Mac/.test(navigator.platform);\n          var cancel = false;\n\n          // Catch any keys that could potentially move the caret. Ctrl can be\n          // used in combination with these keys on Windows and Linux; and Alt\n          // can be used on OS X, so make sure the unused one isn't used.\n          let metaKey = isMac ? aEvent.ctrlKey : aEvent.altKey;\n          if (!metaKey) {\n            switch (aEvent.keyCode) {\n              case KeyEvent.DOM_VK_LEFT:\n              case KeyEvent.DOM_VK_RIGHT:\n              case KeyEvent.DOM_VK_HOME:\n                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);\n                break;\n            }\n          }\n\n          // Handle keys that are not part of a keyboard shortcut (no Ctrl or Alt)\n          if (!aEvent.ctrlKey && !aEvent.altKey) {\n            switch (aEvent.keyCode) {\n              case KeyEvent.DOM_VK_TAB:\n                if (this.tabScrolling && this.popup.popupOpen)\n                  cancel = this.mController.handleKeyNavigation(aEvent.shiftKey ?\n                                                                KeyEvent.DOM_VK_UP :\n                                                                KeyEvent.DOM_VK_DOWN);\n                else if (this.forceComplete && this.mController.matchCount >= 1)\n                  this.mController.handleTab();\n                break;\n              case KeyEvent.DOM_VK_UP:\n              case KeyEvent.DOM_VK_DOWN:\n              case KeyEvent.DOM_VK_PAGE_UP:\n              case KeyEvent.DOM_VK_PAGE_DOWN:\n                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);\n                break;\n            }\n          }\n\n          // Handle readline/emacs-style navigation bindings on Mac.\n          if (isMac &&\n              this.popup.popupOpen &&\n              aEvent.ctrlKey &&\n              (aEvent.key === \"n\" || aEvent.key === \"p\")) {\n            const effectiveKey = (aEvent.key === \"p\") ?\n                                 KeyEvent.DOM_VK_UP :\n                                 KeyEvent.DOM_VK_DOWN;\n            cancel = this.mController.handleKeyNavigation(effectiveKey);\n          }\n\n          // Handle keys we know aren't part of a shortcut, even with Alt or\n          // Ctrl.\n          switch (aEvent.keyCode) {\n            case KeyEvent.DOM_VK_ESCAPE:\n              cancel = this.mController.handleEscape();\n              break;\n            case KeyEvent.DOM_VK_RETURN:\n              if (isMac) {\n                // Prevent the default action, since it will beep on Mac\n                if (aEvent.metaKey)\n                  aEvent.preventDefault();\n              }\n              if (this.popup.selectedIndex >= 0) {\n                this._selectionDetails = {\n                  index: this.popup.selectedIndex,\n                  kind: \"key\",\n                };\n              }\n              cancel = this.handleEnter(aEvent, aOptions);\n              break;\n            case KeyEvent.DOM_VK_DELETE:\n              if (isMac && !aEvent.shiftKey) {\n                break;\n              }\n              cancel = this.handleDelete();\n              break;\n            case KeyEvent.DOM_VK_BACK_SPACE:\n              if (isMac && aEvent.shiftKey) {\n                cancel = this.handleDelete();\n              }\n              break;\n            case KeyEvent.DOM_VK_DOWN:\n            case KeyEvent.DOM_VK_UP:\n              if (aEvent.altKey)\n                this.toggleHistoryPopup();\n              break;\n            case KeyEvent.DOM_VK_F4:\n              if (!isMac) {\n                this.toggleHistoryPopup();\n              }\n              break;\n          }\n\n          if (cancel) {\n            aEvent.stopPropagation();\n            aEvent.preventDefault();\n          }\n\n          return true;\n        ]]></body>\n      </method>\n\n      <method name=\"handleEnter\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          return this.mController.handleEnter(false, event || null);\n        ]]></body>\n      </method>\n\n      <method name=\"handleDelete\">\n        <body><![CDATA[\n          return this.mController.handleDelete();\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: miscellaneous ::::::::::::: -->\n\n      <method name=\"initSearchNames\">\n        <body><![CDATA[\n          if (!this.mSearchNames) {\n            var names = this.getAttribute(\"autocompletesearch\");\n            if (!names)\n              this.mSearchNames = [];\n            else\n              this.mSearchNames = names.split(\" \");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_focus\">\n        <!-- doesn't reset this.mController -->\n        <body><![CDATA[\n          this._dontBlur = true;\n          this.focus();\n          this._dontBlur = false;\n        ]]></body>\n      </method>\n\n      <method name=\"resetActionType\">\n        <body><![CDATA[\n          if (this.mIgnoreInput)\n            return;\n          this.removeAttribute(\"actiontype\");\n        ]]></body>\n      </method>\n\n      <method name=\"_setValueInternal\">\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aIsUserInput\"/>\n        <body><![CDATA[\n          this.mIgnoreInput = true;\n\n          if (typeof this.onBeforeValueSet == \"function\")\n            aValue = this.onBeforeValueSet(aValue);\n\n          if (typeof this.trimValue == \"function\" &&\n              !this._textValueSetByCompleteDefault)\n            aValue = this.trimValue(aValue);\n\n          this.valueIsTyped = false;\n          if (aIsUserInput) {\n            this.inputField.setUserInput(aValue);\n          } else {\n            this.inputField.value = aValue;\n          }\n\n          if (typeof this.formatValue == \"function\")\n            this.formatValue();\n\n          this.mIgnoreInput = false;\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"ValueChange\", true, true);\n          this.inputField.dispatchEvent(event);\n          return aValue;\n        ]]></body>\n      </method>\n\n      <method name=\"onInput\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this.mIgnoreInput && this.mController.input == this) {\n            this.valueIsTyped = true;\n            this.mController.handleText();\n          }\n          this.resetActionType();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"input\"><![CDATA[\n        this.onInput(event);\n      ]]></handler>\n\n      <handler event=\"keypress\" phase=\"capturing\" group=\"system\"\n               action=\"return this.onKeyPress(event);\"/>\n\n      <handler event=\"compositionstart\" phase=\"capturing\"\n               action=\"if (this.mController.input == this) this.mController.handleStartComposition();\"/>\n\n      <handler event=\"compositionend\" phase=\"capturing\"\n               action=\"if (this.mController.input == this) this.mController.handleEndComposition();\"/>\n\n      <handler event=\"focus\" phase=\"capturing\"><![CDATA[\n        this.attachController();\n        if (window.gBrowser && window.gBrowser.selectedBrowser.hasAttribute(\"usercontextid\")) {\n          this.userContextId = parseInt(window.gBrowser.selectedBrowser.getAttribute(\"usercontextid\"));\n        } else {\n          this.userContextId = 0;\n        }\n      ]]></handler>\n\n      <handler event=\"blur\" phase=\"capturing\"><![CDATA[\n        if (!this._dontBlur) {\n          if (this.forceComplete && this.mController.matchCount >= 1) {\n            // If forceComplete is requested, we need to call the enter processing\n            // on blur so the input will be forced to the closest match.\n            // Thunderbird is the only consumer of forceComplete and this is used\n            // to force an recipient's email to the exact address book entry.\n            this.mController.handleEnter(true);\n          }\n          if (!this.ignoreBlurWhileSearching)\n            this.detachController();\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autocomplete-rich-result-popup\">\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\">\n      <xul:richlistbox anonid=\"richlistbox\" class=\"autocomplete-richlistbox\" flex=\"1\"/>\n      <xul:hbox>\n        <children/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIAutoCompletePopup\">\n      <field name=\"mInput\">null</field>\n      <field name=\"mPopupOpen\">false</field>\n      <field name=\"_currentIndex\">0</field>\n\n      <constructor><![CDATA[\n        if (!this.listEvents) {\n          this.listEvents = {\n            handleEvent: event => {\n              if (!this.parentNode) {\n                return;\n              }\n\n              switch (event.type) {\n                case \"mouseup\":\n                  // Don't call onPopupClick for the scrollbar buttons, thumb,\n                  // slider, etc. If we hit the richlistbox and not a\n                  // richlistitem, we ignore the event.\n                  if (event.target.closest(\"richlistbox,richlistitem\")\n                                  .localName == \"richlistitem\") {\n                    this.onPopupClick(event);\n                  }\n                  break;\n                case \"mousemove\":\n                  if (Date.now() - this.mLastMoveTime <= 30) {\n                    return;\n                  }\n\n                  let item = event.target.closest(\"richlistbox,richlistitem\");\n\n                  // If we hit the richlistbox and not a richlistitem, we ignore\n                  // the event.\n                  if (item.localName == \"richlistbox\") {\n                    return;\n                  }\n\n                  let index = this.richlistbox.getIndexOfItem(item);\n\n                  this.mousedOverIndex = index;\n\n                  if (item.selectedByMouseOver) {\n                    this.richlistbox.selectedIndex = index;\n                  }\n\n                  this.mLastMoveTime = Date.now();\n                  break;\n              }\n            },\n          };\n          this.richlistbox.addEventListener(\"mouseup\", this.listEvents);\n          this.richlistbox.addEventListener(\"mousemove\", this.listEvents);\n        }\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        if (this.listEvents) {\n          this.richlistbox.removeEventListener(\"mouseup\", this.listEvents);\n          this.richlistbox.removeEventListener(\"mousemove\", this.listEvents);\n          delete this.listEvents;\n        }\n      ]]></destructor>\n\n      <!-- =================== nsIAutoCompletePopup =================== -->\n\n      <property name=\"input\" readonly=\"true\"\n                onget=\"return this.mInput\"/>\n\n      <property name=\"overrideValue\" readonly=\"true\"\n                onget=\"return null;\"/>\n\n      <property name=\"popupOpen\" readonly=\"true\"\n                onget=\"return this.mPopupOpen;\"/>\n\n      <method name=\"closePopup\">\n        <body>\n          <![CDATA[\n          if (this.mPopupOpen) {\n            this.hidePopup();\n            this.removeAttribute(\"width\");\n          }\n        ]]>\n        </body>\n      </method>\n\n      <!-- This is the default number of rows that we give the autocomplete\n           popup when the textbox doesn't have a \"maxrows\" attribute\n           for us to use. -->\n      <field name=\"defaultMaxRows\" readonly=\"true\">6</field>\n\n      <!-- In some cases (e.g. when the input's dropmarker button is clicked),\n           the input wants to display a popup with more rows. In that case, it\n           should increase its maxRows property and store the \"normal\" maxRows\n           in this field. When the popup is hidden, we restore the input's\n           maxRows to the value stored in this field.\n\n           This field is set to -1 between uses so that we can tell when it's\n           been set by the input and when we need to set it in the popupshowing\n           handler. -->\n      <field name=\"_normalMaxRows\">-1</field>\n\n      <property name=\"maxRows\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n          return (this.mInput && this.mInput.maxRows) || this.defaultMaxRows;\n        ]]>\n        </getter>\n      </property>\n\n      <method name=\"getNextIndex\">\n        <parameter name=\"aReverse\"/>\n        <parameter name=\"aAmount\"/>\n        <parameter name=\"aIndex\"/>\n        <parameter name=\"aMaxRow\"/>\n        <body><![CDATA[\n          if (aMaxRow < 0)\n            return -1;\n\n          var newIdx = aIndex + (aReverse ? -1 : 1) * aAmount;\n          if (aReverse && aIndex == -1 || newIdx > aMaxRow && aIndex != aMaxRow)\n            newIdx = aMaxRow;\n          else if (!aReverse && aIndex == -1 || newIdx < 0 && aIndex != 0)\n            newIdx = 0;\n\n          if (newIdx < 0 && aIndex == 0 || newIdx > aMaxRow && aIndex == aMaxRow)\n            aIndex = -1;\n          else\n            aIndex = newIdx;\n\n          return aIndex;\n        ]]></body>\n      </method>\n\n      <method name=\"onPopupClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          this.input.controller.handleEnter(true, aEvent);\n        ]]></body>\n      </method>\n\n      <property name=\"selectedIndex\"\n                onget=\"return this.richlistbox.selectedIndex;\">\n        <setter>\n          <![CDATA[\n          if (val != this.richlistbox.selectedIndex) {\n            this._previousSelectedIndex = this.richlistbox.selectedIndex;\n          }\n          this.richlistbox.selectedIndex = val;\n          // Since ensureElementIsVisible may cause an expensive Layout flush,\n          // invoke it only if there may be a scrollbar, so if we could fetch\n          // more results than we can show at once.\n          // maxResults is the maximum number of fetched results, maxRows is the\n          // maximum number of rows we show at once, without a scrollbar.\n          if (this.mPopupOpen && this.maxResults > this.maxRows) {\n            // when clearing the selection (val == -1, so selectedItem will be\n            // null), we want to scroll back to the top.  see bug #406194\n            this.richlistbox.ensureElementIsVisible(\n              this.richlistbox.selectedItem || this.richlistbox.firstElementChild);\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <field name=\"_previousSelectedIndex\">-1</field>\n      <field name=\"mLastMoveTime\">Date.now()</field>\n      <field name=\"mousedOverIndex\">-1</field>\n\n      <method name=\"onSearchBegin\">\n        <body><![CDATA[\n          this.mousedOverIndex = -1;\n\n          if (typeof this._onSearchBegin == \"function\") {\n            this._onSearchBegin();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          // until we have \"baseBinding\", (see bug #373652) this allows\n          // us to override openAutocompletePopup(), but still call\n          // the method on the base class\n          this._openAutocompletePopup(aInput, aElement);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          if (!this.mPopupOpen) {\n            // It's possible that the panel is hidden initially\n            // to avoid impacting startup / new window performance\n            aInput.popup.hidden = false;\n\n            this.mInput = aInput;\n            // clear any previous selection, see bugs 400671 and 488357\n            this.selectedIndex = -1;\n\n            var width = aElement.getBoundingClientRect().width;\n            this.setAttribute(\"width\", width > 100 ? width : 100);\n            // invalidate() depends on the width attribute\n            this._invalidate();\n\n            this.openPopup(aElement, \"after_start\", 0, 0, false, false);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"invalidate\">\n        <parameter name=\"reason\"/>\n        <body>\n          <![CDATA[\n          // Don't bother doing work if we're not even showing\n          if (!this.mPopupOpen)\n            return;\n\n          this._invalidate(reason);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_invalidate\">\n        <parameter name=\"reason\"/>\n        <body>\n          <![CDATA[\n          // collapsed if no matches\n          this.richlistbox.collapsed = (this.matchCount == 0);\n\n          // Update the richlistbox height.\n          if (this._adjustHeightRAFToken) {\n            cancelAnimationFrame(this._adjustHeightRAFToken);\n            this._adjustHeightRAFToken = null;\n          }\n\n          if (this.mPopupOpen) {\n            delete this._adjustHeightOnPopupShown;\n            this._adjustHeightRAFToken = requestAnimationFrame(() => this.adjustHeight());\n          } else {\n            this._adjustHeightOnPopupShown = true;\n          }\n\n          this._currentIndex = 0;\n          if (this._appendResultTimeout) {\n            clearTimeout(this._appendResultTimeout);\n          }\n          this._appendCurrentResult(reason);\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"maxResults\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            // This is how many richlistitems will be kept around.\n            // Note, this getter may be overridden, or instances\n            // can have the nomaxresults attribute set to have no\n            // limit.\n            if (this.getAttribute(\"nomaxresults\") == \"true\") {\n              return Infinity;\n            }\n\n            return 20;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"matchCount\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n          return Math.min(this.mInput.controller.matchCount, this.maxResults);\n          ]]>\n        </getter>\n      </property>\n\n      <method name=\"_collapseUnusedItems\">\n        <body>\n          <![CDATA[\n            let existingItemsCount = this.richlistbox.children.length;\n            for (let i = this.matchCount; i < existingItemsCount; ++i) {\n              let item = this.richlistbox.children[i];\n\n              item.collapsed = true;\n              if (typeof item._onCollapse == \"function\") {\n                item._onCollapse();\n              }\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"adjustHeight\">\n        <body>\n          <![CDATA[\n          // Figure out how many rows to show\n          let rows = this.richlistbox.children;\n          let numRows = Math.min(this.matchCount, this.maxRows, rows.length);\n\n          // Default the height to 0 if we have no rows to show\n          let height = 0;\n          if (numRows) {\n            let firstRowRect = rows[0].getBoundingClientRect();\n            if (this._rlbPadding == undefined) {\n              let style = window.getComputedStyle(this.richlistbox);\n              let paddingTop = parseInt(style.paddingTop) || 0;\n              let paddingBottom = parseInt(style.paddingBottom) || 0;\n              this._rlbPadding = paddingTop + paddingBottom;\n            }\n\n            // The class `forceHandleUnderflow` is for the item might need to\n            // handle OverUnderflow or Overflow when the height of an item will\n            // be changed dynamically.\n            for (let i = 0; i < numRows; i++) {\n              if (rows[i].classList.contains(\"forceHandleUnderflow\")) {\n                rows[i].handleOverUnderflow();\n              }\n            }\n\n            let lastRowRect = rows[numRows - 1].getBoundingClientRect();\n            // Calculate the height to have the first row to last row shown\n            height = lastRowRect.bottom - firstRowRect.top +\n                     this._rlbPadding;\n          }\n\n          let currentHeight = this.richlistbox.getBoundingClientRect().height;\n          if (height <= currentHeight) {\n            this._collapseUnusedItems();\n          }\n          this.richlistbox.style.removeProperty(\"height\");\n          // We need to get the ceiling of the calculated value to ensure that the box fully contains\n          // all of its contents and doesn't cause a scrollbar since nsIBoxObject only expects a\n          // `long`. e.g. if `height` is 99.5 the richlistbox would render at height 99px with a\n          // scrollbar for the extra 0.5px.\n          this.richlistbox.height = Math.ceil(height);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_appendCurrentResult\">\n        <parameter name=\"invalidateReason\"/>\n        <body>\n          <![CDATA[\n          var controller = this.mInput.controller;\n          var matchCount = this.matchCount;\n          var existingItemsCount = this.richlistbox.children.length;\n\n          // Process maxRows per chunk to improve performance and user experience\n          for (let i = 0; i < this.maxRows; i++) {\n            if (this._currentIndex >= matchCount) {\n              break;\n            }\n            let item;\n            let itemExists = this._currentIndex < existingItemsCount;\n\n            let originalValue, originalText, originalType;\n            let style = controller.getStyleAt(this._currentIndex);\n            let value =\n              style && style.includes(\"autofill\") ?\n              controller.getFinalCompleteValueAt(this._currentIndex) :\n              controller.getValueAt(this._currentIndex);\n            let label = controller.getLabelAt(this._currentIndex);\n            let comment = controller.getCommentAt(this._currentIndex);\n            let image = controller.getImageAt(this._currentIndex);\n            // trim the leading/trailing whitespace\n            let trimmedSearchString = controller.searchString.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n\n            let reusable = false;\n            if (itemExists) {\n              item = this.richlistbox.children[this._currentIndex];\n\n              // Url may be a modified version of value, see _adjustAcItem().\n              originalValue = item.getAttribute(\"url\") || item.getAttribute(\"ac-value\");\n              originalText = item.getAttribute(\"ac-text\");\n              originalType = item.getAttribute(\"originaltype\");\n\n              // The styles on the list which have different <content> structure and overrided\n              // _adjustAcItem() are unreusable.\n              const UNREUSEABLE_STYLES = [\n                \"autofill-profile\",\n                \"autofill-footer\",\n                \"autofill-clear-button\",\n                \"autofill-insecureWarning\",\n                \"generatedPassword\",\n                \"insecureWarning\",\n                \"loginsFooter\",\n                \"loginWithOrigin\",\n              ];\n              // Reuse the item when its style is exactly equal to the previous style or\n              // neither of their style are in the UNREUSEABLE_STYLES.\n              reusable = originalType === style ||\n                !(UNREUSEABLE_STYLES.includes(style) || UNREUSEABLE_STYLES.includes(originalType));\n            }\n\n            // If no reusable item available, then create a new item.\n            if (!reusable) {\n              let options = null;\n              switch (style) {\n                case \"autofill-profile\":\n                  options = { is: \"autocomplete-profile-listitem\" };\n                  break;\n                case \"autofill-footer\":\n                  options = { is: \"autocomplete-profile-listitem-footer\" };\n                  break;\n                case \"autofill-clear-button\":\n                  options = { is: \"autocomplete-profile-listitem-clear-button\" };\n                  break;\n                case \"autofill-insecureWarning\":\n                  options = { is: \"autocomplete-creditcard-insecure-field\" };\n                  break;\n                case \"generatedPassword\":\n                  options = { is: \"autocomplete-two-line-richlistitem\" };\n                  break;\n                case \"insecureWarning\":\n                  options = { is: \"autocomplete-richlistitem-insecure-warning\" };\n                  break;\n                case \"loginsFooter\":\n                  options = { is: \"autocomplete-richlistitem-logins-footer\" };\n                  break;\n                case \"loginWithOrigin\":\n                  options = { is: \"autocomplete-login-richlistitem\" };\n                  break;\n                default:\n                  options = { is: \"autocomplete-richlistitem\" };\n              }\n              item = document.createXULElement(\"richlistitem\", options);\n              item.className = \"autocomplete-richlistitem\";\n            }\n\n            item.setAttribute(\"dir\", this.style.direction);\n            item.setAttribute(\"ac-image\", image);\n            item.setAttribute(\"ac-value\", value);\n            item.setAttribute(\"ac-label\", label);\n            item.setAttribute(\"ac-comment\", comment);\n            item.setAttribute(\"ac-text\", trimmedSearchString);\n\n            // Completely reuse the existing richlistitem for invalidation\n            // due to new results, but only when: the item is the same, *OR*\n            // we are about to replace the currently moused-over item, to\n            // avoid surprising the user.\n            let iface = Ci.nsIAutoCompletePopup;\n            if (reusable &&\n                originalText == trimmedSearchString &&\n                invalidateReason == iface.INVALIDATE_REASON_NEW_RESULT &&\n                (originalValue == value ||\n                 this.mousedOverIndex === this._currentIndex)) {\n              // try to re-use the existing item\n              let reused = item._reuseAcItem();\n              if (reused) {\n                this._currentIndex++;\n                continue;\n              }\n            } else {\n              if (typeof item._cleanup == \"function\") {\n                item._cleanup();\n              }\n              item.setAttribute(\"originaltype\", style);\n            }\n\n            if (reusable) {\n              // Adjust only when the result's type is reusable for existing\n              // item's. Otherwise, we might insensibly call old _adjustAcItem()\n              // as new binding has not been attached yet.\n              // We don't need to worry about switching to new binding, since\n              // _adjustAcItem() will fired by its own constructor accordingly.\n              item._adjustAcItem();\n              item.collapsed = false;\n            } else if (itemExists) {\n              let oldItem = this.richlistbox.children[this._currentIndex];\n              this.richlistbox.replaceChild(item, oldItem);\n            } else {\n              this.richlistbox.appendChild(item);\n            }\n\n            this._currentIndex++;\n          }\n\n          if (typeof this.onResultsAdded == \"function\") {\n            // The items bindings may not be attached yet, so we must delay this\n            // before we can properly handle items properly without breaking\n            // the richlistbox.\n            Services.tm.dispatchToMainThread(() => this.onResultsAdded());\n          }\n\n          if (this._currentIndex < matchCount) {\n            // yield after each batch of items so that typing the url bar is\n            // responsive\n            this._appendResultTimeout = setTimeout(() => this._appendCurrentResult(), 0);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"overflowPadding\"\n                onget=\"return Number(this.getAttribute('overflowpadding'))\"\n                readonly=\"true\" />\n\n      <method name=\"selectBy\">\n        <parameter name=\"aReverse\"/>\n        <parameter name=\"aPage\"/>\n        <body>\n          <![CDATA[\n          try {\n            var amount = aPage ? 5 : 1;\n\n            // because we collapsed unused items, we can't use this.richlistbox.getRowCount(), we need to use the matchCount\n            this.selectedIndex = this.getNextIndex(aReverse, amount, this.selectedIndex, this.matchCount - 1);\n            if (this.selectedIndex == -1) {\n              this.input._focus();\n            }\n          } catch (ex) {\n            // do nothing - occasionally timer-related js errors happen here\n            // e.g. \"this.selectedIndex has no properties\", when you type fast and hit a\n            // navigation key before this popup has opened\n          }\n            ]]>\n        </body>\n      </method>\n\n      <field name=\"richlistbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"richlistbox\");\n      </field>\n\n      <property name=\"view\"\n                onget=\"return this.mInput.controller;\"\n                onset=\"return val;\"/>\n\n    </implementation>\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // If normalMaxRows wasn't already set by the input, then set it here\n        // so that we restore the correct number when the popup is hidden.\n\n        // Null-check this.mInput; see bug 1017914\n        if (this._normalMaxRows < 0 && this.mInput) {\n          this._normalMaxRows = this.mInput.maxRows;\n        }\n\n        // Set an attribute for styling the popup based on the input.\n        let inputID = \"\";\n        if (this.mInput && this.mInput.ownerDocument &&\n            this.mInput.ownerDocument.documentURIObject.schemeIs(\"chrome\")) {\n          inputID = this.mInput.id;\n          // Take care of elements with no id that are inside xbl bindings\n          if (!inputID) {\n            let bindingParent = this.mInput.ownerDocument.getBindingParent(this.mInput);\n            if (bindingParent) {\n              inputID = bindingParent.id;\n            }\n          }\n        }\n        this.setAttribute(\"autocompleteinput\", inputID);\n\n        this.mPopupOpen = true;\n      ]]></handler>\n\n      <handler event=\"popupshown\">\n        <![CDATA[\n          if (this._adjustHeightOnPopupShown) {\n            delete this._adjustHeightOnPopupShown;\n            this.adjustHeight();\n          }\n      ]]>\n      </handler>\n\n      <handler event=\"popuphiding\"><![CDATA[\n        var isListActive = true;\n        if (this.selectedIndex == -1)\n          isListActive = false;\n        this.input.controller.stopSearch();\n\n        this.removeAttribute(\"autocompleteinput\");\n        this.mPopupOpen = false;\n\n        // Reset the maxRows property to the cached \"normal\" value (if there's\n        // any), and reset normalMaxRows so that we can detect whether it was set\n        // by the input when the popupshowing handler runs.\n\n        // Null-check this.mInput; see bug 1017914\n        if (this.mInput && this._normalMaxRows > 0) {\n          this.mInput.maxRows = this._normalMaxRows;\n        }\n        this._normalMaxRows = -1;\n        // If the list was being navigated and then closed, make sure\n        // we fire accessible focus event back to textbox\n\n        // Null-check this.mInput; see bug 1017914\n        if (isListActive && this.mInput) {\n          this.mInput.mIgnoreFocus = true;\n          this.mInput._focus();\n          this.mInput.mIgnoreFocus = false;\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"general.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"generalBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"basecontrol\">\n    <implementation implements=\"nsIDOMXULControlElement\">\n      <!-- public implementation -->\n      <property name=\"disabled\" onset=\"if (val) this.setAttribute('disabled', 'true');\n                                       else this.removeAttribute('disabled');\n                                       return val;\"\n                                onget=\"return this.getAttribute('disabled') == 'true';\"/>\n      <property name=\"tabIndex\" onget=\"return parseInt(this.getAttribute('tabindex')) || 0\"\n                                onset=\"if (val) this.setAttribute('tabindex', val);\n                                       else this.removeAttribute('tabindex'); return val;\"/>\n    </implementation>\n  </binding>\n\n  <binding id=\"basetext\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <implementation>\n      <!-- public implementation -->\n      <property name=\"label\"      onset=\"this.setAttribute('label',val); return val;\"\n                                  onget=\"return this.getAttribute('label');\"/>\n      <property name=\"crop\"       onset=\"this.setAttribute('crop',val); return val;\"\n                                  onget=\"return this.getAttribute('crop');\"/>\n      <property name=\"image\"      onset=\"this.setAttribute('image',val); return val;\"\n                                  onget=\"return this.getAttribute('image');\"/>\n      <property name=\"command\"    onset=\"this.setAttribute('command',val); return val;\"\n                                  onget=\"return this.getAttribute('command');\"/>\n      <property name=\"accessKey\">\n        <getter>\n          <![CDATA[\n            return this.getAttribute(\"accesskey\");\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            // Always store on the control\n            this.setAttribute(\"accesskey\", val);\n            // If there is a label, change the accesskey on the labelElement\n            // if it's also set there\n            let labelElement = document.getElementsByAttribute(\"control\", this.id)[0];\n            if (labelElement) {\n              labelElement.setAttribute(\"accesskey\", val);\n            }\n            return val;\n          ]]>\n        </setter>\n      </property>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"popup.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"popupBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"popup\">\n    <content>\n      <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                          smoothscroll=\"false\">\n        <children/>\n      </xul:arrowscrollbox>\n    </content>\n\n    <implementation>\n      <field name=\"scrollBox\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"class\", \"popup-internal-box\");\n      </field>\n\n      <field name=\"AUTOSCROLL_INTERVAL\">25</field>\n      <field name=\"NOT_DRAGGING\">0</field>\n      <field name=\"DRAG_OVER_BUTTON\">-1</field>\n      <field name=\"DRAG_OVER_POPUP\">1</field>\n\n      <field name=\"_draggingState\">this.NOT_DRAGGING</field>\n      <field name=\"_scrollTimer\">0</field>\n\n      <method name=\"_enableDragScrolling\">\n        <!-- when overItem is true, drag started over menuitem; when false, drag\n             started while the popup was opening.\n          -->\n        <parameter name=\"overItem\"/>\n        <body>\n        <![CDATA[\n          if (!this._draggingState) {\n            this.setCaptureAlways();\n            this._draggingState = overItem ? this.DRAG_OVER_POPUP : this.DRAG_OVER_BUTTON;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_clearScrollTimer\">\n        <body>\n        <![CDATA[\n          if (this._scrollTimer) {\n            this.ownerGlobal.clearInterval(this._scrollTimer);\n            this._scrollTimer = 0;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <constructor><![CDATA[\n        // Enable the drag-to-scroll events only in menulist popups.\n        if (!this.parentNode || this.parentNode.localName != \"menulist\") {\n          return;\n        }\n\n        // XBL bindings might be constructed more than once.\n        if (this.eventListenersAdded) {\n          return;\n        }\n        this.eventListenersAdded = true;\n\n        this.addEventListener(\"popupshown\", () => {\n          // Enable drag scrolling even when the mouse wasn't used. The\n          // mousemove handler will remove it if the mouse isn't down.\n          this._enableDragScrolling(false);\n        });\n\n        this.addEventListener(\"popuphidden\", () => {\n          this._draggingState = this.NOT_DRAGGING;\n          this._clearScrollTimer();\n          this.releaseCapture();\n        });\n\n        this.addEventListener(\"mousedown\", event => {\n          if (event.button != 0) {\n            return;\n          }\n\n          if (this.state == \"open\" &&\n            (event.target.localName == \"menuitem\" ||\n              event.target.localName == \"menu\" ||\n              event.target.localName == \"menucaption\")) {\n            this._enableDragScrolling(true);\n          }\n        });\n\n        this.addEventListener(\"mouseup\", event => {\n          if (event.button != 0) {\n            return;\n          }\n\n          this._draggingState = this.NOT_DRAGGING;\n          this._clearScrollTimer();\n        });\n\n        this.addEventListener(\"mousemove\", event => {\n          if (!this._draggingState) {\n            return;\n          }\n\n          this._clearScrollTimer();\n\n          // If the user released the mouse before the popup opens, we will\n          // still be capturing, so check that the button is still pressed. If\n          // not, release the capture and do nothing else. This also handles if\n          // the dropdown was opened via the keyboard.\n          if (!(event.buttons & 1)) {\n            this._draggingState = this.NOT_DRAGGING;\n            this.releaseCapture();\n            return;\n          }\n\n          // If dragging outside the top or bottom edge of the popup, but within\n          // the popup area horizontally, scroll the list in that direction. The\n          // _draggingState flag is used to ensure that scrolling does not start\n          // until the mouse has moved over the popup first, preventing\n          // scrolling while over the dropdown button.\n          let popupRect = this.getOuterScreenRect();\n          if (event.screenX >= popupRect.left &&\n              event.screenX <= popupRect.right) {\n            if (this._draggingState == this.DRAG_OVER_BUTTON) {\n              if (event.screenY > popupRect.top &&\n                  event.screenY < popupRect.bottom) {\n                this._draggingState = this.DRAG_OVER_POPUP;\n              }\n            }\n\n            if (this._draggingState == this.DRAG_OVER_POPUP &&\n                (event.screenY <= popupRect.top ||\n                 event.screenY >= popupRect.bottom)) {\n              let scrollAmount = event.screenY <= popupRect.top ? -1 : 1;\n              this.scrollBox.scrollByIndex(scrollAmount, true);\n\n              let win = this.ownerGlobal;\n              this._scrollTimer = win.setInterval(() => {\n                this.scrollBox.scrollByIndex(scrollAmount, true);\n              }, this.AUTOSCROLL_INTERVAL);\n            }\n          }\n        });\n      ]]></constructor>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\">\n        <![CDATA[\n          var array = [];\n          var width = 0;\n          for (var menuitem = this.firstElementChild; menuitem; menuitem = menuitem.nextElementSibling) {\n            if (menuitem.localName == \"menuitem\" && menuitem.hasAttribute(\"acceltext\")) {\n              var accel = menuitem.menuAccel;\n              if (accel) {\n                array.push(accel);\n                let accelWidth = accel.getBoundingClientRect().width;\n                if (accelWidth > width) {\n                  width = accelWidth;\n                }\n              }\n            }\n          }\n          for (var i = 0; i < array.length; i++)\n            array[i].width = width;\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"panel\">\n    <implementation>\n      <field name=\"_prevFocus\">0</field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // Capture the previous focus before has a chance to get set inside the panel\n        try {\n          this._prevFocus = Cu\n                            .getWeakReference(document.commandDispatcher.focusedElement);\n          if (this._prevFocus.get())\n            return;\n        } catch (ex) { }\n\n        this._prevFocus = Cu.getWeakReference(document.activeElement);\n      ]]></handler>\n      <handler event=\"popupshown\"><![CDATA[\n        // Fire event for accessibility APIs\n        var alertEvent = document.createEvent(\"Events\");\n        alertEvent.initEvent(\"AlertActive\", true, true);\n        this.dispatchEvent(alertEvent);\n       ]]></handler>\n      <handler event=\"popuphiding\"><![CDATA[\n        try {\n          this._currentFocus = document.commandDispatcher.focusedElement;\n        } catch (e) {\n          this._currentFocus = document.activeElement;\n        }\n      ]]></handler>\n      <handler event=\"popuphidden\"><![CDATA[\n        function doFocus() {\n          // Focus was set on an element inside this panel,\n          // so we need to move it back to where it was previously\n          try {\n            let fm = Cc[\"@mozilla.org/focus-manager;1\"]\n                       .getService(Ci.nsIFocusManager);\n            fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);\n          } catch (e) {\n            prevFocus.focus();\n          }\n        }\n        var currentFocus = this._currentFocus;\n        var prevFocus = this._prevFocus ? this._prevFocus.get() : null;\n        this._currentFocus = null;\n        this._prevFocus = null;\n\n        // Avoid changing focus if focus changed while we hide the popup\n        // (This can happen e.g. if the popup is hiding as a result of a\n        // click/keypress that focused something)\n        let nowFocus;\n        try {\n          nowFocus = document.commandDispatcher.focusedElement;\n        } catch (e) {\n          nowFocus = document.activeElement;\n        }\n        if (nowFocus && nowFocus != currentFocus)\n          return;\n\n        if (prevFocus && this.getAttribute(\"norestorefocus\") != \"true\") {\n          // Try to restore focus\n          try {\n            if (document.commandDispatcher.focusedWindow != window)\n              return; // Focus has already been set to a window outside of this panel\n          } catch (ex) {}\n\n          if (!currentFocus) {\n            doFocus();\n            return;\n          }\n          while (currentFocus) {\n            if (currentFocus == this) {\n              doFocus();\n              return;\n            }\n            currentFocus = currentFocus.parentNode;\n          }\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"arrowpanel\" extends=\"chrome://global/content/bindings/popup.xml#panel\">\n    <content flip=\"both\" side=\"top\" position=\"bottomcenter topleft\" consumeoutsideclicks=\"false\">\n      <xul:vbox anonid=\"container\" class=\"panel-arrowcontainer\" flex=\"1\"\n               xbl:inherits=\"side,panelopen\">\n        <xul:box anonid=\"arrowbox\" class=\"panel-arrowbox\">\n          <xul:image anonid=\"arrow\" class=\"panel-arrow\" xbl:inherits=\"side\"/>\n        </xul:box>\n        <xul:box class=\"panel-arrowcontent\" xbl:inherits=\"side,align,dir,orient,pack\" flex=\"1\">\n          <children/>\n        </xul:box>\n      </xul:vbox>\n    </content>\n    <implementation>\n      <field name=\"_fadeTimer\">null</field>\n      <method name=\"adjustArrowPosition\">\n        <body>\n        <![CDATA[\n        var anchor = this.anchorNode;\n        if (!anchor) {\n          return;\n        }\n\n        var container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n        var arrowbox = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\");\n\n        var position = this.alignmentPosition;\n        var offset = this.alignmentOffset;\n\n        this.setAttribute(\"arrowposition\", position);\n\n        if (position.indexOf(\"start_\") == 0 || position.indexOf(\"end_\") == 0) {\n          container.orient = \"horizontal\";\n          arrowbox.orient = \"vertical\";\n          if (position.indexOf(\"_after\") > 0) {\n            arrowbox.pack = \"end\";\n          } else {\n            arrowbox.pack = \"start\";\n          }\n          arrowbox.style.transform = \"translate(0, \" + -offset + \"px)\";\n\n          // The assigned side stays the same regardless of direction.\n          var isRTL = (window.getComputedStyle(this).direction == \"rtl\");\n\n          if (position.indexOf(\"start_\") == 0) {\n            container.dir = \"reverse\";\n            this.setAttribute(\"side\", isRTL ? \"left\" : \"right\");\n          } else {\n            container.dir = \"\";\n            this.setAttribute(\"side\", isRTL ? \"right\" : \"left\");\n          }\n        } else if (position.indexOf(\"before_\") == 0 || position.indexOf(\"after_\") == 0) {\n          container.orient = \"\";\n          arrowbox.orient = \"\";\n          if (position.indexOf(\"_end\") > 0) {\n            arrowbox.pack = \"end\";\n          } else {\n            arrowbox.pack = \"start\";\n          }\n          arrowbox.style.transform = \"translate(\" + -offset + \"px, 0)\";\n\n          if (position.indexOf(\"before_\") == 0) {\n            container.dir = \"reverse\";\n            this.setAttribute(\"side\", \"bottom\");\n          } else {\n            container.dir = \"\";\n            this.setAttribute(\"side\", \"top\");\n          }\n        }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\">\n      <![CDATA[\n        var arrow = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrow\");\n        arrow.hidden = this.anchorNode == null;\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\")\n                .style.removeProperty(\"transform\");\n\n        if (this.getAttribute(\"animate\") != \"false\") {\n          this.setAttribute(\"animate\", \"open\");\n          // the animating attribute prevents user interaction during transition\n          // it is removed when popupshown fires\n          this.setAttribute(\"animating\", \"true\");\n        }\n\n        // set fading\n        var fade = this.getAttribute(\"fade\");\n        var fadeDelay = 0;\n        if (fade == \"fast\") {\n          fadeDelay = 1;\n        } else if (fade == \"slow\") {\n          fadeDelay = 4000;\n        } else {\n          return;\n        }\n\n        this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);\n      ]]>\n      </handler>\n      <handler event=\"popuphiding\" phase=\"target\">\n        let animate = (this.getAttribute(\"animate\") != \"false\");\n\n        if (this._fadeTimer) {\n          clearTimeout(this._fadeTimer);\n          if (animate) {\n            this.setAttribute(\"animate\", \"fade\");\n          }\n        } else if (animate) {\n          this.setAttribute(\"animate\", \"cancel\");\n        }\n      </handler>\n      <handler event=\"popupshown\" phase=\"target\">\n        this.removeAttribute(\"animating\");\n        this.setAttribute(\"panelopen\", \"true\");\n      </handler>\n      <handler event=\"popuphidden\" phase=\"target\">\n        this.removeAttribute(\"panelopen\");\n        if (this.getAttribute(\"animate\") != \"false\") {\n          this.removeAttribute(\"animate\");\n        }\n      </handler>\n      <handler event=\"popuppositioned\" phase=\"target\">\n        this.adjustArrowPosition();\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"richlistbox.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This file relies on these specific Chrome/XBL globals -->\n<!-- globals ChromeNodeList -->\n\n<bindings id=\"richlistboxBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"richlistitem\"\n           extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <field name=\"selectedByMouseOver\">false</field>\n\n      <destructor>\n        <![CDATA[\n          var control = this.control;\n          if (!control)\n            return;\n          // When we are destructed and we are current or selected, unselect ourselves\n          // so that richlistbox's selection doesn't point to something not in the DOM.\n          // We don't want to reset last-selected, so we set _suppressOnSelect.\n          if (this.selected) {\n            var suppressSelect = control._suppressOnSelect;\n            control._suppressOnSelect = true;\n            control.removeItemFromSelection(this);\n            control._suppressOnSelect = suppressSelect;\n          }\n          if (this.current)\n            control.currentItem = null;\n        ]]>\n      </destructor>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"label\" readonly=\"true\">\n        <!-- Setter purposely not implemented; the getter returns a\n             concatentation of label text to expose via accessibility APIs -->\n        <getter>\n          <![CDATA[\n            const XULNS =\n              \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n            return Array.from(this.getElementsByTagNameNS(XULNS, \"label\"),\n                             label => label.value)\n                        .join(\" \");\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"searchLabel\">\n        <getter>\n          <![CDATA[\n            return this.hasAttribute(\"searchlabel\") ?\n                   this.getAttribute(\"searchlabel\") : this.label;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            if (val !== null)\n              this.setAttribute(\"searchlabel\", val);\n            else\n              // fall back to the label property (default value)\n              this.removeAttribute(\"searchlabel\");\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"value\" onget=\"return this.getAttribute('value');\"\n                             onset=\"this.setAttribute('value', val); return val;\"/>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"selected\" onget=\"return this.getAttribute('selected') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.setAttribute(\"selected\", \"true\");\n          else\n            this.removeAttribute(\"selected\");\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"control\">\n        <getter><![CDATA[\n          var parent = this.parentNode;\n          while (parent) {\n            if (parent.localName == \"richlistbox\")\n              return parent;\n            parent = parent.parentNode;\n          }\n          return null;\n        ]]></getter>\n      </property>\n\n      <property name=\"current\" onget=\"return this.getAttribute('current') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.setAttribute(\"current\", \"true\");\n          else\n            this.removeAttribute(\"current\");\n          return val;\n        ]]></setter>\n      </property>\n    </implementation>\n\n    <handlers>\n      <!-- If there is no modifier key, we select on mousedown, not\n           click, so that drags work correctly. -->\n      <handler event=\"mousedown\">\n        <![CDATA[\n          var control = this.control;\n          if (!control || control.disabled)\n            return;\n          if ((!event.ctrlKey || (/Mac/.test(navigator.platform) && event.button == 2)) &&\n              !event.shiftKey && !event.metaKey) {\n            if (!this.selected) {\n              control.selectItem(this);\n            }\n            control.currentItem = this;\n          }\n        ]]>\n      </handler>\n\n      <!-- On a click (up+down on the same item), deselect everything\n           except this item. -->\n      <handler event=\"click\" button=\"0\">\n        <![CDATA[\n          var control = this.control;\n          if (!control || control.disabled)\n            return;\n          control._userSelecting = true;\n          if (control.selType != \"multiple\") {\n            control.selectItem(this);\n          } else if (event.ctrlKey || event.metaKey) {\n            control.toggleItemSelection(this);\n            control.currentItem = this;\n          } else if (event.shiftKey) {\n            control.selectItemRange(null, this);\n            control.currentItem = this;\n          } else {\n            /* We want to deselect all the selected items except what was\n              clicked, UNLESS it was a right-click.  We have to do this\n              in click rather than mousedown so that you can drag a\n              selected group of items */\n\n            // use selectItemRange instead of selectItem, because this\n            // doesn't de- and reselect this item if it is selected\n            control.selectItemRange(this, this);\n          }\n          control._userSelecting = false;\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"scrollbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"arrowscrollboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"arrowscrollbox\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <content>\n      <xul:toolbarbutton class=\"scrollbutton-up\"\n                         anonid=\"scrollbutton-up\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtostart\"\n                         onclick=\"_onButtonClick(event);\"\n                         onmousedown=\"_onButtonMouseDown(event, -1);\"\n                         onmouseup=\"_onButtonMouseUp(event);\"\n                         onmouseover=\"_onButtonMouseOver(-1);\"\n                         onmouseout=\"_onButtonMouseOut();\"/>\n      <xul:spacer class=\"arrowscrollbox-overflow-start-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtostart\"/>\n      <xul:scrollbox class=\"arrowscrollbox-scrollbox\"\n                     anonid=\"scrollbox\"\n                     flex=\"1\"\n                     xbl:inherits=\"orient,align,pack,dir,smoothscroll\">\n        <children/>\n      </xul:scrollbox>\n      <xul:spacer class=\"arrowscrollbox-overflow-end-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtoend\"/>\n      <xul:toolbarbutton class=\"scrollbutton-down\"\n                         anonid=\"scrollbutton-down\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtoend\"\n                         onclick=\"_onButtonClick(event);\"\n                         onmousedown=\"_onButtonMouseDown(event, 1);\"\n                         onmouseup=\"_onButtonMouseUp(event);\"\n                         onmouseover=\"_onButtonMouseOver(1);\"\n                         onmouseout=\"_onButtonMouseOut();\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (!this.hasAttribute(\"smoothscroll\")) {\n          this.smoothScroll = this._prefBranch\n                                  .getBoolPref(\"toolkit.scrollbox.smoothScroll\", true);\n        }\n\n        this.setAttribute(\"notoverflowing\", \"true\");\n        this._updateScrollButtonsDisabledState();\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // Release timer to avoid reference cycles.\n        if (this._scrollTimer) {\n          this._scrollTimer.cancel();\n          this._scrollTimer = null;\n        }\n      ]]></destructor>\n\n      <field name=\"scrollbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbox\");\n      </field>\n      <field name=\"_scrollButtonUp\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbutton-up\");\n      </field>\n      <field name=\"_scrollButtonDown\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbutton-down\");\n      </field>\n\n      <field name=\"_scrollIndex\">0</field>\n\n      <field name=\"_arrowScrollAnim\"><![CDATA[({\n        scrollbox: this,\n        requestHandle: 0, /* 0 indicates there is no pending request */\n        start: function arrowSmoothScroll_start() {\n          this.lastFrameTime = window.performance.now();\n          if (!this.requestHandle)\n            this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));\n        },\n        stop: function arrowSmoothScroll_stop() {\n          window.cancelAnimationFrame(this.requestHandle);\n          this.requestHandle = 0;\n        },\n        sample: function arrowSmoothScroll_handleEvent(timeStamp) {\n          const scrollIndex = this.scrollbox._scrollIndex;\n          const timePassed = timeStamp - this.lastFrameTime;\n          this.lastFrameTime = timeStamp;\n\n          const scrollDelta = 0.5 * timePassed * scrollIndex;\n          this.scrollbox.scrollByPixels(scrollDelta, true);\n          this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));\n        },\n      })]]></field>\n\n      <property name=\"_clickToScroll\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.hasAttribute(\"clicktoscroll\");\n        ]]></getter>\n      </property>\n\n      <property name=\"_scrollDelay\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._clickToScroll) {\n            return this._prefBranch.getIntPref(\n                            \"toolkit.scrollbox.clickToScroll.scrollDelay\", 150);\n          }\n\n          // Use the same REPEAT_DELAY as \"nsRepeatService.h\".\n          return /Mac/.test(navigator.platform) ? 25 : 50;\n        ]]></getter>\n      </property>\n\n      <field name=\"__prefBranch\">null</field>\n      <property name=\"_prefBranch\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.__prefBranch === null) {\n            this.__prefBranch = Cc[\"@mozilla.org/preferences-service;1\"]\n                                  .getService(Ci.nsIPrefBranch);\n          }\n          return this.__prefBranch;\n        ]]></getter>\n      </property>\n\n      <field name=\"_scrollIncrement\">null</field>\n      <property name=\"scrollIncrement\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._scrollIncrement === null) {\n            this._scrollIncrement = this._prefBranch\n                                        .getIntPref(\"toolkit.scrollbox.scrollIncrement\", 20);\n          }\n          return this._scrollIncrement;\n        ]]></getter>\n      </property>\n\n      <property name=\"smoothScroll\">\n        <getter><![CDATA[\n          return this.getAttribute(\"smoothscroll\") == \"true\";\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"smoothscroll\", !!val);\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"scrollClientRect\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.scrollbox.getBoundingClientRect();\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollClientSize\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this.scrollbox.clientHeight :\n                 this.scrollbox.clientWidth;\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollSize\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this.scrollbox.scrollHeight :\n                 this.scrollbox.scrollWidth;\n        ]]></getter>\n      </property>\n\n      <property name=\"lineScrollAmount\" readonly=\"true\">\n        <getter><![CDATA[\n          // line scroll amout should be the width (at horizontal scrollbox) or\n          // the height (at vertical scrollbox) of the scrolled elements.\n          // However, the elements may have different width or height.  So,\n          // for consistent speed, let's use avalage with of the elements.\n          var elements = this._getScrollableElements();\n          return elements.length && (this.scrollSize / elements.length);\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollPosition\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this.scrollbox.scrollTop :\n                 this.scrollbox.scrollLeft;\n        ]]></getter>\n      </property>\n\n      <field name=\"_startEndProps\"><![CDATA[\n        this.orient == \"vertical\" ? [\"top\", \"bottom\"] : [\"left\", \"right\"];\n      ]]></field>\n\n      <field name=\"_isRTLScrollbox\"><![CDATA[\n        this.orient != \"vertical\" &&\n        document.defaultView.getComputedStyle(this.scrollbox).direction == \"rtl\";\n      ]]></field>\n\n      <method name=\"_onButtonClick\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (this._clickToScroll) {\n            this._distanceScroll(event);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseDown\">\n        <parameter name=\"event\"/>\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._clickToScroll && event.button == 0) {\n            this._startScroll(index);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseUp\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (this._clickToScroll && event.button == 0) {\n            this._stopScroll();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseOver\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._clickToScroll) {\n            this._continueScroll(index);\n          } else {\n            this._startScroll(index);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseOut\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._clickToScroll) {\n            this._pauseScroll();\n          } else {\n            this._stopScroll();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_boundsWithoutFlushing\">\n        <parameter name=\"element\"/>\n        <body><![CDATA[\n          if (!(\"_DOMWindowUtils\" in this)) {\n            this._DOMWindowUtils = window.windowUtils;\n          }\n\n          return this._DOMWindowUtils ?\n                 this._DOMWindowUtils.getBoundsWithoutFlushing(element) :\n                 element.getBoundingClientRect();\n        ]]></body>\n      </method>\n\n      <method name=\"_canScrollToElement\">\n        <parameter name=\"element\"/>\n        <body><![CDATA[\n          if (element.hidden) {\n            return false;\n          }\n\n          // See if the element is hidden via CSS without the hidden attribute.\n          // If we get only zeros for the client rect, this means the element\n          // is hidden. As a performance optimization, we don't flush layout\n          // here which means that on the fly changes aren't fully supported.\n          let rect = this._boundsWithoutFlushing(element);\n          return !!(rect.top || rect.left || rect.width || rect.height);\n        ]]></body>\n      </method>\n\n      <field name=\"_ensureElementIsVisibleAnimationFrame\">0</field>\n      <method name=\"ensureElementIsVisible\">\n        <parameter name=\"element\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (!this._canScrollToElement(element))\n            return;\n\n          if (this._ensureElementIsVisibleAnimationFrame) {\n            window.cancelAnimationFrame(this._ensureElementIsVisibleAnimationFrame);\n          }\n          this._ensureElementIsVisibleAnimationFrame = window.requestAnimationFrame(() => {\n            element.scrollIntoView({ block: \"nearest\",\n                                     behavior: aInstant ? \"instant\" : \"auto\" });\n            this._ensureElementIsVisibleAnimationFrame = 0;\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"scrollByIndex\">\n        <parameter name=\"index\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (index == 0)\n            return;\n\n          var rect = this.scrollClientRect;\n          var [start, end] = this._startEndProps;\n          var x = index > 0 ? rect[end] + 1 : rect[start] - 1;\n          var nextElement = this._elementFromPoint(x, index);\n          if (!nextElement)\n            return;\n\n          var targetElement;\n          if (this._isRTLScrollbox)\n            index *= -1;\n          while (index < 0 && nextElement) {\n            if (this._canScrollToElement(nextElement))\n              targetElement = nextElement;\n            nextElement = nextElement.previousElementSibling;\n            index++;\n          }\n          while (index > 0 && nextElement) {\n            if (this._canScrollToElement(nextElement))\n              targetElement = nextElement;\n            nextElement = nextElement.nextElementSibling;\n            index--;\n          }\n          if (!targetElement)\n            return;\n\n          this.ensureElementIsVisible(targetElement, aInstant);\n        ]]></body>\n      </method>\n\n      <method name=\"_getScrollableElements\">\n        <body><![CDATA[\n          var nodes = this.children;\n          if (nodes.length == 1 &&\n              nodes[0].localName == \"children\" &&\n              nodes[0].namespaceURI == \"http://www.mozilla.org/xbl\") {\n            nodes = document.getBindingParent(this).children;\n          }\n\n          return Array.prototype.filter.call(nodes, this._canScrollToElement, this);\n        ]]></body>\n      </method>\n\n      <method name=\"_elementFromPoint\">\n        <parameter name=\"aX\"/>\n        <parameter name=\"aPhysicalScrollDir\"/>\n        <body><![CDATA[\n          var elements = this._getScrollableElements();\n          if (!elements.length)\n            return null;\n\n          if (this._isRTLScrollbox)\n            elements.reverse();\n\n          var [start, end] = this._startEndProps;\n          var low = 0;\n          var high = elements.length - 1;\n\n          if (aX < elements[low].getBoundingClientRect()[start] ||\n              aX > elements[high].getBoundingClientRect()[end])\n            return null;\n\n          var mid, rect;\n          while (low <= high) {\n            mid = Math.floor((low + high) / 2);\n            rect = elements[mid].getBoundingClientRect();\n            if (rect[start] > aX)\n              high = mid - 1;\n            else if (rect[end] < aX)\n              low = mid + 1;\n            else\n              return elements[mid];\n          }\n\n          // There's no element at the requested coordinate, but the algorithm\n          // from above yields an element next to it, in a random direction.\n          // The desired scrolling direction leads to the correct element.\n\n          if (!aPhysicalScrollDir)\n            return null;\n\n          if (aPhysicalScrollDir < 0 && rect[start] > aX)\n            mid = Math.max(mid - 1, 0);\n          else if (aPhysicalScrollDir > 0 && rect[end] < aX)\n            mid = Math.min(mid + 1, elements.length - 1);\n\n          return elements[mid];\n        ]]></body>\n      </method>\n\n      <method name=\"_startScroll\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._isRTLScrollbox) {\n            index *= -1;\n          }\n\n          if (this._clickToScroll) {\n            this._scrollIndex = index;\n            this._mousedown = true;\n\n            if (this.smoothScroll) {\n              this._arrowScrollAnim.start();\n              return;\n            }\n          }\n\n          if (!this._scrollTimer) {\n            this._scrollTimer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n          } else {\n            this._scrollTimer.cancel();\n          }\n\n          let callback;\n          if (this._clickToScroll) {\n            callback = () => {\n              if (!document && this._scrollTimer) {\n                this._scrollTimer.cancel();\n              }\n              this.scrollByIndex(this._scrollIndex);\n            };\n          } else {\n            callback = () => this.scrollByPixels(this.scrollIncrement * index);\n          }\n\n          this._scrollTimer.initWithCallback(callback, this._scrollDelay,\n                                             Ci.nsITimer.TYPE_REPEATING_SLACK);\n\n          callback();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_stopScroll\">\n        <body><![CDATA[\n          if (this._scrollTimer)\n            this._scrollTimer.cancel();\n\n          if (this._clickToScroll) {\n            this._mousedown = false;\n            if (!this._scrollIndex || !this.smoothScroll)\n              return;\n\n            this.scrollByIndex(this._scrollIndex);\n            this._scrollIndex = 0;\n\n            this._arrowScrollAnim.stop();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_pauseScroll\">\n        <body><![CDATA[\n          if (this._mousedown) {\n            this._stopScroll();\n            this._mousedown = true;\n            document.addEventListener(\"mouseup\", this);\n            document.addEventListener(\"blur\", this, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_continueScroll\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._mousedown)\n            this._startScroll(index);\n        ]]></body>\n      </method>\n\n      <method name=\"_distanceScroll\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.detail < 2 || aEvent.detail > 3)\n            return;\n\n          var scrollBack = (aEvent.originalTarget == this._scrollButtonUp);\n          var scrollLeftOrUp = this._isRTLScrollbox ? !scrollBack : scrollBack;\n          var targetElement;\n\n          if (aEvent.detail == 2) {\n            // scroll by the size of the scrollbox\n            let [start, end] = this._startEndProps;\n            let x;\n            if (scrollLeftOrUp)\n              x = this.scrollClientRect[start] - this.scrollClientSize;\n            else\n              x = this.scrollClientRect[end] + this.scrollClientSize;\n            targetElement = this._elementFromPoint(x, scrollLeftOrUp ? -1 : 1);\n\n            // the next partly-hidden element will become fully visible,\n            // so don't scroll too far\n            if (targetElement)\n              targetElement = scrollBack ?\n                              targetElement.nextElementSibling :\n                              targetElement.previousElementSibling;\n          }\n\n          if (!targetElement) {\n            // scroll to the first resp. last element\n            let elements = this._getScrollableElements();\n            targetElement = scrollBack ?\n                            elements[0] :\n                            elements[elements.length - 1];\n          }\n\n          this.ensureElementIsVisible(targetElement);\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.type == \"mouseup\" ||\n              aEvent.type == \"blur\" && aEvent.target == document) {\n            this._mousedown = false;\n            document.removeEventListener(\"mouseup\", this);\n            document.removeEventListener(\"blur\", this, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"scrollByPixels\">\n        <parameter name=\"aPixels\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          let scrollOptions = { behavior: aInstant ? \"instant\" : \"auto\" };\n          scrollOptions[this._startEndProps[0]] = aPixels;\n          this.scrollbox.scrollBy(scrollOptions);\n        ]]></body>\n      </method>\n\n      <field name=\"_prevMouseScrolls\">[null, null]</field>\n\n      <field name=\"_touchStart\">-1</field>\n\n      <field name=\"_scrollButtonUpdatePending\">false</field>\n      <method name=\"_updateScrollButtonsDisabledState\">\n        <body><![CDATA[\n          if (this.hasAttribute(\"notoverflowing\")) {\n            this.setAttribute(\"scrolledtoend\", \"true\");\n            this.setAttribute(\"scrolledtostart\", \"true\");\n            return;\n          }\n\n          if (this._scrollButtonUpdatePending) {\n            return;\n          }\n          this._scrollButtonUpdatePending = true;\n\n          // Wait until after the next paint to get current layout data from\n          // getBoundsWithoutFlushing.\n          window.requestAnimationFrame(() => {\n            setTimeout(() => {\n              if (!this._startEndProps) {\n                // We've been destroyed in the meantime.\n                return;\n              }\n\n              this._scrollButtonUpdatePending = false;\n\n              let scrolledToStart = false;\n              let scrolledToEnd = false;\n\n              if (this.hasAttribute(\"notoverflowing\")) {\n                scrolledToStart = true;\n                scrolledToEnd = true;\n              } else {\n                let [leftOrTop, rightOrBottom] = this._startEndProps;\n                let leftOrTopEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[leftOrTop]);\n                let rightOrBottomEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[rightOrBottom]);\n\n                let elements = this._getScrollableElements();\n                let [leftOrTopElement, rightOrBottomElement] = [elements[0], elements[elements.length - 1]];\n                if (this._isRTLScrollbox) {\n                  [leftOrTopElement, rightOrBottomElement] = [rightOrBottomElement, leftOrTopElement];\n                }\n\n                if (leftOrTopElement &&\n                    leftOrTopEdge(leftOrTopElement) >= leftOrTopEdge(this.scrollbox)) {\n                  scrolledToStart = !this._isRTLScrollbox;\n                  scrolledToEnd = this._isRTLScrollbox;\n                } else if (rightOrBottomElement &&\n                           rightOrBottomEdge(rightOrBottomElement) <= rightOrBottomEdge(this.scrollbox)) {\n                  scrolledToStart = this._isRTLScrollbox;\n                  scrolledToEnd = !this._isRTLScrollbox;\n                }\n              }\n\n              if (scrolledToEnd) {\n                this.setAttribute(\"scrolledtoend\", \"true\");\n              } else {\n                this.removeAttribute(\"scrolledtoend\");\n              }\n\n              if (scrolledToStart) {\n                this.setAttribute(\"scrolledtostart\", \"true\");\n              } else {\n                this.removeAttribute(\"scrolledtostart\");\n              }\n            }, 0);\n          });\n        ]]></body>\n      </method>\n\n      <field name=\"_isScrolling\">false</field>\n      <field name=\"_destination\">0</field>\n      <field name=\"_direction\">0</field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"wheel\"><![CDATA[\n        // Don't consume the event if we can't scroll.\n        if (this.hasAttribute(\"notoverflowing\")) {\n          return;\n        }\n\n        let doScroll = false;\n        let instant;\n        let scrollAmount = 0;\n        if (this.orient == \"vertical\") {\n          doScroll = true;\n          if (event.deltaMode == event.DOM_DELTA_PIXEL)\n            scrollAmount = event.deltaY;\n          else if (event.deltaMode == event.DOM_DELTA_PAGE)\n            scrollAmount = event.deltaY * this.scrollClientSize;\n          else\n            scrollAmount = event.deltaY * this.lineScrollAmount;\n        } else {\n          // We allow vertical scrolling to scroll a horizontal scrollbox\n          // because many users have a vertical scroll wheel but no\n          // horizontal support.\n          // Because of this, we need to avoid scrolling chaos on trackpads\n          // and mouse wheels that support simultaneous scrolling in both axes.\n          // We do this by scrolling only when the last two scroll events were\n          // on the same axis as the current scroll event.\n          // For diagonal scroll events we only respect the dominant axis.\n          let isVertical = Math.abs(event.deltaY) > Math.abs(event.deltaX);\n          let delta = isVertical ? event.deltaY : event.deltaX;\n          let scrollByDelta = isVertical && this._isRTLScrollbox ? -delta : delta;\n\n          if (this._prevMouseScrolls.every(prev => prev == isVertical)) {\n            doScroll = true;\n            if (event.deltaMode == event.DOM_DELTA_PIXEL) {\n              scrollAmount = scrollByDelta;\n              instant = true;\n            } else if (event.deltaMode == event.DOM_DELTA_PAGE) {\n              scrollAmount = scrollByDelta * this.scrollClientSize;\n            } else {\n              scrollAmount = scrollByDelta * this.lineScrollAmount;\n            }\n          }\n\n          if (this._prevMouseScrolls.length > 1)\n            this._prevMouseScrolls.shift();\n          this._prevMouseScrolls.push(isVertical);\n        }\n\n        if (doScroll) {\n          let direction = scrollAmount < 0 ? -1 : 1;\n          let startPos = this.scrollPosition;\n\n          if (!this._isScrolling || this._direction != direction) {\n            this._destination = startPos + scrollAmount;\n            this._direction = direction;\n          } else {\n            // We were already in the process of scrolling in this direction\n            this._destination = this._destination + scrollAmount;\n            scrollAmount = this._destination - startPos;\n          }\n          this.scrollByPixels(scrollAmount, instant);\n        }\n\n        event.stopPropagation();\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"touchstart\"><![CDATA[\n        if (event.touches.length > 1) {\n          // Multiple touch points detected, abort. In particular this aborts\n          // the panning gesture when the user puts a second finger down after\n          // already panning with one finger. Aborting at this point prevents\n          // the pan gesture from being resumed until all fingers are lifted\n          // (as opposed to when the user is back down to one finger).\n          this._touchStart = -1;\n        } else {\n          this._touchStart = (this.orient == \"vertical\"\n                ? event.touches[0].screenY\n                : event.touches[0].screenX);\n        }\n      ]]></handler>\n\n      <handler event=\"touchmove\"><![CDATA[\n        if (event.touches.length == 1 &&\n            this._touchStart >= 0) {\n          var touchPoint = (this.orient == \"vertical\"\n                ? event.touches[0].screenY\n                : event.touches[0].screenX);\n          var delta = this._touchStart - touchPoint;\n          if (Math.abs(delta) > 0) {\n            this.scrollByPixels(delta, true);\n            this._touchStart = touchPoint;\n          }\n          event.preventDefault();\n        }\n      ]]></handler>\n\n      <handler event=\"touchend\"><![CDATA[\n        this._touchStart = -1;\n      ]]></handler>\n\n      <handler event=\"underflow\" phase=\"capturing\"><![CDATA[\n        // Ignore underflow events:\n        // - from nested scrollable elements\n        // - corresponding to an overflow event that we ignored\n        if (event.target != this ||\n            this.hasAttribute(\"notoverflowing\")) {\n          return;\n        }\n\n        // Ignore events that doesn't match our orientation.\n        // Scrollport event orientation:\n        //   0: vertical\n        //   1: horizontal\n        //   2: both\n        if (this.orient == \"vertical\") {\n          if (event.detail == 1)\n            return;\n        } else if (event.detail == 0) {\n          // horizontal scrollbox\n          return;\n        }\n\n        this.setAttribute(\"notoverflowing\", \"true\");\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"overflow\" phase=\"capturing\"><![CDATA[\n        // Ignore overflow events:\n        // - from nested scrollable elements\n        if (event.target != this) {\n          return;\n        }\n\n        // Ignore events that doesn't match our orientation.\n        // Scrollport event orientation:\n        //   0: vertical\n        //   1: horizontal\n        //   2: both\n        if (this.orient == \"vertical\") {\n          if (event.detail == 1)\n            return;\n        } else if (event.detail == 0) {\n          // horizontal scrollbox\n          return;\n        }\n\n        this.removeAttribute(\"notoverflowing\");\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"scroll\"><![CDATA[\n        this._isScrolling = true;\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"scrollend\"><![CDATA[\n        this._isScrolling = false;\n        this._destination = 0;\n        this._direction = 0;\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"textbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This files relies on these specific Chrome/XBL globals -->\n<!-- globals ChromeWindow -->\n\n\n<!DOCTYPE bindings [\n  <!ENTITY % textcontextDTD SYSTEM \"chrome://global/locale/textcontext.dtd\" >\n  %textcontextDTD;\n]>\n\n<bindings id=\"textboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"textbox\">\n    <content>\n      <children/>\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\" xbl:inherits=\"context,spellcheck\">\n        <html:input class=\"textbox-input\" anonid=\"input\"\n                    xbl:inherits=\"value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,noinitialfocus,mozactionhint,spellcheck\"/>\n      </xul:moz-input-box>\n    </content>\n\n    <implementation>\n      <!-- nsIDOMXULLabeledControlElement -->\n      <field name=\"crop\">\"\"</field>\n      <field name=\"image\">\"\"</field>\n      <field name=\"command\">\"\"</field>\n      <field name=\"accessKey\">\"\"</field>\n\n      <field name=\"mInputField\">null</field>\n      <field name=\"mIgnoreClick\">false</field>\n      <field name=\"mIgnoreFocus\">false</field>\n      <field name=\"mEditor\">null</field>\n\n      <property name=\"inputField\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.mInputField)\n            this.mInputField = document.getAnonymousElementByAttribute(this, \"anonid\", \"input\");\n          return this.mInputField;\n        ]]></getter>\n      </property>\n\n      <property name=\"value\"      onset=\"this.inputField.value = val; return val;\"\n                                  onget=\"return this.inputField.value;\"/>\n      <property name=\"defaultValue\" onset=\"this.inputField.defaultValue = val; return val;\"\n                                  onget=\"return this.inputField.defaultValue;\"/>\n      <property name=\"label\"      onset=\"this.setAttribute('label', val); return val;\"\n                                  onget=\"return this.getAttribute('label') || this.placeholder;\" />\n      <property name=\"placeholder\" onset=\"this.inputField.placeholder = val; return val;\"\n                                  onget=\"return this.inputField.placeholder;\"/>\n      <property name=\"emptyText\"  onset=\"this.placeholder = val; return val;\"\n                                  onget=\"return this.placeholder;\"/>\n      <property name=\"type\"       onset=\"if (val) this.setAttribute('type', val);\n                                         else this.removeAttribute('type'); return val;\"\n                                  onget=\"return this.getAttribute('type');\"/>\n      <property name=\"maxLength\"  onset=\"this.inputField.maxLength = val; return val;\"\n                                  onget=\"return this.inputField.maxLength;\"/>\n      <property name=\"disabled\"   onset=\"this.inputField.disabled = val;\n                                         if (val) this.setAttribute('disabled', 'true');\n                                         else this.removeAttribute('disabled'); return val;\"\n                                  onget=\"return this.inputField.disabled;\"/>\n      <property name=\"tabIndex\"   onget=\"return parseInt(this.getAttribute('tabindex'));\"\n                                  onset=\"this.inputField.tabIndex = val;\n                                         if (val) this.setAttribute('tabindex', val);\n                                         else this.removeAttribute('tabindex'); return val;\"/>\n      <property name=\"size\"       onset=\"this.inputField.size = val; return val;\"\n                                  onget=\"return this.inputField.size;\"/>\n      <property name=\"readOnly\"   onset=\"this.inputField.readOnly = val;\n                                         if (val) this.setAttribute('readonly', 'true');\n                                         else this.removeAttribute('readonly'); return val;\"\n                                  onget=\"return this.inputField.readOnly;\"/>\n      <property name=\"clickSelectsAll\"\n                onget=\"return this.getAttribute('clickSelectsAll') == 'true';\"\n                onset=\"if (val) this.setAttribute('clickSelectsAll', 'true');\n                       else this.removeAttribute('clickSelectsAll'); return val;\" />\n\n      <property name=\"editor\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.mEditor) {\n            this.mEditor = this.inputField.editor;\n          }\n          return this.mEditor;\n        ]]></getter>\n      </property>\n\n      <method name=\"reset\">\n        <body><![CDATA[\n          this.value = this.defaultValue;\n          try {\n            this.editor.transactionManager.clear();\n            return true;\n          } catch (e) {}\n          return false;\n        ]]></body>\n      </method>\n\n      <method name=\"select\">\n        <body>\n          this.inputField.select();\n        </body>\n      </method>\n\n      <method name=\"setUserInput\">\n        <parameter name=\"value\"/>\n        <body><![CDATA[\n          this.inputField.setUserInput(value);\n        ]]></body>\n      </method>\n\n      <property name=\"controllers\"    readonly=\"true\" onget=\"return this.inputField.controllers\"/>\n      <property name=\"textLength\"     readonly=\"true\"\n                                      onget=\"return this.inputField.textLength;\"/>\n      <property name=\"selectionStart\" onset=\"this.inputField.selectionStart = val; return val;\"\n                                      onget=\"return this.inputField.selectionStart;\"/>\n      <property name=\"selectionEnd\"   onset=\"this.inputField.selectionEnd = val; return val;\"\n                                      onget=\"return this.inputField.selectionEnd;\"/>\n\n      <method name=\"setSelectionRange\">\n        <parameter name=\"aSelectionStart\"/>\n        <parameter name=\"aSelectionEnd\"/>\n        <body>\n          // According to https://html.spec.whatwg.org/#do-not-apply,\n          // setSelectionRange() is only available on a limited set of input types.\n          if (this.inputField.type == \"text\") {\n            this.inputField.setSelectionRange( aSelectionStart, aSelectionEnd );\n          }\n        </body>\n      </method>\n\n      <method name=\"_setNewlineHandling\">\n        <body><![CDATA[\n          var str = this.getAttribute(\"newlines\");\n          if (str && this.editor) {\n            const nsIPlaintextEditor = Ci.nsIPlaintextEditor;\n            for (var x in nsIPlaintextEditor) {\n              if (/^eNewlines/.test(x)) {\n                if (str == RegExp.rightContext.toLowerCase()) {\n                  this.editor.QueryInterface(nsIPlaintextEditor)\n                      .newlineHandling = nsIPlaintextEditor[x];\n                  break;\n                }\n              }\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_maybeSelectAll\">\n        <body><![CDATA[\n          if (!this.mIgnoreClick && this.clickSelectsAll &&\n              document.activeElement == this.inputField &&\n              this.inputField.selectionStart == this.inputField.selectionEnd)\n            this.editor.selectAll();\n        ]]></body>\n      </method>\n\n      <constructor><![CDATA[\n        var str = this._cachedInputFieldValue;\n        if (str) {\n          this.inputField.value = str;\n          delete this._cachedInputFieldValue;\n        }\n\n        this._setNewlineHandling();\n\n        if (this.hasAttribute(\"emptytext\"))\n          this.placeholder = this.getAttribute(\"emptytext\");\n      ]]></constructor>\n\n      <destructor>\n        <![CDATA[\n          var field = this.inputField;\n          if (field && field.value) {\n            this._cachedInputFieldValue = field.value;\n          }\n\n          this.mInputField = null;\n        ]]>\n      </destructor>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"focus\" phase=\"capturing\">\n        <![CDATA[\n          if (this.hasAttribute(\"focused\"))\n            return;\n\n          switch (event.originalTarget) {\n            case this:\n              // Forward focus to actual HTML input\n              this.inputField.focus();\n              this.setAttribute(\"focused\", \"true\");\n              break;\n            case this.inputField:\n              if (this.mIgnoreFocus) {\n                this.mIgnoreFocus = false;\n              } else if (this.clickSelectsAll) {\n                try {\n                  if (!this.editor || !this.editor.composing)\n                    this.editor.selectAll();\n                } catch (e) {}\n              }\n              this.setAttribute(\"focused\", \"true\");\n              break;\n            default:\n              // Otherwise, allow other children (e.g. URL bar buttons) to get focus\n              break;\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"blur\" phase=\"capturing\">\n        <![CDATA[\n          this.removeAttribute(\"focused\");\n\n          // don't trigger clickSelectsAll when switching application windows\n          if (window == window.top &&\n              window.isChromeWindow &&\n              document.activeElement == this.inputField)\n            this.mIgnoreFocus = true;\n        ]]>\n      </handler>\n\n      <handler event=\"mousedown\">\n        <![CDATA[\n          this.mIgnoreClick = this.hasAttribute(\"focused\");\n\n          if (!this.mIgnoreClick) {\n            this.mIgnoreFocus = true;\n            this.setSelectionRange(0, 0);\n            if (event.originalTarget == this ||\n                event.originalTarget == this.inputField.parentNode)\n              this.inputField.focus();\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"click\" action=\"this._maybeSelectAll();\"/>\n\n\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"extensions.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE page [\n<!ENTITY % extensionsDTD SYSTEM \"chrome://mozapps/locale/extensions/extensions.dtd\">\n%extensionsDTD;\n]>\n\n<!-- import-globals-from extensions.js -->\n\n<bindings id=\"addonBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\">\n\n\n  <!-- Rating - displays current/average rating, allows setting user rating -->\n  <binding id=\"rating\">\n    <content>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(1);\"\n                 onclick=\"document.getBindingParent(this).userRating = 1;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(2);\"\n                 onclick=\"document.getBindingParent(this).userRating = 2;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(3);\"\n                 onclick=\"document.getBindingParent(this).userRating = 3;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(4);\"\n                 onclick=\"document.getBindingParent(this).userRating = 4;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(5);\"\n                 onclick=\"document.getBindingParent(this).userRating = 5;\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._updateStars();\n      ]]></constructor>\n\n      <property name=\"stars\" readonly=\"true\">\n        <getter><![CDATA[\n          return document.getAnonymousNodes(this);\n        ]]></getter>\n      </property>\n\n      <property name=\"averageRating\">\n        <getter><![CDATA[\n          if (this.hasAttribute(\"averagerating\"))\n            return this.getAttribute(\"averagerating\");\n          return -1;\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"averagerating\", val);\n          if (this.showRating == \"average\")\n            this._updateStars();\n        ]]></setter>\n      </property>\n\n      <property name=\"userRating\">\n        <getter><![CDATA[\n          if (this.hasAttribute(\"userrating\"))\n            return this.getAttribute(\"userrating\");\n          return -1;\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.showRating != \"user\")\n            return;\n          this.setAttribute(\"userrating\", val);\n          if (this.showRating == \"user\")\n            this._updateStars();\n        ]]></setter>\n      </property>\n\n      <property name=\"showRating\">\n        <getter><![CDATA[\n          if (this.hasAttribute(\"showrating\"))\n            return this.getAttribute(\"showrating\");\n          return \"average\";\n        ]]></getter>\n        <setter><![CDATA[\n          if (val != \"average\" || val != \"user\")\n            throw Components.Exception(\"Invalid value\", Cr.NS_ERROR_ILLEGAL_VALUE);\n          this.setAttribute(\"showrating\", val);\n          this._updateStars();\n        ]]></setter>\n      </property>\n\n      <method name=\"_updateStars\">\n        <body><![CDATA[\n          var stars = this.stars;\n          var rating = this[this.showRating + \"Rating\"];\n          // average ratings can be non-whole numbers, round them so they\n          // match to their closest star\n          rating = Math.round(rating);\n          for (let i = 0; i < stars.length; i++)\n            stars[i].setAttribute(\"on\", rating > i);\n        ]]></body>\n      </method>\n\n      <method name=\"_hover\">\n        <parameter name=\"aScore\"/>\n        <body><![CDATA[\n          if (this.showRating != \"user\")\n            return;\n          var stars = this.stars;\n          for (let i = 0; i < stars.length; i++)\n            stars[i].setAttribute(\"on\", i <= (aScore - 1));\n        ]]></body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"mouseout\">\n        this._updateStars();\n      </handler>\n    </handlers>\n  </binding>\n\n  <!-- Download progress - shows graphical progress of download and any\n       related status message. -->\n  <binding id=\"download-progress\">\n    <content>\n      <xul:stack flex=\"1\">\n        <xul:hbox flex=\"1\">\n          <xul:hbox class=\"start-cap\"/>\n          <html:progress anonid=\"progress\" class=\"progress\" max=\"100\"/>\n          <xul:hbox class=\"end-cap\"/>\n        </xul:hbox>\n        <xul:hbox class=\"status-container\">\n          <xul:spacer flex=\"1\"/>\n          <xul:label anonid=\"status\" class=\"status\"/>\n          <xul:spacer flex=\"1\"/>\n          <xul:button anonid=\"cancel-btn\" class=\"cancel\"\n                      tooltiptext=\"FROM-DTD.progress.cancel.tooltip;\"\n                      oncommand=\"document.getBindingParent(this).cancel();\"/>\n        </xul:hbox>\n      </xul:stack>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        var progress = 0;\n        if (this.hasAttribute(\"progress\"))\n          progress = parseInt(this.getAttribute(\"progress\"));\n        this.progress = progress;\n      ]]></constructor>\n\n      <field name=\"_progress\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"progress\");\n      </field>\n      <field name=\"_cancel\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"cancel-btn\");\n      </field>\n      <field name=\"_status\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"status\");\n      </field>\n\n      <property name=\"progress\">\n        <setter><![CDATA[\n          // This property is always updated after maxProgress.\n          if (this.getAttribute(\"mode\") == \"determined\") {\n            this._progress.value = val;\n          }\n          if (val == this._progress.max)\n            this.setAttribute(\"complete\", true);\n          else\n            this.removeAttribute(\"complete\");\n        ]]></setter>\n      </property>\n\n      <property name=\"maxProgress\">\n        <setter><![CDATA[\n          if (val == -1) {\n            this.setAttribute(\"mode\", \"undetermined\");\n            this._progress.removeAttribute(\"value\");\n          } else {\n            this.setAttribute(\"mode\", \"determined\");\n            this._progress.setAttribute(\"max\", val);\n          }\n        ]]></setter>\n      </property>\n\n      <property name=\"status\">\n        <getter><![CDATA[\n          return this._status.value;\n        ]]></getter>\n        <setter><![CDATA[\n          this._status.value = val;\n        ]]></setter>\n      </property>\n\n      <method name=\"cancel\">\n        <body><![CDATA[\n          this.mInstall.cancel();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n  <!-- Category item - an item in the category list. -->\n  <binding id=\"category\"\n           extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <content align=\"center\">\n      <xul:image anonid=\"icon\" class=\"category-icon\"/>\n      <xul:label anonid=\"name\" class=\"category-name\" crop=\"end\" flex=\"1\" xbl:inherits=\"value=name\"/>\n      <xul:label anonid=\"badge\" class=\"category-badge\" xbl:inherits=\"value=count\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (!this.hasAttribute(\"count\"))\n          this.setAttribute(\"count\", 0);\n      ]]></constructor>\n\n      <property name=\"badgeCount\">\n        <getter><![CDATA[\n          return this.getAttribute(\"count\");\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.getAttribute(\"count\") == val)\n            return;\n\n          this.setAttribute(\"count\", val);\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"CategoryBadgeUpdated\", true, true);\n          this.dispatchEvent(event);\n        ]]></setter>\n      </property>\n    </implementation>\n  </binding>\n\n\n  <!-- Creator link - Name of a user/developer, providing a link if relevant. -->\n  <binding id=\"creator-link\">\n    <content>\n      <xul:label anonid=\"label\" value=\"FROM-DTD.addon.createdBy.label;\"/>\n      <xul:label anonid=\"creator-link\" class=\"creator-link\" is=\"text-link\"/>\n      <xul:label anonid=\"creator-name\" class=\"creator-name\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (this.hasAttribute(\"nameonly\") &&\n            this.getAttribute(\"nameonly\") == \"true\") {\n          this._label.hidden = true;\n        }\n      ]]></constructor>\n\n      <field name=\"_label\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"label\");\n      </field>\n      <field name=\"_creatorLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"creator-link\");\n      </field>\n      <field name=\"_creatorName\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"creator-name\");\n      </field>\n\n      <method name=\"setCreator\">\n        <parameter name=\"aCreator\"/>\n        <parameter name=\"aHomepageURL\"/>\n        <body><![CDATA[\n          if (!aCreator) {\n            this.collapsed = true;\n            return;\n          }\n          this.collapsed = false;\n          var url = aCreator.url || aHomepageURL;\n          var showLink = !!url;\n          if (showLink) {\n            this._creatorLink.value = aCreator.name;\n            this._creatorLink.href = url;\n          } else {\n            this._creatorName.value = aCreator.name;\n          }\n          this._creatorLink.hidden = !showLink;\n          this._creatorName.hidden = showLink;\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Install status - Displays the status of an install/upgrade. -->\n  <binding id=\"install-status\">\n    <content>\n      <xul:label anonid=\"message\"/>\n      <xul:box anonid=\"progress\" class=\"download-progress\"/>\n      <xul:button anonid=\"install-remote-btn\" hidden=\"true\"\n                  class=\"addon-control install\" label=\"FROM-DTD.addon.install.label;\"\n                  tooltiptext=\"FROM-DTD.addon.install.tooltip;\"\n                  oncommand=\"document.getBindingParent(this).installRemote();\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (this.mInstall)\n          this.initWithInstall(this.mInstall);\n        else if (this.mControl.mAddon.install)\n          this.initWithInstall(this.mControl.mAddon.install);\n        else\n          this.refreshState();\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        if (this.mInstall)\n          this.mInstall.removeListener(this);\n      ]]></destructor>\n\n      <field name=\"_message\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"message\");\n      </field>\n      <field name=\"_progress\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"progress\");\n      </field>\n      <field name=\"_installRemote\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"install-remote-btn\");\n      </field>\n      <field name=\"_undo\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"undo-btn\");\n      </field>\n\n      <method name=\"initWithInstall\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          if (this.mInstall) {\n            this.mInstall.removeListener(this);\n            this.mInstall = null;\n          }\n          this.mInstall = aInstall;\n          this._progress.mInstall = aInstall;\n          this.refreshState();\n          this.mInstall.addListener(this);\n        ]]></body>\n      </method>\n\n      <method name=\"refreshState\">\n        <body><![CDATA[\n          var showInstallRemote = false;\n\n          if (this.mInstall) {\n            switch (this.mInstall.state) {\n              case AddonManager.STATE_AVAILABLE:\n                if (this.mControl.getAttribute(\"remote\") != \"true\")\n                  break;\n\n                this._progress.hidden = true;\n                showInstallRemote = true;\n                break;\n              case AddonManager.STATE_DOWNLOADING:\n                this.showMessage(\"installDownloading\");\n                break;\n              case AddonManager.STATE_CHECKING:\n                this.showMessage(\"installVerifying\");\n                break;\n              case AddonManager.STATE_DOWNLOADED:\n                this.showMessage(\"installDownloaded\");\n                break;\n              case AddonManager.STATE_DOWNLOAD_FAILED:\n                // XXXunf expose what error occured (bug 553487)\n                this.showMessage(\"installDownloadFailed\", true);\n                break;\n              case AddonManager.STATE_INSTALLING:\n                this.showMessage(\"installInstalling\");\n                break;\n              case AddonManager.STATE_INSTALL_FAILED:\n                // XXXunf expose what error occured (bug 553487)\n                this.showMessage(\"installFailed\", true);\n                break;\n              case AddonManager.STATE_CANCELLED:\n                this.showMessage(\"installCancelled\", true);\n                break;\n            }\n          }\n\n          this._installRemote.hidden = !showInstallRemote;\n\n          if (\"refreshInfo\" in this.mControl)\n            this.mControl.refreshInfo();\n        ]]></body>\n      </method>\n\n      <method name=\"showMessage\">\n        <parameter name=\"aMsgId\"/>\n        <parameter name=\"aHideProgress\"/>\n        <body><![CDATA[\n          this._message.setAttribute(\"hidden\", !aHideProgress);\n          this._progress.setAttribute(\"hidden\", !!aHideProgress);\n\n          var msg = gStrings.ext.GetStringFromName(aMsgId);\n          if (aHideProgress)\n            this._message.value = msg;\n          else\n            this._progress.status = msg;\n        ]]></body>\n      </method>\n\n      <method name=\"installRemote\">\n        <body><![CDATA[\n          if (this.mControl.getAttribute(\"remote\") != \"true\")\n            return;\n\n          delete this.mControl.mAddon;\n          this.mControl.mInstall = this.mInstall;\n          this.mControl.setAttribute(\"status\", \"installing\");\n          let prompt = Services.prefs.getBoolPref(\"extensions.webextPermissionPrompts\", false);\n          if (prompt) {\n            this.mInstall.promptHandler = info => new Promise((resolve, reject) => {\n              // Skip prompts for non-webextensions\n              if (!info.addon.userPermissions) {\n                resolve();\n                return;\n              }\n              let subject = {\n                wrappedJSObject: {\n                  target: window.docShell.chromeEventHandler,\n                  info: {\n                    addon: info.addon,\n                    source: \"AMO\",\n                    icon: info.addon.iconURL,\n                    permissions: info.addon.userPermissions,\n                    resolve,\n                    reject,\n                  },\n                },\n              };\n              Services.obs.notifyObservers(subject, \"webextension-permission-prompt\");\n            });\n          }\n          this.mInstall.install();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadStarted\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadEnded\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadFailed\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadProgress\">\n        <body><![CDATA[\n          this._progress.maxProgress = this.mInstall.maxProgress;\n          this._progress.progress = this.mInstall.progress;\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallStarted\">\n        <body><![CDATA[\n          this._progress.progress = 0;\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallEnded\">\n        <body><![CDATA[\n          this.refreshState();\n          if (\"onInstallCompleted\" in this.mControl)\n            this.mControl.onInstallCompleted();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallFailed\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Addon - base - parent binding of any item representing an addon. -->\n  <binding id=\"addon-base\"\n           extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <implementation>\n      <property name=\"isLegacy\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.mAddon.install) {\n            return false;\n          }\n          return isLegacyExtension(this.mAddon);\n        ]]></getter>\n      </property>\n\n      <method name=\"hasPermission\">\n        <parameter name=\"aPerm\"/>\n        <body><![CDATA[\n          var perm = AddonManager[\"PERM_CAN_\" + aPerm.toUpperCase()];\n          return !!(this.mAddon.permissions & perm);\n        ]]></body>\n      </method>\n\n      <method name=\"isPending\">\n        <parameter name=\"aAction\"/>\n        <body><![CDATA[\n          var action = AddonManager[\"PENDING_\" + aAction.toUpperCase()];\n          return !!(this.mAddon.pendingOperations & action);\n        ]]></body>\n      </method>\n\n      <method name=\"typeHasFlag\">\n        <parameter name=\"aFlag\"/>\n        <body><![CDATA[\n          let flag = AddonManager[\"TYPE_\" + aFlag];\n          let type = AddonManager.addonTypes[this.mAddon.type];\n\n          return !!(type.flags & flag);\n        ]]></body>\n      </method>\n\n      <method name=\"onUninstalled\">\n        <body><![CDATA[\n          this.remove();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Addon - generic - A normal addon item, or an update to one -->\n  <binding id=\"addon-generic\"\n           extends=\"chrome://mozapps/content/extensions/extensions.xml#addon-base\">\n    <content tooltiptext=\"FROM-DTD.addon.details.tooltip;\">\n      <xul:hbox anonid=\"warning-container\"\n                class=\"warning\">\n        <xul:image class=\"warning-icon\"/>\n        <xul:label anonid=\"warning\" flex=\"1\"/>\n        <xul:label anonid=\"warning-link\" is=\"text-link\"/>\n        <xul:button anonid=\"warning-btn\" class=\"button-link\" hidden=\"true\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n      <xul:hbox anonid=\"error-container\"\n                class=\"error\">\n        <xul:image class=\"error-icon\"/>\n        <xul:label anonid=\"error\" flex=\"1\"/>\n        <xul:label anonid=\"error-link\" hidden=\"true\" is=\"text-link\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n      <xul:hbox anonid=\"pending-container\"\n                class=\"pending\">\n        <xul:image class=\"pending-icon\"/>\n        <xul:label anonid=\"pending\" flex=\"1\"/>\n        <xul:button anonid=\"undo-btn\" class=\"button-link\"\n                    label=\"FROM-DTD.addon.undoAction.label;\"\n                    tooltipText=\"FROM-DTD.addon.undoAction.tooltip;\"\n                    oncommand=\"document.getBindingParent(this).undo();\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n\n      <xul:image class=\"card-heading-image\" anonid=\"theme-screenshot\" xbl:inherits=\"src=previewURL\"/>\n\n      <xul:hbox class=\"content-container\">\n        <xul:vbox class=\"icon-container\">\n          <xul:image anonid=\"icon\" class=\"icon\"/>\n        </xul:vbox>\n        <xul:vbox class=\"content-inner-container\" flex=\"1\">\n          <xul:hbox class=\"basicinfo-container\">\n              <xul:hbox class=\"name-container\">\n                <xul:label anonid=\"name\" class=\"name\" crop=\"end\" flex=\"1\"\n                           tooltip=\"addonitem-tooltip\" xbl:inherits=\"xbl:text=name\"/>\n                <xul:label anonid=\"legacy\" class=\"legacy-warning\" value=\"FROM-DTD.addon.legacy.label;\" is=\"text-link\"/>\n                <xul:label class=\"disabled-postfix\" value=\"FROM-DTD.addon.disabled.postfix;\"/>\n                <xul:label class=\"update-postfix\" value=\"FROM-DTD.addon.update.postfix;\"/>\n                <xul:spacer flex=\"5000\"/> <!-- Necessary to make the name crop -->\n              </xul:hbox>\n            <xul:label anonid=\"date-updated\" class=\"date-updated\"\n                       unknown=\"FROM-DTD.addon.unknownDate;\"/>\n          </xul:hbox>\n\n          <xul:hbox class=\"advancedinfo-container\" flex=\"1\">\n            <xul:vbox class=\"description-outer-container\" flex=\"1\">\n              <xul:hbox class=\"description-container\">\n                <xul:label anonid=\"description\" class=\"description\" crop=\"end\" flex=\"1\"/>\n                <xul:spacer flex=\"5000\"/> <!-- Necessary to make the description crop -->\n              </xul:hbox>\n              <xul:hbox class=\"relnotes-toggle-container\">\n                <xul:button anonid=\"relnotes-toggle-btn\" class=\"relnotes-toggle\"\n                            hidden=\"true\" label=\"FROM-DTD.cmd.showReleaseNotes.label;\"\n                            tooltiptext=\"FROM-DTD.cmd.showReleaseNotes.tooltip;\"\n                            showlabel=\"FROM-DTD.cmd.showReleaseNotes.label;\"\n                            showtooltip=\"FROM-DTD.cmd.showReleaseNotes.tooltip;\"\n                            hidelabel=\"FROM-DTD.cmd.hideReleaseNotes.label;\"\n                            hidetooltip=\"FROM-DTD.cmd.hideReleaseNotes.tooltip;\"\n                            oncommand=\"document.getBindingParent(this).toggleReleaseNotes();\"/>\n              </xul:hbox>\n              <xul:vbox anonid=\"relnotes-container\" class=\"relnotes-container\">\n                <xul:label class=\"relnotes-header\" value=\"FROM-DTD.addon.releaseNotes.label;\"/>\n                <xul:label anonid=\"relnotes-loading\" value=\"FROM-DTD.addon.loadingReleaseNotes.label;\"/>\n                <xul:label anonid=\"relnotes-error\" hidden=\"true\"\n                           value=\"FROM-DTD.addon.errorLoadingReleaseNotes.label;\"/>\n                <xul:vbox anonid=\"relnotes\" class=\"relnotes\"/>\n              </xul:vbox>\n            </xul:vbox>\n          </xul:hbox>\n        </xul:vbox>\n        <xul:vbox class=\"status-control-wrapper\">\n          <xul:hbox class=\"status-container\">\n            <xul:hbox anonid=\"checking-update\" hidden=\"true\">\n              <xul:image class=\"spinner\"/>\n              <xul:label value=\"FROM-DTD.addon.checkingForUpdates.label;\"/>\n            </xul:hbox>\n            <xul:vbox anonid=\"update-available\" class=\"update-available\"\n                      hidden=\"true\">\n              <xul:checkbox anonid=\"include-update\" class=\"include-update\"\n                            label=\"FROM-DTD.addon.includeUpdate.label;\" checked=\"true\"\n                            oncommand=\"document.getBindingParent(this).onIncludeUpdateChanged();\"/>\n              <xul:hbox class=\"update-info-container\">\n                <xul:label class=\"update-available-notice\"\n                           value=\"FROM-DTD.addon.updateAvailable.label;\"/>\n                <xul:button anonid=\"update-btn\" class=\"addon-control update\"\n                            label=\"FROM-DTD.addon.updateNow.label;\"\n                            tooltiptext=\"FROM-DTD.addon.updateNow.tooltip;\"\n                            oncommand=\"document.getBindingParent(this).upgrade();\"/>\n              </xul:hbox>\n            </xul:vbox>\n            <xul:hbox anonid=\"install-status\" class=\"install-status\"\n                      hidden=\"true\"/>\n          </xul:hbox>\n          <xul:hbox anonid=\"control-container\" class=\"control-container\" flex=\"1\">\n            <xul:button anonid=\"preferences-btn\"\n                        class=\"addon-control preferences\"\n\n                        label=\"FROM-DTD.cmd.showPreferencesWin.label;\"\n                        tooltiptext=\"FROM-DTD.cmd.showPreferencesWin.tooltip;\"\n\n                        oncommand=\"document.getBindingParent(this).showPreferences();\"/>\n            <xul:button anonid=\"enable-btn\"  class=\"addon-control enable\"\n                        label=\"FROM-DTD.cmd.enableAddon.label;\"\n                        oncommand=\"document.getBindingParent(this).userDisabled = false;\"/>\n            <xul:button anonid=\"disable-btn\" class=\"addon-control disable\"\n                        label=\"FROM-DTD.cmd.disableAddon.label;\"\n                        oncommand=\"document.getBindingParent(this).userDisabled = true;\"/>\n            <xul:button anonid=\"replacement-btn\" class=\"addon-control replacement\"\n                        label=\"FROM-DTD.cmd.findReplacement.label;\"\n                        oncommand=\"document.getBindingParent(this).findReplacement();\"/>\n            <xul:button anonid=\"remove-btn\" class=\"addon-control remove\"\n                        label=\"FROM-DTD.cmd.uninstallAddon.label;\"\n                        oncommand=\"document.getBindingParent(this).uninstall();\"/>\n            <xul:menulist anonid=\"state-menulist\"\n                          class=\"addon-control state\"\n                          flex=\"1\"\n                          tooltiptext=\"FROM-DTD.cmd.stateMenu.tooltip;\">\n              <xul:menupopup>\n                <xul:menuitem anonid=\"ask-to-activate-menuitem\"\n                              class=\"addon-control\"\n                              label=\"FROM-DTD.cmd.askToActivate.label;\"\n                              tooltiptext=\"FROM-DTD.cmd.askToActivate.tooltip;\"\n                              oncommand=\"document.getBindingParent(this).userDisabled = AddonManager.STATE_ASK_TO_ACTIVATE;\"/>\n                <xul:menuitem anonid=\"always-activate-menuitem\"\n                              class=\"addon-control\"\n                              label=\"FROM-DTD.cmd.alwaysActivate.label;\"\n                              tooltiptext=\"FROM-DTD.cmd.alwaysActivate.tooltip;\"\n                              oncommand=\"document.getBindingParent(this).userDisabled = false;\"/>\n                <xul:menuitem anonid=\"never-activate-menuitem\"\n                              class=\"addon-control\"\n                              label=\"FROM-DTD.cmd.neverActivate.label;\"\n                              tooltiptext=\"FROM-DTD.cmd.neverActivate.tooltip;\"\n                              oncommand=\"document.getBindingParent(this).userDisabled = true;\"/>\n              </xul:menupopup>\n            </xul:menulist>\n          </xul:hbox>\n        </xul:vbox>\n      </xul:hbox>\n      <xul:hbox class=\"description-container privateBrowsing-notice-container\">\n        <xul:label anonid=\"privateBrowsing\" class=\"description privateBrowsing-notice\" value=\"FROM-DTD.addon.privateBrowsing.label;\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        window.customElements.upgrade(this._stateMenulist);\n        window.customElements.upgrade(this._enableBtn);\n        window.customElements.upgrade(this._disableBtn);\n        window.customElements.upgrade(this._askToActivateMenuitem);\n        window.customElements.upgrade(this._alwaysActivateMenuitem);\n        window.customElements.upgrade(this._neverActivateMenuitem);\n\n        this._installStatus = document.getAnonymousElementByAttribute(this, \"anonid\", \"install-status\");\n        this._installStatus.mControl = this;\n\n        this.setAttribute(\"contextmenu\", \"addonitem-popup\");\n\n        this._showStatus(\"none\");\n\n        this._initWithAddon(this.mAddon);\n\n        gEventManager.registerAddonListener(this, this.mAddon.id);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        gEventManager.unregisterAddonListener(this, this.mAddon.id);\n      ]]></destructor>\n\n      <field name=\"_warningContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning-container\");\n      </field>\n      <field name=\"_warning\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning\");\n      </field>\n      <field name=\"_warningLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning-link\");\n      </field>\n      <field name=\"_warningBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning-btn\");\n      </field>\n      <field name=\"_errorContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"error-container\");\n      </field>\n      <field name=\"_error\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"error\");\n      </field>\n      <field name=\"_errorLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"error-link\");\n      </field>\n      <field name=\"_pendingContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"pending-container\");\n      </field>\n      <field name=\"_pending\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"pending\");\n      </field>\n      <field name=\"_infoContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"info-container\");\n      </field>\n      <field name=\"_info\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"info\");\n      </field>\n      <field name=\"_icon\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"icon\");\n      </field>\n      <field name=\"_dateUpdated\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"date-updated\");\n      </field>\n      <field name=\"_description\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"description\");\n      </field>\n      <field name=\"_stateMenulist\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"state-menulist\");\n      </field>\n      <field name=\"_askToActivateMenuitem\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"ask-to-activate-menuitem\");\n      </field>\n      <field name=\"_alwaysActivateMenuitem\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"always-activate-menuitem\");\n      </field>\n      <field name=\"_neverActivateMenuitem\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"never-activate-menuitem\");\n      </field>\n      <field name=\"_preferencesBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"preferences-btn\");\n      </field>\n      <field name=\"_enableBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"enable-btn\");\n      </field>\n      <field name=\"_disableBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"disable-btn\");\n      </field>\n      <field name=\"_removeBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"remove-btn\");\n      </field>\n      <field name=\"_updateBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"update-btn\");\n      </field>\n      <field name=\"_controlContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"control-container\");\n      </field>\n      <field name=\"_installStatus\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"install-status\");\n      </field>\n      <field name=\"_checkingUpdate\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"checking-update\");\n      </field>\n      <field name=\"_updateAvailable\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"update-available\");\n      </field>\n      <field name=\"_includeUpdate\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"include-update\");\n      </field>\n      <field name=\"_relNotesLoaded\">false</field>\n      <field name=\"_relNotesToggle\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-toggle-btn\");\n      </field>\n      <field name=\"_relNotesLoading\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-loading\");\n      </field>\n      <field name=\"_relNotesError\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-error\");\n      </field>\n      <field name=\"_relNotesContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-container\");\n      </field>\n      <field name=\"_relNotes\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes\");\n      </field>\n\n      <property name=\"userDisabled\">\n        <getter><![CDATA[\n          return this.mAddon.userDisabled;\n        ]]></getter>\n        <setter><![CDATA[\n          if (val === true) {\n            gViewController.commands.cmd_disableItem.doCommand(this.mAddon);\n          } else if (val === false) {\n            gViewController.commands.cmd_enableItem.doCommand(this.mAddon);\n          } else {\n            this.mAddon.userDisabled = val;\n          }\n        ]]></setter>\n      </property>\n\n      <property name=\"includeUpdate\">\n        <getter><![CDATA[\n          return this._includeUpdate.checked && !!this.mManualUpdate;\n        ]]></getter>\n        <setter><![CDATA[\n          // XXXunf Eventually, we'll want to persist this for individual\n          //        updates - see bug 594619.\n          this._includeUpdate.checked = !!val;\n        ]]></setter>\n      </property>\n\n      <method name=\"_initWithAddon\">\n        <parameter name=\"aAddon\"/>\n        <body><![CDATA[\n          this.mAddon = aAddon;\n\n          this._installStatus.mAddon = this.mAddon;\n          this._updateDates();\n          this._updateState();\n\n          this.setAttribute(\"name\", aAddon.name);\n\n          var iconURL = AddonManager.getPreferredIconURL(aAddon, 24, window);\n          if (iconURL)\n            this._icon.src = iconURL;\n          else\n            this._icon.src = \"\";\n\n          if (this.mAddon.description)\n            this._description.value = this.mAddon.description;\n          else\n            this._description.hidden = true;\n\n          // Set a previewURL for themes if one exists.\n          let previewURL = this.mAddon.type == \"theme\" &&\n            this.mAddon.screenshots &&\n            this.mAddon.screenshots[0] &&\n            this.mAddon.screenshots[0].url;\n          this.setAttribute(\"previewURL\", previewURL ? previewURL : \"\");\n          this.setAttribute(\"hasPreview\", previewURL ? \"true\" : \"fase\");\n\n          let legacyWarning = legacyExtensionsEnabled && !this.mAddon.install &&\n            isLegacyExtension(this.mAddon);\n          this.setAttribute(\"legacy\", legacyWarning);\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"legacy\").href = SUPPORT_URL + \"webextensions\";\n\n          if (!allowPrivateBrowsingByDefault && this.mAddon.type === \"extension\") {\n            ExtensionPermissions.get(this.mAddon.id).then((perms) => {\n              let allowed = perms.permissions.includes(\"internal:privateBrowsingAllowed\");\n              this.setAttribute(\"privateBrowsing\", allowed);\n              if (!allowed && PrivateBrowsingUtils.isContentWindowPrivate(window)) {\n                // Hide the preferences button if the current window is\n                // private and the addon is not allowed to access it.\n                this._preferencesBtn.hidden = true;\n              }\n            });\n          }\n\n          if (!(\"applyBackgroundUpdates\" in this.mAddon) ||\n              (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DISABLE ||\n               (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DEFAULT &&\n                !AddonManager.autoUpdateDefault))) {\n            AddonManager.getAllInstalls().then(aInstallsList => {\n              // This can return after the binding has been destroyed,\n              // so try to detect that and return early\n              if (!(\"onNewInstall\" in this))\n                return;\n              for (let install of aInstallsList) {\n                if (install.existingAddon &&\n                    install.existingAddon.id == this.mAddon.id &&\n                    install.state == AddonManager.STATE_AVAILABLE) {\n                  this.onNewInstall(install);\n                  this.onIncludeUpdateChanged();\n                }\n              }\n            });\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_showStatus\">\n        <parameter name=\"aType\"/>\n        <body><![CDATA[\n          this._controlContainer.hidden = aType != \"none\" &&\n                                          !(aType == \"update-available\" && !this.hasAttribute(\"upgrade\"));\n\n          this._installStatus.hidden = aType != \"progress\";\n          if (aType == \"progress\")\n            this._installStatus.refreshState();\n          this._checkingUpdate.hidden = aType != \"checking-update\";\n          this._updateAvailable.hidden = aType != \"update-available\";\n          this._relNotesToggle.hidden = !(this.mManualUpdate ?\n                                          this.mManualUpdate.releaseNotesURI :\n                                          this.mAddon.releaseNotesURI);\n        ]]></body>\n      </method>\n\n      <method name=\"_updateDates\">\n        <body><![CDATA[\n          function formatDate(aDate) {\n            const dtOptions = { year: \"numeric\", month: \"long\", day: \"numeric\" };\n            return aDate.toLocaleDateString(undefined, dtOptions);\n          }\n\n          if (this.mAddon.updateDate)\n            this._dateUpdated.value = formatDate(this.mAddon.updateDate);\n          else\n            this._dateUpdated.value = this._dateUpdated.getAttribute(\"unknown\");\n        ]]></body>\n      </method>\n\n      <method name=\"_updateState\">\n        <body><![CDATA[\n          if (this.parentNode.selectedItem == this)\n            gViewController.updateCommands();\n\n          var pending = this.mAddon.pendingOperations;\n          if (pending & AddonManager.PENDING_UNINSTALL) {\n            this.removeAttribute(\"notification\");\n\n            // We don't care about pending operations other than uninstall.\n            // They're transient, and cannot be undone.\n            this.setAttribute(\"pending\", \"uninstall\");\n            this._pending.textContent = gStrings.ext.formatStringFromName(\n              \"notification.restartless-uninstall\",\n              [this.mAddon.name]);\n          } else {\n            this.removeAttribute(\"pending\");\n\n            var isUpgrade = this.hasAttribute(\"upgrade\");\n            var install = this._installStatus.mInstall;\n\n            if (install && install.state == AddonManager.STATE_DOWNLOAD_FAILED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.downloadError\",\n                [this.mAddon.name]\n              );\n              this._warningBtn.label = gStrings.ext.GetStringFromName(\"notification.downloadError.retry\");\n              this._warningBtn.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n              this._warningBtn.setAttribute(\"oncommand\", \"document.getBindingParent(this).retryInstall();\");\n              this._warningBtn.hidden = false;\n              this._warningLink.hidden = true;\n            } else if (install && install.state == AddonManager.STATE_INSTALL_FAILED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.installError\",\n                [this.mAddon.name]\n              );\n              this._warningBtn.label = gStrings.ext.GetStringFromName(\"notification.installError.retry\");\n              this._warningBtn.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n              this._warningBtn.setAttribute(\"oncommand\", \"document.getBindingParent(this).retryInstall();\");\n              this._warningBtn.hidden = false;\n              this._warningLink.hidden = true;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_BLOCKED) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.blocked\",\n                [this.mAddon.name]\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.blocked.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._errorLink.href = url;\n                this._errorLink.hidden = false;\n              });\n            } else if (!isUpgrade && isDisabledUnsigned(this.mAddon)) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.unsignedAndDisabled\", [this.mAddon.name, gStrings.brandShortName]\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.unsigned.link\");\n              this._errorLink.href = SUPPORT_URL + \"unsigned-addons\";\n              this._errorLink.hidden = false;\n            } else if ((!isUpgrade && !this.mAddon.isCompatible) && (AddonManager.checkCompatibility\n            || (this.mAddon.blocklistState != Ci.nsIBlocklistService.STATE_SOFTBLOCKED))) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.incompatible\",\n                [this.mAddon.name, gStrings.brandShortName, gStrings.appVersion]\n              );\n              this._warningLink.hidden = true;\n              this._warningBtn.hidden = true;\n            } else if (!isUpgrade && !isCorrectlySigned(this.mAddon)) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.unsigned\", [this.mAddon.name, gStrings.brandShortName]\n              );\n              this._warningLink.value = gStrings.ext.GetStringFromName(\"notification.unsigned.link\");\n              this._warningLink.href = SUPPORT_URL + \"unsigned-addons\";\n              this._warningLink.hidden = false;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_SOFTBLOCKED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.softblocked\",\n                [this.mAddon.name]\n              );\n              this._warningLink.value = gStrings.ext.GetStringFromName(\"notification.softblocked.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._warningLink.href = url;\n                this._warningLink.hidden = false;\n              });\n              this._warningBtn.hidden = true;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_OUTDATED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.outdated\",\n                [this.mAddon.name]\n              );\n              this._warningLink.value = gStrings.ext.GetStringFromName(\"notification.outdated.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._warningLink.href = url;\n                this._warningLink.hidden = false;\n              });\n              this._warningBtn.hidden = true;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_VULNERABLE_UPDATE_AVAILABLE) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.vulnerableUpdatable\",\n                [this.mAddon.name]\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.vulnerableUpdatable.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._errorLink.href = url;\n                this._errorLink.hidden = false;\n              });\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_VULNERABLE_NO_UPDATE) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.vulnerableNoUpdate\",\n                [this.mAddon.name]\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.vulnerableNoUpdate.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._errorLink.href = url;\n                this._errorLink.hidden = false;\n              });\n            } else if (this.mAddon.isGMPlugin && !this.mAddon.isInstalled &&\n                       this.mAddon.isActive) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent =\n                gStrings.ext.formatStringFromName(\"notification.gmpPending\",\n                                                  [this.mAddon.name]);\n            } else {\n              this.removeAttribute(\"notification\");\n            }\n          }\n\n          this._preferencesBtn.hidden = !this.mAddon.optionsType && this.mAddon.type != \"plugin\";\n\n          if (this.typeHasFlag(\"SUPPORTS_ASK_TO_ACTIVATE\")) {\n            this._enableBtn.disabled = true;\n            this._disableBtn.disabled = true;\n            this._askToActivateMenuitem.disabled = !this.hasPermission(\"ask_to_activate\");\n            let alwaysActivateProp = this.mAddon.isFlashPlugin ? \"hidden\" : \"disabled\";\n            this._alwaysActivateMenuitem[alwaysActivateProp] = !this.hasPermission(\"enable\");\n            this._neverActivateMenuitem.disabled = !this.hasPermission(\"disable\");\n            if (!this.mAddon.isActive) {\n              this._stateMenulist.selectedItem = this._neverActivateMenuitem;\n            } else if (this.mAddon.userDisabled == AddonManager.STATE_ASK_TO_ACTIVATE) {\n              this._stateMenulist.selectedItem = this._askToActivateMenuitem;\n            } else {\n              this._stateMenulist.selectedItem = this._alwaysActivateMenuitem;\n            }\n            let hasActivatePermission =\n              [\"ask_to_activate\", \"enable\", \"disable\"].some(perm => this.hasPermission(perm));\n            this._stateMenulist.disabled = !hasActivatePermission;\n            this._stateMenulist.hidden = false;\n            this._askToActivateMenuitem.classList.add(\"no-auto-hide\");\n            this._alwaysActivateMenuitem.classList.add(\"no-auto-hide\");\n            this._neverActivateMenuitem.classList.add(\"no-auto-hide\");\n            this._stateMenulist.classList.add(\"no-auto-hide\");\n          } else {\n            this._stateMenulist.hidden = true;\n\n            let enableTooltip = gViewController.commands.cmd_enableItem\n                                               .getTooltip(this.mAddon);\n            this._enableBtn.setAttribute(\"tooltiptext\", enableTooltip);\n            if (this.hasPermission(\"enable\")) {\n              this._enableBtn.hidden = false;\n            } else {\n              this._enableBtn.hidden = true;\n            }\n\n            let disableTooltip = gViewController.commands.cmd_disableItem\n                                                .getTooltip(this.mAddon);\n            this._disableBtn.setAttribute(\"tooltiptext\", disableTooltip);\n            if (this.hasPermission(\"disable\")) {\n              this._disableBtn.hidden = false;\n            } else {\n              this._disableBtn.hidden = true;\n            }\n          }\n\n          let uninstallTooltip = gViewController.commands.cmd_uninstallItem\n                                                .getTooltip(this.mAddon);\n          this._removeBtn.setAttribute(\"tooltiptext\", uninstallTooltip);\n          if (this.hasPermission(\"uninstall\")) {\n            this._removeBtn.hidden = false;\n          } else {\n            this._removeBtn.hidden = true;\n          }\n\n          this.setAttribute(\"active\", this.mAddon.isActive);\n\n          var showProgress = (this.mAddon.install &&\n                              this.mAddon.install.state != AddonManager.STATE_INSTALLED);\n          this._showStatus(showProgress ? \"progress\" : \"none\");\n        ]]></body>\n      </method>\n\n      <method name=\"_fetchReleaseNotes\">\n        <parameter name=\"aURI\"/>\n        <body><![CDATA[\n          let sendToggleEvent = () => {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"RelNotesToggle\", true, true);\n            this.dispatchEvent(event);\n          };\n\n          if (!aURI || this._relNotesLoaded) {\n            sendToggleEvent();\n            return;\n          }\n\n          this._relNotesLoaded = true;\n          this._relNotesLoading.hidden = false;\n          this._relNotesError.hidden = true;\n\n          loadReleaseNotes(aURI).then(fragment => {\n            this._relNotesLoading.hidden = true;\n            this._relNotes.appendChild(fragment);\n            if (this.hasAttribute(\"show-relnotes\")) {\n              var container = this._relNotesContainer;\n              container.style.height = container.scrollHeight + \"px\";\n            }\n            sendToggleEvent();\n          }, () => {\n            this._relNotesLoading.hidden = true;\n            this._relNotesError.hidden = false;\n            this._relNotesLoaded = false; // allow loading to be re-tried\n            sendToggleEvent();\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"toggleReleaseNotes\">\n        <body><![CDATA[\n          if (this.hasAttribute(\"show-relnotes\")) {\n            this._relNotesContainer.style.height = \"0px\";\n            this.removeAttribute(\"show-relnotes\");\n            this._relNotesToggle.setAttribute(\n              \"label\",\n              this._relNotesToggle.getAttribute(\"showlabel\")\n            );\n            this._relNotesToggle.setAttribute(\n              \"tooltiptext\",\n              this._relNotesToggle.getAttribute(\"showtooltip\")\n            );\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"RelNotesToggle\", true, true);\n            this.dispatchEvent(event);\n          } else {\n            this._relNotesContainer.style.height = this._relNotesContainer.scrollHeight +\n                                                   \"px\";\n            this.setAttribute(\"show-relnotes\", true);\n            this._relNotesToggle.setAttribute(\n              \"label\",\n              this._relNotesToggle.getAttribute(\"hidelabel\")\n            );\n            this._relNotesToggle.setAttribute(\n              \"tooltiptext\",\n              this._relNotesToggle.getAttribute(\"hidetooltip\")\n            );\n            var uri = this.mManualUpdate ?\n                      this.mManualUpdate.releaseNotesURI :\n                      this.mAddon.releaseNotesURI;\n            this._fetchReleaseNotes(uri);\n\n            // Dispatch an event so extensions.js can record telemetry.\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"RelNotesShow\", true, true);\n            this.dispatchEvent(event);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"undo\">\n        <body><![CDATA[\n          gViewController.commands.cmd_cancelOperation.doCommand(this.mAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"uninstall\">\n        <body><![CDATA[\n          // If the type doesn't support undoing of restartless uninstalls,\n          // then we fake it by just disabling it it, and doing the real\n          // uninstall later.\n          if (this.typeHasFlag(\"SUPPORTS_UNDO_RESTARTLESS_UNINSTALL\")) {\n            this.mAddon.uninstall(true);\n          } else {\n            this.setAttribute(\"wasDisabled\", this.mAddon.userDisabled);\n\n            // We must set userDisabled to true first, this will call\n            // _updateState which will clear any pending attribute set.\n            this.mAddon.disable().then(() => {\n              // This won't update any other add-on manager views (bug 582002)\n              this.setAttribute(\"pending\", \"uninstall\");\n            });\n          }\n\n          // Dispatch an event so extensions.js can track telemetry.\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"Uninstall\", true, true);\n          this.dispatchEvent(event);\n        ]]></body>\n      </method>\n\n      <method name=\"showPreferences\">\n        <body><![CDATA[\n          gViewController.doCommand(\"cmd_showItemPreferences\", this.mAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"upgrade\">\n        <body><![CDATA[\n          var install = this.mManualUpdate;\n          delete this.mManualUpdate;\n          install.install();\n        ]]></body>\n      </method>\n\n      <method name=\"retryInstall\">\n        <body><![CDATA[\n          var install = this._installStatus.mInstall;\n          if (!install)\n            return;\n          if (install.state != AddonManager.STATE_DOWNLOAD_FAILED &&\n              install.state != AddonManager.STATE_INSTALL_FAILED)\n            return;\n          install.install();\n        ]]></body>\n      </method>\n\n      <method name=\"showInDetailView\">\n        <body><![CDATA[\n          gViewController.loadView(\"addons://detail/\" +\n                                   encodeURIComponent(this.mAddon.id));\n        ]]></body>\n      </method>\n\n      <method name=\"findReplacement\">\n        <body><![CDATA[\n          let url = (this.mAddon.type == \"theme\") ?\n            SUPPORT_URL + \"complete-themes\" :\n            `https://addons.mozilla.org/find-replacement/?guid=${this.mAddon.id}`;\n            openURL(url);\n        ]]></body>\n      </method>\n\n      <method name=\"onIncludeUpdateChanged\">\n        <body><![CDATA[\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"IncludeUpdateChanged\", true, true);\n          this.dispatchEvent(event);\n        ]]></body>\n      </method>\n\n      <method name=\"onEnabling\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onEnabled\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDisabling\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDisabled\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onUninstalling\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onOperationCancelled\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onPropertyChanged\">\n        <parameter name=\"aProperties\"/>\n        <body><![CDATA[\n          if (aProperties.includes(\"appDisabled\") ||\n              aProperties.includes(\"signedState\") ||\n              aProperties.includes(\"userDisabled\"))\n            this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onUpdateAvailable\">\n        <body><![CDATA[\n          this._showStatus(\"update-available\");\n        ]]></body>\n      </method>\n\n      <method name=\"onNoUpdateAvailable\">\n        <body><![CDATA[\n          this._showStatus(\"none\");\n        ]]></body>\n      </method>\n\n      <method name=\"onCheckingUpdate\">\n        <body><![CDATA[\n          this._showStatus(\"checking-update\");\n        ]]></body>\n      </method>\n\n      <method name=\"onCompatibilityUpdateAvailable\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onExternalInstall\">\n        <parameter name=\"aAddon\"/>\n        <parameter name=\"aExistingAddon\"/>\n        <body><![CDATA[\n          if (aExistingAddon.id != this.mAddon.id)\n            return;\n\n          this._initWithAddon(aAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"onNewInstall\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          if (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_ENABLE)\n            return;\n          if (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DEFAULT &&\n              AddonManager.autoUpdateDefault)\n            return;\n\n          this.mManualUpdate = aInstall;\n          this._showStatus(\"update-available\");\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadStarted\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          this._updateState();\n          this._showStatus(\"progress\");\n          this._installStatus.initWithInstall(aInstall);\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallStarted\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          this._updateState();\n          this._showStatus(\"progress\");\n          this._installStatus.initWithInstall(aInstall);\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallEnded\">\n        <parameter name=\"aInstall\"/>\n        <parameter name=\"aAddon\"/>\n        <body><![CDATA[\n          this._initWithAddon(aAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadFailed\">\n        <body><![CDATA[\n            this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallFailed\">\n        <body><![CDATA[\n            this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallCancelled\">\n        <body><![CDATA[\n            this._updateState();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        if (![\"button\", \"checkbox\", \"menulist\", \"menuitem\"].includes(event.originalTarget.localName) &&\n            !event.originalTarget.classList.contains(\"text-link\") &&\n            // Treat the relnotes container as embedded text instead of a click target.\n            !event.originalTarget.closest(\".relnotes-container\")) {\n          this.showInDetailView();\n        } else if (event.originalTarget.localName == \"a\" &&\n                   event.originalTarget.closest(\".relnotes-container\") &&\n                   event.originalTarget.href) {\n          event.preventDefault();\n          event.stopPropagation();\n          openURL(event.originalTarget.href);\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n\n  <!-- Addon - uninstalled - An uninstalled addon that can be re-installed. -->\n  <binding id=\"addon-uninstalled\"\n           extends=\"chrome://mozapps/content/extensions/extensions.xml#addon-base\">\n    <content>\n      <xul:hbox class=\"pending\">\n        <xul:image class=\"pending-icon\"/>\n        <xul:label anonid=\"notice\" flex=\"1\"/>\n        <xul:button anonid=\"undo-btn\" class=\"button-link\"\n                    label=\"FROM-DTD.addon.undoRemove.label;\"\n                    tooltiptext=\"FROM-DTD.addon.undoRemove.tooltip;\"\n                    oncommand=\"document.getBindingParent(this).cancelUninstall();\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._notice.textContent = gStrings.ext.formatStringFromName(\"uninstallNotice\",\n                                                                     [this.mAddon.name]);\n\n        gEventManager.registerAddonListener(this, this.mAddon.id);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        gEventManager.unregisterAddonListener(this, this.mAddon.id);\n      ]]></destructor>\n\n      <field name=\"_notice\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"notice\");\n      </field>\n\n      <method name=\"cancelUninstall\">\n        <body><![CDATA[\n          // This assumes that disabling does not require a restart when\n          // uninstalling doesn't. Things will still work if not, the add-on\n          // will just still be active until finally getting uninstalled.\n\n          if (this.isPending(\"uninstall\"))\n            this.mAddon.cancelUninstall();\n          else if (this.getAttribute(\"wasDisabled\") != \"true\")\n            this.mAddon.enable();\n\n          // Dispatch an event so extensions.js can record telemetry.\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"Undo\", true, true);\n          this.dispatchEvent(event);\n\n          this.removeAttribute(\"pending\");\n        ]]></body>\n      </method>\n\n      <method name=\"onExternalInstall\">\n        <parameter name=\"aAddon\"/>\n        <parameter name=\"aExistingAddon\"/>\n        <body><![CDATA[\n          if (aExistingAddon.id != this.mAddon.id)\n            return;\n\n          // Make sure any newly installed add-on has the correct disabled state\n          if (this.hasAttribute(\"wasDisabled\")) {\n            if (this.getAttribute(\"wasDisabled\") == \"true\")\n              aAddon.disable();\n            else\n              aAddon.enable();\n          }\n\n          this.mAddon = aAddon;\n\n          this.removeAttribute(\"pending\");\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallStarted\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          // Make sure any newly installed add-on has the correct disabled state\n          if (this.hasAttribute(\"wasDisabled\")) {\n            if (this.getAttribute(\"wasDisabled\") == \"true\")\n              aInstall.addon.disable();\n            else\n              aInstall.addon.enable();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallEnded\">\n        <parameter name=\"aInstall\"/>\n        <parameter name=\"aAddon\"/>\n        <body><![CDATA[\n          this.mAddon = aAddon;\n\n          this.removeAttribute(\"pending\");\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Addon - installing - an addon item that is currently being installed -->\n  <binding id=\"addon-installing\"\n           extends=\"chrome://mozapps/content/extensions/extensions.xml#addon-base\">\n    <content>\n      <xul:hbox anonid=\"warning-container\" class=\"warning\">\n        <xul:image class=\"warning-icon\"/>\n        <xul:label anonid=\"warning\" flex=\"1\"/>\n        <xul:button anonid=\"warning-link\" class=\"button-link\"\n                   oncommand=\"document.getBindingParent(this).retryInstall();\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n      <xul:hbox class=\"content-container\">\n        <xul:vbox class=\"icon-outer-container\">\n          <xul:vbox class=\"icon-container\">\n            <xul:image anonid=\"icon\" class=\"icon\"/>\n          </xul:vbox>\n        </xul:vbox>\n        <xul:vbox class=\"fade name-outer-container\" flex=\"1\">\n          <xul:hbox class=\"name-container\">\n            <xul:label anonid=\"name\" class=\"name\" crop=\"end\" tooltip=\"addonitem-tooltip\"/>\n          </xul:hbox>\n        </xul:vbox>\n        <xul:vbox class=\"install-status-container\">\n          <xul:hbox anonid=\"install-status\" class=\"install-status\"/>\n        </xul:vbox>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._installStatus.mControl = this;\n        this._installStatus.mInstall = this.mInstall;\n        this.refreshInfo();\n      ]]></constructor>\n\n      <field name=\"_icon\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"icon\");\n      </field>\n      <field name=\"_name\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"name\");\n      </field>\n      <field name=\"_warning\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"warning\");\n      </field>\n      <field name=\"_warningLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"warning-link\");\n      </field>\n      <field name=\"_installStatus\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"install-status\");\n      </field>\n\n      <method name=\"onInstallCompleted\">\n        <body><![CDATA[\n          this.mAddon = this.mInstall.addon;\n          this.setAttribute(\"name\", this.mAddon.name);\n          this.setAttribute(\"value\", this.mAddon.id);\n          this.setAttribute(\"status\", \"installed\");\n        ]]></body>\n      </method>\n\n      <method name=\"refreshInfo\">\n        <body><![CDATA[\n          this.mAddon = this.mAddon || this.mInstall.addon;\n          if (this.mAddon) {\n            this._icon.src = this.mAddon.iconURL ||\n                             (this.mInstall ? this.mInstall.iconURL : \"\");\n            this._name.value = this.mAddon.name;\n          } else {\n            this._icon.src = this.mInstall.iconURL;\n            // AddonInstall.name isn't always available - fallback to filename\n            if (this.mInstall.name) {\n              this._name.value = this.mInstall.name;\n            } else if (this.mInstall.sourceURI) {\n              var url = Cc[\"@mozilla.org/network/standard-url-mutator;1\"]\n                          .createInstance(Ci.nsIStandardURLMutator)\n                          .init(Ci.nsIStandardURL.URLTYPE_STANDARD,\n                                80, this.mInstall.sourceURI.spec,\n                                null, null)\n                          .finalize()\n                          .QueryInterface(Ci.nsIURL);\n              this._name.value = url.fileName;\n            }\n          }\n\n          if (this.mInstall.state == AddonManager.STATE_DOWNLOAD_FAILED) {\n            this.setAttribute(\"notification\", \"warning\");\n            this._warning.textContent = gStrings.ext.formatStringFromName(\n              \"notification.downloadError\",\n              [this._name.value]\n            );\n            this._warningLink.label = gStrings.ext.GetStringFromName(\"notification.downloadError.retry\");\n            this._warningLink.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n          } else if (this.mInstall.state == AddonManager.STATE_INSTALL_FAILED) {\n            this.setAttribute(\"notification\", \"warning\");\n            this._warning.textContent = gStrings.ext.formatStringFromName(\n              \"notification.installError\",\n              [this._name.value]\n            );\n            this._warningLink.label = gStrings.ext.GetStringFromName(\"notification.installError.retry\");\n            this._warningLink.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n          } else {\n            this.removeAttribute(\"notification\");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"retryInstall\">\n        <body><![CDATA[\n          this.mInstall.install();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"detail-row\">\n    <content>\n      <xul:label class=\"detail-row-label\" xbl:inherits=\"value=label\"/>\n      <xul:label class=\"detail-row-value\" xbl:inherits=\"value\"/>\n    </content>\n\n    <implementation>\n      <property name=\"value\">\n        <getter><![CDATA[\n          return this.getAttribute(\"value\");\n        ]]></getter>\n        <setter><![CDATA[\n          if (!val)\n            this.removeAttribute(\"value\");\n          else\n            this.setAttribute(\"value\", val);\n        ]]></setter>\n      </property>\n    </implementation>\n  </binding>\n\n</bindings>\n"}];
    </script>
  </head>
  <body>
  <main>
  <header>
  <div id="links">
    <a href="../">Home</a>
    <a href="https://github.com/bgrins/xbl-analysis">Code</a>
  </div>
  <h1>XBL To Custom Element Converter</h1>
  </header>
  <div id="converter">
    <ul>
    <li><a href='#' data-index=0>urlbarBindings.xml</a></li>
<li><a href='#' data-index=1>menu.xml</a></li>
<li><a href='#' data-index=2>autocomplete.xml</a></li>
<li><a href='#' data-index=3>general.xml</a></li>
<li><a href='#' data-index=4>popup.xml</a></li>
<li><a href='#' data-index=5>richlistbox.xml</a></li>
<li><a href='#' data-index=6>scrollbox.xml</a></li>
<li><a href='#' data-index=7>textbox.xml</a></li>
<li><a href='#' data-index=8>extensions.xml</a></li>
    </ul>
    <textarea>
    <?xml version="1.0"?>
<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->


<bindings id="generalBindings"
   xmlns="http://www.mozilla.org/xbl"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
   xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="basecontrol">
    <implementation implements="nsIDOMXULControlElement">
      <!-- public implementation -->
      <property name="disabled" onset="if (val) this.setAttribute('disabled', 'true');
                                       else this.removeAttribute('disabled');
                                       return val;"
                                onget="return this.getAttribute('disabled') == 'true';"/>
      <property name="tabIndex" onget="return parseInt(this.getAttribute('tabindex')) || 0"
                                onset="if (val) this.setAttribute('tabindex', val);
                                       else this.removeAttribute('tabindex'); return val;"/>
    </implementation>
  </binding>

  <binding id="basetext" extends="chrome://global/content/bindings/general.xml#basecontrol">
    <implementation>
      <!-- public implementation -->
      <property name="label"      onset="this.setAttribute('label',val); return val;"
                                  onget="return this.getAttribute('label');"/>
      <property name="crop"       onset="this.setAttribute('crop',val); return val;"
                                  onget="return this.getAttribute('crop');"/>
      <property name="image"      onset="this.setAttribute('image',val); return val;"
                                  onget="return this.getAttribute('image');"/>
      <property name="command"    onset="this.setAttribute('command',val); return val;"
                                  onget="return this.getAttribute('command');"/>
      <property name="accessKey">
        <getter>
          <![CDATA[
            return this.getAttribute("accesskey");
          ]]>
        </getter>
        <setter>
          <![CDATA[
            // Always store on the control
            this.setAttribute("accesskey", val);
            // If there is a label, change the accesskey on the labelElement
            // if it's also set there
            let labelElement = document.getElementsByAttribute("control", this.id)[0];
            if (labelElement) {
              labelElement.setAttribute("accesskey", val);
            }
            return val;
          ]]>
        </setter>
      </property>
    </implementation>
  </binding>

</bindings>

    </textarea>
    <pre></pre>
  </div>
  </main>
    <script>
    function getJSForBinding(binding) {
  let js = [];
  let elementName = binding.attrs.id;
  let className = 'Moz' + titleCase(elementName);
  let hasExtends = !!formatExtends(binding.attrs.extends);
  js.push(`class ${className} `);
  if (hasExtends) {
    js.push(`extends Moz${formatExtends(binding.attrs.extends)} `);
  } else {
    js.push(`extends MozXULElement `);
  }

  js.push('{')

  let childMarkup = [];
  let content = binding.find("content");
  if (content.length === 0) {
    content = binding.find("xbl:content");
  }
  if (content.length > 1) {
    throw "Unexpected second content field";
  } else if (content.length === 1) {
    function printChild(child, depth) {
      let attrs = '';
      for (var attr in child.attrs) {
        attrs += ' ' + attr.replace('xbl:', '') + '="' + child.attrs[attr].replace('"', '\"').replace(/xbl\:/g, '') + '"';
      }
      let name = child.name.replace('xul:', '');
      let padding = (new Array(depth + 3)).join("  ");
      childMarkup.push(`\n${padding}<${name}${attrs}>`);
      child.children.forEach(c => printChild(c, depth+1));
      let closePadding = child.children.length ? `\n${padding}` : '';
      childMarkup.push(`${closePadding}</${name}>`);
    }
    content[0].children.forEach(c => printChild(c, 1));
  } else {
    console.log("No content for binding", binding.attrs.id);
  }

  let innerHTML = "";

  if (content.length) {
    innerHTML += 'this.textContent = "";\n';
    innerHTML += "this.appendChild(MozXULElement.parseXULToFragment(`" + childMarkup.join('') + "\n    `));\n";

    if (childMarkup.join("").includes("inherits=")) {
      innerHTML += "// XXX: Implement `this.inheritAttribute()` for the [inherits] attribute in the markup above!\n";
    }
  }

  let xblconstructor = (binding.find("constructor") || [])[0];
  let xblconstructorComment = xblconstructor ? formatComment(xblconstructor.comment) : null;
  xblconstructor = xblconstructor ? `${xblconstructor.cdata || xblconstructor.value}` : '';
  if (xblconstructorComment) {
    xblconstructor = xblconstructorComment + "\n" + xblconstructor;
  }
  // Or, try / catch since many components will fail when loaded in a tab due to chrome references
  // xblconstructor = xblconstructor ? `try { ${xblconstructor.cdata} } catch(e) { }` : '';

  let xbldestructor = (binding.find("destructor") || [])[0];
  let xbldestructorComment = xbldestructor ? formatComment(xbldestructor.comment) : null;
  xbldestructor = xbldestructor ? `${xbldestructor.cdata || xbldestructor.value}` : '';
  // Or, try / catch since many components will fail when loaded in a tab due to chrome references
  // xbldestructor = xbldestructor ? `try { ${xbldestructor.cdata} } catch(e) { }` : '';
  if (xbldestructor != '') {
    xbldestructor = `disconnectedCallback() { ${xbldestructor} }`
    if (xblconstructorComment) {
      xbldestructor = xblconstructorComment + "\n" + xbldestructor;
    }
  }

  let handlers = [];
console.log(binding.attrs.id);
if (binding.attrs.id == "browser") {
  console.log("BROWSER", binding.find('handler').length);
}
  // <handler>
  for (let handler of binding.find('handler')) {
    let comment = formatComment(handler.comment);
    if (comment) {
      handlers.push(comment);
    }

    let secondParam = "";
    let isCapturing = handler.attrs.phase === "capturing";
    if (handler.attrs.group === "system") {
      if (isCapturing) {
        secondParam = `, { capture: true, mozSystemGroup: true }`;
      } else {
        secondParam = `, { mozSystemGroup: true }`;
      }
    } else if (isCapturing) {
      secondParam = ", true";
    }
    let keycode = handler.attrs.keycode ?
`
if (event.keyCode != KeyEvent.DOM_${handler.attrs.keycode}) {
  return;
}
` : "";
    let button = handler.attrs.button ?
`
if (event.button != ${handler.attrs.button}) {
  return;
}
` : "";

// console.log("BROWSER", binding.attrs.id);
// if (binding.attrs.id == "browser") {
//   console.log("BROWSER", keycode);
// }
    handlers.push(`this.addEventListener("${handler.attrs.event}", (event) => {${keycode}${button} ${handler.cdata || handler.value || handler.attrs.action}}${secondParam});\n`);
  }


  // <field>
  let fields = [];
  for (let field of binding.find('field')) {
    // Work around fields like _weekStart in the datepicker where the value is coming from a dtd.
    // Just print an empty string in that case.
    let data = (field.cdata || field.value || "").trim();
    if (data.startsWith("FROM-DTD")) {
      data = `"${data}"`
    }
    data = (data.length === 0) ? '""' : data;

    // Remove leading comments, which would cause the 'return' to be on a different line
    // than the expression.
    let leadingComments = [];
    let expressions = data.split("\n");
    for (var i = 0; i < expressions.length; i++) {
      if (expressions[i].trim().startsWith("//")) {
        leadingComments.push(expressions[i]);
      } else {
        expressions = expressions.slice(i);
        break;
      }
    }

    let expr = expressions.join("\n");
    if (expr[expr.length - 1] !== ";") {
      expr += ";";
    }
    // Strip away parens that were only needed for XBL
    if (expr[0] === "(" && expr[expr.length - 2] === ")") {
      expr = expr.substring(1, expr.length - 2) + ";";
    }

    let comment = formatComment(field.comment);
    if (comment) {
      fields.push(comment);
    }

    if (leadingComments.length) {
      fields.push(leadingComments.join("\n"));
    }

    fields.push(`this.${field.attrs.name} = ${expr}\n`);

    // let setter = field.attrs.readonly ? '' :
    // `set(val) {
    //     delete this.${field.attrs.name};
    //     return this.${field.attrs.name} = val;
    // },`;

    // fields.push(`Object.defineProperty(this, "${field.attrs.name}", {
    //   configurable: true,
    //   enumerable: true,
    //   get() {
    //     ${comments.join('\n')}
    //     delete this.${field.attrs.name};
    //     return this.${field.attrs.name} = ${expressions.join('\n')}
    //   },
    //   ${setter}
    // })`);
  }

  if (handlers.length) {
    js.push(`
      constructor() {
        super();

        ${handlers.join("\n")}
      }
    `)
  }

  js.push(`
    connectedCallback() {
      if (this.delayConnectedCallback()) {
        return;
      }
      ${innerHTML}
      ${fields.join("\n")}

      ${xblconstructor}
    }
  `);

  // <property>
  for (let property of binding.find('property')) {
    let comment = formatComment(property.comment);
    if (comment) {
      js.push(comment);
    }
    if (property.attrs.onset) {
      js.push(`
        set ${property.attrs.name}(val) {
          ${property.attrs.onset}
        }
      `);
    } else if(property.find('setter').length) {
      js.push(`
        set ${property.attrs.name}(val) {${property.find('setter')[0].cdata || property.find('setter')[0].value}}
      `);
    }
    if (property.attrs.onget) {
      js.push(`
        get ${property.attrs.name}() {
          ${property.attrs.onget}
        }
      `);
    } else if(property.find('getter').length) {
      js.push(`
        get ${property.attrs.name}() {${property.find('getter')[0].cdata || property.find('getter')[0].value}}
      `);
    }
  }

  // <method>
  for (let method of binding.find('method')) {
    js.push('\n');
    let comment = formatComment(method.comment);
    if (comment) {
      js.push(comment);
    }
    js.push(`${method.attrs.name}(`);
    js.push(`${method.find('parameter').map(p => p.attrs.name).join(',')}`);
    js.push(`) {`);
    js.push(method.find('body')[0].cdata || method.find('body')[0].value);
    js.push(`}\n`);
  }

  js.push(`${xbldestructor}`);

  js.push("}\n\n");

  let implements =
    binding.find("implementation").length &&
    binding.find("implementation")[0].attrs.implements
  if (implements) {
    implements = implements.split(",").map(i=>"Ci." + i.trim()).join(", ");
    js.push(`MozXULElement.implementCustomInterface(${className}, [${implements}]);`)
  }



  js.push(`customElements.define("${elementName}", ${className});
  `)
  return js.join(' ');
}
    function titleCase(str) {
  if (str == "basecontrol") {
    // Special case so we don't end up with Basecontrol:
    return "BaseControl";
  }
  return str[0].toUpperCase() + str.substr(1).replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
}
    function formatExtends(ext) {
  if (!ext || ext.startsWith("xul:")) {
    return null;
  }
  return titleCase(ext.split('#')[1]);
}
    function formatComment(comment, spaces = 2) {
  if (!comment) {
    return '';
  }

  let spacesStr = new Array(spaces).join(" ");
  let commentArr = comment.split("\n").map(s=> s.trim());
  if (!commentArr[0]) { commentArr.shift(); }
  if (!commentArr[commentArr.length - 1]) { commentArr.pop(); }
  let commentFormatted = commentArr
    .map(s => (s ? `${spacesStr}* ${s}` : `${spacesStr}*`))
    .join("\n");

  return `${spacesStr}/**\n${commentFormatted}\n${spacesStr}*/`;
}
    function getFormattedJSForBinding(binding) {
  let js = [];
  js.push(
`/* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

"use strict";

// This is loaded into all XUL windows. Wrap in a block to prevent
// leaking to window scope.
{

`);

  js.push(js_beautify(
    getJSForBinding(binding),
    {
      indent_size: 2,
      // preserve_newlines: false,
      max_preserve_newlines: 2,
      brace_style: "preserve-inline"
      // keep_array_indentation: true
    }
  ));

  js.push(`

}
`);

  return js.join("");
}

    var textarea = document.querySelector("textarea");
    var pre = document.querySelector("pre");
    function createPreview() {
      var body = textarea.value;
      body = body.replace(/&([a-z0-9-]+);/gi, "FROM-DTD-$1"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2-$3"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2-$3-$4"); // Replace DTD entities
      var parsed = xmlom.parseString(body, {
        xmlns: true,
      });
      parsed.then(doc => {
        console.log(doc, doc.find("binding"));
        let js = doc.find("binding").map(binding => {
          return getFormattedJSForBinding(binding);
        }).join("\n");
        pre.textContent = js;
      }).catch(e => {
        pre.textContent =  "Error parsing XML:\n" + e;
      });
    }
    textarea.addEventListener("input", createPreview);
    createPreview();

    document.querySelector("ul").addEventListener("click", function(e) {
      if (e.originalTarget.localName === "a") {
        e.preventDefault();
        textarea.value = files[e.originalTarget.dataset.index].body;
        createPreview();
      }
    });
    </script>
  </body>
  </html>
