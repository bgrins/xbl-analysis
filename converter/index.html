
  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8">
    <title>XBL To Custom Element Converter</title>
    <link rel="stylesheet" href="../static/styles.css" />
    <script src="../static/xmlom.js"></script>
    <script src="../static/beautify.js"></script>
    <style>
    main {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
      width: 100vw;
      position: absolute;
      top: 0;
      left: 0;
    }
    #converter {
      font-family: monospace;
      display: grid;
      overflow: hidden;
      grid-template-columns: auto 1fr 1fr;
      grid-gap: 10px;
    }
    textarea, pre {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: monospace;
      font-size: 12px;
    }
    ul {
      min-width: 100px;
      margin: 0;
      padding: 0;
      overflow: scroll;
      font-size: smaller;
    }
    li {
      margin: 0;
      padding: 0;
      list-style: none;
      word-break: keep-all;
    }
    </style>
    <script>
      var files = [{"file":"tabbrowser.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"tabBrowserBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"tabbrowser-arrowscrollbox\" extends=\"chrome://global/content/bindings/scrollbox.xml#arrowscrollbox\">\n    <implementation>\n      <!-- Override scrollbox.xml method, since our scrollbox's children are\n           inherited from the binding parent -->\n      <method name=\"_getScrollableElements\">\n        <body><![CDATA[\n          return Array.filter(document.getBindingParent(this).children,\n                              this._canScrollToElement, this);\n        ]]></body>\n      </method>\n      <method name=\"_canScrollToElement\">\n        <parameter name=\"tab\"/>\n        <body><![CDATA[\n          return !tab._pinnedUnscrollable && !tab.hidden;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"underflow\" phase=\"capturing\"><![CDATA[\n        // Ignore underflow events:\n        // - from nested scrollable elements\n        // - for vertical orientation\n        // - corresponding to an overflow event that we ignored\n        let tabs = document.getBindingParent(this);\n        if (event.originalTarget != this.scrollbox ||\n            event.detail == 0 ||\n            !tabs.hasAttribute(\"overflow\")) {\n          return;\n        }\n\n        tabs.removeAttribute(\"overflow\");\n\n        if (tabs._lastTabClosedByMouse) {\n          tabs._expandSpacerBy(this._scrollButtonDown.clientWidth);\n        }\n\n        for (let tab of Array.from(gBrowser._removingTabs)) {\n          gBrowser.removeTab(tab);\n        }\n\n        tabs._positionPinnedTabs();\n      ]]></handler>\n      <handler event=\"overflow\"><![CDATA[\n        // Ignore overflow events:\n        // - from nested scrollable elements\n        // - for vertical orientation\n        if (event.originalTarget != this.scrollbox ||\n            event.detail == 0) {\n          return;\n        }\n\n        var tabs = document.getBindingParent(this);\n        tabs.setAttribute(\"overflow\", \"true\");\n        tabs._positionPinnedTabs();\n        tabs._handleTabSelect(true);\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"tabbrowser-tabs\"\n           extends=\"chrome://global/content/bindings/tabbox.xml#tabs\">\n    <content>\n      <xul:hbox class=\"tab-drop-indicator-box\">\n        <xul:image class=\"tab-drop-indicator\" anonid=\"tab-drop-indicator\" collapsed=\"true\"/>\n      </xul:hbox>\n      <xul:arrowscrollbox anonid=\"arrowscrollbox\" orient=\"horizontal\" flex=\"1\"\n                          style=\"min-width: 1px;\"\n                          clicktoscroll=\"true\"\n                          class=\"tabbrowser-arrowscrollbox\">\n<!--\n This is a hack to circumvent bug 472020, otherwise the tabs show up on the\n right of the newtab button.\n-->\n        <children includes=\"tab\"/>\n<!--\n  This is to ensure anything extensions put here will go before the newtab\n  button, necessary due to the previous hack.\n-->\n        <children/>\n        <xul:toolbarbutton class=\"tabs-newtab-button toolbarbutton-1\"\n                           anonid=\"tabs-newtab-button\"\n                           command=\"cmd_newNavigatorTab\"\n                           onclick=\"checkForMiddleClick(this, event);\"\n                           />\n        <xul:spacer class=\"closing-tabs-spacer\" anonid=\"closing-tabs-spacer\"\n                    style=\"width: 0;\"/>\n      </xul:arrowscrollbox>\n    </content>\n\n    <implementation implements=\"nsIObserver\">\n      <constructor>\n        <![CDATA[\n          this._tabClipWidth = Services.prefs.getIntPref(\"browser.tabs.tabClipWidth\");\n          this._hiddenSoundPlayingTabs = new Set();\n\n          let strId = PrivateBrowsingUtils.isWindowPrivate(window) ?\n              \"emptyPrivateTabTitle\" : \"emptyTabTitle\";\n          this.emptyTabTitle = gTabBrowserBundle.GetStringFromName(\"tabs.\" + strId);\n\n          var tab = this.firstElementChild;\n          tab.label = this.emptyTabTitle;\n\n          let newTabButton = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"tabs-newtab-button\");\n          newTabButton.setAttribute(\"tooltiptext\", GetDynamicShortcutTooltipText(\"tabs-newtab-button\"));\n\n          window.addEventListener(\"resize\", this);\n\n          Services.prefs.addObserver(\"privacy.userContext\", this);\n          this.observe(null, \"nsPref:changed\", \"privacy.userContext.enabled\");\n\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"_tabMinWidthPref\",\n            \"browser.tabs.tabMinWidth\", null,\n            (pref, prevValue, newValue) => this._tabMinWidth = newValue,\n            newValue => {\n              const LIMIT = 50;\n              return Math.max(newValue, LIMIT);\n            },\n          );\n\n          this._tabMinWidth = this._tabMinWidthPref;\n\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"_multiselectEnabledPref\",\n            \"browser.tabs.multiselect\", null,\n            (pref, prevValue, newValue) => this._multiselectEnabled = newValue);\n          this._multiselectEnabled = this._multiselectEnabledPref;\n\n          this._setPositionalAttributes();\n\n          CustomizableUI.addListener(this);\n          this._updateNewTabVisibility();\n\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"_closeTabByDblclick\",\n            \"browser.tabs.closeTabByDblclick\", false);\n\n          if (gMultiProcessBrowser) {\n            this.tabbox.tabpanels.setAttribute(\"async\", \"true\");\n          }\n        ]]>\n      </constructor>\n\n      <destructor>\n        <![CDATA[\n          Services.prefs.removeObserver(\"privacy.userContext\", this);\n\n          CustomizableUI.removeListener(this);\n        ]]>\n      </destructor>\n\n      <field name=\"tabbox\" readonly=\"true\">\n        document.getElementById(\"tabbrowser-tabbox\");\n      </field>\n\n      <field name=\"contextMenu\" readonly=\"true\">\n        document.getElementById(\"tabContextMenu\");\n      </field>\n\n      <field name=\"arrowScrollbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowscrollbox\");\n      </field>\n\n      <field name=\"_firstTab\">null</field>\n      <field name=\"_lastTab\">null</field>\n      <field name=\"_beforeSelectedTab\">null</field>\n      <field name=\"_beforeHoveredTab\">null</field>\n      <field name=\"_afterHoveredTab\">null</field>\n      <field name=\"_hoveredTab\">null</field>\n\n      <property name=\"_tabMinWidth\">\n        <setter>\n          this.style.setProperty(\"--tab-min-width\", val + \"px\");\n          return val;\n        </setter>\n      </property>\n\n      <property name=\"_multiselectEnabled\">\n        <setter>\n          // Unlike boolean HTML attributes, the value of boolean ARIA attributes actually matters.\n          this.setAttribute(\"aria-multiselectable\", !!val);\n          return val;\n        </setter>\n        <getter>\n          return this.getAttribute(\"aria-multiselectable\") == \"true\";\n        </getter>\n      </property>\n\n      <method name=\"observe\">\n        <parameter name=\"aSubject\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aData\"/>\n        <body><![CDATA[\n          switch (aTopic) {\n            case \"nsPref:changed\":\n              // This is has to deal with changes in\n              // privacy.userContext.enabled and\n              // privacy.userContext.longPressBehavior.\n              let containersEnabled = Services.prefs.getBoolPref(\"privacy.userContext.enabled\")\n                                        && !PrivateBrowsingUtils.isWindowPrivate(window);\n\n              // This pref won't change so often, so just recreate the menu.\n              let longPressBehavior = Services.prefs.getIntPref(\"privacy.userContext.longPressBehavior\");\n\n              // If longPressBehavior pref is set to 0 (or any invalid value)\n              // long press menu is disabled.\n              if (containersEnabled && (longPressBehavior <= 0 || longPressBehavior > 2)) {\n                containersEnabled = false;\n              }\n\n              const newTab = document.getElementById(\"new-tab-button\");\n              const newTab2 = document.getAnonymousElementByAttribute(this, \"anonid\", \"tabs-newtab-button\");\n\n              for (let parent of [newTab, newTab2]) {\n                if (!parent)\n                  continue;\n\n                gClickAndHoldListenersOnElement.remove(parent);\n                parent.removeAttribute(\"type\");\n                if (parent.firstElementChild) {\n                  parent.firstElementChild.remove();\n                }\n\n                if (containersEnabled) {\n                  let popup = document.createElementNS(\n                                \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\",\n                                \"menupopup\");\n                  if (parent.id) {\n                    popup.id = \"newtab-popup\";\n                  } else {\n                    popup.setAttribute(\"anonid\", \"newtab-popup\");\n                  }\n                  popup.className = \"new-tab-popup\";\n                  popup.setAttribute(\"position\", \"after_end\");\n                  popup.addEventListener(\"popupshowing\", event => {\n                    createUserContextMenu(event, {\n                      useAccessKeys: false,\n                      showDefaultTab: Services.prefs.getIntPref(\"privacy.userContext.longPressBehavior\") == 1,\n                    });\n                  });\n                  parent.appendChild(popup);\n\n                  // longPressBehavior == 2 means that the menu is shown after X\n                  // millisecs. Otherwise, with 1, the menu is open immediatelly.\n                  if (longPressBehavior == 2) {\n                    gClickAndHoldListenersOnElement.add(parent);\n                  }\n\n                  parent.setAttribute(\"type\", \"menu\");\n                }\n              }\n\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <property name=\"_isCustomizing\" readonly=\"true\">\n        <getter><![CDATA[\n          return document.documentElement.getAttribute(\"customizing\") == \"true\";\n        ]]></getter>\n      </property>\n\n      <method name=\"_getVisibleTabs\">\n        <body><![CDATA[\n          // Cannot access gBrowser before it's initialized.\n          if (!gBrowser) {\n            return [ this.firstElementChild ];\n          }\n\n          return gBrowser.visibleTabs;\n        ]]></body>\n      </method>\n\n      <method name=\"_setPositionalAttributes\">\n        <body><![CDATA[\n          let visibleTabs = this._getVisibleTabs();\n          if (!visibleTabs.length) {\n            return;\n          }\n          let selectedTab = this.selectedItem;\n          let selectedIndex = visibleTabs.indexOf(selectedTab);\n          if (this._beforeSelectedTab) {\n            this._beforeSelectedTab.removeAttribute(\"beforeselected-visible\");\n          }\n\n          if (selectedTab.closing || selectedIndex <= 0) {\n            this._beforeSelectedTab = null;\n          } else {\n            let beforeSelectedTab = visibleTabs[selectedIndex - 1];\n            let separatedByScrollButton = this.getAttribute(\"overflow\") == \"true\" &&\n              beforeSelectedTab.pinned && !selectedTab.pinned;\n            if (!separatedByScrollButton) {\n              this._beforeSelectedTab = beforeSelectedTab;\n              this._beforeSelectedTab.setAttribute(\"beforeselected-visible\",\n                                                   \"true\");\n            }\n          }\n\n          if (this._firstTab)\n            this._firstTab.removeAttribute(\"first-visible-tab\");\n          this._firstTab = visibleTabs[0];\n          this._firstTab.setAttribute(\"first-visible-tab\", \"true\");\n          if (this._lastTab)\n            this._lastTab.removeAttribute(\"last-visible-tab\");\n          this._lastTab = visibleTabs[visibleTabs.length - 1];\n          this._lastTab.setAttribute(\"last-visible-tab\", \"true\");\n\n          let hoveredTab = this._hoveredTab;\n          if (hoveredTab) {\n            hoveredTab._mouseleave();\n          }\n          hoveredTab = this.querySelector(\"tab:hover\");\n          if (hoveredTab) {\n            hoveredTab._mouseenter();\n          }\n\n          // Update before-multiselected attributes.\n          // gBrowser may not be initialized yet, so avoid using it\n          for (let i = 0; i < visibleTabs.length - 1; i++) {\n            let tab = visibleTabs[i];\n            let nextTab = visibleTabs[i + 1];\n            tab.removeAttribute(\"before-multiselected\");\n            if (nextTab.multiselected) {\n              tab.setAttribute(\"before-multiselected\", \"true\");\n            }\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_blockDblClick\">false</field>\n\n      <field name=\"_tabDropIndicator\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"tab-drop-indicator\");\n      </field>\n\n      <field name=\"_dragOverDelay\">350</field>\n      <field name=\"_dragTime\">0</field>\n\n      <field name=\"_closeButtonsUpdatePending\">false</field>\n      <method name=\"_updateCloseButtons\">\n        <body><![CDATA[\n          // If we're overflowing, tabs are at their minimum widths.\n          if (this.getAttribute(\"overflow\") == \"true\") {\n            this.setAttribute(\"closebuttons\", \"activetab\");\n            return;\n          }\n\n          if (this._closeButtonsUpdatePending) {\n            return;\n          }\n          this._closeButtonsUpdatePending = true;\n\n          // Wait until after the next paint to get current layout data from\n          // getBoundsWithoutFlushing.\n          window.requestAnimationFrame(() => {\n            window.requestAnimationFrame(() => {\n              this._closeButtonsUpdatePending = false;\n\n              // The scrollbox may have started overflowing since we checked\n              // overflow earlier, so check again.\n              if (this.getAttribute(\"overflow\") == \"true\") {\n                this.setAttribute(\"closebuttons\", \"activetab\");\n                return;\n              }\n\n              // Check if tab widths are below the threshold where we want to\n              // remove close buttons from background tabs so that people don't\n              // accidentally close tabs by selecting them.\n              let rect = ele => {\n                return window.windowUtils.getBoundsWithoutFlushing(ele);\n              };\n              let tab = this._getVisibleTabs()[gBrowser._numPinnedTabs];\n              if (tab && rect(tab).width <= this._tabClipWidth) {\n                this.setAttribute(\"closebuttons\", \"activetab\");\n              } else {\n                this.removeAttribute(\"closebuttons\");\n              }\n            });\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"_updateHiddenTabsStatus\">\n        <body><![CDATA[\n          if (gBrowser.visibleTabs.length < gBrowser.tabs.length) {\n            this.setAttribute(\"hashiddentabs\", \"true\");\n          } else {\n            this.removeAttribute(\"hashiddentabs\");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_handleTabSelect\">\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          let selectedTab = this.selectedItem;\n          if (this.getAttribute(\"overflow\") == \"true\")\n            this.arrowScrollbox.ensureElementIsVisible(selectedTab, aInstant);\n\n          selectedTab._notselectedsinceload = false;\n        ]]></body>\n      </method>\n\n      <field name=\"_closingTabsSpacer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"closing-tabs-spacer\");\n      </field>\n\n      <field name=\"_tabDefaultMaxWidth\">NaN</field>\n      <field name=\"_lastTabClosedByMouse\">false</field>\n      <field name=\"_hasTabTempMaxWidth\">false</field>\n\n      <!-- Try to keep the active tab's close button under the mouse cursor -->\n      <method name=\"_lockTabSizing\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aTabWidth\"/>\n        <body><![CDATA[\n          let tabs = this._getVisibleTabs();\n          if (!tabs.length) {\n            return;\n          }\n\n          var isEndTab = (aTab._tPos > tabs[tabs.length - 1]._tPos);\n\n          if (!this._tabDefaultMaxWidth) {\n            this._tabDefaultMaxWidth =\n              parseFloat(window.getComputedStyle(aTab).maxWidth);\n          }\n          this._lastTabClosedByMouse = true;\n\n          if (this.getAttribute(\"overflow\") == \"true\") {\n            // Don't need to do anything if we're in overflow mode and aren't scrolled\n            // all the way to the right, or if we're closing the last tab.\n            if (isEndTab || !this.arrowScrollbox._scrollButtonDown.disabled) {\n              return;\n            }\n            // If the tab has an owner that will become the active tab, the owner will\n            // be to the left of it, so we actually want the left tab to slide over.\n            // This can't be done as easily in non-overflow mode, so we don't bother.\n            if (aTab.owner) {\n              return;\n            }\n            this._expandSpacerBy(aTabWidth);\n          } else { // non-overflow mode\n            // Locking is neither in effect nor needed, so let tabs expand normally.\n            if (isEndTab && !this._hasTabTempMaxWidth) {\n              return;\n            }\n            let numPinned = gBrowser._numPinnedTabs;\n            // Force tabs to stay the same width, unless we're closing the last tab,\n            // which case we need to let them expand just enough so that the overall\n            // tabbar width is the same.\n            if (isEndTab) {\n              let numNormalTabs = tabs.length - numPinned;\n              aTabWidth = aTabWidth * (numNormalTabs + 1) / numNormalTabs;\n              if (aTabWidth > this._tabDefaultMaxWidth) {\n                aTabWidth = this._tabDefaultMaxWidth;\n              }\n            }\n            aTabWidth += \"px\";\n            let tabsToReset = [];\n            for (let i = numPinned; i < tabs.length; i++) {\n              let tab = tabs[i];\n              tab.style.setProperty(\"max-width\", aTabWidth, \"important\");\n              if (!isEndTab) { // keep tabs the same width\n                tab.style.transition = \"none\";\n                tabsToReset.push(tab);\n              }\n            }\n\n            if (tabsToReset.length) {\n              window.promiseDocumentFlushed(() => {}).then(() => {\n                window.requestAnimationFrame(() => {\n                  for (let tab of tabsToReset) {\n                    tab.style.transition = \"\";\n                  }\n                });\n              });\n            }\n\n            this._hasTabTempMaxWidth = true;\n            gBrowser.addEventListener(\"mousemove\", this);\n            window.addEventListener(\"mouseout\", this);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_expandSpacerBy\">\n        <parameter name=\"pixels\"/>\n        <body><![CDATA[\n          let spacer = this._closingTabsSpacer;\n          spacer.style.width = parseFloat(spacer.style.width) + pixels + \"px\";\n          this.setAttribute(\"using-closing-tabs-spacer\", \"true\");\n          gBrowser.addEventListener(\"mousemove\", this);\n          window.addEventListener(\"mouseout\", this);\n        ]]></body>\n      </method>\n\n      <method name=\"_unlockTabSizing\">\n        <body><![CDATA[\n          gBrowser.removeEventListener(\"mousemove\", this);\n          window.removeEventListener(\"mouseout\", this);\n\n          if (this._hasTabTempMaxWidth) {\n            this._hasTabTempMaxWidth = false;\n            let tabs = this._getVisibleTabs();\n            for (let i = 0; i < tabs.length; i++) {\n              tabs[i].style.maxWidth = \"\";\n            }\n          }\n\n          if (this.hasAttribute(\"using-closing-tabs-spacer\")) {\n            this.removeAttribute(\"using-closing-tabs-spacer\");\n            this._closingTabsSpacer.style.width = 0;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"uiDensityChanged\">\n        <body><![CDATA[\n          this._positionPinnedTabs();\n          this._updateCloseButtons();\n          this._handleTabSelect(true);\n        ]]></body>\n      </method>\n\n      <field name=\"_lastNumPinned\">0</field>\n      <field name=\"_pinnedTabsLayoutCache\">null</field>\n      <method name=\"_positionPinnedTabs\">\n        <body><![CDATA[\n          let numPinned = gBrowser._numPinnedTabs;\n          let doPosition = this.getAttribute(\"overflow\") == \"true\" &&\n                           this._getVisibleTabs().length > numPinned &&\n                           numPinned > 0;\n\n          if (doPosition) {\n            this.setAttribute(\"positionpinnedtabs\", \"true\");\n\n            let layoutData = this._pinnedTabsLayoutCache;\n            let uiDensity = document.documentElement.getAttribute(\"uidensity\");\n            if (!layoutData ||\n                layoutData.uiDensity != uiDensity) {\n              let arrowScrollbox = this.arrowScrollbox;\n              layoutData = this._pinnedTabsLayoutCache = {\n                uiDensity,\n                pinnedTabWidth: this.children[0].getBoundingClientRect().width,\n                scrollButtonWidth: arrowScrollbox._scrollButtonDown.getBoundingClientRect().width,\n              };\n            }\n\n            let width = 0;\n            for (let i = numPinned - 1; i >= 0; i--) {\n              let tab = this.children[i];\n              width += layoutData.pinnedTabWidth;\n              tab.style.setProperty(\"margin-inline-start\",\n                -(width + layoutData.scrollButtonWidth) + \"px\", \"important\");\n              tab._pinnedUnscrollable = true;\n            }\n            this.style.paddingInlineStart = width + \"px\";\n          } else {\n            this.removeAttribute(\"positionpinnedtabs\");\n\n            for (let i = 0; i < numPinned; i++) {\n              let tab = this.children[i];\n              tab.style.marginInlineStart = \"\";\n              tab._pinnedUnscrollable = false;\n            }\n\n            this.style.paddingInlineStart = \"\";\n          }\n\n          if (this._lastNumPinned != numPinned) {\n            this._lastNumPinned = numPinned;\n            this._handleTabSelect(true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_animateTabMove\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);\n          let movingTabs = draggedTab._dragData.movingTabs;\n\n          if (this.getAttribute(\"movingtab\") != \"true\") {\n            this.setAttribute(\"movingtab\", \"true\");\n            gNavToolbox.setAttribute(\"movingtab\", \"true\");\n            if (!draggedTab.multiselected)\n              this.selectedItem = draggedTab;\n          }\n\n          if (!(\"animLastScreenX\" in draggedTab._dragData))\n            draggedTab._dragData.animLastScreenX = draggedTab._dragData.screenX;\n\n          let screenX = event.screenX;\n          if (screenX == draggedTab._dragData.animLastScreenX)\n            return;\n\n          // Direction of the mouse movement.\n          let ltrMove = screenX > draggedTab._dragData.animLastScreenX;\n\n          draggedTab._dragData.animLastScreenX = screenX;\n\n          let pinned = draggedTab.pinned;\n          let numPinned = gBrowser._numPinnedTabs;\n          let tabs = this._getVisibleTabs()\n                         .slice(pinned ? 0 : numPinned,\n                                pinned ? numPinned : undefined);\n\n          if (RTL_UI) {\n            tabs.reverse();\n            // Copy moving tabs array to avoid infinite reversing.\n            movingTabs = [...movingTabs].reverse();\n          }\n          let tabWidth = draggedTab.getBoundingClientRect().width;\n          let shiftWidth = tabWidth * movingTabs.length;\n          draggedTab._dragData.tabWidth = tabWidth;\n\n          // Move the dragged tab based on the mouse position.\n\n          let leftTab = tabs[0];\n          let rightTab = tabs[tabs.length - 1];\n          let rightMovingTabScreenX = movingTabs[movingTabs.length - 1].boxObject.screenX;\n          let leftMovingTabScreenX = movingTabs[0].boxObject.screenX;\n          let translateX = screenX - draggedTab._dragData.screenX;\n          if (!pinned) {\n            translateX += this.arrowScrollbox.scrollbox.scrollLeft - draggedTab._dragData.scrollX;\n          }\n          let leftBound = leftTab.boxObject.screenX - leftMovingTabScreenX;\n          let rightBound = (rightTab.boxObject.screenX + rightTab.boxObject.width) -\n                           (rightMovingTabScreenX + tabWidth);\n          translateX = Math.min(Math.max(translateX, leftBound), rightBound);\n\n          for (let tab of movingTabs) {\n            tab.style.transform = \"translateX(\" + translateX + \"px)\";\n          }\n\n          draggedTab._dragData.translateX = translateX;\n\n          // Determine what tab we're dragging over.\n          // * Single tab dragging: Point of reference is the center of the dragged tab. If that\n          //   point touches a background tab, the dragged tab would take that\n          //   tab's position when dropped.\n          // * Multiple tabs dragging: All dragged tabs are one \"giant\" tab with two\n          //   points of reference (center of tabs on the extremities). When\n          //   mouse is moving from left to right, the right reference gets activated,\n          //   otherwise the left reference will be used. Everything else works the same\n          //   as single tab dragging.\n          // * We're doing a binary search in order to reduce the amount of\n          //   tabs we need to check.\n\n          tabs = tabs.filter(t => !movingTabs.includes(t) || t == draggedTab);\n          let leftTabCenter = leftMovingTabScreenX + translateX + tabWidth / 2;\n          let rightTabCenter = rightMovingTabScreenX + translateX + tabWidth / 2;\n          let tabCenter = ltrMove ? rightTabCenter : leftTabCenter;\n          let newIndex = -1;\n          let oldIndex = \"animDropIndex\" in draggedTab._dragData ?\n                         draggedTab._dragData.animDropIndex : movingTabs[0]._tPos;\n          let low = 0;\n          let high = tabs.length - 1;\n          while (low <= high) {\n            let mid = Math.floor((low + high) / 2);\n            if (tabs[mid] == draggedTab && ++mid > high)\n              break;\n            let boxObject = tabs[mid].boxObject;\n            screenX = boxObject.screenX + getTabShift(tabs[mid], oldIndex);\n            if (screenX > tabCenter) {\n              high = mid - 1;\n            } else if (screenX + boxObject.width < tabCenter) {\n              low = mid + 1;\n            } else {\n              newIndex = tabs[mid]._tPos;\n              break;\n            }\n          }\n          if (newIndex >= oldIndex)\n            newIndex++;\n          if (newIndex < 0 || newIndex == oldIndex)\n            return;\n          draggedTab._dragData.animDropIndex = newIndex;\n\n          // Shift background tabs to leave a gap where the dragged tab\n          // would currently be dropped.\n\n          for (let tab of tabs) {\n            if (tab != draggedTab) {\n              let shift = getTabShift(tab, newIndex);\n              tab.style.transform = shift ? \"translateX(\" + shift + \"px)\" : \"\";\n            }\n          }\n\n          function getTabShift(tab, dropIndex) {\n            if (tab._tPos < draggedTab._tPos && tab._tPos >= dropIndex)\n              return (RTL_UI ? -shiftWidth : shiftWidth);\n            if (tab._tPos > draggedTab._tPos && tab._tPos < dropIndex)\n              return (RTL_UI ? shiftWidth : -shiftWidth);\n            return 0;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_finishAnimateTabMove\">\n        <body><![CDATA[\n          if (this.getAttribute(\"movingtab\") != \"true\") {\n            return;\n          }\n\n          for (let tab of this._getVisibleTabs()) {\n            tab.style.transform = \"\";\n          }\n\n          this.removeAttribute(\"movingtab\");\n          gNavToolbox.removeAttribute(\"movingtab\");\n\n          this._handleTabSelect();\n        ]]></body>\n      </method>\n\n      <!--  Regroup all selected tabs around the\n            tab in param  -->\n      <method name=\"_groupSelectedTabs\">\n        <parameter name=\"tab\"/>\n        <body><![CDATA[\n          let draggedTabPos = tab._tPos;\n          let selectedTabs = gBrowser.selectedTabs;\n          let animate = gBrowser.animationsEnabled;\n\n          tab.groupingTabsData = {\n            finished: !animate,\n          };\n\n\n          // Animate left selected tabs\n\n          let insertAtPos = draggedTabPos - 1;\n          for (let i = selectedTabs.indexOf(tab) - 1; i > -1; i--) {\n            let movingTab = selectedTabs[i];\n            insertAtPos = newIndex(movingTab, insertAtPos);\n\n            if (animate) {\n              movingTab.groupingTabsData = {};\n              addAnimationData(movingTab, insertAtPos, \"left\");\n            } else {\n              gBrowser.moveTabTo(movingTab, insertAtPos);\n            }\n            insertAtPos--;\n          }\n\n          // Animate right selected tabs\n\n          insertAtPos = draggedTabPos + 1;\n          for (let i = selectedTabs.indexOf(tab) + 1; i < selectedTabs.length; i++) {\n            let movingTab = selectedTabs[i];\n            insertAtPos = newIndex(movingTab, insertAtPos);\n\n            if (animate) {\n              movingTab.groupingTabsData = {};\n              addAnimationData(movingTab, insertAtPos, \"right\");\n            } else {\n              gBrowser.moveTabTo(movingTab, insertAtPos);\n            }\n            insertAtPos++;\n          }\n\n          // Slide the relevant tabs to their new position.\n          for (let t of this._getVisibleTabs()) {\n            if (t.groupingTabsData && t.groupingTabsData.translateX) {\n              let translateX = (RTL_UI ? -1 : 1) * t.groupingTabsData.translateX;\n              t.style.transform = \"translateX(\" + translateX + \"px)\";\n            }\n          }\n\n          function newIndex(aTab, index) {\n            // Don't allow mixing pinned and unpinned tabs.\n            if (aTab.pinned) {\n              return Math.min(index, gBrowser._numPinnedTabs - 1);\n            }\n            return Math.max(index, gBrowser._numPinnedTabs);\n          }\n\n          function addAnimationData(movingTab, movingTabNewIndex, side) {\n            let movingTabOldIndex = movingTab._tPos;\n\n            if (movingTabOldIndex == movingTabNewIndex) {\n              // movingTab is already at the right position\n              // and thus don't need to be animated.\n              return;\n            }\n\n            let movingTabWidth = movingTab.boxObject.width;\n            let shift = (movingTabNewIndex - movingTabOldIndex) * movingTabWidth;\n\n            movingTab.groupingTabsData.animate = true;\n            movingTab.setAttribute(\"tab-grouping\", \"true\");\n\n            movingTab.groupingTabsData.translateX = shift;\n\n            let onTransitionEnd = transitionendEvent => {\n              if (transitionendEvent.propertyName != \"transform\" ||\n                  transitionendEvent.originalTarget != movingTab) {\n                return;\n              }\n              movingTab.removeEventListener(\"transitionend\", onTransitionEnd);\n              movingTab.groupingTabsData.newIndex = movingTabNewIndex;\n              movingTab.groupingTabsData.animate = false;\n            };\n\n            movingTab.addEventListener(\"transitionend\", onTransitionEnd);\n\n            // Add animation data for tabs between movingTab (selected\n            // tab moving towards the dragged tab) and draggedTab.\n            // Those tabs in the middle should move in\n            // the opposite direction of movingTab.\n\n            let lowerIndex = Math.min(movingTabOldIndex, draggedTabPos);\n            let higherIndex = Math.max(movingTabOldIndex, draggedTabPos);\n\n            for (let i = lowerIndex + 1; i < higherIndex; i++) {\n              let middleTab = gBrowser.visibleTabs[i];\n\n              if (middleTab.pinned != movingTab.pinned) {\n                // Don't mix pinned and unpinned tabs\n                break;\n              }\n\n              if (middleTab.multiselected) {\n                // Skip because this selected tab should\n                // be shifted towards the dragged Tab.\n                continue;\n              }\n\n              if (!middleTab.groupingTabsData || !middleTab.groupingTabsData.translateX) {\n                middleTab.groupingTabsData = { translateX: 0};\n              }\n              if (side == \"left\") {\n                middleTab.groupingTabsData.translateX -= movingTabWidth;\n              } else {\n                middleTab.groupingTabsData.translateX += movingTabWidth;\n              }\n\n              middleTab.setAttribute(\"tab-grouping\", \"true\");\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_finishGroupSelectedTabs\">\n        <parameter name=\"tab\"/>\n        <body><![CDATA[\n          if (!tab.groupingTabsData || tab.groupingTabsData.finished)\n            return;\n\n          tab.groupingTabsData.finished = true;\n\n          let selectedTabs = gBrowser.selectedTabs;\n          let tabIndex = selectedTabs.indexOf(tab);\n\n          // Moving left tabs\n          for (let i = tabIndex - 1; i > -1; i--) {\n            let movingTab = selectedTabs[i];\n            if (movingTab.groupingTabsData.newIndex) {\n              gBrowser.moveTabTo(movingTab, movingTab.groupingTabsData.newIndex);\n            }\n          }\n\n          // Moving right tabs\n          for (let i = tabIndex + 1; i < selectedTabs.length; i++) {\n            let movingTab = selectedTabs[i];\n            if (movingTab.groupingTabsData.newIndex) {\n              gBrowser.moveTabTo(movingTab, movingTab.groupingTabsData.newIndex);\n            }\n          }\n\n          for (let t of this._getVisibleTabs()) {\n            t.style.transform = \"\";\n            t.removeAttribute(\"tab-grouping\");\n            delete t.groupingTabsData;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_isGroupTabsAnimationOver\">\n        <body><![CDATA[\n          for (let tab of gBrowser.selectedTabs) {\n            if (tab.groupingTabsData && tab.groupingTabsData.animate)\n              return false;\n          }\n          return true;\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.type) {\n            case \"resize\":\n              if (aEvent.target != window)\n                break;\n\n              this._updateCloseButtons();\n              this._handleTabSelect(true);\n              break;\n            case \"mouseout\":\n              // If the \"related target\" (the node to which the pointer went) is not\n              // a child of the current document, the mouse just left the window.\n              let relatedTarget = aEvent.relatedTarget;\n              if (relatedTarget && relatedTarget.ownerDocument == document)\n                break;\n            case \"mousemove\":\n              if (document.getElementById(\"tabContextMenu\").state != \"open\")\n                this._unlockTabSizing();\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_animateElement\">\n        this.arrowScrollbox._scrollButtonDown;\n      </field>\n\n      <method name=\"_notifyBackgroundTab\">\n        <parameter name=\"aTab\"/>\n        <body><![CDATA[\n          if (aTab.pinned || aTab.hidden || this.getAttribute(\"overflow\") != \"true\")\n            return;\n\n          this._lastTabToScrollIntoView = aTab;\n          if (!this._backgroundTabScrollPromise) {\n            this._backgroundTabScrollPromise = window.promiseDocumentFlushed(() => {\n              let lastTabRect = this._lastTabToScrollIntoView.getBoundingClientRect();\n              let selectedTab = this.selectedItem;\n              if (selectedTab.pinned) {\n                selectedTab = null;\n              } else {\n                selectedTab = selectedTab.getBoundingClientRect();\n                selectedTab = {left: selectedTab.left, right: selectedTab.right};\n              }\n              return [\n                this._lastTabToScrollIntoView,\n                this.arrowScrollbox.scrollClientRect,\n                {left: lastTabRect.left, right: lastTabRect.right},\n                selectedTab,\n              ];\n            }).then(([tabUsed, scrollRect, tabRect, selectedRect]) => {\n              // First off, remove the promise so we can re-enter if necessary.\n              delete this._backgroundTabScrollPromise;\n              // Then, if the layout info isn't for the last-scrolled-to-tab, re-run\n              // the code above to get layout info for *that* tab, and don't do\n              // anything here, as we really just want to run this for the last-opened tab.\n              if (this._lastTabToScrollIntoView != tabUsed) {\n                this._notifyBackgroundTab(this._lastTabToScrollIntoView);\n                return;\n              }\n              delete this._lastTabToScrollIntoView;\n              // Is the new tab already completely visible?\n              if (scrollRect.left <= tabRect.left && tabRect.right <= scrollRect.right)\n                return;\n\n              if (this.arrowScrollbox.smoothScroll) {\n                // Can we make both the new tab and the selected tab completely visible?\n                if (!selectedRect ||\n                    Math.max(tabRect.right - selectedRect.left, selectedRect.right - tabRect.left) <=\n                      scrollRect.width) {\n                  this.arrowScrollbox.ensureElementIsVisible(aTab);\n                  return;\n                }\n\n                this.arrowScrollbox.scrollByPixels(RTL_UI ?\n                                                     selectedRect.right - scrollRect.right :\n                                                     selectedRect.left - scrollRect.left);\n              }\n\n              if (!this._animateElement.hasAttribute(\"highlight\")) {\n                this._animateElement.setAttribute(\"highlight\", \"true\");\n                setTimeout(function(ele) {\n                  ele.removeAttribute(\"highlight\");\n                }, 150, this._animateElement);\n              }\n            });\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_getDragTargetTab\">\n        <parameter name=\"event\"/>\n        <parameter name=\"isLink\"/>\n        <body><![CDATA[\n          let tab = event.target.localName == \"tab\" ? event.target : null;\n          if (tab && isLink) {\n            let boxObject = tab.boxObject;\n            if (event.screenX < boxObject.screenX + boxObject.width * .25 ||\n                event.screenX > boxObject.screenX + boxObject.width * .75)\n              return null;\n          }\n          return tab;\n        ]]></body>\n      </method>\n\n      <method name=\"_getDropIndex\">\n        <parameter name=\"event\"/>\n        <parameter name=\"isLink\"/>\n        <body><![CDATA[\n          var tabs = this.children;\n          var tab = this._getDragTargetTab(event, isLink);\n          if (!RTL_UI) {\n            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)\n              if (event.screenX < tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)\n                return i;\n          } else {\n            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)\n              if (event.screenX > tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)\n                return i;\n          }\n          return tabs.length;\n        ]]></body>\n      </method>\n\n      <method name=\"_getDropEffectForTabDrag\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          var dt = event.dataTransfer;\n\n          let isMovingTabs = dt.mozItemCount > 0;\n          for (let i = 0; i < dt.mozItemCount; i++) {\n            // tabs are always added as the first type\n            let types = dt.mozTypesAt(0);\n            if (types[0] != TAB_DROP_TYPE) {\n              isMovingTabs = false;\n              break;\n            }\n          }\n\n          if (isMovingTabs) {\n            let sourceNode = dt.mozGetDataAt(TAB_DROP_TYPE, 0);\n            if (sourceNode instanceof XULElement &&\n                sourceNode.localName == \"tab\" &&\n                sourceNode.ownerGlobal.isChromeWindow &&\n                sourceNode.ownerDocument.documentElement.getAttribute(\"windowtype\") == \"navigator:browser\" &&\n                sourceNode.ownerGlobal.gBrowser.tabContainer == sourceNode.parentNode) {\n              // Do not allow transfering a private tab to a non-private window\n              // and vice versa.\n              if (PrivateBrowsingUtils.isWindowPrivate(window) !=\n                  PrivateBrowsingUtils.isWindowPrivate(sourceNode.ownerGlobal))\n                return \"none\";\n\n              if (window.gMultiProcessBrowser !=\n                  sourceNode.ownerGlobal.gMultiProcessBrowser)\n                return \"none\";\n\n              return dt.dropEffect == \"copy\" ? \"copy\" : \"move\";\n            }\n          }\n\n          if (browserDragAndDrop.canDropLink(event)) {\n            return \"link\";\n          }\n          return \"none\";\n        ]]></body>\n      </method>\n\n      <method name=\"_handleNewTab\">\n        <parameter name=\"tab\"/>\n        <body><![CDATA[\n          if (tab.parentNode != this) {\n            return;\n          }\n          tab._fullyOpen = true;\n          gBrowser.tabAnimationsInProgress--;\n\n          this._updateCloseButtons();\n\n          if (tab.getAttribute(\"selected\") == \"true\") {\n            this._handleTabSelect();\n          } else if (!tab.hasAttribute(\"skipbackgroundnotify\")) {\n            this._notifyBackgroundTab(tab);\n          }\n\n          // XXXmano: this is a temporary workaround for bug 345399\n          // We need to manually update the scroll buttons disabled state\n          // if a tab was inserted to the overflow area or removed from it\n          // without any scrolling and when the tabbar has already\n          // overflowed.\n          this.arrowScrollbox._updateScrollButtonsDisabledState();\n\n          // Preload the next about:newtab if there isn't one already.\n          gBrowser._createPreloadBrowser();\n        ]]></body>\n      </method>\n\n      <method name=\"_canAdvanceToTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          return !aTab.closing;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getRelatedElement\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          if (!aTab) {\n            return null;\n          }\n\n          // Cannot access gBrowser before it's initialized.\n          if (!gBrowser) {\n            return this.tabbox.tabpanels.firstElementChild;\n          }\n\n          // If the tab's browser is lazy, we need to `_insertBrowser` in order\n          // to have a linkedPanel.  This will also serve to bind the browser\n          // and make it ready to use when the tab is selected.\n          gBrowser._insertBrowser(aTab);\n          return document.getElementById(aTab.linkedPanel);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_updateNewTabVisibility\">\n        <body><![CDATA[\n          // Helper functions to help deal with customize mode wrapping some items\n          let wrap = n => n.parentNode.localName == \"toolbarpaletteitem\" ? n.parentNode : n;\n          let unwrap = n => n && n.localName == \"toolbarpaletteitem\" ? n.firstElementChild : n;\n\n          // Starting from the tabs element, find the next sibling that:\n          // - isn't hidden; and\n          // - isn't the all-tabs button.\n          // If it's the new tab button, consider the new tab button adjacent to the tabs.\n          // If the new tab button is marked as adjacent and the tabstrip doesn't\n          // overflow, we'll display the 'new tab' button inline in the tabstrip.\n          // In all other cases, the separate new tab button is displayed in its\n          // customized location.\n          let sib = this;\n          do {\n            sib = unwrap(wrap(sib).nextElementSibling);\n          } while (sib && (sib.hidden ||\n                           sib.id == \"alltabs-button\"));\n\n          const kAttr = \"hasadjacentnewtabbutton\";\n          if (sib && sib.id == \"new-tab-button\") {\n            this.setAttribute(kAttr, \"true\");\n          } else {\n            this.removeAttribute(kAttr);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onWidgetAfterDOMChange\">\n        <parameter name=\"aNode\"/>\n        <parameter name=\"aNextNode\"/>\n        <parameter name=\"aContainer\"/>\n        <body><![CDATA[\n          if (aContainer.ownerDocument == document &&\n              aContainer.id == \"TabsToolbar-customization-target\") {\n            this._updateNewTabVisibility();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onAreaNodeRegistered\">\n        <parameter name=\"aArea\"/>\n        <parameter name=\"aContainer\"/>\n        <body><![CDATA[\n          if (aContainer.ownerDocument == document &&\n              aArea == \"TabsToolbar\") {\n            this._updateNewTabVisibility();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onAreaReset\">\n        <parameter name=\"aArea\"/>\n        <parameter name=\"aContainer\"/>\n        <body><![CDATA[\n          this.onAreaNodeRegistered(aArea, aContainer);\n        ]]></body>\n      </method>\n\n      <method name=\"_hiddenSoundPlayingStatusChanged\">\n        <parameter name=\"tab\"/>\n        <parameter name=\"opts\"/>\n        <body><![CDATA[\n          let closed = opts && opts.closed;\n          if (!closed && tab.soundPlaying && tab.hidden) {\n            this._hiddenSoundPlayingTabs.add(tab);\n            this.setAttribute(\"hiddensoundplaying\", \"true\");\n          } else {\n            this._hiddenSoundPlayingTabs.delete(tab);\n            if (this._hiddenSoundPlayingTabs.size == 0) {\n              this.removeAttribute(\"hiddensoundplaying\");\n            }\n          }\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"TabSelect\"><![CDATA[\n        this._handleTabSelect();\n      ]]></handler>\n\n      <handler event=\"TabClose\"><![CDATA[\n        this._hiddenSoundPlayingStatusChanged(event.target, {closed: true});\n      ]]></handler>\n\n      <handler event=\"TabAttrModified\"><![CDATA[\n        if (event.detail.changed.includes(\"soundplaying\") && event.target.hidden) {\n          this._hiddenSoundPlayingStatusChanged(event.target);\n        }\n      ]]></handler>\n\n      <handler event=\"TabHide\"><![CDATA[\n        if (event.target.soundPlaying) {\n          this._hiddenSoundPlayingStatusChanged(event.target);\n        }\n      ]]></handler>\n\n      <handler event=\"TabShow\"><![CDATA[\n        if (event.target.soundPlaying) {\n          this._hiddenSoundPlayingStatusChanged(event.target);\n        }\n      ]]></handler>\n\n      <handler event=\"transitionend\"><![CDATA[\n        if (event.propertyName != \"max-width\") {\n          return;\n        }\n\n        var tab = event.target;\n\n        if (tab.getAttribute(\"fadein\") == \"true\") {\n          if (tab._fullyOpen) {\n            this._updateCloseButtons();\n          } else {\n            this._handleNewTab(tab);\n          }\n        } else if (tab.closing) {\n          gBrowser._endRemoveTab(tab);\n        }\n      ]]></handler>\n\n      <handler event=\"dblclick\"><![CDATA[\n        // When the tabbar has an unified appearance with the titlebar\n        // and menubar, a double-click in it should have the same behavior\n        // as double-clicking the titlebar\n        if (TabsInTitlebar.enabled)\n          return;\n\n        if (event.button != 0 ||\n            event.originalTarget.localName != \"scrollbox\")\n          return;\n\n        if (!this._blockDblClick)\n          BrowserOpenTab();\n\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"click\" button=\"0\" phase=\"capturing\"><![CDATA[\n        /* Catches extra clicks meant for the in-tab close button.\n         * Placed here to avoid leaking (a temporary handler added from the\n         * in-tab close button binding would close over the tab and leak it\n         * until the handler itself was removed). (bug 897751)\n         *\n         * The only sequence in which a second click event (i.e. dblclik)\n         * can be dispatched on an in-tab close button is when it is shown\n         * after the first click (i.e. the first click event was dispatched\n         * on the tab). This happens when we show the close button only on\n         * the active tab. (bug 352021)\n         * The only sequence in which a third click event can be dispatched\n         * on an in-tab close button is when the tab was opened with a\n         * double click on the tabbar. (bug 378344)\n         * In both cases, it is most likely that the close button area has\n         * been accidentally clicked, therefore we do not close the tab.\n         *\n         * We don't want to ignore processing of more than one click event,\n         * though, since the user might actually be repeatedly clicking to\n         * close many tabs at once.\n         */\n        let target = event.originalTarget;\n        if (target.classList.contains(\"tab-close-button\")) {\n          // We preemptively set this to allow the closing-multiple-tabs-\n          // in-a-row case.\n          if (this._blockDblClick) {\n            target._ignoredCloseButtonClicks = true;\n          } else if (event.detail > 1 && !target._ignoredCloseButtonClicks) {\n            target._ignoredCloseButtonClicks = true;\n            event.stopPropagation();\n            return;\n          } else {\n            // Reset the \"ignored click\" flag\n            target._ignoredCloseButtonClicks = false;\n          }\n        }\n\n        /* Protects from close-tab-button errant doubleclick:\n         * Since we're removing the event target, if the user\n         * double-clicks the button, the dblclick event will be dispatched\n         * with the tabbar as its event target (and explicit/originalTarget),\n         * which treats that as a mouse gesture for opening a new tab.\n         * In this context, we're manually blocking the dblclick event.\n         */\n        if (this._blockDblClick) {\n          if (!(\"_clickedTabBarOnce\" in this)) {\n            this._clickedTabBarOnce = true;\n            return;\n          }\n          delete this._clickedTabBarOnce;\n          this._blockDblClick = false;\n        }\n      ]]></handler>\n\n      <handler event=\"click\"><![CDATA[\n        if (event.button != 1) {\n          return;\n        }\n\n        if (event.target.localName == \"tab\") {\n          gBrowser.removeTab(event.target, {\n            animate: true,\n            byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE,\n          });\n        } else if (event.originalTarget.localName == \"scrollbox\") {\n          // The user middleclicked an open space on the tabstrip. This could\n          // be because they intend to open a new tab, but it could also be\n          // because they just removed a tab and they now middleclicked on the\n          // resulting space while that tab is closing. In that case, we don't\n          // want to open a tab. So if we're removing one or more tabs, and\n          // the tab click is before the end of the last visible tab, we do\n          // nothing.\n          if (gBrowser._removingTabs.length) {\n            let visibleTabs = this._getVisibleTabs();\n            let lastTab = visibleTabs[visibleTabs.length - 1];\n            let endOfTab = lastTab.getBoundingClientRect()[RTL_UI ? \"left\" : \"right\"];\n            if ((!RTL_UI && event.clientX > endOfTab) ||\n                (RTL_UI && event.clientX < endOfTab)) {\n              BrowserOpenTab();\n            }\n          } else {\n            BrowserOpenTab();\n          }\n        } else {\n          return;\n        }\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"keydown\" group=\"system\"><![CDATA[\n        let {altKey, shiftKey} = event;\n        let [accel, nonAccel] = AppConstants.platform == \"macosx\" ? [event.metaKey, event.ctrlKey] : [event.ctrlKey, event.metaKey];\n\n        let keyComboForMove = accel && shiftKey && !altKey && !nonAccel;\n        let keyComboForFocus = accel && !shiftKey && !altKey && !nonAccel;\n\n        if (!keyComboForMove && !keyComboForFocus) {\n          return;\n        }\n\n        // Don't check if the event was already consumed because tab navigation\n        // should work always for better user experience.\n        let {visibleTabs, selectedTab} = gBrowser;\n        let {arrowKeysShouldWrap} = this;\n        let focusedTabIndex = this.ariaFocusedIndex;\n        if (focusedTabIndex == -1) {\n          focusedTabIndex = visibleTabs.indexOf(selectedTab);\n        }\n        let lastFocusedTabIndex = focusedTabIndex;\n        switch (event.keyCode) {\n          case KeyEvent.DOM_VK_UP:\n            if (keyComboForMove) {\n              gBrowser.moveTabBackward();\n            } else {\n              focusedTabIndex--;\n            }\n            break;\n          case KeyEvent.DOM_VK_DOWN:\n            if (keyComboForMove) {\n              gBrowser.moveTabForward();\n            } else {\n              focusedTabIndex++;\n            }\n            break;\n          case KeyEvent.DOM_VK_RIGHT:\n          case KeyEvent.DOM_VK_LEFT:\n            if (keyComboForMove) {\n              gBrowser.moveTabOver(event);\n            } else if ((!RTL_UI && event.keyCode == KeyEvent.DOM_VK_RIGHT) ||\n                       (RTL_UI && event.keyCode == KeyEvent.DOM_VK_LEFT)) {\n              focusedTabIndex++;\n            } else {\n              focusedTabIndex--;\n            }\n            break;\n          case KeyEvent.DOM_VK_HOME:\n            if (keyComboForMove) {\n              gBrowser.moveTabToStart();\n            } else {\n              focusedTabIndex = 0;\n            }\n            break;\n          case KeyEvent.DOM_VK_END:\n            if (keyComboForMove) {\n              gBrowser.moveTabToEnd();\n            } else {\n              focusedTabIndex = visibleTabs.length - 1;\n            }\n            break;\n          case KeyEvent.DOM_VK_SPACE:\n            if (visibleTabs[lastFocusedTabIndex].multiselected) {\n              gBrowser.removeFromMultiSelectedTabs(visibleTabs[lastFocusedTabIndex]);\n            } else {\n              gBrowser.addToMultiSelectedTabs(visibleTabs[lastFocusedTabIndex], false);\n            }\n            break;\n          default:\n            // Consume the keydown event for the above keyboard\n            // shortcuts only.\n            return;\n        }\n\n        if (arrowKeysShouldWrap) {\n          if (focusedTabIndex >= visibleTabs.length) {\n            focusedTabIndex = 0;\n          } else if (focusedTabIndex < 0) {\n            focusedTabIndex = visibleTabs.length - 1;\n          }\n        } else {\n          focusedTabIndex = Math.min(visibleTabs.length - 1, Math.max(0, focusedTabIndex));\n        }\n\n        if (keyComboForFocus &&\n            focusedTabIndex != lastFocusedTabIndex) {\n          this.ariaFocusedItem = visibleTabs[focusedTabIndex];\n        }\n\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        var tab = this._getDragTargetTab(event, false);\n        if (!tab || this._isCustomizing)\n          return;\n\n        let selectedTabs = gBrowser.selectedTabs;\n        let otherSelectedTabs = selectedTabs.filter(selectedTab => selectedTab != tab);\n        let dataTransferOrderedTabs = [tab].concat(otherSelectedTabs);\n\n        let dt = event.dataTransfer;\n        for (let i = 0; i < dataTransferOrderedTabs.length; i++) {\n          let dtTab = dataTransferOrderedTabs[i];\n\n          dt.mozSetDataAt(TAB_DROP_TYPE, dtTab, i);\n          let dtBrowser = dtTab.linkedBrowser;\n\n          // We must not set text/x-moz-url or text/plain data here,\n          // otherwise trying to detach the tab by dropping it on the desktop\n          // may result in an \"internet shortcut\"\n          dt.mozSetDataAt(\"text/x-moz-text-internal\", dtBrowser.currentURI.spec, i);\n        }\n\n        // Set the cursor to an arrow during tab drags.\n        dt.mozCursor = \"default\";\n\n        // Set the tab as the source of the drag, which ensures we have a stable\n        // node to deliver the `dragend` event.  See bug 1345473.\n        dt.addElement(tab);\n\n        if (tab.multiselected) {\n          this._groupSelectedTabs(tab);\n        }\n\n        // Create a canvas to which we capture the current tab.\n        // Until canvas is HiDPI-aware (bug 780362), we need to scale the desired\n        // canvas size (in CSS pixels) to the window's backing resolution in order\n        // to get a full-resolution drag image for use on HiDPI displays.\n        let windowUtils = window.windowUtils;\n        let scale = windowUtils.screenPixelsPerCSSPixel / windowUtils.fullZoom;\n        let canvas = this._dndCanvas;\n        if (!canvas) {\n          this._dndCanvas = canvas =\n            document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n          canvas.style.width = \"100%\";\n          canvas.style.height = \"100%\";\n          canvas.mozOpaque = true;\n        }\n\n        canvas.width = 160 * scale;\n        canvas.height = 90 * scale;\n        let toDrag = canvas;\n        let dragImageOffset = -16;\n        let browser = tab.linkedBrowser;\n        if (gMultiProcessBrowser) {\n          var context = canvas.getContext(\"2d\");\n          context.fillStyle = \"white\";\n          context.fillRect(0, 0, canvas.width, canvas.height);\n\n          let captureListener;\n          let platform = AppConstants.platform;\n          // On Windows and Mac we can update the drag image during a drag\n          // using updateDragImage. On Linux, we can use a panel.\n          if (platform == \"win\" || platform == \"macosx\") {\n            captureListener = function() {\n              dt.updateDragImage(canvas, dragImageOffset, dragImageOffset);\n            };\n          } else {\n            // Create a panel to use it in setDragImage\n            // which will tell xul to render a panel that follows\n            // the pointer while a dnd session is on.\n            if (!this._dndPanel) {\n              this._dndCanvas = canvas;\n              this._dndPanel = document.createXULElement(\"panel\");\n              this._dndPanel.className = \"dragfeedback-tab\";\n              this._dndPanel.setAttribute(\"type\", \"drag\");\n              let wrapper = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"div\");\n              wrapper.style.width = \"160px\";\n              wrapper.style.height = \"90px\";\n              wrapper.appendChild(canvas);\n              this._dndPanel.appendChild(wrapper);\n              document.documentElement.appendChild(this._dndPanel);\n            }\n            toDrag = this._dndPanel;\n          }\n          // PageThumb is async with e10s but that's fine\n          // since we can update the image during the dnd.\n          PageThumbs.captureToCanvas(browser, canvas, captureListener);\n        } else {\n          // For the non e10s case we can just use PageThumbs\n          // sync, so let's use the canvas for setDragImage.\n          PageThumbs.captureToCanvas(browser, canvas);\n          dragImageOffset = dragImageOffset * scale;\n        }\n        dt.setDragImage(toDrag, dragImageOffset, dragImageOffset);\n\n        // _dragData.offsetX/Y give the coordinates that the mouse should be\n        // positioned relative to the corner of the new window created upon\n        // dragend such that the mouse appears to have the same position\n        // relative to the corner of the dragged tab.\n        function clientX(ele) {\n          return ele.getBoundingClientRect().left;\n        }\n        let tabOffsetX = clientX(tab) - clientX(this);\n        tab._dragData = {\n          offsetX: event.screenX - window.screenX - tabOffsetX,\n          offsetY: event.screenY - window.screenY,\n          scrollX: this.arrowScrollbox.scrollbox.scrollLeft,\n          screenX: event.screenX,\n          movingTabs: (tab.multiselected ? gBrowser.selectedTabs : [tab])\n                      .filter(t => t.pinned == tab.pinned),\n        };\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        var effects = this._getDropEffectForTabDrag(event);\n\n        var ind = this._tabDropIndicator;\n        if (effects == \"\" || effects == \"none\") {\n          ind.collapsed = true;\n          return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n\n        var arrowScrollbox = this.arrowScrollbox;\n\n        // autoscroll the tab strip if we drag over the scroll\n        // buttons, even if we aren't dragging a tab, but then\n        // return to avoid drawing the drop indicator\n        var pixelsToScroll = 0;\n        if (this.getAttribute(\"overflow\") == \"true\") {\n          var targetAnonid = event.originalTarget.getAttribute(\"anonid\");\n          switch (targetAnonid) {\n            case \"scrollbutton-up\":\n              pixelsToScroll = arrowScrollbox.scrollIncrement * -1;\n              break;\n            case \"scrollbutton-down\":\n              pixelsToScroll = arrowScrollbox.scrollIncrement;\n              break;\n          }\n          if (pixelsToScroll)\n            arrowScrollbox.scrollByPixels((RTL_UI ? -1 : 1) * pixelsToScroll, true);\n        }\n\n        let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);\n        if ((effects == \"move\" || effects == \"copy\") &&\n            this == draggedTab.parentNode) {\n          ind.collapsed = true;\n\n          if (!this._isGroupTabsAnimationOver()) {\n            // Wait for grouping tabs animation to finish\n            return;\n          }\n          this._finishGroupSelectedTabs(draggedTab);\n\n          if (effects == \"move\") {\n            this._animateTabMove(event);\n            return;\n          }\n        }\n\n        this._finishAnimateTabMove();\n\n        if (effects == \"link\") {\n          let tab = this._getDragTargetTab(event, true);\n          if (tab) {\n            if (!this._dragTime)\n              this._dragTime = Date.now();\n            if (Date.now() >= this._dragTime + this._dragOverDelay)\n              this.selectedItem = tab;\n            ind.collapsed = true;\n            return;\n          }\n        }\n\n        var rect = arrowScrollbox.getBoundingClientRect();\n        var newMargin;\n        if (pixelsToScroll) {\n          // if we are scrolling, put the drop indicator at the edge\n          // so that it doesn't jump while scrolling\n          let scrollRect = arrowScrollbox.scrollClientRect;\n          let minMargin = scrollRect.left - rect.left;\n          let maxMargin = Math.min(minMargin + scrollRect.width,\n                                   scrollRect.right);\n          if (RTL_UI) {\n            [minMargin, maxMargin] = [this.clientWidth - maxMargin,\n                                      this.clientWidth - minMargin];\n          }\n          newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;\n        } else {\n          let newIndex = this._getDropIndex(event, effects == \"link\");\n          if (newIndex == this.children.length) {\n            let tabRect = this.children[newIndex - 1].getBoundingClientRect();\n            if (RTL_UI) {\n              newMargin = rect.right - tabRect.left;\n            } else {\n              newMargin = tabRect.right - rect.left;\n            }\n          } else {\n            let tabRect = this.children[newIndex].getBoundingClientRect();\n            if (RTL_UI) {\n              newMargin = rect.right - tabRect.right;\n            } else {\n              newMargin = tabRect.left - rect.left;\n            }\n          }\n        }\n\n        ind.collapsed = false;\n\n        newMargin += ind.clientWidth / 2;\n        if (RTL_UI) {\n          newMargin *= -1;\n        }\n\n        ind.style.transform = \"translate(\" + Math.round(newMargin) + \"px)\";\n        ind.style.marginInlineStart = (-ind.clientWidth) + \"px\";\n      ]]></handler>\n\n      <handler event=\"drop\"><![CDATA[\n        var dt = event.dataTransfer;\n        var dropEffect = dt.dropEffect;\n        var draggedTab;\n        let movingTabs;\n        if (dt.mozTypesAt(0)[0] == TAB_DROP_TYPE) { // tab copy or move\n          draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);\n          // not our drop then\n          if (!draggedTab)\n            return;\n          movingTabs = draggedTab._dragData.movingTabs;\n          draggedTab.parentNode._finishGroupSelectedTabs(draggedTab);\n        }\n\n        this._tabDropIndicator.collapsed = true;\n        event.stopPropagation();\n        if (draggedTab && dropEffect == \"copy\") {\n          // copy the dropped tab (wherever it's from)\n          let newIndex = this._getDropIndex(event, false);\n          let draggedTabCopy;\n          for (let tab of movingTabs) {\n            let newTab = gBrowser.duplicateTab(tab);\n            gBrowser.moveTabTo(newTab, newIndex++);\n            if (tab == draggedTab)\n              draggedTabCopy = newTab;\n          }\n          if (draggedTab.parentNode != this || event.shiftKey) {\n            this.selectedItem = draggedTabCopy;\n          }\n        } else if (draggedTab && draggedTab.parentNode == this) {\n          let oldTranslateX = Math.round(draggedTab._dragData.translateX);\n          let tabWidth = Math.round(draggedTab._dragData.tabWidth);\n          let translateOffset = oldTranslateX % tabWidth;\n          let newTranslateX = oldTranslateX - translateOffset;\n          if (oldTranslateX > 0 && translateOffset > tabWidth / 2) {\n            newTranslateX += tabWidth;\n          } else if (oldTranslateX < 0 && -translateOffset > tabWidth / 2) {\n            newTranslateX -= tabWidth;\n          }\n\n          let dropIndex = \"animDropIndex\" in draggedTab._dragData &&\n                          draggedTab._dragData.animDropIndex;\n          let incrementDropIndex = true;\n          if (dropIndex && dropIndex > movingTabs[0]._tPos) {\n            dropIndex--;\n            incrementDropIndex = false;\n          }\n\n          let animate = gBrowser.animationsEnabled;\n          if (oldTranslateX && oldTranslateX != newTranslateX && animate) {\n            for (let tab of movingTabs) {\n              tab.setAttribute(\"tabdrop-samewindow\", \"true\");\n              tab.style.transform = \"translateX(\" + newTranslateX + \"px)\";\n              let onTransitionEnd = transitionendEvent => {\n                if (transitionendEvent.propertyName != \"transform\" ||\n                    transitionendEvent.originalTarget != tab) {\n                  return;\n                }\n                tab.removeEventListener(\"transitionend\", onTransitionEnd);\n\n                tab.removeAttribute(\"tabdrop-samewindow\");\n\n                this._finishAnimateTabMove();\n                if (dropIndex !== false) {\n                  gBrowser.moveTabTo(tab, dropIndex);\n                  if (incrementDropIndex)\n                    dropIndex++;\n                }\n\n                gBrowser.syncThrobberAnimations(tab);\n              };\n              tab.addEventListener(\"transitionend\", onTransitionEnd);\n            }\n          } else {\n            this._finishAnimateTabMove();\n            if (dropIndex !== false) {\n              for (let tab of movingTabs) {\n                gBrowser.moveTabTo(tab, dropIndex);\n                if (incrementDropIndex)\n                  dropIndex++;\n              }\n            }\n          }\n        } else if (draggedTab) {\n          let newIndex = this._getDropIndex(event, false);\n          let newTabs = [];\n          for (let tab of movingTabs) {\n            let newTab = gBrowser.adoptTab(tab, newIndex++, tab == draggedTab);\n            newTabs.push(newTab);\n          }\n\n          // Restore tab selection\n          gBrowser.addRangeToMultiSelectedTabs(newTabs[0], newTabs[newTabs.length - 1]);\n        } else {\n          // Pass true to disallow dropping javascript: or data: urls\n          let links;\n          try {\n            links = browserDragAndDrop.dropLinks(event, true);\n          } catch (ex) {}\n\n          if (!links || links.length === 0)\n            return;\n\n          let inBackground = Services.prefs.getBoolPref(\"browser.tabs.loadInBackground\");\n          if (event.shiftKey)\n            inBackground = !inBackground;\n\n          let targetTab = this._getDragTargetTab(event, true);\n          let userContextId = this.selectedItem.getAttribute(\"usercontextid\");\n          let replace = !!targetTab;\n          let newIndex = this._getDropIndex(event, true);\n          let urls = links.map(link => link.url);\n\n          let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(event);\n\n          (async () => {\n            if (urls.length >= Services.prefs.getIntPref(\"browser.tabs.maxOpenBeforeWarn\")) {\n              // Sync dialog cannot be used inside drop event handler.\n              let answer = await OpenInTabsUtils.promiseConfirmOpenInTabs(urls.length,\n                                                                          window);\n              if (!answer) {\n                return;\n              }\n            }\n\n            gBrowser.loadTabs(urls, {\n              inBackground,\n              replace,\n              allowThirdPartyFixup: true,\n              targetTab,\n              newIndex,\n              userContextId,\n              triggeringPrincipal,\n            });\n          })();\n        }\n\n        if (draggedTab) {\n          delete draggedTab._dragData;\n        }\n      ]]></handler>\n\n      <handler event=\"dragend\"><![CDATA[\n        var dt = event.dataTransfer;\n        var draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);\n\n        // Prevent this code from running if a tabdrop animation is\n        // running since calling _finishAnimateTabMove would clear\n        // any CSS transition that is running.\n        if (draggedTab.hasAttribute(\"tabdrop-samewindow\"))\n          return;\n\n        this._finishGroupSelectedTabs(draggedTab);\n        this._finishAnimateTabMove();\n\n        if (dt.mozUserCancelled || dt.dropEffect != \"none\" || this._isCustomizing) {\n          delete draggedTab._dragData;\n          return;\n        }\n\n        // Disable detach within the browser toolbox\n        var eX = event.screenX;\n        var eY = event.screenY;\n        var wX = window.screenX;\n        // check if the drop point is horizontally within the window\n        if (eX > wX && eX < (wX + window.outerWidth)) {\n          // also avoid detaching if the the tab was dropped too close to\n          // the tabbar (half a tab)\n          let rect = window.windowUtils.getBoundsWithoutFlushing(this.arrowScrollbox);\n          let detachTabThresholdY = window.screenY + rect.top + 1.5 * rect.height;\n          if (eY < detachTabThresholdY && eY > window.screenY)\n            return;\n        }\n\n        // screen.availLeft et. al. only check the screen that this window is on,\n        // but we want to look at the screen the tab is being dropped onto.\n        var screen = Cc[\"@mozilla.org/gfx/screenmanager;1\"]\n                       .getService(Ci.nsIScreenManager)\n                       .screenForRect(eX, eY, 1, 1);\n        var fullX = {}, fullY = {}, fullWidth = {}, fullHeight = {};\n        var availX = {}, availY = {}, availWidth = {}, availHeight = {};\n        // get full screen rect and available rect, both in desktop pix\n        screen.GetRectDisplayPix(fullX, fullY, fullWidth, fullHeight);\n        screen.GetAvailRectDisplayPix(availX, availY, availWidth, availHeight);\n\n        // scale factor to convert desktop pixels to CSS px\n        var scaleFactor =\n          screen.contentsScaleFactor / screen.defaultCSSScaleFactor;\n        // synchronize CSS-px top-left coordinates with the screen's desktop-px\n        // coordinates, to ensure uniqueness across multiple screens\n        // (compare the equivalent adjustments in nsGlobalWindow::GetScreenXY()\n        // and related methods)\n        availX.value = (availX.value - fullX.value) * scaleFactor + fullX.value;\n        availY.value = (availY.value - fullY.value) * scaleFactor + fullY.value;\n        availWidth.value *= scaleFactor;\n        availHeight.value *= scaleFactor;\n\n        // ensure new window entirely within screen\n        var winWidth = Math.min(window.outerWidth, availWidth.value);\n        var winHeight = Math.min(window.outerHeight, availHeight.value);\n        var left = Math.min(Math.max(eX - draggedTab._dragData.offsetX, availX.value),\n                            availX.value + availWidth.value - winWidth);\n        var top = Math.min(Math.max(eY - draggedTab._dragData.offsetY, availY.value),\n                           availY.value + availHeight.value - winHeight);\n\n        delete draggedTab._dragData;\n\n        if (gBrowser.tabs.length == 1) {\n          // resize _before_ move to ensure the window fits the new screen.  if\n          // the window is too large for its screen, the window manager may do\n          // automatic repositioning.\n          window.resizeTo(winWidth, winHeight);\n          window.moveTo(left, top);\n          window.focus();\n        } else {\n          let props = { screenX: left, screenY: top, suppressanimation: 1 };\n          if (AppConstants.platform != \"win\") {\n            props.outerWidth = winWidth;\n            props.outerHeight = winHeight;\n          }\n          gBrowser.replaceTabsWithWindow(draggedTab, props);\n        }\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragexit\"><![CDATA[\n        this._dragTime = 0;\n\n        // This does not work at all (see bug 458613)\n        var target = event.relatedTarget;\n        while (target && target != this)\n          target = target.parentNode;\n        if (target)\n          return;\n\n        this._tabDropIndicator.collapsed = true;\n        event.stopPropagation();\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"tabbrowser-tab\"\n           extends=\"chrome://global/content/bindings/tabbox.xml#tab\">\n    <content context=\"tabContextMenu\">\n      <xul:stack class=\"tab-stack\" flex=\"1\">\n        <xul:vbox xbl:inherits=\"selected=visuallyselected,fadein\"\n                  class=\"tab-background\">\n          <xul:hbox xbl:inherits=\"selected=visuallyselected,multiselected,before-multiselected\"\n                    class=\"tab-line\"/>\n          <xul:spacer flex=\"1\"/>\n          <xul:hbox class=\"tab-bottom-line\"/>\n        </xul:vbox>\n        <xul:hbox xbl:inherits=\"pinned,bursting,notselectedsinceload\"\n                  anonid=\"tab-loading-burst\"\n                  class=\"tab-loading-burst\"/>\n        <xul:hbox xbl:inherits=\"pinned,selected=visuallyselected,titlechanged,attention\"\n                  class=\"tab-content\" align=\"center\">\n          <xul:hbox xbl:inherits=\"fadein,pinned,busy,progress,selected=visuallyselected\"\n                    anonid=\"tab-throbber\"\n                    class=\"tab-throbber\"\n                    layer=\"true\"/>\n          <xul:hbox xbl:inherits=\"fadein,pinned,busy,progress,selected=visuallyselected,pendingicon\"\n                    anonid=\"tab-icon-pending\"\n                    class=\"tab-icon-pending\"/>\n          <xul:image xbl:inherits=\"src=image,triggeringprincipal=iconloadingprincipal,requestcontextid,fadein,pinned,selected=visuallyselected,busy,crashed,sharing\"\n                     anonid=\"tab-icon-image\"\n                     class=\"tab-icon-image\"\n                     validate=\"never\"\n                     role=\"presentation\"/>\n          <xul:image xbl:inherits=\"sharing,selected=visuallyselected,pinned\"\n                     anonid=\"sharing-icon\"\n                     class=\"tab-sharing-icon-overlay\"\n                     role=\"presentation\"/>\n          <xul:image xbl:inherits=\"crashed,busy,soundplaying,soundplaying-scheduledremoval,pinned,muted,blocked,selected=visuallyselected,activemedia-blocked\"\n                     anonid=\"overlay-icon\"\n                     class=\"tab-icon-overlay\"\n                     role=\"presentation\"/>\n          <xul:hbox class=\"tab-label-container\"\n                    xbl:inherits=\"pinned,selected=visuallyselected,labeldirection\"\n                    onoverflow=\"this.setAttribute('textoverflow', 'true');\"\n                    onunderflow=\"this.removeAttribute('textoverflow');\"\n                    flex=\"1\">\n            <xul:label class=\"tab-text tab-label\" anonid=\"tab-label\"\n                       xbl:inherits=\"xbl:text=label,accesskey,fadein,pinned,selected=visuallyselected,attention\"\n                       role=\"presentation\"/>\n          </xul:hbox>\n          <xul:image xbl:inherits=\"soundplaying,soundplaying-scheduledremoval,pinned,muted,blocked,selected=visuallyselected,activemedia-blocked\"\n                     anonid=\"soundplaying-icon\"\n                     class=\"tab-icon-sound\"\n                     role=\"presentation\"/>\n          <xul:image anonid=\"close-button\"\n                     xbl:inherits=\"fadein,pinned,selected=visuallyselected\"\n                     class=\"tab-close-button close-icon\"\n                     role=\"presentation\"/>\n        </xul:hbox>\n      </xul:stack>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (!(\"_lastAccessed\" in this)) {\n          this.updateLastAccessed();\n        }\n      ]]></constructor>\n\n      <property name=\"_visuallySelected\">\n        <setter>\n          <![CDATA[\n          if (val == (this.getAttribute(\"visuallyselected\") == \"true\")) {\n            return val;\n          }\n\n          if (val) {\n            this.setAttribute(\"visuallyselected\", \"true\");\n          } else {\n            this.removeAttribute(\"visuallyselected\");\n          }\n          gBrowser._tabAttrModified(this, [\"visuallyselected\"]);\n\n          return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"_selected\">\n        <setter>\n          <![CDATA[\n          // in e10s we want to only pseudo-select a tab before its rendering is done, so that\n          // the rest of the system knows that the tab is selected, but we don't want to update its\n          // visual status to selected until after we receive confirmation that its content has painted.\n          if (val)\n            this.setAttribute(\"selected\", \"true\");\n          else\n            this.removeAttribute(\"selected\");\n\n          // If we're non-e10s we should update the visual selection as well at the same time,\n          // *or* if we're e10s and the visually selected tab isn't changing, in which case the\n          // tab switcher code won't run and update anything else (like the before- and after-\n          // selected attributes).\n          if (!gMultiProcessBrowser || (val && this.hasAttribute(\"visuallyselected\"))) {\n            this._visuallySelected = val;\n          }\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n      <field name=\"_selectedOnFirstMouseDown\">false</field>\n\n      <property name=\"pinned\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"pinned\") == \"true\";\n        </getter>\n      </property>\n      <property name=\"hidden\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"hidden\") == \"true\";\n        </getter>\n      </property>\n      <property name=\"muted\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"muted\") == \"true\";\n        </getter>\n      </property>\n      <property name=\"multiselected\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"multiselected\") == \"true\";\n        </getter>\n      </property>\n      <property name=\"beforeMultiselected\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"before-multiselected\") == \"true\";\n        </getter>\n      </property>\n      <!--\n      Describes how the tab ended up in this mute state. May be any of:\n\n       - undefined: The tabs mute state has never changed.\n       - null: The mute state was last changed through the UI.\n       - Any string: The ID was changed through an extension API. The string\n                     must be the ID of the extension which changed it.\n      -->\n      <field name=\"muteReason\">undefined</field>\n\n      <property name=\"userContextId\" readonly=\"true\">\n        <getter>\n          return this.hasAttribute(\"usercontextid\")\n                   ? parseInt(this.getAttribute(\"usercontextid\"))\n                   : 0;\n        </getter>\n      </property>\n\n      <property name=\"soundPlaying\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"soundplaying\") == \"true\";\n        </getter>\n      </property>\n\n      <property name=\"activeMediaBlocked\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"activemedia-blocked\") == \"true\";\n        </getter>\n      </property>\n\n      <property name=\"isEmpty\" readonly=\"true\">\n        <getter>\n          // Determines if a tab is \"empty\", usually used in the context of determining\n          // if it's ok to close the tab.\n          if (this.hasAttribute(\"busy\"))\n            return false;\n\n          if (this.hasAttribute(\"customizemode\"))\n            return false;\n\n          let browser = this.linkedBrowser;\n          if (!isBlankPageURL(browser.currentURI.spec))\n            return false;\n\n          if (!checkEmptyPageOrigin(browser))\n            return false;\n\n          if (browser.canGoForward || browser.canGoBack)\n            return false;\n\n          return true;\n        </getter>\n      </property>\n\n      <property name=\"lastAccessed\">\n        <getter>\n          return this._lastAccessed == Infinity ? Date.now() : this._lastAccessed;\n        </getter>\n      </property>\n      <method name=\"updateLastAccessed\">\n        <parameter name=\"aDate\"/>\n        <body><![CDATA[\n          this._lastAccessed = this.selected ? Infinity : (aDate || Date.now());\n        ]]></body>\n      </method>\n\n      <field name=\"mOverCloseButton\">false</field>\n      <property name=\"_overPlayingIcon\" readonly=\"true\">\n        <getter><![CDATA[\n          let iconVisible = this.hasAttribute(\"soundplaying\") ||\n                            this.hasAttribute(\"muted\") ||\n                            this.hasAttribute(\"activemedia-blocked\");\n          let soundPlayingIcon =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"soundplaying-icon\");\n          let overlayIcon =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"overlay-icon\");\n\n          return soundPlayingIcon && soundPlayingIcon.matches(\":hover\") ||\n                 (overlayIcon && overlayIcon.matches(\":hover\") && iconVisible);\n        ]]></getter>\n      </property>\n      <field name=\"mCorrespondingMenuitem\">null</field>\n\n      <!--\n      While it would make sense to track this in a field, the field will get nuked\n      once the node is gone from the DOM, which causes us to think the tab is not\n      closed, which causes us to make wrong decisions. So we use an expando instead.\n      <field name=\"closing\">false</field>\n      -->\n\n      <method name=\"_mouseenter\">\n        <body><![CDATA[\n          if (this.hidden || this.closing) {\n            return;\n          }\n\n          let tabContainer = this.parentNode;\n          let visibleTabs = tabContainer._getVisibleTabs();\n          let tabIndex = visibleTabs.indexOf(this);\n\n          if (this.selected)\n            tabContainer._handleTabSelect();\n\n          if (tabIndex == 0) {\n            tabContainer._beforeHoveredTab = null;\n          } else {\n            let candidate = visibleTabs[tabIndex - 1];\n            let separatedByScrollButton =\n              tabContainer.getAttribute(\"overflow\") == \"true\" &&\n              candidate.pinned && !this.pinned;\n            if (!candidate.selected && !separatedByScrollButton) {\n              tabContainer._beforeHoveredTab = candidate;\n              candidate.setAttribute(\"beforehovered\", \"true\");\n            }\n          }\n\n          if (tabIndex == visibleTabs.length - 1) {\n            tabContainer._afterHoveredTab = null;\n          } else {\n            let candidate = visibleTabs[tabIndex + 1];\n            if (!candidate.selected) {\n              tabContainer._afterHoveredTab = candidate;\n              candidate.setAttribute(\"afterhovered\", \"true\");\n            }\n          }\n\n          tabContainer._hoveredTab = this;\n          if (this.linkedPanel && !this.selected) {\n            this.linkedBrowser.unselectedTabHover(true);\n            this.startUnselectedTabHoverTimer();\n          }\n\n          // Prepare connection to host beforehand.\n          SessionStore.speculativeConnectOnTabHover(this);\n\n          let tabToWarm = this;\n          if (this.mOverCloseButton) {\n            tabToWarm = gBrowser._findTabToBlurTo(this);\n          }\n          gBrowser.warmupTab(tabToWarm);\n        ]]></body>\n      </method>\n\n      <method name=\"_mouseleave\">\n        <body><![CDATA[\n          let tabContainer = this.parentNode;\n          if (tabContainer._beforeHoveredTab) {\n            tabContainer._beforeHoveredTab.removeAttribute(\"beforehovered\");\n            tabContainer._beforeHoveredTab = null;\n          }\n          if (tabContainer._afterHoveredTab) {\n            tabContainer._afterHoveredTab.removeAttribute(\"afterhovered\");\n            tabContainer._afterHoveredTab = null;\n          }\n\n          tabContainer._hoveredTab = null;\n          if (this.linkedPanel && !this.selected) {\n            this.linkedBrowser.unselectedTabHover(false);\n            this.cancelUnselectedTabHoverTimer();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"startUnselectedTabHoverTimer\">\n        <body><![CDATA[\n          // Only record data when we need to.\n          if (!this.linkedBrowser.shouldHandleUnselectedTabHover) {\n            return;\n          }\n\n          if (!TelemetryStopwatch.running(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this)) {\n            TelemetryStopwatch.start(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this);\n          }\n\n          if (this._hoverTabTimer) {\n            clearTimeout(this._hoverTabTimer);\n            this._hoverTabTimer = null;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"cancelUnselectedTabHoverTimer\">\n        <body><![CDATA[\n          // Since we're listening \"mouseout\" event, instead of \"mouseleave\".\n          // Every time the cursor is moving from the tab to its child node (icon),\n          // it would dispatch \"mouseout\"(for tab) first and then dispatch\n          // \"mouseover\" (for icon, eg: close button, speaker icon) soon.\n          // It causes we would cancel present TelemetryStopwatch immediately\n          // when cursor is moving on the icon, and then start a new one.\n          // In order to avoid this situation, we could delay cancellation and\n          // remove it if we get \"mouseover\" within very short period.\n          this._hoverTabTimer = setTimeout(() => {\n            if (TelemetryStopwatch.running(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this)) {\n              TelemetryStopwatch.cancel(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this);\n            }\n          }, 100);\n        ]]></body>\n      </method>\n\n      <method name=\"finishUnselectedTabHoverTimer\">\n        <body><![CDATA[\n          // Stop timer when the tab is opened.\n          if (TelemetryStopwatch.running(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this)) {\n            TelemetryStopwatch.finish(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"startMediaBlockTimer\">\n        <body><![CDATA[\n          TelemetryStopwatch.start(\"TAB_MEDIA_BLOCKING_TIME_MS\", this);\n        ]]></body>\n      </method>\n\n       <method name=\"finishMediaBlockTimer\">\n        <body><![CDATA[\n          TelemetryStopwatch.finish(\"TAB_MEDIA_BLOCKING_TIME_MS\", this);\n        ]]></body>\n      </method>\n\n      <method name=\"toggleMuteAudio\">\n        <parameter name=\"aMuteReason\"/>\n        <body>\n        <![CDATA[\n          let browser = this.linkedBrowser;\n          let modifiedAttrs = [];\n          let hist = Services.telemetry.getHistogramById(\"TAB_AUDIO_INDICATOR_USED\");\n\n          if (this.hasAttribute(\"activemedia-blocked\")) {\n            this.removeAttribute(\"activemedia-blocked\");\n            modifiedAttrs.push(\"activemedia-blocked\");\n\n            browser.resumeMedia();\n            hist.add(3 /* unblockByClickingIcon */);\n            this.finishMediaBlockTimer();\n          } else {\n            if (browser.audioMuted) {\n              if (this.linkedPanel) {\n                // \"Lazy Browser\" should not invoke its unmute method\n                browser.unmute();\n              }\n              this.removeAttribute(\"muted\");\n              hist.add(1 /* unmute */);\n            } else {\n              if (this.linkedPanel) {\n                // \"Lazy Browser\" should not invoke its mute method\n                browser.mute();\n              }\n              this.setAttribute(\"muted\", \"true\");\n              hist.add(0 /* mute */);\n            }\n            this.muteReason = aMuteReason || null;\n            modifiedAttrs.push(\"muted\");\n          }\n          gBrowser._tabAttrModified(this, modifiedAttrs);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setUserContextId\">\n        <parameter name=\"aUserContextId\"/>\n        <body>\n        <![CDATA[\n          if (aUserContextId) {\n            if (this.linkedBrowser) {\n              this.linkedBrowser.setAttribute(\"usercontextid\", aUserContextId);\n            }\n            this.setAttribute(\"usercontextid\", aUserContextId);\n          } else {\n            if (this.linkedBrowser) {\n              this.linkedBrowser.removeAttribute(\"usercontextid\");\n            }\n            this.removeAttribute(\"usercontextid\");\n          }\n\n          ContextualIdentityService.setTabStyle(this);\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"mouseover\"><![CDATA[\n        if (event.originalTarget.getAttribute(\"anonid\") == \"close-button\") {\n          this.mOverCloseButton = true;\n        }\n\n        this._mouseenter();\n      ]]></handler>\n      <handler event=\"mouseout\"><![CDATA[\n        if (event.originalTarget.getAttribute(\"anonid\") == \"close-button\") {\n          this.mOverCloseButton = false;\n        }\n\n        this._mouseleave();\n      ]]></handler>\n\n      <handler event=\"dragstart\" phase=\"capturing\">\n        this.style.MozUserFocus = \"\";\n      </handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        if (this.mOverCloseButton) {\n          event.stopPropagation();\n        }\n      ]]></handler>\n\n      <handler event=\"mousedown\" phase=\"capturing\">\n      <![CDATA[\n        let tabContainer = this.parentNode;\n\n        if (tabContainer._closeTabByDblclick &&\n            event.button == 0 &&\n            event.detail == 1) {\n          this._selectedOnFirstMouseDown = this.selected;\n        }\n\n        if (this.selected) {\n          this.style.MozUserFocus = \"ignore\";\n        } else if (event.originalTarget.classList.contains(\"tab-close-button\") ||\n                   event.originalTarget.classList.contains(\"tab-icon-sound\") ||\n                   event.originalTarget.classList.contains(\"tab-icon-overlay\")) {\n            // Prevent tabbox.xml from selecting the tab.\n            event.stopPropagation();\n        }\n\n        if (event.button == 1) {\n          gBrowser.warmupTab(gBrowser._findTabToBlurTo(this));\n        }\n\n        if (event.button == 0 && tabContainer._multiselectEnabled) {\n          let shiftKey = event.shiftKey;\n          let accelKey = event.getModifierState(\"Accel\");\n          if (shiftKey) {\n            const lastSelectedTab = gBrowser.lastMultiSelectedTab;\n            if (!accelKey) {\n              gBrowser.selectedTab = lastSelectedTab;\n\n              // Make sure selection is cleared when tab-switch doesn't happen.\n              gBrowser.clearMultiSelectedTabs(false);\n            }\n            gBrowser.addRangeToMultiSelectedTabs(lastSelectedTab, this);\n\n            // Prevent tabbox.xml from selecting the tab.\n            event.stopPropagation();\n          } else if (accelKey) {\n            // Ctrl (Cmd for mac) key is pressed\n            if (this.multiselected) {\n              gBrowser.removeFromMultiSelectedTabs(this, true);\n            } else if (this != gBrowser.selectedTab) {\n              gBrowser.addToMultiSelectedTabs(this, false);\n              gBrowser.lastMultiSelectedTab = this;\n            }\n\n            // Prevent tabbox.xml from selecting the tab.\n            event.stopPropagation();\n          } else if (!this.selected && this.multiselected) {\n            gBrowser.lockClearMultiSelectionOnce();\n          }\n        }\n      ]]>\n      </handler>\n      <handler event=\"mouseup\">\n        // Make sure that clear-selection is released.\n        // Otherwise selection using Shift key may be broken.\n        gBrowser.unlockClearMultiSelection();\n\n        this.style.MozUserFocus = \"\";\n      </handler>\n\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        if (event.getModifierState(\"Accel\") || event.shiftKey) {\n          return;\n        }\n\n        if (gBrowser.multiSelectedTabsCount > 0 &&\n            !event.originalTarget.classList.contains(\"tab-close-button\") &&\n            !event.originalTarget.classList.contains(\"tab-icon-sound\") &&\n            !event.originalTarget.classList.contains(\"tab-icon-overlay\")) {\n          // Tabs were previously multi-selected and user clicks on a tab\n          // without holding Ctrl/Cmd Key\n\n          // Force positional attributes to update when the\n          // target (of the click) is the \"active\" tab.\n          let updatePositionalAttr = gBrowser.selectedTab == this;\n\n          gBrowser.clearMultiSelectedTabs(updatePositionalAttr);\n        }\n\n        if (event.originalTarget.classList.contains(\"tab-icon-sound\") ||\n            (event.originalTarget.classList.contains(\"tab-icon-overlay\") &&\n             (event.originalTarget.hasAttribute(\"soundplaying\") ||\n              event.originalTarget.hasAttribute(\"muted\")))) {\n          if (this.multiselected) {\n            gBrowser.toggleMuteAudioOnMultiSelectedTabs(this);\n          } else {\n            this.toggleMuteAudio();\n          }\n          return;\n        }\n\n        if (event.originalTarget.getAttribute(\"anonid\") == \"close-button\") {\n          if (this.multiselected) {\n            gBrowser.removeMultiSelectedTabs();\n          } else {\n            gBrowser.removeTab(this, {\n              animate: true,\n              byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE,\n            });\n          }\n          // This enables double-click protection for the tab container\n          // (see tabbrowser-tabs 'click' handler).\n          gBrowser.tabContainer._blockDblClick = true;\n        }\n      ]]></handler>\n\n      <handler event=\"dblclick\" button=\"0\" phase=\"capturing\"><![CDATA[\n        // for the one-close-button case\n        if (event.originalTarget.getAttribute(\"anonid\") == \"close-button\") {\n          event.stopPropagation();\n        }\n\n        let tabContainer = this.parentNode;\n        if (tabContainer._closeTabByDblclick &&\n            this._selectedOnFirstMouseDown &&\n            this.selected &&\n            !(event.originalTarget.classList.contains(\"tab-icon-sound\") ||\n              event.originalTarget.classList.contains(\"tab-icon-overlay\"))) {\n          gBrowser.removeTab(this, {\n            animate: true,\n            byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE,\n          });\n        }\n      ]]></handler>\n\n      <handler event=\"animationend\">\n      <![CDATA[\n        if (event.originalTarget.getAttribute(\"anonid\") == \"tab-loading-burst\") {\n          this.removeAttribute(\"bursting\");\n        }\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"urlbarBindings.xml","body":"<?xml version=\"1.0\"?>\n\n<!--\n-*- Mode: HTML -*-\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n-->\n\n<!DOCTYPE bindings [\n<!ENTITY % notificationDTD SYSTEM \"chrome://global/locale/notification.dtd\">\n%notificationDTD;\n<!ENTITY % browserDTD SYSTEM \"chrome://browser/locale/browser.dtd\">\n%browserDTD;\n<!ENTITY % brandDTD SYSTEM \"chrome://branding/locale/brand.dtd\">\n%brandDTD;\n]>\n\n<bindings id=\"urlbarBindings\" xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"urlbar\" extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content>\n      <children includes=\"box\"/>\n      <xul:moz-input-box anonid=\"moz-input-box\"\n                         tooltip=\"aHTMLTooltip\"\n                         class=\"urlbar-input-box\"\n                         flex=\"1\">\n        <children/>\n        <html:input anonid=\"scheme\"\n                    class=\"urlbar-scheme textbox-input\"\n                    required=\"required\"\n                    xbl:inherits=\"textoverflow,focused\"/>\n        <html:input anonid=\"input\"\n                    class=\"urlbar-input textbox-input\"\n                    allowevents=\"true\"\n                    inputmode=\"mozAwesomebar\"\n                    xbl:inherits=\"value,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,focused,textoverflow\"/>\n      </xul:moz-input-box>\n      <xul:image anonid=\"urlbar-go-button\"\n                 class=\"urlbar-go-button urlbar-icon\"\n                 onclick=\"gURLBar.handleCommand(event);\"\n                 tooltiptext=\"FROM-DTD.goEndCap.tooltip;\"\n                 xbl:inherits=\"pageproxystate,parentfocused=focused,usertyping\"/>\n      <xul:dropmarker anonid=\"historydropmarker\"\n                      class=\"urlbar-history-dropmarker urlbar-icon chromeclass-toolbar-additional\"\n                      tooltiptext=\"FROM-DTD.urlbar.openHistoryPopup.tooltip;\"\n                      allowevents=\"true\"\n                      xbl:inherits=\"open,parentfocused=focused,usertyping\"/>\n      <children includes=\"hbox\"/>\n    </content>\n  </binding>\n\n  <binding id=\"legacy-urlbar\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete\">\n    <content>\n      <children includes=\"box\"/>\n      <xul:moz-input-box anonid=\"moz-input-box\"\n                         tooltip=\"aHTMLTooltip\"\n                         class=\"urlbar-input-box\"\n                         flex=\"1\">\n        <children/>\n        <html:input anonid=\"scheme\"\n                    class=\"urlbar-scheme textbox-input\"\n                    required=\"required\"\n                    xbl:inherits=\"textoverflow,focused\"/>\n        <html:input anonid=\"input\"\n                    class=\"urlbar-input textbox-input\"\n                    allowevents=\"true\"\n                    inputmode=\"mozAwesomebar\"\n                    xbl:inherits=\"value,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,focused,textoverflow\"/>\n      </xul:moz-input-box>\n      <xul:image anonid=\"urlbar-go-button\"\n                 class=\"urlbar-go-button urlbar-icon\"\n                 onclick=\"gURLBar.handleCommand(event);\"\n                 tooltiptext=\"FROM-DTD.goEndCap.tooltip;\"\n                 xbl:inherits=\"pageproxystate,parentfocused=focused,usertyping\"/>\n      <xul:dropmarker anonid=\"historydropmarker\"\n                      class=\"urlbar-history-dropmarker urlbar-icon chromeclass-toolbar-additional\"\n                      tooltiptext=\"FROM-DTD.urlbar.openHistoryPopup.tooltip;\"\n                      allowevents=\"true\"\n                      xbl:inherits=\"open,parentfocused=focused,usertyping\"/>\n      <children includes=\"hbox\"/>\n    </content>\n\n    <implementation implements=\"nsIObserver\">\n      <field name=\"ExtensionSearchHandler\" readonly=\"true\">\n        (ChromeUtils.import(\"resource://gre/modules/ExtensionSearchHandler.jsm\", {})).ExtensionSearchHandler;\n      </field>\n\n      <constructor><![CDATA[\n        // UrlbarInput compatibility shims\n        this.document = document;\n        this.window = window;\n        this.textbox = this;\n\n        this._prefs = Cc[\"@mozilla.org/preferences-service;1\"]\n                        .getService(Ci.nsIPrefService)\n                        .getBranch(\"browser.urlbar.\");\n        this._prefs.addObserver(\"\", this);\n\n        this._defaultPrefs = Cc[\"@mozilla.org/preferences-service;1\"]\n                               .getService(Ci.nsIPrefService)\n                               .getDefaultBranch(\"browser.urlbar.\");\n\n        Services.prefs.addObserver(\"browser.search.suggest.enabled\", this);\n        this.browserSearchSuggestEnabled = Services.prefs.getBoolPref(\"browser.search.suggest.enabled\");\n\n        this.openInTab = this._prefs.getBoolPref(\"openintab\");\n        this.clickSelectsAll = this._prefs.getBoolPref(\"clickSelectsAll\");\n        this.doubleClickSelectsAll = this._prefs.getBoolPref(\"doubleClickSelectsAll\");\n        this.completeDefaultIndex = this._prefs.getBoolPref(\"autoFill\");\n        this.speculativeConnectEnabled = this._prefs.getBoolPref(\"speculativeConnect.enabled\");\n        this.urlbarSearchSuggestEnabled = this._prefs.getBoolPref(\"suggest.searches\");\n        this.timeout = this._prefs.getIntPref(\"delay\");\n        this._mayTrimURLs = this._prefs.getBoolPref(\"trimURLs\");\n        this._adoptIntoActiveWindow = this._prefs.getBoolPref(\"switchTabs.adoptIntoActiveWindow\");\n        this._ctrlCanonizesURLs = this._prefs.getBoolPref(\"ctrlCanonizesURLs\");\n        this.inputField.controllers.insertControllerAt(0, this._copyCutController);\n        this.inputField.addEventListener(\"paste\", this);\n        this.inputField.addEventListener(\"mousedown\", this);\n        this.inputField.addEventListener(\"mouseover\", this);\n        this.inputField.addEventListener(\"overflow\", this);\n        this.inputField.addEventListener(\"underflow\", this);\n        this.inputField.addEventListener(\"scrollend\", this);\n        window.addEventListener(\"resize\", this);\n\n        var textBox = document.getAnonymousElementByAttribute(this,\n                                                \"anonid\", \"moz-input-box\");\n        // Force the Custom Element to upgrade until Bug 1470242 handles this:\n        customElements.upgrade(textBox);\n        var cxmenu = textBox.menupopup;\n        var pasteAndGo;\n        cxmenu.addEventListener(\"popupshowing\", function() {\n          if (!pasteAndGo)\n            return;\n          var controller = document.commandDispatcher.getControllerForCommand(\"cmd_paste\");\n          var enabled = controller.isCommandEnabled(\"cmd_paste\");\n          if (enabled)\n            pasteAndGo.removeAttribute(\"disabled\");\n          else\n            pasteAndGo.setAttribute(\"disabled\", \"true\");\n        });\n\n        var insertLocation = cxmenu.firstElementChild;\n        while (insertLocation.nextElementSibling &&\n               insertLocation.getAttribute(\"cmd\") != \"cmd_paste\")\n          insertLocation = insertLocation.nextElementSibling;\n        if (insertLocation) {\n          pasteAndGo = document.createXULElement(\"menuitem\");\n          let label = Services.strings.createBundle(\"chrome://browser/locale/browser.properties\").\n                                   GetStringFromName(\"pasteAndGo.label\");\n          pasteAndGo.setAttribute(\"label\", label);\n          pasteAndGo.setAttribute(\"anonid\", \"paste-and-go\");\n          pasteAndGo.setAttribute(\"oncommand\",\n              \"gURLBar.select(); goDoCommand('cmd_paste'); gURLBar.handleCommand();\");\n          cxmenu.insertBefore(pasteAndGo, insertLocation.nextElementSibling);\n        }\n\n        this.popup.addEventListener(\"popupshowing\", () => {\n          this._enableOrDisableOneOffSearches();\n        }, {capture: true, once: true});\n\n        // history dropmarker open state\n        this.popup.addEventListener(\"popupshowing\", () => {\n          this.setAttribute(\"open\", \"true\");\n        });\n        this.popup.addEventListener(\"popuphidden\", () => {\n          requestAnimationFrame(() => {\n            this.removeAttribute(\"open\");\n          });\n        });\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // Somehow, it's possible for the XBL destructor to fire without the\n        // constructor ever having fired. Fix:\n        if (!this._prefs) {\n          return;\n        }\n        this._prefs.removeObserver(\"\", this);\n        this._prefs = null;\n        Services.prefs.removeObserver(\"browser.search.suggest.enabled\", this);\n        this.inputField.controllers.removeController(this._copyCutController);\n        this.inputField.removeEventListener(\"paste\", this);\n        this.inputField.removeEventListener(\"mousedown\", this);\n        this.inputField.removeEventListener(\"mouseover\", this);\n        this.inputField.removeEventListener(\"overflow\", this);\n        this.inputField.removeEventListener(\"underflow\", this);\n        this.inputField.removeEventListener(\"scrollend\", this);\n        window.removeEventListener(\"resize\", this);\n\n        if (this._deferredKeyEventTimeout) {\n          clearTimeout(this._deferredKeyEventTimeout);\n          this._deferredKeyEventTimeout = null;\n        }\n\n        // Null out the one-offs' popup and textbox so that it cleans up its\n        // internal state for both.  Most importantly, it removes the event\n        // listeners that it added to both.\n        this.popup.oneOffSearchButtons.popup = null;\n        this.popup.oneOffSearchButtons.textbox = null;\n      ]]></destructor>\n\n      <field name=\"valueFormatter\" readonly=\"true\">\n        new UrlbarValueFormatter(this);\n      </field>\n\n      <field name=\"goButton\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"urlbar-go-button\");\n      </field>\n\n      <field name=\"_value\">\"\"</field>\n      <field name=\"gotResultForCurrentQuery\">false</field>\n\n      <!--\n        This is set around HandleHenter so it can be used in handleCommand.\n        It is also used to track whether we must handle a delayed handleEnter,\n        by checking if it has been cleared.\n      -->\n      <field name=\"handleEnterInstance\">null</field>\n\n      <!--\n        Since we never want scrollbars, we always use the maxResults value.\n      -->\n      <property name=\"maxRows\"\n                onget=\"return this.popup.maxResults;\"/>\n\n      <!--\n        Set by focusAndSelectUrlBar to indicate whether the next focus event was\n        initiated by an explicit user action. See the \"focus\" handler below.\n      -->\n      <field name=\"userInitiatedFocus\">false</field>\n\n      <!--\n        onBeforeValueGet is called by the base-binding's .value getter.\n        It can return an object with a \"value\" property, to override the\n        return value of the getter.\n      -->\n      <method name=\"onBeforeValueGet\">\n        <body><![CDATA[\n          return { value: this._value };\n        ]]></body>\n      </method>\n\n      <!--\n        onBeforeValueSet is called by the base-binding's .value setter.\n        It should return the value that the setter should use.\n      -->\n      <method name=\"onBeforeValueSet\">\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          this._value = aValue;\n          var returnValue = aValue;\n          var action = this._parseActionUrl(aValue);\n\n          if (action) {\n            switch (action.type) {\n              case \"switchtab\": // Fall through.\n              case \"remotetab\": // Fall through.\n              case \"visiturl\": {\n                returnValue = action.params.displayUrl;\n                break;\n              }\n              case \"keyword\": // Fall through.\n              case \"searchengine\": {\n                returnValue = action.params.input;\n                break;\n              }\n              case \"extension\": {\n                returnValue = action.params.content;\n                break;\n              }\n            }\n          } else {\n            let originalUrl = ReaderMode.getOriginalUrlObjectForDisplay(aValue);\n            if (originalUrl) {\n              returnValue = originalUrl.displaySpec;\n            }\n          }\n\n          // Set the actiontype only if the user is not overriding actions.\n          if (action && this._pressedNoActionKeys.size == 0) {\n            this.setAttribute(\"actiontype\", action.type);\n          } else {\n            this.removeAttribute(\"actiontype\");\n          }\n          return returnValue;\n        ]]></body>\n      </method>\n\n      <method name=\"onKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aOptions\"/>\n        <body><![CDATA[\n          switch (aEvent.keyCode) {\n            case KeyEvent.DOM_VK_LEFT:\n            case KeyEvent.DOM_VK_RIGHT:\n            case KeyEvent.DOM_VK_HOME:\n              // Reset the selected index so that nsAutoCompleteController\n              // simply closes the popup without trying to fill anything.\n              this.popup.selectedIndex = -1;\n              break;\n            case KeyEvent.DOM_VK_TAB:\n              this.userSelectionBehavior = \"tab\";\n              // The user is explicitly making a selection, so the popup\n              // should get accessibility focus.\n              this.popup.richlistbox.suppressMenuItemEvent = false;\n              break;\n            case KeyEvent.DOM_VK_UP:\n            case KeyEvent.DOM_VK_DOWN:\n            case KeyEvent.DOM_VK_PAGE_UP:\n            case KeyEvent.DOM_VK_PAGE_DOWN:\n              if (this.userSelectionBehavior != \"tab\")\n                this.userSelectionBehavior = \"arrow\";\n              // The user is explicitly making a selection, so the popup\n              // should get accessibility focus.\n              this.popup.richlistbox.suppressMenuItemEvent = false;\n              break;\n          }\n\n          if (AppConstants.platform == \"macosx\") {\n            switch (aEvent.key) {\n              case \"n\":\n              case \"p\":\n                if (aEvent.ctrlKey) {\n                  // The user is explicitly making a selection, so the popup\n                  // should get accessibility focus.\n                  this.popup.richlistbox.suppressMenuItemEvent = false;\n                }\n                break;\n            }\n          }\n\n          let noDefer = aOptions && aOptions.noDefer;\n          if (!noDefer && this._shouldDeferKeyEvent(aEvent)) {\n            this._deferKeyEvent(aEvent, \"onKeyPress\");\n            return false;\n          }\n          if (this.popup.popupOpen && this.popup.handleKeyPress(aEvent)) {\n            return true;\n          }\n          return this.handleKeyPress(aEvent, aOptions);\n        ]]></body>\n      </method>\n\n      <!--\n        Search results arrive asynchronously, which means that keypresses may\n        arrive before results do and therefore not have the effect the user\n        intends.  That's especially likely to happen with the down arrow and\n        enter keys due to the one-off search buttons: if the user very quickly\n        pastes something in the input, presses the down arrow key, and then hits\n        enter, they are probably expecting to visit the first result.  But if\n        there are no results, then pressing down and enter will trigger the\n        first one-off button.  To prevent that undesirable behavior, certain\n        keys are buffered and deferred until more results arrive, at which time\n        they're replayed.\n\n        @param  event\n                The key event that should maybe be deferred.\n        @return True if the event should be deferred, false if not.\n       -->\n      <method name=\"_shouldDeferKeyEvent\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          // If any event has been deferred for this search, then defer all\n          // subsequent events so that the user does not experience any\n          // keypresses out of order.  All events will be replayed when\n          // _deferredKeyEventTimeout fires.\n          if (this._deferredKeyEventQueue.length) {\n            return true;\n          }\n\n          // At this point, no events have been deferred for this search, and we\n          // need to decide whether `event` is the first one that should be.\n          if (!this._keyCodesToDefer.has(event.keyCode) &&\n              !(/Mac/.test(navigator.platform) &&\n                event.ctrlKey &&\n                (event.key === \"n\" || event.key === \"p\") &&\n                this.popupOpen)) {\n\n            // Not a key that should trigger deferring.\n            return false;\n          }\n\n          let waitedLongEnough =\n            this._searchStartDate + this._deferredKeyEventTimeoutMs <= Cu.now();\n          if (waitedLongEnough) {\n            // This is a key that we would defer, but enough time has passed\n            // since the start of the search that we don't want to block the\n            // user's keypresses anymore.\n            return false;\n          }\n\n          if (event.keyCode == KeyEvent.DOM_VK_TAB && !this.popupOpen) {\n            // The popup is closed and the user pressed the Tab key.  The\n            // focus should move out of the urlbar immediately.\n            return false;\n          }\n\n          return !this._safeToPlayDeferredKeyEvent(event);\n        ]]></body>\n      </method>\n\n      <!--\n        Returns true if the given deferred key event can be played now without\n        possibly surprising the user.  This depends on the state of the popup,\n        its results, and the type of keypress.  Use this method only after\n        determining that the event should be deferred, or after it's already\n        been deferred and you want to know if it can be played now.\n\n        @param  event\n                The key event.\n        @return True if the event can be played, false if not.\n      -->\n      <method name=\"_safeToPlayDeferredKeyEvent\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (event.keyCode == KeyEvent.DOM_VK_RETURN) {\n            return this.popup.selectedIndex != 0 ||\n                   this.gotResultForCurrentQuery;\n          }\n\n          if (!this.gotResultForCurrentQuery || !this.popupOpen) {\n            // We're still waiting on the first result, or the popup hasn't\n            // opened yet, so not safe.\n            return false;\n          }\n\n          let maxResultsRemaining =\n            this.popup.maxResults - this.popup.matchCount;\n          if (maxResultsRemaining == 0) {\n            // The popup can't possibly have any more results, so there's no\n            // need to defer any event now.\n            return true;\n          }\n\n          if (event.keyCode == KeyEvent.DOM_VK_DOWN) {\n            // Don't play the event if the last result is selected so that the\n            // user doesn't accidentally arrow down into the one-off buttons\n            // when they didn't mean to.\n            let lastResultSelected =\n              this.popup.selectedIndex + 1 == this.popup.matchCount;\n            return !lastResultSelected;\n          }\n\n          return true;\n        ]]></body>\n      </method>\n\n      <!--\n        Adds a key event to the deferred event queue.\n\n        @param event\n               The key event to defer.\n        @param methodName\n               The name of the method on `this` to call.  It's expected to take\n               two arguments: the event, and an optional options object:\n               {\n                  noDefer: If true, then the event is being replayed and it\n                           should not be deferred again.\n               }\n      -->\n      <method name=\"_deferKeyEvent\">\n        <parameter name=\"event\"/>\n        <parameter name=\"methodName\"/>\n        <body><![CDATA[\n          // Somehow event.defaultPrevented ends up true for deferred events.\n          // autocomplete ignores defaultPrevented events, which means it would\n          // ignore replayed deferred events if we didn't tell it to bypass\n          // defaultPrevented.  That's the purpose of this expando.  If we could\n          // figure out what's setting defaultPrevented and prevent it, then we\n          // could get rid of this.\n          if (event.urlbarDeferred) {\n            throw new Error(\"Key event already deferred!\");\n          }\n          event.urlbarDeferred = true;\n\n          this._deferredKeyEventQueue.push({\n            methodName,\n            event,\n            searchString: this.mController.searchString,\n          });\n\n          if (!this._deferredKeyEventTimeout) {\n            // Start the timeout that will unconditionally replay all deferred\n            // events when it fires so that, after a certain point, we don't\n            // keep blocking the user's keypresses when nothing else has caused\n            // the events to be replayed.  Do not check whether it's safe to\n            // replay the events because otherwise it may look like we ignored\n            // the user's input.\n            let elapsed = Cu.now() - this._searchStartDate;\n            let remaining = this._deferredKeyEventTimeoutMs - elapsed;\n            this._deferredKeyEventTimeout = setTimeout(() => {\n              this.replayAllDeferredKeyEvents();\n              this._deferredKeyEventTimeout = null;\n            }, Math.max(0, remaining));\n          }\n        ]]></body>\n      </method>\n\n      <!-- The enter key is always deferred, so it's not included here. -->\n      <field name=\"_keyCodesToDefer\">new Set([\n        KeyboardEvent.DOM_VK_RETURN,\n        KeyboardEvent.DOM_VK_DOWN,\n        KeyboardEvent.DOM_VK_TAB,\n      ])</field>\n      <field name=\"_deferredKeyEventQueue\">[]</field>\n      <field name=\"_deferredKeyEventTimeout\">null</field>\n      <field name=\"_deferredKeyEventTimeoutMs\">200</field>\n      <field name=\"_searchStartDate\">0</field>\n\n      <method name=\"replaySafeDeferredKeyEvents\">\n        <body><![CDATA[\n          if (!this._deferredKeyEventQueue.length) {\n            return;\n          }\n          let instance = this._deferredKeyEventQueue[0];\n          if (!this._safeToPlayDeferredKeyEvent(instance.event)) {\n            return;\n          }\n          this._deferredKeyEventQueue.shift();\n          this._replayKeyEventInstance(instance);\n          Services.tm.dispatchToMainThread(() => {\n            this.replaySafeDeferredKeyEvents();\n          });\n        ]]></body>\n      </method>\n\n      <!--\n        Unconditionally replays all deferred key events.  This does not check\n        whether it's safe to replay the events; use replaySafeDeferredKeyEvents\n        for that.  Use this method when you must replay all events so that it\n        does not appear that we ignored the user's input.\n      -->\n      <method name=\"replayAllDeferredKeyEvents\">\n        <body><![CDATA[\n          let instance = this._deferredKeyEventQueue.shift();\n          if (!instance) {\n            return;\n          }\n          this._replayKeyEventInstance(instance);\n          Services.tm.dispatchToMainThread(() => {\n            this.replayAllDeferredKeyEvents();\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"_replayKeyEventInstance\">\n        <parameter name=\"instance\"/>\n        <body><![CDATA[\n          // Safety check: handle only if the search string didn't change.\n          if (this.mController.searchString == instance.searchString) {\n            this[instance.methodName](instance.event, {noDefer: true});\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_mayTrimURLs\">true</field>\n      <method name=\"trimValue\">\n        <parameter name=\"aURL\"/>\n        <body><![CDATA[\n          // This method must not modify the given URL such that calling\n          // nsIURIFixup::createFixupURI with the result will produce a different URI.\n          return this._mayTrimURLs ? trimURL(aURL) : aURL;\n        ]]></body>\n      </method>\n\n      <!--\n        This method tries to apply styling to the text in the input, depending\n        on the text.  See the _format* methods.\n      -->\n      <method name=\"formatValue\">\n        <body><![CDATA[\n          this.valueFormatter.update();\n        ]]></body>\n      </method>\n\n      <method name=\"handleRevert\">\n        <body><![CDATA[\n          var isScrolling = this.popupOpen;\n\n          gBrowser.userTypedValue = null;\n\n          // don't revert to last valid url unless page is NOT loading\n          // and user is NOT key-scrolling through autocomplete list\n          if (!XULBrowserWindow.isBusy && !isScrolling) {\n            URLBarSetURI(null, true);\n\n            // If the value isn't empty and the urlbar has focus, select the value.\n            if (this.value && this.hasAttribute(\"focused\"))\n              this.select();\n          }\n\n          // tell widget to revert to last typed text only if the user\n          // was scrolling when they hit escape\n          return !isScrolling;\n        ]]></body>\n      </method>\n\n      <method name=\"_whereToOpen\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let isMouseEvent = event instanceof MouseEvent;\n          let reuseEmpty = !isMouseEvent;\n          let where = undefined;\n          if (!isMouseEvent && event && event.altKey) {\n            // We support using 'alt' to open in a tab, because ctrl/shift\n            // might be used for canonizing URLs:\n            where = event.shiftKey ? \"tabshifted\" : \"tab\";\n          } else if (!isMouseEvent && this._ctrlCanonizesURLs && event && event.ctrlKey) {\n            // If we're allowing canonization, and this is a key event with ctrl\n            // pressed, open in current tab to allow ctrl-enter to canonize URL.\n            where = \"current\";\n          } else {\n            where = whereToOpenLink(event, false, false);\n          }\n          if (this.openInTab) {\n            if (where == \"current\") {\n              where = \"tab\";\n            } else if (where == \"tab\") {\n              where = \"current\";\n            }\n            reuseEmpty = true;\n          }\n          if (where == \"tab\" && reuseEmpty && gBrowser.selectedTab.isEmpty) {\n            where = \"current\";\n          }\n          return where;\n        ]]></body>\n      </method>\n\n      <!--\n        This is ultimately called by the autocomplete controller as the result\n        of handleEnter when the Return key is pressed in the textbox.  Since\n        onPopupClick also calls handleEnter, this is also called as a result in\n        that case.\n\n        @param event\n               The event that triggered the command.\n        @param openUILinkWhere\n               Optional.  The \"where\" to pass to openTrustedLinkIn.  This method\n               computes the appropriate \"where\" given the event, but you can\n               use this to override it.\n        @param openUILinkParams\n               Optional.  The parameters to pass to openTrustedLinkIn.  As with\n               \"where\", this method computes the appropriate parameters, but\n               any parameters you supply here will override those.\n      -->\n      <method name=\"handleCommand\">\n        <parameter name=\"event\"/>\n        <parameter name=\"openUILinkWhere\"/>\n        <parameter name=\"openUILinkParams\"/>\n        <parameter name=\"triggeringPrincipal\"/>\n        <body><![CDATA[\n          let isMouseEvent = event instanceof MouseEvent;\n          if (isMouseEvent && event.button == 2) {\n            // Do nothing for right clicks.\n            return;\n          }\n\n          // Determine whether to use the selected one-off search button.  In\n          // one-off search buttons parlance, \"selected\" means that the button\n          // has been navigated to via the keyboard.  So we want to use it if\n          // the triggering event is not a mouse click -- i.e., it's a Return\n          // key -- or if the one-off was mouse-clicked.\n          let selectedOneOff = this.popup.oneOffSearchButtons.selectedButton;\n          if (selectedOneOff &&\n              isMouseEvent &&\n              event.originalTarget != selectedOneOff) {\n            selectedOneOff = null;\n          }\n\n          // Do the command of the selected one-off if it's not an engine.\n          if (selectedOneOff && !selectedOneOff.engine) {\n            selectedOneOff.doCommand();\n            return;\n          }\n\n          let where = openUILinkWhere || this._whereToOpen(event);\n\n          let url = this.value;\n          if (!url) {\n            return;\n          }\n\n          BrowserUsageTelemetry.recordUrlbarSelectedResultMethod(\n            event, this.userSelectionBehavior);\n\n          let mayInheritPrincipal = false;\n          let postData = null;\n          let browser = gBrowser.selectedBrowser;\n          let action = this._parseActionUrl(url);\n\n          if (selectedOneOff && selectedOneOff.engine) {\n            // If there's a selected one-off button then load a search using\n            // the one-off's engine.\n            [url, postData] =\n              this._parseAndRecordSearchEngineLoad(selectedOneOff.engine,\n                                                   this.oneOffSearchQuery,\n                                                   event);\n          } else if (action) {\n            switch (action.type) {\n              case \"visiturl\":\n                // Unifiedcomplete uses fixupURI to tell if something is a visit\n                // or a search, and passes out the fixedURI as the url param.\n                // By using that uri we would end up passing a different string\n                // to the docshell that may run a different not-found heuristic.\n                // For example, \"mozilla/run\" would be fixed by unifiedcomplete\n                // to \"http://mozilla/run\". The docshell, once it can't resolve\n                // mozilla, would note the string has a scheme, and try to load\n                // http://mozilla.com/run instead of searching \"mozilla/run\".\n                // So, if we have the original input at hand, we pass it through\n                // and let the docshell handle it.\n                if (action.params.input) {\n                  url = action.params.input;\n                  break;\n                }\n                url = action.params.url;\n                break;\n              case \"remotetab\":\n                url = action.params.url;\n                break;\n              case \"keyword\":\n                if (action.params.postData) {\n                  postData = UrlbarUtils.getPostDataStream(action.params.postData);\n                }\n                mayInheritPrincipal = true;\n                url = action.params.url;\n                break;\n              case \"switchtab\":\n                url = action.params.url;\n                if (this.hasAttribute(\"actiontype\")) {\n                  this.handleRevert();\n                  let prevTab = gBrowser.selectedTab;\n                  let loadOpts = {\n                    adoptIntoActiveWindow: this._adoptIntoActiveWindow,\n                  };\n\n                  if (switchToTabHavingURI(url, false, loadOpts) &&\n                      prevTab.isEmpty) {\n                    gBrowser.removeTab(prevTab);\n                  }\n                  return;\n                }\n\n                // Once we get here, we got a switchtab action but the user\n                // bypassed it by pressing shift/meta/ctrl. Those modifiers\n                // might otherwise affect where we open - we always want to\n                // open in the current tab.\n                where = \"current\";\n                break;\n              case \"searchengine\":\n                if (selectedOneOff && selectedOneOff.engine) {\n                  // Replace the engine with the selected one-off engine.\n                  action.params.engineName = selectedOneOff.engine.name;\n                }\n                // If the selected result is an @alias offer -- an @alias with\n                // an empty query string -- then instead of loading the engine's\n                // empty search results page, put the @alias in the input so\n                // that the user can type a search query and search directly\n                // from the urlbar.\n                if (action.params.alias &&\n                    action.params.alias.startsWith(\"@\") &&\n                    !action.params.searchQuery) {\n                  this.search(action.params.input);\n                  return;\n                }\n                const actionDetails = {\n                  isSuggestion: !!action.params.searchSuggestion,\n                  alias: action.params.alias,\n                };\n                [url, postData] = this._parseAndRecordSearchEngineLoad(\n                  action.params.engineName,\n                  action.params.searchSuggestion || action.params.searchQuery,\n                  event,\n                  actionDetails\n                );\n                break;\n              case \"extension\":\n                this.handleRevert();\n                // Give the extension control of handling the command.\n                let searchString = action.params.content;\n                let keyword = action.params.keyword;\n                this.ExtensionSearchHandler.handleInputEntered(keyword, searchString, where);\n                return;\n            }\n          } else {\n            // This is a fallback for add-ons and old testing code that directly\n            // set value and try to confirm it. UnifiedComplete should always\n            // resolve to a valid url.\n            try {\n              url = url.trim();\n              new URL(url);\n            } catch (ex) {\n              let lastLocationChange = browser.lastLocationChange;\n              UrlbarUtils.getShortcutOrURIAndPostData(url).then(data => {\n                if (where != \"current\" ||\n                    browser.lastLocationChange == lastLocationChange) {\n                  this._loadURL(data.url, browser, data.postData, where,\n                                openUILinkParams, data.mayInheritPrincipal,\n                                triggeringPrincipal);\n                }\n              });\n              return;\n            }\n          }\n\n          this._loadURL(url, browser, postData, where, openUILinkParams,\n                        mayInheritPrincipal, triggeringPrincipal);\n        ]]></body>\n      </method>\n\n      <property name=\"oneOffSearchQuery\">\n        <getter><![CDATA[\n          // If the user has selected a search suggestion, chances are they\n          // want to use the one off search engine to search for that suggestion,\n          // not the string that they manually entered into the location bar.\n          let action = this._parseActionUrl(this.value);\n          if (action && action.type == \"searchengine\") {\n            return action.params.input;\n          }\n          // this.textValue may be an autofilled string.  Search only with the\n          // portion that the user typed, if any, by preferring the autocomplete\n          // controller's searchString (including handleEnterInstance.searchString).\n          return this.handleEnterSearchString ||\n                 this.mController.searchString ||\n                 this.textValue;\n        ]]></getter>\n      </property>\n\n      <method name=\"_loadURL\">\n        <parameter name=\"url\"/>\n        <parameter name=\"browser\"/>\n        <parameter name=\"postData\"/>\n        <parameter name=\"openUILinkWhere\"/>\n        <parameter name=\"openUILinkParams\"/>\n        <parameter name=\"mayInheritPrincipal\"/>\n        <parameter name=\"triggeringPrincipal\"/>\n        <body><![CDATA[\n          this.value = url;\n          browser.userTypedValue = url;\n          if (gInitialPages.includes(url)) {\n            browser.initialPageLoadedFromURLBar = url;\n          }\n          try {\n            UrlbarUtils.addToUrlbarHistory(url, window);\n          } catch (ex) {\n            // Things may go wrong when adding url to session history,\n            // but don't let that interfere with the loading of the url.\n            Cu.reportError(ex);\n          }\n\n          let params = {\n            postData,\n            allowThirdPartyFixup: true,\n            triggeringPrincipal,\n          };\n          if (openUILinkWhere == \"current\") {\n            params.targetBrowser = browser;\n            params.indicateErrorPageLoad = true;\n            params.allowPinnedTabHostChange = true;\n            params.allowPopups = url.startsWith(\"javascript:\");\n          } else {\n            params.initiatingDoc = document;\n          }\n          params.allowInheritPrincipal = mayInheritPrincipal;\n\n          if (openUILinkParams) {\n            for (let key in openUILinkParams) {\n              params[key] = openUILinkParams[key];\n            }\n          }\n\n          // Focus the content area before triggering loads, since if the load\n          // occurs in a new tab, we want focus to be restored to the content\n          // area when the current tab is re-selected.\n          browser.focus();\n\n          if (openUILinkWhere != \"current\") {\n            this.handleRevert();\n          }\n\n          try {\n            openTrustedLinkIn(url, openUILinkWhere, params);\n          } catch (ex) {\n            // This load can throw an exception in certain cases, which means\n            // we'll want to replace the URL with the loaded URL:\n            if (ex.result != Cr.NS_ERROR_LOAD_SHOWED_ERRORPAGE) {\n              this.handleRevert();\n            }\n          }\n\n          // Ensure the start of the URL is visible for usability reasons.\n          this.selectionStart = this.selectionEnd = 0;\n        ]]></body>\n      </method>\n\n      <method name=\"_parseAndRecordSearchEngineLoad\">\n        <parameter name=\"engineOrEngineName\"/>\n        <parameter name=\"query\"/>\n        <parameter name=\"event\"/>\n        <parameter name=\"searchActionDetails\"/>\n        <body><![CDATA[\n          let engine =\n            typeof(engineOrEngineName) == \"string\" ?\n              Services.search.getEngineByName(engineOrEngineName) :\n              engineOrEngineName;\n          let isOneOff = this.popup.oneOffSearchButtons\n              .maybeRecordTelemetry(event);\n          // Infer the type of the event which triggered the search.\n          let eventType = \"unknown\";\n          if (event instanceof KeyboardEvent) {\n            eventType = \"key\";\n          } else if (event instanceof MouseEvent) {\n            eventType = \"mouse\";\n          }\n          // Augment the search action details object.\n          let details = searchActionDetails || {};\n          details.isOneOff = isOneOff;\n          details.type = eventType;\n\n          BrowserSearch.recordSearchInTelemetry(engine, \"urlbar\", details);\n          let submission = engine.getSubmission(query, null, \"keyword\");\n          return [submission.uri.spec, submission.postData];\n        ]]></body>\n      </method>\n\n      <method name=\"maybeCanonizeURL\">\n        <parameter name=\"aTriggeringEvent\"/>\n        <parameter name=\"aUrl\"/>\n        <body><![CDATA[\n          // Only add the suffix when the URL bar value isn't already \"URL-like\",\n          // and only if we get a keyboard event, to match user expectations.\n          if (!/^\\s*[^.:\\/\\s]+(?:\\/.*|\\s*)$/i.test(aUrl) ||\n              !this._ctrlCanonizesURLs ||\n              !(aTriggeringEvent instanceof KeyboardEvent) ||\n              !aTriggeringEvent.ctrlKey) {\n            return;\n          }\n\n          let suffix = Services.prefs.getCharPref(\"browser.fixup.alternate.suffix\", \".com/\");\n          if (!suffix.endsWith(\"/\")) {\n            suffix += \"/\";\n          }\n\n          // trim leading/trailing spaces (bug 233205)\n          let url = aUrl.trim();\n\n          // Tack www. and suffix on.  If user has appended directories, insert\n          // suffix before them (bug 279035).  Be careful not to get two slashes.\n          let firstSlash = url.indexOf(\"/\");\n          if (firstSlash >= 0) {\n            url = url.substring(0, firstSlash) + suffix +\n                  url.substring(firstSlash + 1);\n          } else {\n            url = url + suffix;\n          }\n\n          this.popup.overrideValue = \"http://www.\" + url;\n        ]]></body>\n      </method>\n\n      <method name=\"_updateUrlTooltip\">\n        <body><![CDATA[\n          if (this.focused || !this._inOverflow) {\n            this.inputField.removeAttribute(\"title\");\n          } else {\n            this.inputField.setAttribute(\"title\", this.value);\n          }\n        ]]></body>\n      </method>\n\n      <!-- Returns:\n           null if there's a security issue and we should do nothing.\n           a URL object if there is one that we're OK with loading,\n           a text value otherwise.\n           -->\n      <method name=\"_getDroppableItem\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let links;\n          try {\n            links = browserDragAndDrop.dropLinks(aEvent);\n          } catch (ex) {\n            // this is possibly a security exception, in which case we should return\n            // null. Always return null because we can't *know* what exception is\n            // being returned.\n            return null;\n          }\n          // The URL bar automatically handles inputs with newline characters,\n          // so we can get away with treating text/x-moz-url flavours as text/plain.\n          if (links.length > 0 && links[0].url) {\n            let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(aEvent);\n            aEvent.preventDefault();\n            let url = links[0].url;\n            let strippedURL = stripUnsafeProtocolOnPaste(url);\n            if (strippedURL != url) {\n              aEvent.stopImmediatePropagation();\n              return null;\n            }\n            let urlObj;\n            try {\n              // If this throws, urlSecurityCheck would also throw, as that's what it\n              // does with things that don't pass the IO service's newURI constructor\n              // without fixup. It's conceivable we may want to relax this check in\n              // the future (so e.g. www.foo.com gets fixed up), but not right now.\n              urlObj = new URL(url);\n              // If we succeed, try to pass security checks. If this works, return the\n              // URL object. If the *security checks* fail, return null.\n              try {\n                urlSecurityCheck(url,\n                                 triggeringPrincipal,\n                                 Ci.nsIScriptSecurityManager.DISALLOW_INHERIT_PRINCIPAL);\n                return urlObj;\n              } catch (ex) {\n                return null;\n              }\n            } catch (ex) {\n              // We couldn't make a URL out of this. Continue on, and return text below.\n            }\n          }\n          return aEvent.dataTransfer.getData(\"text/unicode\");\n        ]]></body>\n      </method>\n\n      <method name=\"onDragOver\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this._getDroppableItem(aEvent)) {\n            aEvent.dataTransfer.dropEffect = \"none\";\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onDrop\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let droppedItem = this._getDroppableItem(aEvent);\n          if (droppedItem) {\n            let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(aEvent);\n            this.value = droppedItem instanceof URL ? droppedItem.href : droppedItem;\n            SetPageProxyState(\"invalid\");\n            this.focus();\n            this.handleCommand(null, undefined, undefined, triggeringPrincipal);\n            // Force not showing the dropped URI immediately.\n            gBrowser.userTypedValue = null;\n            URLBarSetURI(null, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"makeURIReadable\">\n        <parameter name=\"aURI\"/>\n        <body>\n          <![CDATA[\n            // Avoid copying 'about:reader?url=', and always provide the original URI:\n            // Reader mode ensures we call createExposableURI itself.\n            let readerStrippedURI = ReaderMode.getOriginalUrlObjectForDisplay(aURI.displaySpec);\n            if (readerStrippedURI) {\n              aURI = readerStrippedURI;\n            } else {\n              // Only copy exposable URIs\n              try {\n                aURI = Services.uriFixup.createExposableURI(aURI);\n              } catch (ex) {}\n            }\n            return aURI;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_getSelectedValueForClipboard\">\n        <body><![CDATA[\n          // Grab the actual input field's value, not our value, which could\n          // include \"moz-action:\".\n          var inputVal = this.inputField.value;\n          let selection = this.editor.selection;\n          const flags = Ci.nsIDocumentEncoder.OutputPreformatted |\n                        Ci.nsIDocumentEncoder.OutputRaw;\n          let selectedVal = selection.toStringWithFormat(\"text/plain\", flags, 0);\n\n          // Handle multiple-range selection as a string for simplicity.\n          if (selection.rangeCount > 1) {\n             return selectedVal;\n          }\n\n          // If the selection doesn't start at the beginning or doesn't span the\n          // full domain or the URL bar is modified or there is no text at all,\n          // nothing else to do here.\n          if (this.selectionStart > 0 || this.valueIsTyped || selectedVal == \"\")\n            return selectedVal;\n          // The selection doesn't span the full domain if it doesn't contain a slash and is\n          // followed by some character other than a slash.\n          if (!selectedVal.includes(\"/\")) {\n            let remainder = inputVal.replace(selectedVal, \"\");\n            if (remainder != \"\" && remainder[0] != \"/\")\n              return selectedVal;\n          }\n\n          // If the value was filled by a search suggestion, just return it.\n          let action = this._parseActionUrl(this.value);\n          if (action && action.type == \"searchengine\")\n            return selectedVal;\n\n          let uriFixup = Cc[\"@mozilla.org/docshell/urifixup;1\"].getService(Ci.nsIURIFixup);\n\n          let uri;\n          if (this.getAttribute(\"pageproxystate\") == \"valid\") {\n            uri = gBrowser.currentURI;\n          } else {\n            // We're dealing with an autocompleted value, create a new URI from that.\n            try {\n              uri = uriFixup.createFixupURI(inputVal, Ci.nsIURIFixup.FIXUP_FLAG_NONE);\n            } catch (e) {}\n            if (!uri)\n              return selectedVal;\n          }\n\n          uri = this.makeURIReadable(uri);\n\n          // If the entire URL is selected, just use the actual loaded URI,\n          // unless we want a decoded URI, or it's a data: or javascript: URI,\n          // since those are hard to read when encoded.\n          if (inputVal == selectedVal &&\n              !uri.schemeIs(\"javascript\") && !uri.schemeIs(\"data\") &&\n              !Services.prefs.getBoolPref(\"browser.urlbar.decodeURLsOnCopy\")) {\n            return uri.displaySpec;\n          }\n\n          // Just the beginning of the URL is selected, or we want a decoded\n          // url. First check for a trimmed value.\n          let spec = uri.displaySpec;\n          let trimmedSpec = this.trimValue(spec);\n          if (spec != trimmedSpec) {\n            // Prepend the portion that trimValue removed from the beginning.\n            // This assumes trimValue will only truncate the URL at\n            // the beginning or end (or both).\n            let trimmedSegments = spec.split(trimmedSpec);\n            selectedVal = trimmedSegments[0] + selectedVal;\n          }\n\n          return selectedVal;\n        ]]></body>\n      </method>\n\n      <field name=\"_copyCutController\"><![CDATA[\n        ({\n          urlbar: this,\n          doCommand(aCommand) {\n            var urlbar = this.urlbar;\n            var val = urlbar._getSelectedValueForClipboard();\n            if (!val)\n              return;\n\n            if (aCommand == \"cmd_cut\" && this.isCommandEnabled(aCommand)) {\n              let start = urlbar.selectionStart;\n              let end = urlbar.selectionEnd;\n              urlbar.inputField.value = urlbar.inputField.value.substring(0, start) +\n                                        urlbar.inputField.value.substring(end);\n              urlbar.selectionStart = urlbar.selectionEnd = start;\n\n              let event = document.createEvent(\"UIEvents\");\n              event.initUIEvent(\"input\", true, false, window, 0);\n              urlbar.inputField.dispatchEvent(event);\n            }\n\n            Cc[\"@mozilla.org/widget/clipboardhelper;1\"]\n              .getService(Ci.nsIClipboardHelper)\n              .copyString(val);\n          },\n          supportsCommand(aCommand) {\n            switch (aCommand) {\n              case \"cmd_copy\":\n              case \"cmd_cut\":\n                return true;\n            }\n            return false;\n          },\n          isCommandEnabled(aCommand) {\n            return this.supportsCommand(aCommand) &&\n                   (aCommand != \"cmd_cut\" || !this.urlbar.readOnly) &&\n                   this.urlbar.selectionStart < this.urlbar.selectionEnd;\n          },\n          onEvent(aEventName) {},\n        })\n      ]]></field>\n\n      <method name=\"observe\">\n        <parameter name=\"aSubject\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aData\"/>\n        <body><![CDATA[\n          if (aTopic == \"nsPref:changed\") {\n            switch (aData) {\n              case \"clickSelectsAll\":\n              case \"doubleClickSelectsAll\":\n                this[aData] = this._prefs.getBoolPref(aData);\n                break;\n              case \"autoFill\":\n                this.completeDefaultIndex = this._prefs.getBoolPref(aData);\n                break;\n              case \"delay\":\n                this.timeout = this._prefs.getIntPref(aData);\n                break;\n              case \"ctrlCanonizesURLs\":\n                this._ctrlCanonizesURLs = this._prefs.getBoolPref(aData);\n                break;\n              case \"speculativeConnect.enabled\":\n                this.speculativeConnectEnabled = this._prefs.getBoolPref(aData);\n                break;\n              case \"openintab\":\n                this.openInTab = this._prefs.getBoolPref(aData);\n                break;\n              case \"browser.search.suggest.enabled\":\n                this.browserSearchSuggestEnabled = Services.prefs.getBoolPref(aData);\n                break;\n              case \"suggest.searches\":\n                this.urlbarSearchSuggestEnabled = this._prefs.getBoolPref(aData);\n              case \"userMadeSearchSuggestionsChoice\":\n                // Mirror the value for future use, see the comment in the\n                // binding's constructor.\n                this._prefs.setBoolPref(\"searchSuggestionsChoice\",\n                  this.urlbarSearchSuggestEnabled);\n                // Clear the cached value to allow changing conditions in tests.\n                delete this._whichSearchSuggestionsNotification;\n                break;\n              case \"trimURLs\":\n                this._mayTrimURLs = this._prefs.getBoolPref(aData);\n                break;\n              case \"oneOffSearches\":\n                this._enableOrDisableOneOffSearches();\n                break;\n              case \"maxRichResults\":\n                this.popup.maxResults = this._prefs.getIntPref(aData);\n                break;\n              case \"switchTabs.adoptIntoActiveWindow\":\n                this._adoptIntoActiveWindow =\n                  this._prefs.getBoolPref(\"switchTabs.adoptIntoActiveWindow\");\n                break;\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_enableOrDisableOneOffSearches\">\n        <body><![CDATA[\n          this.popup.toggleOneOffSearches(\n            this._prefs.getBoolPref(\"oneOffSearches\"),\n            \"pref\"\n          );\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.type) {\n            case \"paste\":\n              let originalPasteData = aEvent.clipboardData.getData(\"text/plain\");\n              if (!originalPasteData) {\n                return;\n              }\n\n              let oldValue = this.inputField.value;\n              let oldStart = oldValue.substring(0, this.inputField.selectionStart);\n              // If there is already non-whitespace content in the URL bar\n              // preceding the pasted content, it's not necessary to check\n              // protocols used by the pasted content:\n              if (oldStart.trim()) {\n                return;\n              }\n              let oldEnd = oldValue.substring(this.inputField.selectionEnd);\n\n              let pasteData = stripUnsafeProtocolOnPaste(originalPasteData);\n              if (originalPasteData != pasteData) {\n                // Unfortunately we're not allowed to set the bits being pasted\n                // so cancel this event:\n                aEvent.preventDefault();\n                aEvent.stopImmediatePropagation();\n\n                this.inputField.value = oldStart + pasteData + oldEnd;\n                // Fix up cursor/selection:\n                let newCursorPos = oldStart.length + pasteData.length;\n                this.inputField.selectionStart = newCursorPos;\n                this.inputField.selectionEnd = newCursorPos;\n              }\n              break;\n            case \"mousedown\":\n              if (this.doubleClickSelectsAll &&\n                  aEvent.button == 0 && aEvent.detail == 2) {\n                this.editor.selectAll();\n                aEvent.preventDefault();\n              }\n              break;\n            case \"mouseover\":\n              this._updateUrlTooltip();\n              break;\n            case \"overflow\": {\n              const targetIsPlaceholder =\n                !aEvent.originalTarget.classList.contains(\"anonymous-div\");\n              // We only care about the non-placeholder text.\n              // This shouldn't be needed, see bug 1487036.\n              if (targetIsPlaceholder) {\n                break;\n              }\n              this._inOverflow = true;\n              this.updateTextOverflow();\n              break;\n            }\n            case \"underflow\": {\n              const targetIsPlaceholder =\n                !aEvent.originalTarget.classList.contains(\"anonymous-div\");\n              // We only care about the non-placeholder text.\n              // This shouldn't be needed, see bug 1487036.\n              if (targetIsPlaceholder) {\n                break;\n              }\n              this._inOverflow = false;\n              this.updateTextOverflow();\n              this._updateUrlTooltip();\n              break;\n            }\n            case \"scrollend\":\n              this.updateTextOverflow();\n              break;\n            case \"TabSelect\":\n              // The autocomplete controller uses heuristic on some internal caches\n              // to handle cases like backspace, autofill or repeated searches.\n              // Ensure to clear those internal caches when switching tabs.\n              this.controller.resetInternalState();\n              break;\n            case \"resize\":\n              if (aEvent.target == window) {\n                // Close the popup since it would be wrongly sized, we'll\n                // recalculate a proper size on reopening. For example, this may\n                // happen when using special OS resize functions like Win+Arrow.\n                this.closePopup();\n\n                // Make sure the host remains visible in the input field\n                // when the window is resized.  We don't want to\n                // hurt resize performance though, so do this only after resize\n                // events have stopped and a small timeout has elapsed.\n                if (this._resizeThrottleTimeout) {\n                  clearTimeout(this._resizeThrottleTimeout);\n                }\n                this._resizeThrottleTimeout = setTimeout(() => {\n                  this._resizeThrottleTimeout = null;\n                  this.valueFormatter.ensureFormattedHostVisible();\n                }, 100);\n              }\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"updateTextOverflow\">\n        <body><![CDATA[\n          if (this._inOverflow) {\n            window.promiseDocumentFlushed(() => {\n              // Check overflow again to ensure it didn't change in the meanwhile.\n              let input = this.inputField;\n              if (input && this._inOverflow) {\n                let side = input.scrollLeft &&\n                           input.scrollLeft == input.scrollLeftMax ? \"start\" : \"end\";\n                window.requestAnimationFrame(() => {\n                  // And check once again, since we might have stopped overflowing\n                  // since the promiseDocumentFlushed callback fired.\n                  if (this._inOverflow) {\n                    this.setAttribute(\"textoverflow\", side);\n                  }\n                });\n              }\n            });\n          } else {\n            this.removeAttribute(\"textoverflow\");\n          }\n        ]]></body>\n      </method>\n\n      <!--\n        onBeforeTextValueGet is called by the base-binding's .textValue getter.\n        It should return the value that the getter should use.\n      -->\n      <method name=\"onBeforeTextValueGet\">\n        <body><![CDATA[\n          return { value: this.inputField.value };\n        ]]></body>\n      </method>\n\n      <!--\n        onBeforeTextValueSet is called by the base-binding's .textValue setter.\n        It should return the value that the setter should use.\n      -->\n      <method name=\"onBeforeTextValueSet\">\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          let val = aValue;\n          let uri;\n          try {\n            uri = makeURI(val);\n          } catch (ex) {}\n\n          if (uri) {\n            // Do not touch moz-action URIs at all.  They depend on being\n            // properly encoded and decoded and will break if decoded\n            // unexpectedly.\n            if (!this._parseActionUrl(val)) {\n              val = losslessDecodeURI(uri);\n            }\n          }\n\n          return val;\n        ]]></body>\n      </method>\n\n      <method name=\"_parseActionUrl\">\n        <parameter name=\"aUrl\"/>\n        <body><![CDATA[\n          const MOZ_ACTION_REGEX = /^moz-action:([^,]+),(.*)$/;\n          if (!MOZ_ACTION_REGEX.test(aUrl))\n            return null;\n\n          // URL is in the format moz-action:ACTION,PARAMS\n          // Where PARAMS is a JSON encoded object.\n          let [, type, params] = aUrl.match(MOZ_ACTION_REGEX);\n\n          let action = {\n            type,\n          };\n\n          action.params = JSON.parse(params);\n          for (let key in action.params) {\n            action.params[key] = decodeURIComponent(action.params[key]);\n          }\n\n          if (\"url\" in action.params) {\n            let uri;\n            try {\n              uri = makeURI(action.params.url);\n              action.params.displayUrl = losslessDecodeURI(uri);\n            } catch (e) {\n              action.params.displayUrl = action.params.url;\n            }\n          }\n\n          return action;\n        ]]></body>\n      </method>\n\n      <property name=\"_noActionKeys\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.__noActionKeys) {\n            this.__noActionKeys = new Set([\n              KeyEvent.DOM_VK_ALT,\n              KeyEvent.DOM_VK_SHIFT,\n            ]);\n            let modifier = AppConstants.platform == \"macosx\" ?\n                           KeyEvent.DOM_VK_META :\n                           KeyEvent.DOM_VK_CONTROL;\n            this.__noActionKeys.add(modifier);\n          }\n          return this.__noActionKeys;\n        ]]></getter>\n      </property>\n\n      <field name=\"_pressedNoActionKeys\"><![CDATA[\n        new Set()\n      ]]></field>\n\n      <method name=\"_clearNoActions\">\n        <parameter name=\"aURL\"/>\n        <body><![CDATA[\n          this._pressedNoActionKeys.clear();\n          this.popup.removeAttribute(\"noactions\");\n          let action = this._parseActionUrl(this._value);\n          if (action)\n            this.setAttribute(\"actiontype\", action.type);\n        ]]></body>\n      </method>\n\n      <method name=\"onInput\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this.mIgnoreInput && this.mController.input == this) {\n            this._value = this.inputField.value;\n            gBrowser.userTypedValue = this.value;\n            this.valueIsTyped = true;\n            if (this.inputField.value) {\n              this.setAttribute(\"usertyping\", \"true\");\n            } else {\n              this.removeAttribute(\"usertyping\");\n            }\n            // If the popup already had accessibility focus, bring it back to\n            // the input, since the user is editing.\n            if (!this.popup.richlistbox.suppressMenuItemEvent &&\n                this.popup.richlistbox.currentItem) {\n              this.popup.richlistbox._fireEvent(\n                this.popup.richlistbox.currentItem, \"DOMMenuItemInactive\");\n            }\n            // The user is typing, so don't give accessibility focus to the\n            // popup, even if an item gets automatically selected.\n            this.popup.richlistbox.suppressMenuItemEvent = true;\n            // Only wait for a result when we are sure to get one.  In some\n            // cases, like when pasting the same exact text, we may not fire\n            // a new search and we won't get a result.\n            this._onInputHandledText = this.mController.handleText();\n            if (this._onInputHandledText) {\n              this.gotResultForCurrentQuery = false;\n              this._searchStartDate = Cu.now();\n              this._deferredKeyEventQueue = [];\n              if (this._deferredKeyEventTimeout) {\n                clearTimeout(this._deferredKeyEventTimeout);\n                this._deferredKeyEventTimeout = null;\n              }\n            }\n          }\n          this.resetActionType();\n        ]]></body>\n      </method>\n\n      <method name=\"handleEnter\">\n        <parameter name=\"event\"/>\n        <parameter name=\"options\"/>\n        <body><![CDATA[\n          // We need to ensure we're using a selected autocomplete result.\n          // A result should automatically be selected by default,\n          // however autocomplete is async and therefore we may not\n          // have a result set relating to the current input yet. If that\n          // happens, we need to mark that when the first result does get added,\n          // it needs to be handled as if enter was pressed with that first\n          // result selected.\n          // If anything other than the default (first) result is selected, then\n          // it must have been manually selected by the human. We let this\n          // explicit choice be used, even if it may be related to a previous\n          // input.\n          // However, if the default result is automatically selected, we\n          // ensure that it corresponds to the current input.\n\n          // Store the current search string so it can be used in handleCommand,\n          // which will be called as a result of mController.handleEnter().\n          this.handleEnterSearchString = this.mController.searchString;\n\n          let noDefer = options && options.noDefer;\n          if (!noDefer && this._shouldDeferKeyEvent(event)) {\n            // Defer the event until the first non-heuristic result comes in.\n            this._deferKeyEvent(event, \"handleEnter\");\n            return false;\n          }\n\n          let canonizeValue = this.value;\n          if (event.ctrlKey) {\n            let action = this._parseActionUrl(canonizeValue);\n            if (action && \"searchSuggestion\" in action.params) {\n              canonizeValue = action.params.searchSuggestion;\n            } else if (this.popup.selectedIndex === 0 &&\n                       this.mController.getStyleAt(0).includes(\"autofill\")) {\n              canonizeValue = this.handleEnterSearchString;\n            }\n          }\n          this.maybeCanonizeURL(event, canonizeValue);\n          let handled = this.mController.handleEnter(false, event);\n          this.handleEnterSearchString = null;\n          this.popup.overrideValue = null;\n          return handled;\n        ]]></body>\n      </method>\n\n      <method name=\"handleDelete\">\n        <body><![CDATA[\n          // If the heuristic result is selected, then the autocomplete\n          // controller's handleDelete implementation will remove it, which is\n          // not what we want.  So in that case, call handleText so it acts as\n          // a backspace on the text value instead of removing the result.\n          if (this.popup.selectedIndex == 0 &&\n              this.popup._isFirstResultHeuristic) {\n            this.mController.handleText();\n            return false;\n          }\n          return this.mController.handleDelete();\n        ]]></body>\n      </method>\n\n      <property name=\"_userMadeSearchSuggestionsChoice\" readonly=\"true\">\n        <getter><![CDATA[\n          return this._prefs.getBoolPref(\"userMadeSearchSuggestionsChoice\") ||\n                 this._defaultPrefs.getBoolPref(\"suggest.searches\") != this._prefs.getBoolPref(\"suggest.searches\");\n        ]]></getter>\n      </property>\n\n      <property name=\"whichSearchSuggestionsNotification\" readonly=\"true\">\n        <getter><![CDATA[\n          // Once we return \"none\" once, we'll always return \"none\".\n          // If available, use the cached value, rather than running all of the\n          // checks again at every locationbar focus.\n          if (this._whichSearchSuggestionsNotification) {\n            return this._whichSearchSuggestionsNotification;\n          }\n\n          if (this.browserSearchSuggestEnabled && !this.inPrivateContext &&\n              // In any case, if the user made a choice we should not nag him.\n              !this._userMadeSearchSuggestionsChoice) {\n            if (this._defaultPrefs.getBoolPref(\"suggest.searches\") &&\n                this.urlbarSearchSuggestEnabled && // Has not been switched off.\n                this._prefs.getIntPref(\"timesBeforeHidingSuggestionsHint\")) {\n              return \"opt-out\";\n            }\n          }\n          return this._whichSearchSuggestionsNotification = \"none\";\n        ]]></getter>\n      </property>\n\n      <method name=\"updateSearchSuggestionsNotificationImpressions\">\n        <parameter name=\"whichNotification\"/>\n        <body><![CDATA[\n          if (whichNotification == \"none\") {\n            throw new Error(\"Unexpected notification type\");\n          }\n\n          let remaining = this._prefs.getIntPref(\"timesBeforeHidingSuggestionsHint\");\n          if (remaining > 0) {\n            this._prefs.setIntPref(\"timesBeforeHidingSuggestionsHint\", remaining - 1);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"maybeShowSearchSuggestionsNotificationOnFocus\">\n        <parameter name=\"mouseFocused\"/>\n        <body><![CDATA[\n          let whichNotification = this.whichSearchSuggestionsNotification;\n          if (this._showSearchSuggestionNotificationOnMouseFocus &&\n              mouseFocused) {\n            // Force showing the opt-out notification.\n            this._whichSearchSuggestionsNotification = whichNotification = \"opt-out\";\n          }\n          if (whichNotification == \"opt-out\") {\n            try {\n              this.popup.openAutocompletePopup(this, this);\n            } finally {\n              if (mouseFocused) {\n                delete this._whichSearchSuggestionsNotification;\n                this._showSearchSuggestionNotificationOnMouseFocus = false;\n              }\n            }\n          }\n        ]]></body>\n      </method>\n\n      <!--\n        Sets the input's value, starts a search, and opens the popup.\n\n        @param  value\n                The input's value will be set to this value, and the search will\n                use it as its query.\n      -->\n      <method name=\"search\">\n        <parameter name=\"value\"/>\n        <body><![CDATA[\n          // Hide the suggestions notification if the search uses an \"@engine\"\n          // search engine alias.\n          if (value.trim()[0] == \"@\") {\n            let which = this.whichSearchSuggestionsNotification;\n            this._whichSearchSuggestionsNotification = \"none\";\n            this.popup.addEventListener(\"popuphidden\", () => {\n              this._whichSearchSuggestionsNotification = which;\n            }, {once: true});\n          }\n\n          // We want the value to be treated as text that the user typed.  It\n          // should go through the controller.handleText() path in onInput() so\n          // that gBrowser.userTypedValue, this.valueIsTyped, etc. are set and\n          // nsAutoCompleteController::HandleText() is called.  Set this.value\n          // and fire an input event to do that.  (If we set this.textValue we'd\n          // get an input event for free, but it would also set mIgnoreInput,\n          // skipping all of the above requirements.)\n          this.focus();\n          this.value = value;\n\n          // Avoid selecting the text if this method is called twice in a row.\n          this.selectionStart = -1;\n\n          let event = document.createEvent(\"Events\");\n          event.initEvent(\"input\", true, true);\n          this.inputField.dispatchEvent(event);\n\n          // handleText() ignores the value if it's the same as the previous\n          // value, but we want consecutive searches with the same value to be\n          // possible.  If handleText() returned false, then manually start a\n          // new search here.\n          if (!this._onInputHandledText) {\n            this.gotResultForCurrentQuery = false;\n            this.controller.startSearch(value);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"typeRestrictToken\">\n        <parameter name=\"char\"/>\n        <body><![CDATA[\n          this.inputField.value = char + \" \";\n\n          let event = this.document.createEvent(\"UIEvents\");\n          event.initUIEvent(\"input\", true, false, window, 0);\n          this.inputField.dispatchEvent(event);\n        ]]></body>\n      </method>\n\n      <method name=\"removeHiddenFocus\">\n        <body><![CDATA[\n          this.classList.remove(\"hidden-focus\");\n        ]]></body>\n      </method>\n\n      <method name=\"hiddenFocus\">\n        <body><![CDATA[\n          this.classList.add(\"hidden-focus\");\n          this.focus();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"keydown\"><![CDATA[\n        if (this._noActionKeys.has(event.keyCode) &&\n            this.popup.selectedIndex >= 0 &&\n            !this._pressedNoActionKeys.has(event.keyCode)) {\n          if (this._pressedNoActionKeys.size == 0) {\n            this.popup.setAttribute(\"noactions\", \"true\");\n            this.removeAttribute(\"actiontype\");\n          }\n          this._pressedNoActionKeys.add(event.keyCode);\n        }\n      ]]></handler>\n\n      <handler event=\"keyup\"><![CDATA[\n        if (this._noActionKeys.has(event.keyCode) &&\n            this._pressedNoActionKeys.has(event.keyCode)) {\n          this._pressedNoActionKeys.delete(event.keyCode);\n          if (this._pressedNoActionKeys.size == 0)\n            this._clearNoActions();\n        }\n      ]]></handler>\n\n      <handler event=\"mousedown\"><![CDATA[\n        if (event.button == 0) {\n          if (event.originalTarget.getAttribute(\"anonid\") == \"historydropmarker\") {\n            this.toggleHistoryPopup();\n          }\n\n          // Eventually show the opt-out notification even if the location bar is\n          // empty, focused, and the user clicks on it.\n          if (this.focused && this.textValue == \"\") {\n            this.maybeShowSearchSuggestionsNotificationOnFocus(true);\n          }\n        }\n      ]]></handler>\n\n      <handler event=\"focus\"><![CDATA[\n        if (event.originalTarget == this.inputField) {\n          this._updateUrlTooltip();\n          this.formatValue();\n          if (this.getAttribute(\"pageproxystate\") != \"valid\") {\n            UpdatePopupNotificationsVisibility();\n          }\n\n          // We show the opt-out notification when the mouse/keyboard focus the\n          // urlbar, but in any case we want to enforce at least one\n          // notification when the user focuses it with the mouse.\n          let whichNotification = this.whichSearchSuggestionsNotification;\n          if (whichNotification == \"opt-out\" &&\n              this._showSearchSuggestionNotificationOnMouseFocus === undefined) {\n            this._showSearchSuggestionNotificationOnMouseFocus = true;\n          }\n\n          // Check whether the focus change came from a keyboard/mouse action.\n          let focusMethod = Services.focus.getLastFocusMethod(window);\n          // If it's a focus started by code and the primary user intention was\n          // not to go to the location bar, don't show a notification.\n          if (!focusMethod && !this.userInitiatedFocus) {\n            return;\n          }\n\n          let mouseFocused = !!(focusMethod & Services.focus.FLAG_BYMOUSE);\n          this.maybeShowSearchSuggestionsNotificationOnFocus(mouseFocused);\n        }\n      ]]></handler>\n\n      <handler event=\"blur\"><![CDATA[\n        if (event.originalTarget == this.inputField) {\n          this._clearNoActions();\n          this.formatValue();\n          if (this.getAttribute(\"pageproxystate\") != \"valid\") {\n            UpdatePopupNotificationsVisibility();\n          }\n        }\n        if (this.ExtensionSearchHandler.hasActiveInputSession()) {\n          this.ExtensionSearchHandler.handleInputCancelled();\n        }\n        if (this._deferredKeyEventTimeout) {\n          clearTimeout(this._deferredKeyEventTimeout);\n          this._deferredKeyEventTimeout = null;\n        }\n        this._deferredKeyEventQueue = [];\n      ]]></handler>\n\n      <handler event=\"dragstart\" phase=\"capturing\"><![CDATA[\n        // Drag only if the gesture starts from the input field.\n        if (this.inputField != event.originalTarget &&\n            !(this.inputField.compareDocumentPosition(event.originalTarget) &\n              Node.DOCUMENT_POSITION_CONTAINED_BY))\n          return;\n\n        // Drag only if the entire value is selected and it's a valid URI.\n        var isFullSelection = this.selectionStart == 0 &&\n                              this.selectionEnd == this.textLength;\n        if (!isFullSelection ||\n            this.getAttribute(\"pageproxystate\") != \"valid\")\n          return;\n\n        var urlString = gBrowser.selectedBrowser.currentURI.displaySpec;\n        var title = gBrowser.selectedBrowser.contentTitle || urlString;\n        var htmlString = \"<a href=\\\"\" + urlString + \"\\\">\" + urlString + \"</a>\";\n\n        var dt = event.dataTransfer;\n        dt.setData(\"text/x-moz-url\", urlString + \"\\n\" + title);\n        dt.setData(\"text/unicode\", urlString);\n        dt.setData(\"text/html\", htmlString);\n\n        dt.effectAllowed = \"copyLink\";\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\" phase=\"capturing\" action=\"this.onDragOver(event, this);\"/>\n      <handler event=\"drop\" phase=\"capturing\" action=\"this.onDrop(event, this);\"/>\n      <handler event=\"select\"><![CDATA[\n        if (!Cc[\"@mozilla.org/widget/clipboard;1\"]\n               .getService(Ci.nsIClipboard)\n               .supportsSelectionClipboard())\n          return;\n\n        if (!window.windowUtils.isHandlingUserInput)\n          return;\n\n        var val = this._getSelectedValueForClipboard();\n        if (!val)\n          return;\n\n        Cc[\"@mozilla.org/widget/clipboardhelper;1\"]\n          .getService(Ci.nsIClipboardHelper)\n          .copyStringToClipboard(val, Ci.nsIClipboard.kSelectionClipboard);\n      ]]></handler>\n    </handlers>\n\n  </binding>\n\n  <binding id=\"urlbar-rich-result-popup\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup\">\n\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\"\n             aria-owns=\"richlistbox\">\n      <xul:deck anonid=\"search-suggestions-notification\"\n                align=\"center\"\n                role=\"alert\"\n                selectedIndex=\"0\">\n        <!-- OPT-OUT -->\n        <xul:hbox flex=\"1\" align=\"center\" anonid=\"search-suggestions-opt-out\">\n          <xul:image class=\"ac-site-icon\" type=\"searchengine\"/>\n          <xul:hbox anonid=\"search-suggestions-hint-typing\">\n            <xul:description class=\"ac-title-text\">FROM-DTD.brandShortName;</xul:description>\n          </xul:hbox>\n          <xul:hbox anonid=\"search-suggestions-hint-box\" flex=\"1\">\n            <xul:description id=\"search-suggestions-hint\">\n              <html:span class=\"prefix\">&#x1f4a1; FROM-DTD.urlbar.searchSuggestionsNotification.hintPrefix;</html:span>\n              <html:span>FROM-DTD.urlbar.searchSuggestionsNotification.hint;</html:span>\n            </xul:description>\n          </xul:hbox>\n          <xul:label id=\"search-suggestions-change-settings\"\n                     class=\"text-link\"\n                     role=\"link\"\n\n                     value=\"FROM-DTD.urlbar.searchSuggestionsNotification.changeSettingsWin;\"\n                     accesskey=\"FROM-DTD.urlbar.searchSuggestionsNotification.changeSettingsWin.accesskey;\"\n\n                     onclick=\"openPreferences('paneSearch', {origin: 'searchChangeSettings'});\"\n                     control=\"search-suggestions-change-settings\"/>\n        </xul:hbox>\n      </xul:deck>\n      <xul:richlistbox anonid=\"richlistbox\" class=\"autocomplete-richlistbox\"\n                       flex=\"1\"/>\n      <xul:hbox anonid=\"footer\">\n        <children/>\n        <xul:hbox anonid=\"one-off-search-buttons\"\n                  class=\"search-one-offs\"\n                  compact=\"true\"\n                  includecurrentengine=\"true\"\n                  disabletab=\"true\"\n                  flex=\"1\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <!--\n        For performance reasons we want to limit the size of the text runs we\n        build and show to the user.\n      -->\n      <field name=\"textRunsMaxLen\">255</field>\n\n      <field name=\"_maxResults\">0</field>\n\n      <field name=\"_bundle\" readonly=\"true\">\n        Cc[\"@mozilla.org/intl/stringbundle;1\"].\n          getService(Ci.nsIStringBundleService).\n          createBundle(\"chrome://browser/locale/places/places.properties\");\n      </field>\n\n      <field name=\"searchSuggestionsNotification\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(\n          this, \"anonid\", \"search-suggestions-notification\"\n        );\n      </field>\n\n      <field name=\"footer\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"footer\");\n      </field>\n\n      <field name=\"shrinkDelay\" readonly=\"true\">\n        250\n      </field>\n\n      <field name=\"oneOffSearchButtons\" readonly=\"true\">\n        new SearchOneOffs(\n          document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                  \"one-off-search-buttons\"));\n      </field>\n\n      <field name=\"_overrideValue\">null</field>\n      <property name=\"overrideValue\"\n                onget=\"return this._overrideValue;\"\n                onset=\"this._overrideValue = val; return val;\"/>\n\n      <method name=\"onPopupClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.button == 2) {\n            // Ignore right-clicks.\n            return;\n          }\n          // Otherwise \"call super\" -- do what autocomplete-base-popup does.\n          this.input.controller.handleEnter(true, aEvent);\n        ]]></body>\n      </method>\n\n      <field name=\"_oneOffSearchesEnabledByReason\">new Map()</field>\n\n      <method name=\"toggleOneOffSearches\">\n        <parameter name=\"enable\"/>\n        <parameter name=\"reason\"/>\n        <body><![CDATA[\n          this._oneOffSearchesEnabledByReason.set(reason || \"runtime\", enable);\n          this._syncOneOffSearchesEnabled();\n        ]]></body>\n      </method>\n\n      <method name=\"_syncOneOffSearchesEnabled\">\n        <body><![CDATA[\n          // If the popup hasn't ever been opened yet, then don't actually do\n          // anything.  (The popup will still be hidden in that case.)  The\n          // input adds a popupshowing listener that will call this method back\n          // and lazily initialize the one-off buttons the first time the popup\n          // opens.  There are performance tests that fail if we don't do this.\n          if (this.hidden) {\n            return;\n          }\n\n          let enable = Array.from(this._oneOffSearchesEnabledByReason.values())\n                            .every(v => v);\n          if (enable) {\n            this.oneOffSearchButtons.telemetryOrigin = \"urlbar\";\n            this.oneOffSearchButtons.style.display = \"-moz-box\";\n            // Set .textbox first, since the popup setter will cause\n            // a _rebuild call that uses it.\n            this.oneOffSearchButtons.textbox = this.input;\n            this.oneOffSearchButtons.popup = this;\n          } else {\n            this.oneOffSearchButtons.telemetryOrigin = null;\n            this.oneOffSearchButtons.style.display = \"none\";\n            this.oneOffSearchButtons.textbox = null;\n            this.oneOffSearchButtons.popup = null;\n          }\n        ]]></body>\n      </method>\n\n      <property name=\"oneOffSearchesEnabled\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.oneOffSearchButtons.style.display != \"none\";\n        ]]></getter>\n      </property>\n\n      <!-- Override this so that navigating between items results in an item\n           always being selected. -->\n      <method name=\"getNextIndex\">\n        <parameter name=\"reverse\"/>\n        <parameter name=\"amount\"/>\n        <parameter name=\"index\"/>\n        <parameter name=\"maxRow\"/>\n        <body><![CDATA[\n          if (maxRow < 0)\n            return -1;\n\n          let newIndex = index + (reverse ? -1 : 1) * amount;\n\n          // We only want to wrap if navigation is in any direction by one item,\n          // otherwise we clamp to one end of the list.\n          // ie, hitting page-down will only cause is to wrap if we're already\n          // at one end of the list.\n\n          // Allow the selection to be removed if the first result is not a\n          // heuristic result.\n          if (!this._isFirstResultHeuristic) {\n            if (reverse && index == -1 || newIndex > maxRow && index != maxRow)\n              newIndex = maxRow;\n            else if (!reverse && index == -1 || newIndex < 0 && index != 0)\n              newIndex = 0;\n\n            if (newIndex < 0 && index == 0 || newIndex > maxRow && index == maxRow)\n              newIndex = -1;\n\n            return newIndex;\n          }\n\n          // Otherwise do not allow the selection to be removed.\n          if (newIndex < 0) {\n            newIndex = index > 0 ? 0 : maxRow;\n          } else if (newIndex > maxRow) {\n            newIndex = index < maxRow ? maxRow : 0;\n          }\n          return newIndex;\n        ]]></body>\n      </method>\n\n      <property name=\"_isFirstResultHeuristic\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            // The popup usually has a special \"heuristic\" first result (added\n            // by UnifiedComplete.js) that is automatically selected when the\n            // popup opens.\n            return this.input.mController.matchCount > 0 &&\n                   this.input.mController\n                             .getStyleAt(0)\n                             .split(/\\s+/).indexOf(\"heuristic\") > 0;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"maxResults\">\n        <getter>\n          <![CDATA[\n            if (!this._maxResults) {\n              this._maxResults = Services.prefs.getIntPref(\"browser.urlbar.maxRichResults\");\n            }\n            return this._maxResults;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            return this._maxResults = parseInt(val);\n          ]]>\n        </setter>\n      </property>\n\n      <!-- This is set either to undefined or to a new object containing\n           { start, end } margin values in pixels. These are used to align the\n           results to the input field. -->\n      <property name=\"margins\"\n                onget=\"return this._margins;\">\n        <setter>\n          <![CDATA[\n          this._margins = val;\n\n          if (val) {\n            /* eslint-disable no-multi-spaces */\n            let paddingInCSS =\n                3   // .autocomplete-richlistbox padding-left/right\n              + 6   // .ac-site-icon margin-inline-start\n              + 16  // .ac-site-icon width\n              + 6;  // .ac-site-icon margin-inline-end\n            /* eslint-enable no-multi-spaces */\n            let actualVal = Math.round(val.start) - paddingInCSS;\n            let actualValEnd = Math.round(val.end);\n            this.style.setProperty(\"--item-padding-start\", actualVal + \"px\");\n            this.style.setProperty(\"--item-padding-end\", actualValEnd + \"px\");\n          } else {\n            this.style.removeProperty(\"--item-padding-start\");\n            this.style.removeProperty(\"--item-padding-end\");\n          }\n\n          return val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          // initially the panel is hidden\n          // to avoid impacting startup / new window performance\n          aInput.popup.hidden = false;\n\n          this._openAutocompletePopup(aInput, aElement);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body><![CDATA[\n          if (this.mPopupOpen) {\n            return;\n          }\n\n          // Explicitly set the direction of the popup because automplete.xml\n          // expects this.\n          this.style.direction = (RTL_UI ? \"rtl\" : \"ltr\");\n\n          // Make the popup span the width of the window.  First, set its width.\n          let documentRect =\n            window.windowUtils\n                .getBoundsWithoutFlushing(window.document.documentElement);\n          let width = documentRect.right - documentRect.left;\n          this.setAttribute(\"width\", width);\n\n          // Now make its starting margin negative so that its leading edge\n          // aligns with the window border.\n          let elementRect =\n            window.windowUtils.getBoundsWithoutFlushing(aElement);\n          if (RTL_UI) {\n            let offset = elementRect.right - documentRect.right;\n            this.style.marginRight = offset + \"px\";\n          } else {\n            let offset = documentRect.left - elementRect.left;\n            this.style.marginLeft = offset + \"px\";\n          }\n\n          // Keep the popup items' site icons aligned with the urlbar's identity\n          // icon if it's not too far from the edge of the window.  We define\n          // \"too far\" as \"more than 30% of the window's width AND more than\n          // 250px\".  Do this *before* adding any items because when the new\n          // value of the margins are different from the previous value, over-\n          // and underflow must be handled for each item already in the popup.\n          let needsHandleOverUnderflow = false;\n          let boundToCheck = RTL_UI ? \"right\" : \"left\";\n          let inputRect = window.windowUtils.getBoundsWithoutFlushing(aInput);\n          let startOffset = Math.abs(inputRect[boundToCheck] - documentRect[boundToCheck]);\n          let alignSiteIcons = startOffset / width <= 0.3 || startOffset <= 250;\n          if (alignSiteIcons) {\n            // Calculate the end margin if we have a start margin.\n            let boundToCheckEnd = RTL_UI ? \"left\" : \"right\";\n            let endOffset = Math.abs(inputRect[boundToCheckEnd] -\n                                     documentRect[boundToCheckEnd]);\n            if (endOffset > startOffset * 2) {\n              // Provide more space when aligning would result in an unbalanced\n              // margin. This allows the location bar to be moved to the start\n              // of the navigation toolbar to reclaim space for results.\n              endOffset = startOffset;\n            }\n            let identityIcon = document.getElementById(\"identity-icon\");\n            let identityRect =\n              window.windowUtils.getBoundsWithoutFlushing(identityIcon);\n            let start = RTL_UI ?\n                        documentRect.right - identityRect.right :\n                        identityRect.left;\n            if (!this.margins || start != this.margins.start ||\n                                 endOffset != this.margins.end ||\n                                 width != this.margins.width) {\n              this.margins = { start, end: endOffset, width };\n              needsHandleOverUnderflow = true;\n            }\n          } else if (this.margins) {\n            // Reset the alignment so that the site icons are positioned\n            // according to whatever's in the CSS.\n            this.margins = undefined;\n            needsHandleOverUnderflow = true;\n          }\n\n          // Now that the margins have been set, start adding items (via\n          // _invalidate).\n          this.mInput = aInput;\n          this.input.controller.setInitiallySelectedIndex(this._isFirstResultHeuristic ? 0 : -1);\n          this.input.userSelectionBehavior = \"none\";\n          this._invalidate();\n\n          try {\n            let whichNotification = aInput.whichSearchSuggestionsNotification;\n            if (whichNotification != \"none\") {\n              // Update the impressions count on real popupshown, since there's\n              // no guarantee openPopup will be respected by the platform.\n              // Though, we must ensure the handled event is the expected one.\n              let impressionId = this._searchSuggestionsImpressionId = {};\n              this.addEventListener(\"popupshown\", () => {\n                if (this._searchSuggestionsImpressionId == impressionId)\n                  aInput.updateSearchSuggestionsNotificationImpressions(whichNotification);\n              }, {once: true});\n              this._showSearchSuggestionsNotification(whichNotification);\n            } else if (this.classList.contains(\"showSearchSuggestionsNotification\")) {\n              this._hideSearchSuggestionsNotification();\n            }\n          } catch (ex) {\n            // Not critical for the urlbar functionality, just report the error.\n            Cu.reportError(ex);\n          }\n\n          // Position the popup below the navbar.  To get the y-coordinate,\n          // which is an offset from the bottom of the input, subtract the\n          // bottom of the navbar from the buttom of the input.\n          let yOffset = Math.round(\n            window.windowUtils.getBoundsWithoutFlushing(document.getElementById(\"nav-bar\")).bottom -\n            window.windowUtils.getBoundsWithoutFlushing(aInput).bottom);\n\n          if (!this.richlistbox.suppressMenuItemEvent && this.richlistbox.currentItem) {\n            // The richlistbox fired a DOMMenuItemActive for accessibility,\n            // but because the popup isn't open yet, accessibility will ignore\n            // it. Therefore, fire it again once the popup opens.\n            this.addEventListener(\"popupshown\", () => {\n              this.richlistbox._fireEvent(this.richlistbox.currentItem,\n                \"DOMMenuItemActive\");\n            }, {once: true});\n          }\n\n          this.openPopup(aElement, \"after_start\", 0, yOffset, false, false);\n\n          // Do this immediately after we've requested the popup to open. This\n          // will cause sync reflows but prevents flickering.\n          if (needsHandleOverUnderflow) {\n            for (let item of this.richlistbox.children) {\n              item.handleOverUnderflow();\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"adjustHeight\">\n        <body>\n          <![CDATA[\n          // If we were going to shrink later, cancel that for now:\n          if (this._shrinkTimeout) {\n            clearTimeout(this._shrinkTimeout);\n            this._shrinkTimeout = null;\n          }\n          let lastRowCount = this._lastRowCount;\n          // Figure out how many rows to show\n          let rows = this.richlistbox.children;\n          this._lastRowCount = rows.length;\n          let numRows = Math.min(this.matchCount, this.maxRows, rows.length);\n\n          // If we're going from 0 to non-0 rows, we might need to remove\n          // the height attribute to allow the popup to size. The attribute\n          // is set from XUL popup management code.\n          if (!lastRowCount && rows.length) {\n            this.removeAttribute(\"height\");\n          }\n\n          // Default the height to 0 if we have no rows to show\n          let height = 0;\n          if (numRows) {\n            if (!this._rowHeight) {\n              window.promiseDocumentFlushed(() => {\n                if (window.closed) {\n                  return;\n                }\n                this._rowHeight = rows[0].getBoundingClientRect().height;\n                let style = window.getComputedStyle(this.richlistbox);\n\n                let paddingTop = parseInt(style.paddingTop) || 0;\n                let paddingBottom = parseInt(style.paddingBottom) || 0;\n                this._rlbPadding = paddingTop + paddingBottom;\n                // Then re-run - but don't dirty layout from inside this callback.\n                window.requestAnimationFrame(() => this.adjustHeight());\n              });\n              return;\n            }\n\n            // Calculate the height to have the first row to last row shown\n            height = (this._rowHeight * numRows) + this._rlbPadding;\n          }\n\n          let animate = this.getAttribute(\"dontanimate\") != \"true\";\n          let currentHeight =\n            parseFloat(this.richlistbox.getAttribute(\"height\"), 10) ||\n            parseFloat(this.richlistbox.style.height, 10) ||\n            0; // It's possible we get here when we haven't set height on the richlistbox\n               // yet, which means parseFloat will return NaN. It should return 0 instead.\n          if (height > currentHeight) {\n            // Grow immediately.\n            if (animate) {\n              this.richlistbox.removeAttribute(\"height\");\n              this.richlistbox.style.height = height + \"px\";\n            } else {\n              this.richlistbox.style.removeProperty(\"height\");\n              this.richlistbox.height = height;\n            }\n          } else if (height < currentHeight) { // Don't shrink if height matches exactly\n            // Delay shrinking to avoid flicker.\n            this._shrinkTimeout = setTimeout(() => {\n              this._collapseUnusedItems();\n              if (animate) {\n                this.richlistbox.removeAttribute(\"height\");\n                this.richlistbox.style.height = height + \"px\";\n              } else {\n                this.richlistbox.style.removeProperty(\"height\");\n                this.richlistbox.height = height;\n              }\n            }, this.shrinkDelay);\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_showSearchSuggestionsNotification\">\n        <parameter name=\"whichNotification\"/>\n        <body>\n          <![CDATA[\n          if (whichNotification == \"opt-out\") {\n            if (this.margins) {\n              this.searchSuggestionsNotification.style.paddingInlineStart =\n                this.margins.start + \"px\";\n            } else {\n              this.searchSuggestionsNotification.style.removeProperty(\"padding-inline-start\");\n            }\n\n            // We want to animate the opt-out hint only once.\n            if (!this._firstSearchSuggestionsNotification) {\n              this._firstSearchSuggestionsNotification = true;\n              this.searchSuggestionsNotification.setAttribute(\"animate\", \"true\");\n            }\n          }\n\n          this.searchSuggestionsNotification.setAttribute(\"aria-describedby\",\n                                                          \"search-suggestions-hint\");\n\n          // With the notification shown, the listbox's height can sometimes be\n          // too small when it's flexed, as it normally is.  Also, it can start\n          // out slightly scrolled down.  Both problems appear together, most\n          // often when the popup is very narrow and the notification's text\n          // must wrap.  Work around them by removing the flex.\n          //\n          // But without flexing the listbox, the listbox's height animation\n          // sometimes fails to complete, leaving the popup too tall.  Work\n          // around that problem by disabling the listbox animation.\n          this.richlistbox.flex = 0;\n          this.setAttribute(\"dontanimate\", \"true\");\n\n          this.classList.add(\"showSearchSuggestionsNotification\");\n          // Don't show the one-off buttons if we are showing onboarding and\n          // there's no result, since it would be ugly and pointless.\n          this.footer.collapsed = this.matchCount == 0;\n          this.input.tabScrolling = this.matchCount != 0;\n\n          // This event allows accessibility APIs to see the notification.\n          if (!this.popupOpen) {\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"AlertActive\", true, true);\n            this.searchSuggestionsNotification.dispatchEvent(event);\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_hideSearchSuggestionsNotification\">\n        <body>\n          <![CDATA[\n          this.classList.remove(\"showSearchSuggestionsNotification\");\n          this.richlistbox.flex = 1;\n          this.removeAttribute(\"dontanimate\");\n          this.searchSuggestionsNotification.removeAttribute(\"animate\");\n          if (this.matchCount) {\n            // Update popup height.\n            this._invalidate();\n          } else {\n            this.closePopup();\n          }\n          ]]>\n        </body>\n      </method>\n\n      <!-- This handles keypress changes to the selection among the one-off\n           search buttons and between the one-offs and the listbox.  It returns\n           true if the keypress was consumed and false if not. -->\n      <method name=\"handleKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          this.oneOffSearchButtons.handleKeyPress(aEvent, this.matchCount,\n                                                  !this._isFirstResultHeuristic,\n                                                  gBrowser.userTypedValue);\n          return aEvent.defaultPrevented && !aEvent.urlbarDeferred;\n        ]]></body>\n      </method>\n\n      <!-- This is called when a one-off is clicked and when \"search in new tab\"\n           is selected from a one-off context menu. -->\n      <method name=\"handleOneOffSearch\">\n        <parameter name=\"event\"/>\n        <parameter name=\"engine\"/>\n        <parameter name=\"where\"/>\n        <parameter name=\"params\"/>\n        <body><![CDATA[\n          this.input.handleCommand(event, where, params);\n        ]]></body>\n      </method>\n\n      <!-- Result listitems call this to determine which search engine they\n           should show in their labels and include in their url attributes. -->\n      <property name=\"overrideSearchEngineName\" readonly=\"true\">\n        <getter><![CDATA[\n          let button = this.oneOffSearchButtons.selectedButton;\n          return button && button.engine && button.engine.name;\n        ]]></getter>\n      </property>\n\n      <method name=\"createResultLabel\">\n        <parameter name=\"item\"/>\n        <parameter name=\"proposedLabel\"/>\n        <body>\n          <![CDATA[\n            let parts = [proposedLabel];\n\n            let action = this.input._parseActionUrl(item.getAttribute(\"url\"));\n            if (action) {\n              switch (action.type) {\n              case \"searchengine\":\n                parts = [\n                  action.params.searchSuggestion || action.params.searchQuery,\n                  action.params.engineName,\n                ];\n                break;\n              case \"switchtab\":\n              case \"remotetab\":\n                parts = [\n                  item.getAttribute(\"title\"),\n                  item.getAttribute(\"displayurl\"),\n                ];\n                break;\n              }\n            }\n\n            let types = item.getAttribute(\"type\").split(/\\s+/);\n            let type = types.find(t => t != \"action\" && t != \"heuristic\");\n            try {\n              // Some types intentionally do not map to strings, which is not\n              // an error.\n              parts.push(this._bundle.GetStringFromName(type + \"ResultLabel\"));\n            } catch (e) {}\n\n            return parts.filter(str => str).join(\" \");\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"maybeSetupSpeculativeConnect\">\n        <parameter name=\"aUriString\"/>\n        <body><![CDATA[\n          try {\n            let uri = makeURI(aUriString);\n            Services.io.speculativeConnect2(uri, gBrowser.contentPrincipal, null);\n          } catch (ex) {\n            // Can't setup speculative connection for this uri string for some\n            // reason, just ignore it.\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onResultsAdded\">\n        <body>\n          <![CDATA[\n            // If nothing is selected yet, select the first result if it is a\n            // pre-selected \"heuristic\" result.  (See UnifiedComplete.js.)\n            let selectHeuristic =\n              this.selectedIndex == -1 && this._isFirstResultHeuristic;\n            if (selectHeuristic) {\n              this.input.controller.setInitiallySelectedIndex(0);\n            }\n\n            // If this is the heuristic result of a new search, format its\n            // search alias in the input or remove the formatting of the\n            // previous alias, as necessary.  We need to check selectHeuristic\n            // because the result may have already been added but only now is\n            // being selected, and we need to check gotResultForCurrentQuery\n            // because the result may be from the previous search and already\n            // selected and is now being reused.\n            if (selectHeuristic || !this.input.gotResultForCurrentQuery) {\n              this.input.formatValue();\n\n              // Also, hide the one-off search buttons if the user is using, or\n              // starting to use, an \"@engine\" search engine alias, or typed\n              // only the search restriction character.\n              let trimmedValue = this.input.value.trim();\n              this.toggleOneOffSearches(\n                trimmedValue[0] != \"@\" &&\n                (trimmedValue[0] != UrlbarTokenizer.RESTRICT.SEARCH ||\n                 trimmedValue.length != 1)\n              );\n            }\n\n            if (this.matchCount > 0) {\n              // If this is the first time we get the result from the current\n              // search and we are not in the private context, we can speculatively\n              // connect to the intended site as a performance optimization.\n              if (!this.input.gotResultForCurrentQuery &&\n                  this.input.speculativeConnectEnabled &&\n                  !this.input.inPrivateContext) {\n                let firstStyle = this.input.mController.getStyleAt(0);\n                if (firstStyle.includes(\"autofill\")) {\n                  let uri = this.input.mController.getFinalCompleteValueAt(0);\n                  this.maybeSetupSpeculativeConnect(uri);\n                } else if (firstStyle.includes(\"searchengine\") &&\n                          this.input.browserSearchSuggestEnabled &&\n                          this.input.urlbarSearchSuggestEnabled) {\n                  // Preconnect to the current search engine only if the search\n                  // suggestions are enabled.\n                  let engine = Services.search.defaultEngine;\n                  engine.speculativeConnect({window,\n                                            originAttributes: gBrowser.contentPrincipal.originAttributes});\n                }\n              }\n\n              // When a result is present the footer should always be visible.\n              this.footer.collapsed = false;\n            }\n\n            this.input.tabScrolling = true;\n            this.input.gotResultForCurrentQuery = true;\n            this.input.replaySafeDeferredKeyEvents();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_onSearchBegin\">\n        <body><![CDATA[\n          // Set the selected index to 0 (heuristic) until a result comes back\n          // and we can evaluate it better.\n          //\n          // This is required to properly manage delayed handleEnter:\n          // 1. if a search starts we set selectedIndex to 0 here, and it will\n          //    be updated by onResultsAdded. Since selectedIndex is 0,\n          //    handleEnter will delay the action if a result didn't arrive yet.\n          // 2. if a search doesn't start (for example if autocomplete is\n          //    disabled), this won't be called, and the selectedIndex will be\n          //    the default -1 value. Then handleEnter will know it should not\n          //    delay the action, cause a result wont't ever arrive.\n          this.input.controller.setInitiallySelectedIndex(0);\n\n          // Since we are starting a new search, reset the currently selected\n          // one-off button, to cover those cases where the oneoff buttons\n          // binding won't receive an actual DOM event. For example, a search\n          // could be started without an actual input event, and the popup may\n          // not have been closed from the previous search.\n          this.oneOffSearchButtons.selectedButton = null;\n        ]]></body>\n      </method>\n\n      <field name=\"_addonIframe\">null</field>\n      <field name=\"_addonIframeOwner\">null</field>\n      <field name=\"_addonIframeOverriddenFunctionsByName\">{}</field>\n\n      <!-- These methods must be overridden and properly handled by the API\n           runtime so that it doesn't break the popup.  If any of these methods\n           is not overridden, then initAddonIframe should throw. -->\n      <field name=\"_addonIframeOverrideFunctionNames\">[\n        \"_invalidate\",\n      ]</field>\n\n      <field name=\"_addonIframeHiddenAnonids\">[\n        \"search-suggestions-notification\",\n        \"richlistbox\",\n        \"one-off-search-buttons\",\n      ]</field>\n      <field name=\"_addonIframeHiddenDisplaysByAnonid\">{}</field>\n\n      <method name=\"initAddonIframe\">\n        <parameter name=\"owner\"/>\n        <parameter name=\"overrides\"/>\n        <body><![CDATA[\n          if (this._addonIframeOwner) {\n            // Another add-on has already requested the iframe.  Return null to\n            // signal to the calling add-on that it should not take over the\n            // popup.  First add-on wins for now.\n            return null;\n          }\n          // Make sure all overrides are provided before doing anything.\n          for (let name of this._addonIframeOverrideFunctionNames) {\n            if (typeof(overrides[name]) != \"function\") {\n              throw new Error(\n                \"Override for method '\" + name + \"' must be given\"\n              );\n            }\n          }\n          // OK, insert the iframe.\n          this._addonIframeOwner = owner;\n          this._addonIframe = this._makeAddonIframe();\n          this._addonIframeOverriddenFunctionsByName = {};\n          for (let name of this._addonIframeOverrideFunctionNames) {\n            this._addonIframeOverriddenFunctionsByName[name] = this[name];\n            this[name] = overrides[name];\n          }\n          return this._addonIframe;\n        ]]></body>\n      </method>\n\n      <method name=\"destroyAddonIframe\">\n        <parameter name=\"owner\"/>\n        <body><![CDATA[\n          if (this._addonIframeOwner != owner) {\n            throw new Error(\"You're not the iframe owner\");\n          }\n          this._addonIframeOwner = null;\n          this._addonIframe.remove();\n          this._addonIframe = null;\n          for (let anonid of this._addonIframeHiddenAnonids) {\n            let child = document.getAnonymousElementByAttribute(\n              this, \"anonid\", anonid\n            );\n            child.style.display =\n              this._addonIframeHiddenDisplaysByAnonid[anonid];\n          }\n          for (let name in this._addonIframeOverriddenFunctionsByName) {\n            this[name] = this._addonIframeOverriddenFunctionsByName[name];\n          }\n          this._addonIframeOverriddenFunctionsByName = {};\n        ]]></body>\n      </method>\n\n      <method name=\"_makeAddonIframe\">\n        <body><![CDATA[\n          this._addonIframeHiddenDisplaysByAnonid = {};\n          for (let anonid of this._addonIframeHiddenAnonids) {\n            let child = document.getAnonymousElementByAttribute(\n              this, \"anonid\", anonid\n            );\n            this._addonIframeHiddenDisplaysByAnonid[anonid] =\n              child.style.display;\n            child.style.display = \"none\";\n          }\n          let iframe = document.createXULElement(\"iframe\");\n          iframe.setAttribute(\"type\", \"content\");\n          iframe.setAttribute(\"flex\", \"1\");\n          iframe.style.transition = \"height 100ms\";\n          this.appendChild(iframe);\n          return iframe;\n        ]]></body>\n      </method>\n\n    </implementation>\n    <handlers>\n\n      <handler event=\"SelectedOneOffButtonChanged\"><![CDATA[\n        // Update all searchengine result items to use the newly selected\n        // engine.\n        for (let item of this.richlistbox.children) {\n          if (item.collapsed) {\n            break;\n          }\n          let url = item.getAttribute(\"url\");\n          if (url) {\n            let action = item._parseActionUrl(url);\n            if (action && action.type == \"searchengine\") {\n              item._adjustAcItem();\n            }\n          }\n        }\n\n        // If the selection moved from the results to the one-off settings\n        // button, then call formatValue to remove the formatting of the search\n        // alias in the input, if any.  In all other cases the alias formatting\n        // is removed when the input's value setter calls formatValue, but in\n        // this specific case, at the time that formatValue is called,\n        // oneOffSearchButtons.selectedButton is still null, so the formatting\n        // is not removed.  The settings button is selected right after that.\n        if (this.oneOffSearchButtons.selectedButton ==\n              this.oneOffSearchButtons.settingsButtonCompact &&\n            (!event.detail || !event.detail.previousSelectedButton)) {\n          this.input.formatValue();\n        }\n      ]]></handler>\n\n      <handler event=\"mousedown\"><![CDATA[\n        // Required to make the xul:label.text-link elements in the search\n        // suggestions notification work correctly when clicked on Linux.\n        // This is copied from the mousedown handler in\n        // browser-search-autocomplete-result-popup, which apparently had a\n        // similar problem.\n        event.preventDefault();\n\n        if (event.button == 2) {\n          // Right mouse button currently allows to select.\n          this.input.userSelectionBehavior = \"rightClick\";\n          // Ignore right-clicks.\n          return;\n        }\n\n        if (!this.input.speculativeConnectEnabled) {\n          return;\n        }\n\n        // Ensure the user is clicking on an url instead of other buttons\n        // on the popup.\n        let elt = event.originalTarget;\n        while (elt && elt.localName != \"richlistitem\" && elt != this) {\n          elt = elt.parentNode;\n        }\n        if (!elt || elt.localName != \"richlistitem\") {\n          return;\n        }\n        // The user might click on a ghost entry which was removed because of\n        // the coming new results.\n        if (this.input.controller.matchCount <= this.selectedIndex) {\n          return;\n        }\n\n        let url = this.input.controller.getFinalCompleteValueAt(this.selectedIndex);\n\n        // Whitelist the cases that we want to speculative connect, and ignore\n        // other moz-action uris or fancy protocols.\n        // Note that it's likely we've speculatively connected to the first\n        // url because it is a heuristic \"autofill\" result (see bug 1348275).\n        // \"moz-action:searchengine\" is also the same case. (see bug 1355443)\n        // So we won't duplicate the effort here.\n        if (url.startsWith(\"http\") && this.selectedIndex > 0) {\n          this.maybeSetupSpeculativeConnect(url);\n        } else if (url.startsWith(\"moz-action:remotetab\")) {\n          // URL is in the format moz-action:ACTION,PARAMS\n          // Where PARAMS is a JSON encoded object.\n          const MOZ_ACTION_REGEX = /^moz-action:([^,]+),(.*)$/;\n          if (!MOZ_ACTION_REGEX.test(url))\n            return;\n\n          let params = JSON.parse(url.match(MOZ_ACTION_REGEX)[2]);\n          if (params.url) {\n            this.maybeSetupSpeculativeConnect(decodeURIComponent(params.url));\n          }\n        }\n\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n  <binding id=\"addon-progress-notification\" extends=\"chrome://global/content/bindings/notification.xml#popup-notification\">\n    <implementation>\n      <constructor><![CDATA[\n        if (!this.notification)\n          return;\n\n        this.notification.options.installs.forEach(function(aInstall) {\n          aInstall.addListener(this);\n        }, this);\n\n        // Calling updateProgress can sometimes cause this notification to be\n        // removed in the middle of refreshing the notification panel which\n        // makes the panel get refreshed again. Just initialise to the\n        // undetermined state and then schedule a proper check at the next\n        // opportunity\n        this.setProgress(0, -1);\n        this._updateProgressTimeout = setTimeout(this.updateProgress.bind(this), 0);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        this.destroy();\n      ]]></destructor>\n\n      <field name=\"progressmeter\" readonly=\"true\">\n        document.getElementById(\"addon-progress-notification-progressmeter\");\n      </field>\n      <field name=\"progresstext\" readonly=\"true\">\n        document.getElementById(\"addon-progress-notification-progresstext\");\n      </field>\n      <property name=\"DownloadUtils\" readonly=\"true\">\n        <getter><![CDATA[\n          let module = {};\n          ChromeUtils.import(\"resource://gre/modules/DownloadUtils.jsm\", module);\n          Object.defineProperty(this, \"DownloadUtils\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: module.DownloadUtils,\n          });\n          return module.DownloadUtils;\n        ]]></getter>\n      </property>\n\n      <method name=\"destroy\">\n        <body><![CDATA[\n          if (!this.notification)\n            return;\n\n          this.notification.options.installs.forEach(function(aInstall) {\n            aInstall.removeListener(this);\n          }, this);\n          clearTimeout(this._updateProgressTimeout);\n        ]]></body>\n      </method>\n\n      <method name=\"setProgress\">\n        <parameter name=\"aProgress\"/>\n        <parameter name=\"aMaxProgress\"/>\n        <body><![CDATA[\n          if (aMaxProgress == -1) {\n            this.progressmeter.removeAttribute(\"value\");\n          } else {\n            this.progressmeter.setAttribute(\"value\", (aProgress * 100) / aMaxProgress);\n          }\n\n          let now = Date.now();\n\n          if (!this.notification.lastUpdate) {\n            this.notification.lastUpdate = now;\n            this.notification.lastProgress = aProgress;\n            return;\n          }\n\n          let delta = now - this.notification.lastUpdate;\n          if ((delta < 400) && (aProgress < aMaxProgress))\n            return;\n\n          delta /= 1000;\n\n          // This algorithm is the same used by the downloads code.\n          let speed = (aProgress - this.notification.lastProgress) / delta;\n          if (this.notification.speed)\n            speed = speed * 0.9 + this.notification.speed * 0.1;\n\n          this.notification.lastUpdate = now;\n          this.notification.lastProgress = aProgress;\n          this.notification.speed = speed;\n\n          let status = null;\n          [status, this.notification.last] = this.DownloadUtils.getDownloadStatus(aProgress, aMaxProgress, speed, this.notification.last);\n          this.progresstext.setAttribute(\"value\", status);\n          this.progresstext.setAttribute(\"tooltiptext\", status);\n        ]]></body>\n      </method>\n\n      <method name=\"cancel\">\n        <body><![CDATA[\n          let installs = this.notification.options.installs;\n          installs.forEach(function(aInstall) {\n            try {\n              aInstall.cancel();\n            } catch (e) {\n              // Cancel will throw if the download has already failed\n            }\n          }, this);\n\n          PopupNotifications.remove(this.notification);\n        ]]></body>\n      </method>\n\n      <method name=\"updateProgress\">\n        <body><![CDATA[\n          if (!this.notification)\n            return;\n\n          let downloadingCount = 0;\n          let progress = 0;\n          let maxProgress = 0;\n\n          this.notification.options.installs.forEach(function(aInstall) {\n            if (aInstall.maxProgress == -1)\n              maxProgress = -1;\n            progress += aInstall.progress;\n            if (maxProgress >= 0)\n              maxProgress += aInstall.maxProgress;\n            if (aInstall.state < AddonManager.STATE_DOWNLOADED)\n              downloadingCount++;\n          });\n\n          if (downloadingCount == 0) {\n            this.destroy();\n            this.progressmeter.removeAttribute(\"value\");\n            let status = gNavigatorBundle.getString(\"addonDownloadVerifying\");\n            this.progresstext.setAttribute(\"value\", status);\n            this.progresstext.setAttribute(\"tooltiptext\", status);\n          } else {\n            this.setProgress(progress, maxProgress);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadProgress\">\n        <body><![CDATA[\n          this.updateProgress();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadFailed\">\n        <body><![CDATA[\n          this.updateProgress();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadCancelled\">\n        <body><![CDATA[\n          this.updateProgress();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadEnded\">\n        <body><![CDATA[\n          this.updateProgress();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"menu.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- import-globals-from controller.js -->\n\n<bindings id=\"placesMenuBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"places-popup-base\"\n           extends=\"chrome://global/content/bindings/popup.xml#popup\">\n    <content>\n      <xul:hbox flex=\"1\">\n        <xul:vbox class=\"menupopup-drop-indicator-bar\" hidden=\"true\">\n          <xul:image class=\"menupopup-drop-indicator\" mousethrough=\"always\"/>\n        </xul:vbox>\n        <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                            smoothscroll=\"false\">\n          <children/>\n        </xul:arrowscrollbox>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n\n      <field name=\"AppConstants\" readonly=\"true\">\n        (ChromeUtils.import(\"resource://gre/modules/AppConstants.jsm\", {})).AppConstants;\n      </field>\n\n      <field name=\"_indicatorBar\">\n        document.getAnonymousElementByAttribute(this, \"class\",\n                                                \"menupopup-drop-indicator-bar\");\n      </field>\n\n      <field name=\"_scrollBox\">\n        document.getAnonymousElementByAttribute(this, \"class\",\n                                                \"popup-internal-box\");\n      </field>\n\n      <!-- This is the view that manage the popup -->\n      <field name=\"_rootView\">PlacesUIUtils.getViewForNode(this);</field>\n\n      <!-- Check if we should hide the drop indicator for the target -->\n      <method name=\"_hideDropIndicator\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let target = aEvent.target;\n\n          // Don't draw the drop indicator outside of markers or if current\n          // node is not a Places node.\n          let betweenMarkers =\n            (this._startMarker.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_FOLLOWING) &&\n            (this._endMarker.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_PRECEDING);\n\n          // Hide the dropmarker if current node is not a Places node.\n          return !(target && target._placesNode && betweenMarkers);\n        ]]></body>\n      </method>\n\n      <!-- This function returns information about where to drop when\n           dragging over this popup insertion point -->\n      <method name=\"_getDropPoint\">\n        <parameter name=\"aEvent\"/>\n          <body><![CDATA[\n            // Can't drop if the menu isn't a folder\n            let resultNode = this._placesNode;\n\n            if (!PlacesUtils.nodeIsFolder(resultNode) ||\n                this._rootView.controller.disallowInsertion(resultNode)) {\n              return null;\n            }\n\n            var dropPoint = { ip: null, folderElt: null };\n\n            // The element we are dragging over\n            let elt = aEvent.target;\n            if (elt.localName == \"menupopup\")\n              elt = elt.parentNode;\n\n            // Calculate positions taking care of arrowscrollbox\n            let scrollbox = this._scrollBox;\n            let eventY = aEvent.layerY + (scrollbox.boxObject.y - this.boxObject.y);\n            let scrollboxOffset = scrollbox.scrollBoxObject.y -\n                                  (scrollbox.boxObject.y - this.boxObject.y);\n            let eltY = elt.boxObject.y - scrollboxOffset;\n            let eltHeight = elt.boxObject.height;\n\n            if (!elt._placesNode) {\n              // If we are dragging over a non places node drop at the end.\n              dropPoint.ip = new PlacesInsertionPoint({\n                parentId: PlacesUtils.getConcreteItemId(resultNode),\n                parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n              });\n              // We can set folderElt if we are dropping over a static menu that\n              // has an internal placespopup.\n              let isMenu = elt.localName == \"menu\" ||\n                 (elt.localName == \"toolbarbutton\" &&\n                  elt.getAttribute(\"type\") == \"menu\");\n              if (isMenu && elt.lastElementChild &&\n                  elt.lastElementChild.hasAttribute(\"placespopup\"))\n                dropPoint.folderElt = elt;\n              return dropPoint;\n            }\n\n            let tagName = PlacesUtils.nodeIsTagQuery(elt._placesNode) ?\n                            elt._placesNode.title : null;\n            if ((PlacesUtils.nodeIsFolder(elt._placesNode) &&\n                 !PlacesUIUtils.isFolderReadOnly(elt._placesNode)) ||\n                PlacesUtils.nodeIsTagQuery(elt._placesNode)) {\n              // This is a folder or a tag container.\n              if (eventY - eltY < eltHeight * 0.20) {\n                // If mouse is in the top part of the element, drop above folder.\n                dropPoint.ip = new PlacesInsertionPoint({\n                  parentId: PlacesUtils.getConcreteItemId(resultNode),\n                  parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n                  orientation: Ci.nsITreeView.DROP_BEFORE,\n                  tagName,\n                  dropNearNode: elt._placesNode,\n                });\n                return dropPoint;\n              } else if (eventY - eltY < eltHeight * 0.80) {\n                // If mouse is in the middle of the element, drop inside folder.\n                dropPoint.ip = new PlacesInsertionPoint({\n                  parentId: PlacesUtils.getConcreteItemId(elt._placesNode),\n                  parentGuid: PlacesUtils.getConcreteItemGuid(elt._placesNode),\n                  tagName,\n                });\n                dropPoint.folderElt = elt;\n                return dropPoint;\n              }\n            } else if (eventY - eltY <= eltHeight / 2) {\n              // This is a non-folder node or a readonly folder.\n              // If the mouse is above the middle, drop above this item.\n              dropPoint.ip = new PlacesInsertionPoint({\n                parentId: PlacesUtils.getConcreteItemId(resultNode),\n                parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n                orientation: Ci.nsITreeView.DROP_BEFORE,\n                tagName,\n                dropNearNode: elt._placesNode,\n              });\n              return dropPoint;\n            }\n\n            // Drop below the item.\n            dropPoint.ip = new PlacesInsertionPoint({\n              parentId: PlacesUtils.getConcreteItemId(resultNode),\n              parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n              orientation: Ci.nsITreeView.DROP_AFTER,\n              tagName,\n              dropNearNode: elt._placesNode,\n            });\n            return dropPoint;\n        ]]></body>\n      </method>\n\n      <!-- Sub-menus should be opened when the mouse drags over them, and closed\n           when the mouse drags off.  The overFolder object manages opening and\n           closing of folders when the mouse hovers. -->\n      <field name=\"_overFolder\"><![CDATA[({\n        _self: this,\n        _folder: {elt: null,\n                  openTimer: null,\n                  hoverTime: 350,\n                  closeTimer: null},\n        _closeMenuTimer: null,\n\n        get elt() {\n          return this._folder.elt;\n        },\n        set elt(val) {\n          return this._folder.elt = val;\n        },\n\n        get openTimer() {\n          return this._folder.openTimer;\n        },\n        set openTimer(val) {\n          return this._folder.openTimer = val;\n        },\n\n        get hoverTime() {\n          return this._folder.hoverTime;\n        },\n        set hoverTime(val) {\n          return this._folder.hoverTime = val;\n        },\n\n        get closeTimer() {\n          return this._folder.closeTimer;\n        },\n        set closeTimer(val) {\n          return this._folder.closeTimer = val;\n        },\n\n        get closeMenuTimer() {\n          return this._closeMenuTimer;\n        },\n        set closeMenuTimer(val) {\n          return this._closeMenuTimer = val;\n        },\n\n        setTimer: function OF__setTimer(aTime) {\n          var timer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n          timer.initWithCallback(this, aTime, timer.TYPE_ONE_SHOT);\n          return timer;\n        },\n\n        notify: function OF__notify(aTimer) {\n          // Function to process all timer notifications.\n\n          if (aTimer == this._folder.openTimer) {\n            // Timer to open a submenu that's being dragged over.\n            this._folder.elt.lastElementChild.setAttribute(\"autoopened\", \"true\");\n            this._folder.elt.lastElementChild.openPopup();\n            this._folder.openTimer = null;\n          } else if (aTimer == this._folder.closeTimer) {\n            // Timer to close a submenu that's been dragged off of.\n            // Only close the submenu if the mouse isn't being dragged over any\n            // of its child menus.\n            var draggingOverChild = PlacesControllerDragHelper\n                                    .draggingOverChildNode(this._folder.elt);\n            if (draggingOverChild)\n              this._folder.elt = null;\n            this.clear();\n\n            // Close any parent folders which aren't being dragged over.\n            // (This is necessary because of the above code that keeps a folder\n            // open while its children are being dragged over.)\n            if (!draggingOverChild)\n              this.closeParentMenus();\n          } else if (aTimer == this.closeMenuTimer) {\n            // Timer to close this menu after the drag exit.\n            var popup = this._self;\n            // if we are no more dragging we can leave the menu open to allow\n            // for better D&D bookmark organization\n            if (PlacesControllerDragHelper.getSession() &&\n                !PlacesControllerDragHelper.draggingOverChildNode(popup.parentNode)) {\n              popup.hidePopup();\n              // Close any parent menus that aren't being dragged over;\n              // otherwise they'll stay open because they couldn't close\n              // while this menu was being dragged over.\n              this.closeParentMenus();\n            }\n            this._closeMenuTimer = null;\n          }\n        },\n\n        //  Helper function to close all parent menus of this menu,\n        //  as long as none of the parent's children are currently being\n        //  dragged over.\n        closeParentMenus: function OF__closeParentMenus() {\n          var popup = this._self;\n          var parent = popup.parentNode;\n          while (parent) {\n            if (parent.localName == \"menupopup\" && parent._placesNode) {\n              if (PlacesControllerDragHelper.draggingOverChildNode(parent.parentNode))\n                break;\n              parent.hidePopup();\n            }\n            parent = parent.parentNode;\n          }\n        },\n\n        //  The mouse is no longer dragging over the stored menubutton.\n        //  Close the menubutton, clear out drag styles, and clear all\n        //  timers for opening/closing it.\n        clear: function OF__clear() {\n          if (this._folder.elt && this._folder.elt.lastElementChild) {\n            if (!this._folder.elt.lastElementChild.hasAttribute(\"dragover\"))\n              this._folder.elt.lastElementChild.hidePopup();\n            // remove menuactive style\n            this._folder.elt.removeAttribute(\"_moz-menuactive\");\n            this._folder.elt = null;\n          }\n          if (this._folder.openTimer) {\n            this._folder.openTimer.cancel();\n            this._folder.openTimer = null;\n          }\n          if (this._folder.closeTimer) {\n            this._folder.closeTimer.cancel();\n            this._folder.closeTimer = null;\n          }\n        },\n      })]]></field>\n\n      <method name=\"_cleanupDragDetails\">\n        <body><![CDATA[\n          // Called on dragend and drop.\n          PlacesControllerDragHelper.currentDropTarget = null;\n          this._rootView._draggedElt = null;\n          this.removeAttribute(\"dragover\");\n          this.removeAttribute(\"dragstart\");\n          this._indicatorBar.hidden = true;\n        ]]></body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"DOMMenuItemActive\"><![CDATA[\n        let elt = event.target;\n        if (elt.parentNode != this)\n          return;\n\n        if (this.AppConstants.platform === \"macosx\") {\n          // XXX: The following check is a temporary hack until bug 420033 is\n          // resolved.\n          let parentElt = elt.parent;\n          while (parentElt) {\n            if (parentElt.id == \"bookmarksMenuPopup\" ||\n                parentElt.id == \"goPopup\")\n              return;\n\n            parentElt = parentElt.parentNode;\n          }\n        }\n\n        if (window.XULBrowserWindow) {\n          let placesNode = elt._placesNode;\n\n          var linkURI;\n          if (placesNode && PlacesUtils.nodeIsURI(placesNode))\n            linkURI = placesNode.uri;\n          else if (elt.hasAttribute(\"targetURI\"))\n            linkURI = elt.getAttribute(\"targetURI\");\n\n          if (linkURI)\n            window.XULBrowserWindow.setOverLink(linkURI, null);\n        }\n      ]]></handler>\n\n      <handler event=\"DOMMenuItemInactive\"><![CDATA[\n        let elt = event.target;\n        if (elt.parentNode != this)\n          return;\n\n        if (window.XULBrowserWindow)\n          window.XULBrowserWindow.setOverLink(\"\", null);\n      ]]></handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        let elt = event.target;\n        if (!elt._placesNode)\n          return;\n\n        let draggedElt = elt._placesNode;\n\n        // Force a copy action if parent node is a query or we are dragging a\n        // not-removable node.\n        if (!this._rootView.controller.canMoveNode(draggedElt))\n          event.dataTransfer.effectAllowed = \"copyLink\";\n\n        // Activate the view and cache the dragged element.\n        this._rootView._draggedElt = draggedElt;\n        this._rootView.controller.setDataTransfer(event);\n        this.setAttribute(\"dragstart\", \"true\");\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"drop\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = event.target;\n\n        let dropPoint = this._getDropPoint(event);\n        if (dropPoint && dropPoint.ip) {\n          PlacesControllerDragHelper.onDrop(dropPoint.ip, event.dataTransfer)\n                                    .catch(Cu.reportError);\n          event.preventDefault();\n        }\n\n        this._cleanupDragDetails();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = event.target;\n        let dt = event.dataTransfer;\n\n        let dropPoint = this._getDropPoint(event);\n        if (!dropPoint || !dropPoint.ip ||\n            !PlacesControllerDragHelper.canDrop(dropPoint.ip, dt)) {\n          this._indicatorBar.hidden = true;\n          event.stopPropagation();\n          return;\n        }\n\n        // Mark this popup as being dragged over.\n        this.setAttribute(\"dragover\", \"true\");\n\n        if (dropPoint.folderElt) {\n          // We are dragging over a folder.\n          // _overFolder should take the care of opening it on a timer.\n          if (this._overFolder.elt &&\n              this._overFolder.elt != dropPoint.folderElt) {\n            // We are dragging over a new folder, let's clear old values\n            this._overFolder.clear();\n          }\n          if (!this._overFolder.elt) {\n            this._overFolder.elt = dropPoint.folderElt;\n            // Create the timer to open this folder.\n            this._overFolder.openTimer = this._overFolder\n                                             .setTimer(this._overFolder.hoverTime);\n          }\n          // Since we are dropping into a folder set the corresponding style.\n          dropPoint.folderElt.setAttribute(\"_moz-menuactive\", true);\n        } else {\n          // We are not dragging over a folder.\n          // Clear out old _overFolder information.\n          this._overFolder.clear();\n        }\n\n        // Autoscroll the popup strip if we drag over the scroll buttons.\n        let anonid = event.originalTarget.getAttribute(\"anonid\");\n        let scrollDir = 0;\n        if (anonid == \"scrollbutton-up\") {\n          scrollDir = -1;\n        } else if (anonid == \"scrollbutton-down\") {\n          scrollDir = 1;\n        }\n        if (scrollDir != 0) {\n          this._scrollBox.scrollByIndex(scrollDir, true);\n        }\n\n        // Check if we should hide the drop indicator for this target.\n        if (dropPoint.folderElt || this._hideDropIndicator(event)) {\n          this._indicatorBar.hidden = true;\n          event.preventDefault();\n          event.stopPropagation();\n          return;\n        }\n\n        // We should display the drop indicator relative to the arrowscrollbox.\n        let scrollbox = this._scrollBox.scrollBoxObject;\n        let newMarginTop = 0;\n        if (scrollDir == 0) {\n          let elt = this.firstElementChild;\n          while (elt && event.screenY > elt.boxObject.screenY +\n                                        elt.boxObject.height / 2)\n            elt = elt.nextElementSibling;\n          newMarginTop = elt ? elt.boxObject.screenY - scrollbox.screenY :\n                               scrollbox.height;\n        } else if (scrollDir == 1)\n          newMarginTop = scrollbox.height;\n\n        // Set the new marginTop based on arrowscrollbox.\n        newMarginTop += scrollbox.y - this._scrollBox.boxObject.y;\n        this._indicatorBar.firstElementChild.style.marginTop = newMarginTop + \"px\";\n        this._indicatorBar.hidden = false;\n\n        event.preventDefault();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragexit\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = null;\n        this.removeAttribute(\"dragover\");\n\n        // If we have not moved to a valid new target clear the drop indicator\n        // this happens when moving out of the popup.\n        let target = event.relatedTarget;\n        if (!target || !this.contains(target))\n          this._indicatorBar.hidden = true;\n\n        // Close any folder being hovered over\n        if (this._overFolder.elt) {\n          this._overFolder.closeTimer = this._overFolder\n                                            .setTimer(this._overFolder.hoverTime);\n        }\n\n        // The autoopened attribute is set when this folder was automatically\n        // opened after the user dragged over it.  If this attribute is set,\n        // auto-close the folder on drag exit.\n        // We should also try to close this popup if the drag has started\n        // from here, the timer will check if we are dragging over a child.\n        if (this.hasAttribute(\"autoopened\") ||\n            this.hasAttribute(\"dragstart\")) {\n          this._overFolder.closeMenuTimer = this._overFolder\n                                                .setTimer(this._overFolder.hoverTime);\n        }\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragend\"><![CDATA[\n        this._cleanupDragDetails();\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n  <!-- Most of this is copied from the arrowpanel binding in popup.xml -->\n  <binding id=\"places-popup-arrow\"\n           extends=\"chrome://browser/content/places/menu.xml#places-popup-base\">\n    <content flip=\"both\" side=\"top\" position=\"bottomcenter topright\">\n      <xul:vbox anonid=\"container\" class=\"panel-arrowcontainer\" flex=\"1\"\n               xbl:inherits=\"side,panelopen\">\n        <xul:box anonid=\"arrowbox\" class=\"panel-arrowbox\">\n          <xul:image anonid=\"arrow\" class=\"panel-arrow\" xbl:inherits=\"side\"/>\n        </xul:box>\n        <xul:box class=\"panel-arrowcontent\" xbl:inherits=\"side,align,dir,orient,pack\" flex=\"1\">\n          <xul:vbox class=\"menupopup-drop-indicator-bar\" hidden=\"true\">\n            <xul:image class=\"menupopup-drop-indicator\" mousethrough=\"always\"/>\n          </xul:vbox>\n          <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                              smoothscroll=\"false\">\n            <children/>\n          </xul:arrowscrollbox>\n        </xul:box>\n      </xul:vbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this.style.pointerEvents = \"none\";\n      ]]></constructor>\n      <method name=\"adjustArrowPosition\">\n        <body><![CDATA[\n          var arrow = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrow\");\n\n          var anchor = this.anchorNode;\n          if (!anchor) {\n            arrow.hidden = true;\n            return;\n          }\n\n          var container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n          var arrowbox = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\");\n\n          var position = this.alignmentPosition;\n          var offset = this.alignmentOffset;\n\n          this.setAttribute(\"arrowposition\", position);\n\n          // if this panel has a \"sliding\" arrow, we may have previously set margins...\n          arrowbox.style.removeProperty(\"transform\");\n          if (position.indexOf(\"start_\") == 0 || position.indexOf(\"end_\") == 0) {\n            container.orient = \"horizontal\";\n            arrowbox.orient = \"vertical\";\n            if (position.indexOf(\"_after\") > 0) {\n              arrowbox.pack = \"end\";\n            } else {\n              arrowbox.pack = \"start\";\n            }\n            arrowbox.style.transform = \"translate(0, \" + -offset + \"px)\";\n\n            // The assigned side stays the same regardless of direction.\n            let isRTL = this.matches(\":-moz-locale-dir(rtl)\");\n\n            if (position.indexOf(\"start_\") == 0) {\n              container.dir = \"reverse\";\n              this.setAttribute(\"side\", isRTL ? \"left\" : \"right\");\n            } else {\n              container.dir = \"\";\n              this.setAttribute(\"side\", isRTL ? \"right\" : \"left\");\n            }\n          } else if (position.indexOf(\"before_\") == 0 || position.indexOf(\"after_\") == 0) {\n            container.orient = \"\";\n            arrowbox.orient = \"\";\n            if (position.indexOf(\"_end\") > 0) {\n              arrowbox.pack = \"end\";\n            } else {\n              arrowbox.pack = \"start\";\n            }\n            arrowbox.style.transform = \"translate(\" + -offset + \"px, 0)\";\n\n            if (position.indexOf(\"before_\") == 0) {\n              container.dir = \"reverse\";\n              this.setAttribute(\"side\", \"bottom\");\n            } else {\n              container.dir = \"\";\n              this.setAttribute(\"side\", \"top\");\n            }\n          }\n\n          arrow.hidden = false;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\"><![CDATA[\n        this.adjustArrowPosition();\n        this.setAttribute(\"animate\", \"open\");\n      ]]></handler>\n      <handler event=\"popupshown\" phase=\"target\"><![CDATA[\n        this.setAttribute(\"panelopen\", \"true\");\n        let disablePointerEvents;\n        if (!this.hasAttribute(\"disablepointereventsfortransition\")) {\n          let container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n          let cs = getComputedStyle(container);\n          let transitionProp = cs.transitionProperty;\n          let transitionTime = parseFloat(cs.transitionDuration);\n          disablePointerEvents = (transitionProp.includes(\"transform\") ||\n                                  transitionProp == \"all\") &&\n                                 transitionTime > 0;\n          this.setAttribute(\"disablepointereventsfortransition\", disablePointerEvents);\n        } else {\n          disablePointerEvents = this.getAttribute(\"disablepointereventsfortransition\") == \"true\";\n        }\n        if (!disablePointerEvents) {\n          this.style.removeProperty(\"pointer-events\");\n        }\n      ]]></handler>\n      <handler event=\"transitionend\"><![CDATA[\n        if (event.originalTarget.getAttribute(\"anonid\") == \"container\" &&\n            (event.propertyName == \"transform\" || event.propertyName == \"-moz-window-transform\")) {\n          this.style.removeProperty(\"pointer-events\");\n        }\n      ]]></handler>\n      <handler event=\"popuphiding\" phase=\"target\"><![CDATA[\n        this.setAttribute(\"animate\", \"cancel\");\n      ]]></handler>\n      <handler event=\"popuphidden\" phase=\"target\"><![CDATA[\n        this.removeAttribute(\"panelopen\");\n        if (this.getAttribute(\"disablepointereventsfortransition\") == \"true\") {\n          this.style.pointerEvents = \"none\";\n        }\n        this.removeAttribute(\"animate\");\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"tree.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- import-globals-from controller.js -->\n<!-- import-globals-from treeView.js -->\n\n<bindings id=\"placesTreeBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"places-tree\" extends=\"chrome://global/content/bindings/tree.xml#tree\">\n    <implementation>\n      <constructor><![CDATA[\n        // Force an initial build.\n        if (this.place)\n          this.place = this.place;\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // Break the treeviewer->result->treeviewer cycle.\n        // Note: unsetting the result's viewer also unsets\n        // the viewer's reference to our tree.\n        var result = this.result;\n        if (result) {\n          result.root.containerOpen = false;\n        }\n\n        // Unregister the controllber before unlinking the view, otherwise it\n        // may still try to update commands on a view with a null result.\n        if (this._controller) {\n          this._controller.terminate();\n          this.controllers.removeController(this._controller);\n        }\n\n        if (this.view) {\n          this.view.uninit();\n        }\n        this.view = null;\n      ]]></destructor>\n\n      <property name=\"controller\"\n                readonly=\"true\"\n                onget=\"return this._controller\"/>\n\n      <property name=\"disableUserActions\"\n                onget=\"return this.getAttribute('disableUserActions') == 'true';\"\n                onset=\"if (val) this.setAttribute('disableUserActions', 'true');\n                       else this.removeAttribute('disableUserActions'); return val;\"/>\n\n      <!-- overriding -->\n      <property name=\"view\">\n        <getter><![CDATA[\n          try {\n            /* eslint-disable no-undef */\n            return Object.getOwnPropertyDescriptor(XULTreeElement.prototype, \"view\").get.\n                          call(this).wrappedJSObject || null;\n            /* eslint-enable no-undef */\n          } catch (e) {\n            return null;\n          }\n        ]]></getter>\n        <setter><![CDATA[\n          /* eslint-disable no-undef */\n          return Object.getOwnPropertyDescriptor(XULTreeElement.prototype, \"view\").set.call(this, val);\n          /* eslint-enable no-undef */\n        ]]></setter>\n      </property>\n\n      <property name=\"associatedElement\"\n                readonly=\"true\"\n                onget=\"return this\"/>\n\n      <method name=\"applyFilter\">\n        <parameter name=\"filterString\"/>\n        <parameter name=\"folderRestrict\"/>\n        <parameter name=\"includeHidden\"/>\n        <body><![CDATA[\n          // preserve grouping\n          var queryNode = PlacesUtils.asQuery(this.result.root);\n          var options = queryNode.queryOptions.clone();\n\n          // Make sure we're getting uri results.\n          // We do not yet support searching into grouped queries or into\n          // tag containers, so we must fall to the default case.\n          if (PlacesUtils.nodeIsHistoryContainer(queryNode) ||\n              PlacesUtils.nodeIsTagQuery(queryNode) ||\n              options.resultType == options.RESULTS_AS_TAGS_ROOT ||\n              options.resultType == options.RESULTS_AS_ROOTS_QUERY)\n            options.resultType = options.RESULTS_AS_URI;\n\n          var query = PlacesUtils.history.getNewQuery();\n          query.searchTerms = filterString;\n\n          if (folderRestrict) {\n            query.setParents(folderRestrict, folderRestrict.length);\n            options.queryType = options.QUERY_TYPE_BOOKMARKS;\n          }\n\n          options.includeHidden = !!includeHidden;\n\n          this.load(query, options);\n        ]]></body>\n      </method>\n\n      <method name=\"load\">\n        <parameter name=\"query\"/>\n        <parameter name=\"options\"/>\n        <body><![CDATA[\n          let result = PlacesUtils.history\n                                  .executeQuery(query, options);\n          let callback;\n          if (this.flatList) {\n            let onOpenFlatContainer = this.onOpenFlatContainer;\n            if (onOpenFlatContainer)\n              callback = new Function(\"aContainer\", onOpenFlatContainer);\n          }\n\n          if (!this._controller) {\n            this._controller = new PlacesController(this);\n            this._controller.disableUserActions = this.disableUserActions;\n            this.controllers.appendController(this._controller);\n          }\n\n          let treeView = new PlacesTreeView(this.flatList, callback, this._controller);\n\n          // Observer removal is done within the view itself.  When the tree\n          // goes away, view.setTree(null) is called, which then\n          // calls removeObserver.\n          result.addObserver(treeView);\n          this.view = treeView;\n\n          if (this.getAttribute(\"selectfirstnode\") == \"true\" && treeView.rowCount > 0) {\n            treeView.selection.select(0);\n          }\n\n          this._cachedInsertionPoint = undefined;\n        ]]></body>\n      </method>\n\n      <property name=\"flatList\">\n        <getter><![CDATA[\n          return this.getAttribute(\"flatList\") == \"true\";\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.flatList != val) {\n            this.setAttribute(\"flatList\", val);\n            // reload with the last place set\n            if (this.place)\n              this.place = this.place;\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"onOpenFlatContainer\">\n        <getter><![CDATA[\n          return this.getAttribute(\"onopenflatcontainer\");\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.onOpenFlatContainer != val) {\n            this.setAttribute(\"onopenflatcontainer\", val);\n            // reload with the last place set\n            if (this.place)\n              this.place = this.place;\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <!--\n        Causes a particular node represented by the specified placeURI to be\n        selected in the tree. All containers above the node in the hierarchy\n        will be opened, so that the node is visible.\n        -->\n      <method name=\"selectPlaceURI\">\n        <parameter name=\"placeURI\"/>\n        <body><![CDATA[\n          // Do nothing if a node matching the given uri is already selected\n          if (this.hasSelection && this.selectedNode.uri == placeURI)\n            return;\n\n          function findNode(container, nodesURIChecked) {\n            var containerURI = container.uri;\n            if (containerURI == placeURI)\n              return container;\n            if (nodesURIChecked.includes(containerURI))\n              return null;\n\n            // never check the contents of the same query\n            nodesURIChecked.push(containerURI);\n\n            var wasOpen = container.containerOpen;\n            if (!wasOpen)\n              container.containerOpen = true;\n            for (var i = 0; i < container.childCount; ++i) {\n              var child = container.getChild(i);\n              var childURI = child.uri;\n              if (childURI == placeURI)\n                return child;\n              else if (PlacesUtils.nodeIsContainer(child)) {\n                var nested = findNode(PlacesUtils.asContainer(child), nodesURIChecked);\n                if (nested)\n                  return nested;\n              }\n            }\n\n            if (!wasOpen)\n              container.containerOpen = false;\n\n            return null;\n          }\n\n          var container = this.result.root;\n          console.assert(container, \"No result, cannot select place URI!\");\n          if (!container)\n            return;\n\n          var child = findNode(container, []);\n          if (child)\n            this.selectNode(child);\n          else {\n            // If the specified child could not be located, clear the selection\n            var selection = this.view.selection;\n            selection.clearSelection();\n          }\n        ]]></body>\n      </method>\n\n      <!--\n        Causes a particular node to be selected in the tree, resulting in all\n        containers above the node in the hierarchy to be opened, so that the\n        node is visible.\n        -->\n      <method name=\"selectNode\">\n        <parameter name=\"node\"/>\n        <body><![CDATA[\n          var view = this.view;\n\n          var parent = node.parent;\n          if (parent && !parent.containerOpen) {\n            // Build a list of all of the nodes that are the parent of this one\n            // in the result.\n            var parents = [];\n            var root = this.result.root;\n            while (parent && parent != root) {\n              parents.push(parent);\n              parent = parent.parent;\n            }\n\n            // Walk the list backwards (opening from the root of the hierarchy)\n            // opening each folder as we go.\n            for (var i = parents.length - 1; i >= 0; --i) {\n              let index = view.treeIndexForNode(parents[i]);\n              if (index != -1 &&\n                  view.isContainer(index) && !view.isContainerOpen(index))\n                view.toggleOpenState(index);\n            }\n            // Select the specified node...\n          }\n\n          let index = view.treeIndexForNode(node);\n          if (index == -1)\n            return;\n\n          view.selection.select(index);\n          // ... and ensure it's visible, not scrolled off somewhere.\n          this.ensureRowIsVisible(index);\n        ]]></body>\n      </method>\n\n      <!-- nsIPlacesView -->\n      <property name=\"result\">\n        <getter><![CDATA[\n          try {\n            return this.view.QueryInterface(Ci.nsINavHistoryResultObserver).result;\n          } catch (e) {\n            return null;\n          }\n        ]]></getter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"place\">\n        <getter><![CDATA[\n          return this.getAttribute(\"place\");\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"place\", val);\n\n          let query = {}, options = {};\n          PlacesUtils.history.queryStringToQuery(val, query, options);\n          this.load(query.value, options.value);\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"hasSelection\">\n        <getter><![CDATA[\n          return this.view && this.view.selection.count >= 1;\n        ]]></getter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"selectedNodes\">\n        <getter><![CDATA[\n          let nodes = [];\n          if (!this.hasSelection)\n            return nodes;\n\n          let selection = this.view.selection;\n          let rc = selection.getRangeCount();\n          let resultview = this.view;\n          for (let i = 0; i < rc; ++i) {\n            let min = { }, max = { };\n            selection.getRangeAt(i, min, max);\n            for (let j = min.value; j <= max.value; ++j) {\n              nodes.push(resultview.nodeForTreeIndex(j));\n            }\n          }\n          return nodes;\n        ]]></getter>\n      </property>\n\n      <method name=\"toggleCutNode\">\n        <parameter name=\"aNode\"/>\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          this.view.toggleCutNode(aNode, aValue);\n        ]]></body>\n      </method>\n\n      <!-- nsIPlacesView -->\n      <property name=\"removableSelectionRanges\">\n        <getter><![CDATA[\n          // This property exists in addition to selectedNodes because it\n          // encodes selection ranges (which only occur in list views) into\n          // the return value. For each removed range, the index at which items\n          // will be re-inserted upon the remove transaction being performed is\n          // the first index of the range, so that the view updates correctly.\n          //\n          // For example, if we remove rows 2,3,4 and 7,8 from a list, when we\n          // undo that operation, if we insert what was at row 3 at row 3 again,\n          // it will show up _after_ the item that was at row 5. So we need to\n          // insert all items at row 2, and the tree view will update correctly.\n          //\n          // Also, this function collapses the selection to remove redundant\n          // data, e.g. when deleting this selection:\n          //\n          //      http://www.foo.com/\n          //  (-) Some Folder\n          //        http://www.bar.com/\n          //\n          // ... returning http://www.bar.com/ as part of the selection is\n          // redundant because it is implied by removing \"Some Folder\". We\n          // filter out all such redundancies since some partial amount of\n          // the folder's children may be selected.\n          //\n          let nodes = [];\n          if (!this.hasSelection)\n            return nodes;\n\n          var selection = this.view.selection;\n          var rc = selection.getRangeCount();\n          var resultview = this.view;\n          // This list is kept independently of the range selected (i.e. OUTSIDE\n          // the for loop) since the row index of a container is unique for the\n          // entire view, and we could have some really wacky selection and we\n          // don't want to blow up.\n          var containers = { };\n          for (var i = 0; i < rc; ++i) {\n            var range = [];\n            var min = { }, max = { };\n            selection.getRangeAt(i, min, max);\n\n            for (var j = min.value; j <= max.value; ++j) {\n              if (this.view.isContainer(j))\n                containers[j] = true;\n              if (!(this.view.getParentIndex(j) in containers))\n                range.push(resultview.nodeForTreeIndex(j));\n            }\n            nodes.push(range);\n          }\n          return nodes;\n        ]]></getter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"draggableSelection\"\n                onget=\"return this.selectedNodes\"/>\n\n      <!-- nsIPlacesView -->\n      <property name=\"selectedNode\">\n        <getter><![CDATA[\n          var view = this.view;\n          if (!view || view.selection.count != 1)\n            return null;\n\n          var selection = view.selection;\n          var min = { }, max = { };\n          selection.getRangeAt(0, min, max);\n\n          return this.view.nodeForTreeIndex(min.value);\n        ]]></getter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"insertionPoint\">\n        <getter><![CDATA[\n          // invalidated on selection and focus changes\n          if (this._cachedInsertionPoint !== undefined)\n            return this._cachedInsertionPoint;\n\n          // there is no insertion point for history queries\n          // so bail out now and save a lot of work when updating commands\n          var resultNode = this.result.root;\n          if (PlacesUtils.nodeIsQuery(resultNode) &&\n              PlacesUtils.asQuery(resultNode).queryOptions.queryType ==\n                Ci.nsINavHistoryQueryOptions.QUERY_TYPE_HISTORY)\n              return this._cachedInsertionPoint = null;\n\n          var orientation = Ci.nsITreeView.DROP_BEFORE;\n          // If there is no selection, insert at the end of the container.\n          if (!this.hasSelection) {\n            var index = this.view.rowCount - 1;\n            this._cachedInsertionPoint =\n              this._getInsertionPoint(index, orientation);\n            return this._cachedInsertionPoint;\n          }\n\n          // This is a two-part process. The first part is determining the drop\n          // orientation.\n          // * The default orientation is to drop _before_ the selected item.\n          // * If the selected item is a container, the default orientation\n          //   is to drop _into_ that container.\n          //\n          // Warning: It may be tempting to use tree indexes in this code, but\n          //          you must not, since the tree is nested and as your tree\n          //          index may change when folders before you are opened and\n          //          closed. You must convert your tree index to a node, and\n          //          then use getChildIndex to find your absolute index in\n          //          the parent container instead.\n          //\n          var resultView = this.view;\n          var selection = resultView.selection;\n          var rc = selection.getRangeCount();\n          var min = { }, max = { };\n          selection.getRangeAt(rc - 1, min, max);\n\n          // If the sole selection is a container, and we are not in\n          // a flatlist, insert into it.\n          // Note that this only applies to _single_ selections,\n          // if the last element within a multi-selection is a\n          // container, insert _adjacent_ to the selection.\n          //\n          // If the sole selection is the bookmarks toolbar folder, we insert\n          // into it even if it is not opened\n          if (selection.count == 1 && resultView.isContainer(max.value) &&\n              !this.flatList)\n            orientation = Ci.nsITreeView.DROP_ON;\n\n          this._cachedInsertionPoint =\n            this._getInsertionPoint(max.value, orientation);\n          return this._cachedInsertionPoint;\n        ]]></getter>\n      </property>\n\n      <method name=\"_getInsertionPoint\">\n        <parameter name=\"index\"/>\n        <parameter name=\"orientation\"/>\n        <body><![CDATA[\n          var result = this.result;\n          var resultview = this.view;\n          var container = result.root;\n          var dropNearNode = null;\n          console.assert(container, \"null container\");\n          // When there's no selection, assume the container is the container\n          // the view is populated from (i.e. the result's itemId).\n          if (index != -1) {\n            var lastSelected = resultview.nodeForTreeIndex(index);\n            if (resultview.isContainer(index) && orientation == Ci.nsITreeView.DROP_ON) {\n              // If the last selected item is an open container, append _into_\n              // it, rather than insert adjacent to it.\n              container = lastSelected;\n              index = -1;\n            } else if (lastSelected.containerOpen &&\n                       orientation == Ci.nsITreeView.DROP_AFTER &&\n                       lastSelected.hasChildren) {\n             // If the last selected item is an open container and the user is\n             // trying to drag into it as a first item, really insert into it.\n             container = lastSelected;\n             orientation = Ci.nsITreeView.DROP_ON;\n             index = 0;\n            } else {\n              // Use the last-selected node's container.\n              container = lastSelected.parent;\n\n              // See comment in the treeView.js's copy of this method\n              if (!container || !container.containerOpen)\n                return null;\n\n              // Avoid the potentially expensive call to getChildIndex\n              // if we know this container doesn't allow insertion\n              if (this.controller.disallowInsertion(container))\n                return null;\n\n              var queryOptions = PlacesUtils.asQuery(result.root).queryOptions;\n              if (queryOptions.sortingMode !=\n                    Ci.nsINavHistoryQueryOptions.SORT_BY_NONE) {\n                // If we are within a sorted view, insert at the end\n                index = -1;\n              } else if (queryOptions.excludeItems ||\n                         queryOptions.excludeQueries) {\n                // Some item may be invisible, insert near last selected one.\n                // We don't replace index here to avoid requests to the db,\n                // instead it will be calculated later by the controller.\n                index = -1;\n                dropNearNode = lastSelected;\n              } else {\n                var lsi = container.getChildIndex(lastSelected);\n                index = orientation == Ci.nsITreeView.DROP_BEFORE ? lsi : lsi + 1;\n              }\n            }\n          }\n\n          if (this.controller.disallowInsertion(container))\n            return null;\n\n          let tagName = PlacesUtils.nodeIsTagQuery(container) ?\n                          PlacesUtils.asQuery(container).query.tags[0] : null;\n\n          return new PlacesInsertionPoint({\n            parentId: PlacesUtils.getConcreteItemId(container),\n            parentGuid: PlacesUtils.getConcreteItemGuid(container),\n            index, orientation, tagName, dropNearNode,\n          });\n        ]]></body>\n      </method>\n\n      <!-- nsIPlacesView -->\n      <method name=\"selectAll\">\n        <body><![CDATA[\n          this.view.selection.selectAll();\n        ]]></body>\n      </method>\n\n      <!-- This method will select the first node in the tree that matches\n           each given item guid. It will open any folder nodes that it needs\n           to in order to show the selected items.\n      -->\n      <method name=\"selectItems\">\n        <parameter name=\"aGuids\"/>\n        <parameter name=\"aOpenContainers\"/>\n        <body><![CDATA[\n          // Never open containers in flat lists.\n          if (this.flatList)\n            aOpenContainers = false;\n          // By default, we do search and select within containers which were\n          // closed (note that containers in which nodes were not found are\n          // closed).\n          if (aOpenContainers === undefined)\n            aOpenContainers = true;\n\n          var guids = aGuids; // don't manipulate the caller's array\n\n          // Array of nodes found by findNodes which are to be selected\n          var nodes = [];\n\n          // Array of nodes found by findNodes which should be opened\n          var nodesToOpen = [];\n\n          // A set of GUIDs of container-nodes that were previously searched,\n          // and thus shouldn't be searched again. This is empty at the initial\n          // start of the recursion and gets filled in as the recursion\n          // progresses.\n          var checkedGuidsSet = new Set();\n\n          /**\n           * Recursively search through a node's children for items\n           * with the given GUIDs. When a matching item is found, remove its GUID\n           * from the GUIDs array, and add the found node to the nodes dictionary.\n           *\n           * NOTE: This method will leave open any node that had matching items\n           * in its subtree.\n           */\n          function findNodes(node) {\n            var foundOne = false;\n            // See if node matches an ID we wanted; add to results.\n            // For simple folder queries, check both itemId and the concrete\n            // item id.\n            var index = guids.indexOf(node.bookmarkGuid);\n            if (index == -1) {\n              let concreteGuid = PlacesUtils.getConcreteItemGuid(node);\n              if (concreteGuid != node.bookmarkGuid) {\n                index = guids.indexOf(concreteGuid);\n              }\n            }\n\n            if (index != -1) {\n              nodes.push(node);\n              foundOne = true;\n              guids.splice(index, 1);\n            }\n\n            var concreteGuid = PlacesUtils.getConcreteItemGuid(node);\n            if (guids.length == 0 || !PlacesUtils.nodeIsContainer(node) ||\n                checkedGuidsSet.has(concreteGuid))\n              return foundOne;\n\n            // Only follow a query if it has been been explicitly opened by the\n            // caller. We support the \"AllBookmarks\" case to allow callers to\n            // specify just the top-level bookmark folders.\n            let shouldOpen = aOpenContainers && (PlacesUtils.nodeIsFolder(node) ||\n              (PlacesUtils.nodeIsQuery(node) && node.bookmarkGuid == PlacesUIUtils.virtualAllBookmarksGuid));\n\n            PlacesUtils.asContainer(node);\n            if (!node.containerOpen && !shouldOpen)\n              return foundOne;\n\n            checkedGuidsSet.add(concreteGuid);\n\n            // Remember the beginning state so that we can re-close\n            // this node if we don't find any additional results here.\n            var previousOpenness = node.containerOpen;\n            node.containerOpen = true;\n            for (var child = 0; child < node.childCount && guids.length > 0; child++) {\n              var childNode = node.getChild(child);\n              var found = findNodes(childNode);\n              if (!foundOne)\n                foundOne = found;\n            }\n\n            // If we didn't find any additional matches in this node's\n            // subtree, revert the node to its previous openness.\n            if (foundOne)\n              nodesToOpen.unshift(node);\n            node.containerOpen = previousOpenness;\n            return foundOne;\n          }\n\n          // Disable notifications while looking for nodes.\n          let result = this.result;\n          let didSuppressNotifications = result.suppressNotifications;\n          if (!didSuppressNotifications)\n            result.suppressNotifications = true;\n          try {\n            findNodes(this.result.root);\n          } finally {\n            if (!didSuppressNotifications)\n              result.suppressNotifications = false;\n          }\n\n          // For all the nodes we've found, highlight the corresponding\n          // index in the tree.\n          var resultview = this.view;\n          var selection = this.view.selection;\n          selection.selectEventsSuppressed = true;\n          selection.clearSelection();\n          // Open nodes containing found items\n          for (let i = 0; i < nodesToOpen.length; i++) {\n            nodesToOpen[i].containerOpen = true;\n          }\n          for (let i = 0; i < nodes.length; i++) {\n            var index = resultview.treeIndexForNode(nodes[i]);\n            if (index == -1)\n              continue;\n            selection.rangedSelect(index, index, true);\n          }\n          selection.selectEventsSuppressed = false;\n        ]]></body>\n      </method>\n\n      <field name=\"_contextMenuShown\">false</field>\n\n      <method name=\"buildContextMenu\">\n        <parameter name=\"aPopup\"/>\n        <body><![CDATA[\n          this._contextMenuShown = true;\n          return this.controller.buildContextMenu(aPopup);\n        ]]></body>\n      </method>\n\n      <method name=\"destroyContextMenu\">\n        <parameter name=\"aPopup\"/>\n          this._contextMenuShown = false;\n        <body/>\n      </method>\n\n      <property name=\"ownerWindow\"\n                readonly=\"true\"\n                onget=\"return window;\"/>\n\n      <field name=\"_active\">true</field>\n      <property name=\"active\"\n                onget=\"return this._active\"\n                onset=\"return this._active = val\"/>\n\n    </implementation>\n    <handlers>\n      <handler event=\"focus\"><![CDATA[\n        this._cachedInsertionPoint = undefined;\n\n        // See select handler. We need the sidebar's places commandset to be\n        // updated as well\n        document.commandDispatcher.updateCommands(\"focus\");\n      ]]></handler>\n      <handler event=\"select\"><![CDATA[\n        this._cachedInsertionPoint = undefined;\n\n        // This additional complexity is here for the sidebars\n        var win = window;\n        while (true) {\n          win.document.commandDispatcher.updateCommands(\"focus\");\n          if (win == window.top)\n            break;\n\n          win = win.parent;\n        }\n      ]]></handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        if (event.target.localName != \"treechildren\")\n          return;\n\n        if (this.disableUserActions) {\n          event.preventDefault();\n          event.stopPropagation();\n          return;\n        }\n\n        let nodes = this.selectedNodes;\n        for (let i = 0; i < nodes.length; i++) {\n          let node = nodes[i];\n\n          // Disallow dragging the root node of a tree.\n          if (!node.parent) {\n            event.preventDefault();\n            event.stopPropagation();\n            return;\n          }\n\n          // If this node is child of a readonly container or cannot be moved,\n          // we must force a copy.\n          if (!this.controller.canMoveNode(node)) {\n            event.dataTransfer.effectAllowed = \"copyLink\";\n            break;\n          }\n        }\n\n        this._controller.setDataTransfer(event);\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        if (event.target.localName != \"treechildren\")\n          return;\n\n        let cell = this.getCellAt(event.clientX, event.clientY);\n        let node = cell.row != -1 ?\n                   this.view.nodeForTreeIndex(cell.row) :\n                   this.result.root;\n        // cache the dropTarget for the view\n        PlacesControllerDragHelper.currentDropTarget = node;\n\n        // We have to calculate the orientation since view.canDrop will use\n        // it and we want to be consistent with the dropfeedback.\n        let rowHeight = this.rowHeight;\n        let eventY = event.clientY - this.treeBody.boxObject.y -\n                     rowHeight * (cell.row - this.getFirstVisibleRow());\n\n        let orientation = Ci.nsITreeView.DROP_BEFORE;\n\n        if (cell.row == -1) {\n          // If the row is not valid we try to insert inside the resultNode.\n          orientation = Ci.nsITreeView.DROP_ON;\n        } else if (PlacesUtils.nodeIsContainer(node) &&\n                 eventY > rowHeight * 0.75) {\n          // If we are below the 75% of a container the treeview we try\n          // to drop after the node.\n          orientation = Ci.nsITreeView.DROP_AFTER;\n        } else if (PlacesUtils.nodeIsContainer(node) &&\n                 eventY > rowHeight * 0.25) {\n          // If we are below the 25% of a container the treeview we try\n          // to drop inside the node.\n          orientation = Ci.nsITreeView.DROP_ON;\n        }\n\n        if (!this.view.canDrop(cell.row, orientation, event.dataTransfer))\n          return;\n\n        event.preventDefault();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragend\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = null;\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"search.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- XULCommandEvent is a specialised global. -->\n<!-- global XULCommandEvent -->\n\n<!DOCTYPE bindings [\n<!ENTITY % browserDTD SYSTEM \"chrome://browser/locale/browser.dtd\">\n%browserDTD;\n]>\n\n<bindings id=\"SearchBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"searchbar-textbox\"\n      extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete\">\n    <implementation>\n      <constructor><![CDATA[\n        if (this.closest(\"searchbar\").parentNode.parentNode.localName ==\n            \"toolbarpaletteitem\")\n          return;\n\n        if (Services.prefs.getBoolPref(\"browser.urlbar.clickSelectsAll\"))\n          this.setAttribute(\"clickSelectsAll\", true);\n\n        let textBox = document.getAnonymousElementByAttribute(this,\n                                              \"anonid\", \"moz-input-box\");\n\n        // Force the Custom Element to upgrade until Bug 1470242 handles this:\n        customElements.upgrade(textBox);\n        let cxmenu = textBox.menupopup;\n        cxmenu.addEventListener(\"popupshowing\",\n                                () => { this.initContextMenu(cxmenu); },\n                                {capture: true, once: true});\n\n        this.setAttribute(\"aria-owns\", this.popup.id);\n        this.closest(\"searchbar\")._textboxInitialized = true;\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // If the context menu has never been opened, there won't be anything\n        // to remove here.\n        // Also, XBL and the customize toolbar code sometimes interact poorly.\n        try {\n          this.controllers.removeController(this.searchbarController);\n        } catch (ex) { }\n      ]]></destructor>\n\n      // Add items to context menu and attach controller to handle them the\n      // first time the context menu is opened.\n      <method name=\"initContextMenu\">\n        <parameter name=\"aMenu\"/>\n        <body><![CDATA[\n          let stringBundle = this.closest(\"searchbar\")._stringBundle;\n\n          let pasteAndSearch, suggestMenuItem;\n          let element, label, akey;\n\n          element = document.createXULElement(\"menuseparator\");\n          aMenu.appendChild(element);\n\n          let insertLocation = aMenu.firstElementChild;\n          while (insertLocation.nextElementSibling &&\n                 insertLocation.getAttribute(\"cmd\") != \"cmd_paste\")\n            insertLocation = insertLocation.nextElementSibling;\n          if (insertLocation) {\n            element = document.createXULElement(\"menuitem\");\n            label = stringBundle.getString(\"cmd_pasteAndSearch\");\n            element.setAttribute(\"label\", label);\n            element.setAttribute(\"anonid\", \"paste-and-search\");\n            element.setAttribute(\"oncommand\", \"BrowserSearch.pasteAndSearch(event)\");\n            aMenu.insertBefore(element, insertLocation.nextElementSibling);\n            pasteAndSearch = element;\n          }\n\n          element = document.createXULElement(\"menuitem\");\n          label = stringBundle.getString(\"cmd_clearHistory\");\n          akey = stringBundle.getString(\"cmd_clearHistory_accesskey\");\n          element.setAttribute(\"label\", label);\n          element.setAttribute(\"accesskey\", akey);\n          element.setAttribute(\"cmd\", \"cmd_clearhistory\");\n          aMenu.appendChild(element);\n\n          element = document.createXULElement(\"menuitem\");\n          label = stringBundle.getString(\"cmd_showSuggestions\");\n          akey = stringBundle.getString(\"cmd_showSuggestions_accesskey\");\n          element.setAttribute(\"anonid\", \"toggle-suggest-item\");\n          element.setAttribute(\"label\", label);\n          element.setAttribute(\"accesskey\", akey);\n          element.setAttribute(\"cmd\", \"cmd_togglesuggest\");\n          element.setAttribute(\"type\", \"checkbox\");\n          element.setAttribute(\"autocheck\", \"false\");\n          suggestMenuItem = element;\n          aMenu.appendChild(element);\n\n          if (AppConstants.platform == \"macosx\") {\n            this.addEventListener(\"keypress\", aEvent => {\n              if (aEvent.keyCode == KeyEvent.DOM_VK_F4)\n                this.openSearch();\n            }, true);\n          }\n\n          this.controllers.appendController(this.searchbarController);\n\n          let onpopupshowing = function() {\n            BrowserSearch.searchBar._textbox.closePopup();\n            if (suggestMenuItem) {\n              let enabled =\n                Services.prefs.getBoolPref(\"browser.search.suggest.enabled\");\n              suggestMenuItem.setAttribute(\"checked\", enabled);\n            }\n\n            if (!pasteAndSearch)\n              return;\n            let controller = document.commandDispatcher.getControllerForCommand(\"cmd_paste\");\n            let enabled = controller.isCommandEnabled(\"cmd_paste\");\n            if (enabled)\n              pasteAndSearch.removeAttribute(\"disabled\");\n            else\n              pasteAndSearch.setAttribute(\"disabled\", \"true\");\n          };\n          aMenu.addEventListener(\"popupshowing\", onpopupshowing);\n          onpopupshowing();\n        ]]></body>\n      </method>\n\n      <!--\n        This overrides the searchParam property in autocomplete.xml.  We're\n        hijacking this property as a vehicle for delivering the privacy\n        information about the window into the guts of nsSearchSuggestions.\n\n        Note that the setter is the same as the parent.  We were not sure whether\n        we can override just the getter.  If that proves to be the case, the setter\n        can be removed.\n      -->\n      <property name=\"searchParam\"\n                onget=\"return this.getAttribute('autocompletesearchparam') +\n                       (PrivateBrowsingUtils.isWindowPrivate(window) ? '|private' : '');\"\n                onset=\"this.setAttribute('autocompletesearchparam', val); return val;\"/>\n\n      <!-- This is implemented so that when textbox.value is set directly (e.g.,\n           by tests), the one-off query is updated. -->\n      <method name=\"onBeforeValueSet\">\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          this.popup.oneOffButtons.query = aValue;\n          return aValue;\n        ]]></body>\n      </method>\n\n      <!--\n        This method overrides the autocomplete binding's openPopup (essentially\n        duplicating the logic from the autocomplete popup binding's\n        openAutocompletePopup method), modifying it so that the popup is aligned with\n        the inner textbox, but sized to not extend beyond the search bar border.\n      -->\n      <method name=\"openPopup\">\n        <body><![CDATA[\n          // Entering customization mode after the search bar had focus causes\n          // the popup to appear again, due to focus returning after the\n          // hamburger panel closes. Don't open in that spurious event.\n          if (document.documentElement.getAttribute(\"customizing\") == \"true\") {\n            return;\n          }\n\n          let popup = this.popup;\n          if (!popup.mPopupOpen) {\n            // Initially the panel used for the searchbar (PopupSearchAutoComplete\n            // in browser.xul) is hidden to avoid impacting startup / new\n            // window performance. The base binding's openPopup would normally\n            // call the overriden openAutocompletePopup in\n            // browser-search-autocomplete-result-popup binding to unhide the popup,\n            // but since we're overriding openPopup we need to unhide the panel\n            // ourselves.\n            popup.hidden = false;\n\n            // Don't roll up on mouse click in the anchor for the search UI.\n            if (popup.id == \"PopupSearchAutoComplete\") {\n              popup.setAttribute(\"norolluponanchor\", \"true\");\n            }\n\n            popup.mInput = this;\n            // clear any previous selection, see bugs 400671 and 488357\n            popup.selectedIndex = -1;\n\n            document.popupNode = null;\n\n            let outerRect = this.getBoundingClientRect();\n            let innerRect = this.inputField.getBoundingClientRect();\n            let width = RTL_UI ?\n                        innerRect.right - outerRect.left :\n                        outerRect.right - innerRect.left;\n            popup.setAttribute(\"width\", width > 100 ? width : 100);\n\n            // invalidate() depends on the width attribute\n            popup._invalidate();\n\n            let yOffset = outerRect.bottom - innerRect.bottom;\n            popup.openPopup(this.inputField, \"after_start\", 0, yOffset, false, false);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"openSearch\">\n        <body>\n          <![CDATA[\n            if (!this.popupOpen) {\n              this.closest(\"searchbar\").openSuggestionsPanel();\n              return false;\n            }\n            return true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"handleEnter\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          // Toggle the open state of the add-engine menu button if it's\n          // selected.  We're using handleEnter for this instead of listening\n          // for the command event because a command event isn't fired.\n          if (this.selectedButton &&\n              this.selectedButton.getAttribute(\"anonid\") ==\n                \"addengine-menu-button\") {\n            this.selectedButton.open = !this.selectedButton.open;\n            return true;\n          }\n          // Otherwise, \"call super\": do what the autocomplete binding's\n          // handleEnter implementation does.\n          return this.mController.handleEnter(false, event || null);\n        ]]></body>\n      </method>\n\n      <!-- override |onTextEntered| in autocomplete.xml -->\n      <method name=\"onTextEntered\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let engine;\n          let oneOff = this.selectedButton;\n          if (oneOff) {\n            if (!oneOff.engine) {\n              oneOff.doCommand();\n              return;\n            }\n            engine = oneOff.engine;\n          }\n          if (this._selectionDetails) {\n            BrowserSearch.searchBar.telemetrySearchDetails = this._selectionDetails;\n            this._selectionDetails = null;\n          }\n          this.closest(\"searchbar\").handleSearchCommand(aEvent, engine);\n        ]]></body>\n      </method>\n\n      <property name=\"selectedButton\">\n        <getter><![CDATA[\n          return this.popup.oneOffButtons.selectedButton;\n        ]]></getter>\n        <setter><![CDATA[\n          return this.popup.oneOffButtons.selectedButton = val;\n        ]]></setter>\n      </property>\n\n      <method name=\"handleKeyboardNavigation\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let popup = this.popup;\n          if (!popup.popupOpen)\n            return;\n\n          // accel + up/down changes the default engine and shouldn't affect\n          // the selection on the one-off buttons.\n          if (aEvent.getModifierState(\"Accel\"))\n            return;\n\n          let suggestionsHidden =\n            popup.richlistbox.getAttribute(\"collapsed\") == \"true\";\n          let numItems = suggestionsHidden ? 0 : this.popup.matchCount;\n          this.popup.oneOffButtons.handleKeyPress(aEvent, numItems, true);\n        ]]></body>\n      </method>\n\n      <!-- nsIController -->\n      <field name=\"searchbarController\" readonly=\"true\"><![CDATA[({\n        _self: this,\n        supportsCommand(aCommand) {\n          return aCommand == \"cmd_clearhistory\" ||\n                 aCommand == \"cmd_togglesuggest\";\n        },\n\n        isCommandEnabled(aCommand) {\n          return true;\n        },\n\n        doCommand(aCommand) {\n          switch (aCommand) {\n            case \"cmd_clearhistory\":\n              let param = this._self.getAttribute(\"autocompletesearchparam\");\n\n              BrowserSearch.searchBar.FormHistory.update({ op: \"remove\", fieldname: param }, null);\n              this._self.value = \"\";\n              break;\n            case \"cmd_togglesuggest\":\n              let enabled =\n                Services.prefs.getBoolPref(\"browser.search.suggest.enabled\");\n              Services.prefs.setBoolPref(\"browser.search.suggest.enabled\",\n                                         !enabled);\n              break;\n            default:\n              // do nothing with unrecognized command\n          }\n        },\n      })]]></field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"input\"><![CDATA[\n        this.popup.removeAttribute(\"showonlysettings\");\n      ]]></handler>\n\n      <handler event=\"keypress\" phase=\"capturing\"\n               action=\"return this.handleKeyboardNavigation(event);\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"accel\"\n               phase=\"capturing\"\n               action='this.closest(\"searchbar\").selectEngine(event, false);'/>\n\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"accel\"\n               phase=\"capturing\"\n               action='this.closest(\"searchbar\").selectEngine(event, true);'/>\n\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"alt\"\n               phase=\"capturing\"\n               action=\"return this.openSearch();\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"alt\"\n               phase=\"capturing\"\n               action=\"return this.openSearch();\"/>\n\n      <handler event=\"dragover\">\n      <![CDATA[\n        let types = event.dataTransfer.types;\n        if (types.includes(\"text/plain\") || types.includes(\"text/x-moz-text-internal\"))\n          event.preventDefault();\n      ]]>\n      </handler>\n\n      <handler event=\"drop\">\n      <![CDATA[\n        let dataTransfer = event.dataTransfer;\n        let data = dataTransfer.getData(\"text/plain\");\n        if (!data)\n          data = dataTransfer.getData(\"text/x-moz-text-internal\");\n        if (data) {\n          event.preventDefault();\n          this.value = data;\n          this.closest(\"searchbar\").openSuggestionsPanel();\n        }\n      ]]>\n      </handler>\n\n    </handlers>\n  </binding>\n\n  <binding id=\"browser-search-autocomplete-result-popup\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup\">\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\">\n      <xul:hbox anonid=\"searchbar-engine\" xbl:inherits=\"showonlysettings\"\n                class=\"search-panel-header search-panel-current-engine\">\n        <xul:image class=\"searchbar-engine-image\" xbl:inherits=\"src\"/>\n        <xul:label anonid=\"searchbar-engine-name\" flex=\"1\" crop=\"end\"\n                   role=\"presentation\"/>\n      </xul:hbox>\n      <xul:richlistbox anonid=\"richlistbox\" class=\"autocomplete-richlistbox search-panel-tree\" flex=\"1\"/>\n      <xul:hbox anonid=\"search-one-off-buttons\" class=\"search-one-offs\"/>\n    </content>\n    <implementation>\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body><![CDATA[\n          // initially the panel is hidden\n          // to avoid impacting startup / new window performance\n          aInput.popup.hidden = false;\n\n          // this method is defined on the base binding\n          this._openAutocompletePopup(aInput, aElement);\n        ]]></body>\n      </method>\n\n      <method name=\"onPopupClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          // Ignore all right-clicks\n          if (aEvent.button == 2)\n            return;\n\n          let searchBar = BrowserSearch.searchBar;\n          let popupForSearchBar = searchBar && searchBar.textbox == this.mInput;\n          if (popupForSearchBar) {\n            searchBar.telemetrySearchDetails = {\n              index: this.selectedIndex,\n              kind: \"mouse\",\n            };\n          }\n\n          // Check for unmodified left-click, and use default behavior\n          if (aEvent.button == 0 && !aEvent.shiftKey && !aEvent.ctrlKey &&\n              !aEvent.altKey && !aEvent.metaKey) {\n            this.input.controller.handleEnter(true, aEvent);\n            return;\n          }\n\n          // Check for middle-click or modified clicks on the search bar\n          if (popupForSearchBar) {\n            BrowserUsageTelemetry.recordSearchbarSelectedResultMethod(\n              aEvent,\n              this.selectedIndex\n            );\n\n            // Handle search bar popup clicks\n            let search = this.input.controller.getValueAt(this.selectedIndex);\n\n            // open the search results according to the clicking subtlety\n            let where = whereToOpenLink(aEvent, false, true);\n            let params = {};\n\n            // But open ctrl/cmd clicks on autocomplete items in a new background tab.\n            let modifier = AppConstants.platform == \"macosx\" ?\n                           aEvent.metaKey :\n                           aEvent.ctrlKey;\n            if (where == \"tab\" && (aEvent instanceof MouseEvent) &&\n                (aEvent.button == 1 || modifier))\n              params.inBackground = true;\n\n            // leave the popup open for background tab loads\n            if (!(where == \"tab\" && params.inBackground)) {\n              // close the autocomplete popup and revert the entered search term\n              this.closePopup();\n              this.input.controller.handleEscape();\n            }\n\n            searchBar.doSearch(search, where, null, params);\n            if (where == \"tab\" && params.inBackground)\n              searchBar.focus();\n            else\n              searchBar.value = search;\n          }\n        ]]></body>\n      </method>\n\n      <!-- Popup rollup is triggered by native events before the mousedown event\n           reaches the DOM. The will be set to true by the popuphiding event and\n           false after the mousedown event has been triggered to detect what\n           caused rollup. -->\n      <field name=\"_isHiding\">false</field>\n      <field name=\"_bundle\">null</field>\n      <property name=\"bundle\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (!this._bundle) {\n              const kBundleURI = \"chrome://browser/locale/search.properties\";\n              this._bundle = Services.strings.createBundle(kBundleURI);\n            }\n            return this._bundle;\n          ]]>\n        </getter>\n      </property>\n\n      <field name=\"oneOffButtons\" readonly=\"true\">\n        new SearchOneOffs(\n          document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                  \"search-one-off-buttons\"));\n      </field>\n\n      <method name=\"updateHeader\">\n        <body><![CDATA[\n          let currentEngine = Services.search.defaultEngine;\n          let uri = currentEngine.iconURI;\n          if (uri) {\n            this.setAttribute(\"src\", uri.spec);\n          } else {\n            // If the default has just been changed to a provider without icon,\n            // avoid showing the icon of the previous default provider.\n            this.removeAttribute(\"src\");\n          }\n\n          let headerText = this.bundle.formatStringFromName(\"searchHeader\",\n                                                            [currentEngine.name], 1);\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"searchbar-engine-name\")\n                  .setAttribute(\"value\", headerText);\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"searchbar-engine\")\n                  .engine = currentEngine;\n        ]]></body>\n      </method>\n\n      <!-- This is called when a one-off is clicked and when \"search in new tab\"\n           is selected from a one-off context menu. -->\n      <method name=\"handleOneOffSearch\">\n        <parameter name=\"event\"/>\n        <parameter name=\"engine\"/>\n        <parameter name=\"where\"/>\n        <parameter name=\"params\"/>\n        <body><![CDATA[\n          let searchbar = document.getElementById(\"searchbar\");\n          searchbar.handleSearchCommandWhere(event, engine, where, params);\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // Force the panel to have the width of the searchbar rather than\n        // the width of the textfield.\n        let DOMUtils = window.windowUtils;\n        let textboxRect = DOMUtils.getBoundsWithoutFlushing(this.mInput);\n        let inputRect = DOMUtils.getBoundsWithoutFlushing(this.mInput.inputField);\n\n        // Ensure the panel is wide enough to fit at least 3 engines.\n        let minWidth = Math.max(textboxRect.width,\n                                this.oneOffButtons.buttonWidth * 3);\n        this.style.minWidth = Math.round(minWidth) + \"px\";\n        // Alignment of the panel with the searchbar is obtained with negative\n        // margins.\n        this.style.marginLeft = (textboxRect.left - inputRect.left) + \"px\";\n        // This second margin is needed when the direction is reversed,\n        // eg. when using command+shift+X.\n        this.style.marginRight = (inputRect.right - textboxRect.right) + \"px\";\n\n        // First handle deciding if we are showing the reduced version of the\n        // popup containing only the preferences button. We do this if the\n        // glass icon has been clicked if the text field is empty.\n        let searchbar = document.getElementById(\"searchbar\");\n        if (searchbar.hasAttribute(\"showonlysettings\")) {\n          searchbar.removeAttribute(\"showonlysettings\");\n          this.setAttribute(\"showonlysettings\", \"true\");\n\n          // Setting this with an xbl-inherited attribute gets overridden the\n          // second time the user clicks the glass icon for some reason...\n          this.richlistbox.collapsed = true;\n        } else {\n          this.removeAttribute(\"showonlysettings\");\n          // Uncollapse as long as we have a view which has >= 1 row.\n          // The autocomplete binding itself will take care of uncollapsing later,\n          // if we currently have no rows but end up having some in the future\n          // when the search string changes\n          this.richlistbox.collapsed = (this.matchCount == 0);\n        }\n\n        // Show the current default engine in the top header of the panel.\n        this.updateHeader();\n      ]]></handler>\n\n      <handler event=\"popuphiding\"><![CDATA[\n        this._isHiding = true;\n        Services.tm.dispatchToMainThread(() => {\n          this._isHiding = false;\n        });\n      ]]></handler>\n\n      <!-- This handles clicks on the topmost \"Foo Search\" header in the\n           popup (hbox[anonid=\"searchbar-engine\"]). -->\n      <handler event=\"click\"><![CDATA[\n        if (event.button == 2) {\n          // Ignore right clicks.\n          return;\n        }\n        let button = event.originalTarget;\n        let engine = button.parentNode.engine;\n        if (!engine) {\n          return;\n        }\n        this.oneOffButtons.handleSearchCommand(event, engine);\n      ]]></handler>\n    </handlers>\n\n  </binding>\n\n</bindings>\n"},{"file":"formautofill.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"formautofillBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"autocomplete-profile-listitem-base\" extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n      </constructor>\n      <!-- For form autofill, we want to unify the selection no matter by\n      keyboard navigation or mouseover in order not to confuse user which\n      profile preview is being shown. This field is set to true to indicate\n      that selectedIndex of popup should be changed while mouseover item -->\n      <field name=\"selectedByMouseOver\">true</field>\n\n      <property name=\"_stringBundle\">\n        <getter><![CDATA[\n          /* global Services */\n          if (!this.__stringBundle) {\n            this.__stringBundle = Services.strings.createBundle(\"chrome://formautofill/locale/formautofill.properties\");\n          }\n          return this.__stringBundle;\n        ]]></getter>\n      </property>\n\n      <method name=\"_cleanup\">\n        <body>\n        <![CDATA[\n          this.removeAttribute(\"formautofillattached\");\n          if (this._itemBox) {\n            this._itemBox.removeAttribute(\"size\");\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_onOverflow\">\n        <body></body>\n      </method>\n\n      <method name=\"_onUnderflow\">\n        <body></body>\n      </method>\n\n      <method name=\"handleOverUnderflow\">\n        <body></body>\n      </method>\n\n      <method name=\"_adjustAutofillItemLayout\">\n        <body>\n        <![CDATA[\n          let outerBoxRect = this.parentNode.getBoundingClientRect();\n\n          // Make item fit in popup as XUL box could not constrain\n          // item's width\n          this._itemBox.style.width = outerBoxRect.width + \"px\";\n          // Use two-lines layout when width is smaller than 150px or\n          // 185px if an image precedes the label.\n          let oneLineMinRequiredWidth = this.getAttribute(\"ac-image\") ? 185 : 150;\n\n          if (outerBoxRect.width <= oneLineMinRequiredWidth) {\n            this._itemBox.setAttribute(\"size\", \"small\");\n          } else {\n            this._itemBox.removeAttribute(\"size\");\n          }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-profile-listitem\" extends=\"chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base\">\n    <xbl:content xmlns=\"http://www.w3.org/1999/xhtml\">\n      <div anonid=\"autofill-item-box\" class=\"autofill-item-box\" xbl:inherits=\"ac-image\">\n        <div class=\"profile-label-col profile-item-col\">\n          <span anonid=\"profile-label-affix\" class=\"profile-label-affix\"></span>\n          <span anonid=\"profile-label\" class=\"profile-label\"></span>\n        </div>\n        <div class=\"profile-comment-col profile-item-col\">\n          <span anonid=\"profile-comment\" class=\"profile-comment\"></span>\n        </div>\n      </div>\n    </xbl:content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n        <![CDATA[\n          this._itemBox = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"autofill-item-box\"\n          );\n          this._labelAffix = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"profile-label-affix\"\n          );\n          this._label = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"profile-label\"\n          );\n          this._comment = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"profile-comment\"\n          );\n\n          this._adjustAcItem();\n        ]]>\n      </constructor>\n\n      <property name=\"selected\" onget=\"return this.getAttribute('selected') == 'true';\">\n        <setter><![CDATA[\n          /* global Cu */\n          if (val) {\n            this.setAttribute(\"selected\", \"true\");\n          } else {\n            this.removeAttribute(\"selected\");\n          }\n\n          let {AutoCompletePopup} = ChromeUtils.import(\"resource://gre/modules/AutoCompletePopup.jsm\", {});\n\n          AutoCompletePopup.sendMessageToBrowser(\"FormAutofill:PreviewProfile\");\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <method name=\"_adjustAcItem\">\n        <body>\n        <![CDATA[\n          this._adjustAutofillItemLayout();\n          this.setAttribute(\"formautofillattached\", \"true\");\n          this._itemBox.style.setProperty(\"--primary-icon\", `url(${this.getAttribute(\"ac-image\")})`);\n\n          let {primaryAffix, primary, secondary} = JSON.parse(this.getAttribute(\"ac-value\"));\n\n          this._labelAffix.textContent = primaryAffix;\n          this._label.textContent = primary;\n          this._comment.textContent = secondary;\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-profile-listitem-footer\" extends=\"chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base\">\n    <xbl:content xmlns=\"http://www.w3.org/1999/xhtml\">\n      <div anonid=\"autofill-footer\" class=\"autofill-item-box autofill-footer\">\n        <div anonid=\"autofill-warning\" class=\"autofill-footer-row autofill-warning\">\n        </div>\n        <div anonid=\"autofill-option-button\" class=\"autofill-footer-row autofill-button\">\n        </div>\n      </div>\n    </xbl:content>\n\n    <handlers>\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        if (this._warningTextBox.contains(event.originalTarget)) {\n          return;\n        }\n\n        window.openPreferences(\"privacy-form-autofill\", {origin: \"autofillFooter\"});\n      ]]></handler>\n    </handlers>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n        <![CDATA[\n          this._itemBox = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"autofill-footer\"\n          );\n          this._optionButton = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"autofill-option-button\"\n          );\n          this._warningTextBox = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"autofill-warning\"\n          );\n\n          /**\n           * A handler for updating warning message once selectedIndex has been changed.\n           *\n           * There're three different states of warning message:\n           * 1. None of addresses were selected: We show all the categories intersection of fields in the\n           *    form and fields in the results.\n           * 2. An address was selested: Show the additional categories that will also be filled.\n           * 3. An address was selected, but the focused category is the same as the only one category: Only show\n           * the exact category that we're going to fill in.\n           *\n           * @private\n           * @param {string[]} data.categories\n           *        The categories of all the fields contained in the selected address.\n           */\n          this._updateWarningNote = ({data} = {}) => {\n            let categories = (data && data.categories) ? data.categories : this._allFieldCategories;\n            // If the length of categories is 1, that means all the fillable fields are in the same\n            // category. We will change the way to inform user according to this flag. When the value\n            // is true, we show \"Also autofills ...\", otherwise, show \"Autofills ...\" only.\n            let hasExtraCategories = categories.length > 1;\n            // Show the categories in certain order to conform with the spec.\n            let orderedCategoryList = [{id: \"address\", l10nId: \"category.address\"},\n                                       {id: \"name\", l10nId: \"category.name\"},\n                                       {id: \"organization\", l10nId: \"category.organization2\"},\n                                       {id: \"tel\", l10nId: \"category.tel\"},\n                                       {id: \"email\", l10nId: \"category.email\"}];\n            let showCategories = hasExtraCategories ?\n              orderedCategoryList.filter(category => categories.includes(category.id) && category.id != this._focusedCategory) :\n              [orderedCategoryList.find(category => category.id == this._focusedCategory)];\n\n            let separator = this._stringBundle.GetStringFromName(\"fieldNameSeparator\");\n            let warningTextTmplKey = hasExtraCategories ? \"phishingWarningMessage\" : \"phishingWarningMessage2\";\n            let categoriesText = showCategories.map(category => this._stringBundle.GetStringFromName(category.l10nId)).join(separator);\n\n            this._warningTextBox.textContent = this._stringBundle.formatStringFromName(warningTextTmplKey,\n              [categoriesText], 1);\n            this.parentNode.parentNode.adjustHeight();\n          };\n\n          this._adjustAcItem();\n        ]]>\n      </constructor>\n\n      <method name=\"_onCollapse\">\n        <body>\n        <![CDATA[\n          /* global messageManager */\n\n          if (this.showWarningText) {\n            messageManager.removeMessageListener(\"FormAutofill:UpdateWarningMessage\", this._updateWarningNote);\n          }\n\n          this._itemBox.removeAttribute(\"no-warning\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_adjustAcItem\">\n        <body>\n        <![CDATA[\n          /* global Cu */\n          this._adjustAutofillItemLayout();\n          this.setAttribute(\"formautofillattached\", \"true\");\n\n          let {AppConstants} = ChromeUtils.import(\"resource://gre/modules/AppConstants.jsm\", {});\n          // TODO: The \"Short\" suffix is pointless now as normal version string is no longer needed,\n          // we should consider removing the suffix if possible when the next time locale change.\n          let buttonTextBundleKey = AppConstants.platform == \"macosx\" ?\n            \"autocompleteFooterOptionOSXShort\" : \"autocompleteFooterOptionShort\";\n          let buttonText = this._stringBundle.GetStringFromName(buttonTextBundleKey);\n          this._optionButton.textContent = buttonText;\n\n          let value = JSON.parse(this.getAttribute(\"ac-value\"));\n\n          this._allFieldCategories = value.categories;\n          this._focusedCategory = value.focusedCategory;\n          this.showWarningText = this._allFieldCategories && this._focusedCategory;\n\n          if (this.showWarningText) {\n            messageManager.addMessageListener(\"FormAutofill:UpdateWarningMessage\", this._updateWarningNote);\n\n            this._updateWarningNote();\n          } else {\n            this._itemBox.setAttribute(\"no-warning\", \"true\");\n          }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-creditcard-insecure-field\" extends=\"chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base\">\n    <xbl:content xmlns=\"http://www.w3.org/1999/xhtml\">\n      <div anonid=\"autofill-item-box\" class=\"autofill-insecure-item\">\n      </div>\n    </xbl:content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n      <![CDATA[\n        this._itemBox = document.getAnonymousElementByAttribute(\n          this, \"anonid\", \"autofill-item-box\"\n        );\n\n        this._adjustAcItem();\n      ]]>\n      </constructor>\n\n      <property name=\"selected\" onget=\"return this.getAttribute('selected') == 'true';\">\n        <setter><![CDATA[\n          // Make this item unselectable since we see this item as a pure message.\n          return false;\n        ]]></setter>\n      </property>\n\n      <method name=\"_adjustAcItem\">\n        <body>\n        <![CDATA[\n          this._adjustAutofillItemLayout();\n          this.setAttribute(\"formautofillattached\", \"true\");\n\n          let value = this.getAttribute(\"ac-value\");\n          this._itemBox.textContent = value;\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-profile-listitem-clear-button\" extends=\"chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base\">\n    <xbl:content xmlns=\"http://www.w3.org/1999/xhtml\">\n      <div anonid=\"autofill-item-box\" class=\"autofill-item-box autofill-footer\">\n        <div anonid=\"autofill-clear-button\" class=\"autofill-footer-row autofill-button\"></div>\n      </div>\n    </xbl:content>\n\n    <handlers>\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        /* global Cu */\n        let {AutoCompletePopup} = ChromeUtils.import(\"resource://gre/modules/AutoCompletePopup.jsm\", {});\n\n        AutoCompletePopup.sendMessageToBrowser(\"FormAutofill:ClearForm\");\n      ]]></handler>\n    </handlers>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n      <![CDATA[\n        this._itemBox = document.getAnonymousElementByAttribute(\n          this, \"anonid\", \"autofill-item-box\"\n        );\n        this._clearBtn = document.getAnonymousElementByAttribute(\n          this, \"anonid\", \"autofill-clear-button\"\n        );\n\n        this._adjustAcItem();\n      ]]>\n      </constructor>\n\n      <method name=\"_adjustAcItem\">\n        <body>\n        <![CDATA[\n          this._adjustAutofillItemLayout();\n          this.setAttribute(\"formautofillattached\", \"true\");\n\n          let clearFormBtnLabel = this._stringBundle.GetStringFromName(\"clearFormBtnLabel2\");\n          this._clearBtn.textContent = clearFormBtnLabel;\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"organizer.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"organizerBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"toolbarbutton-dropdown\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:image class=\"menubar-left\" xbl:inherits=\"src=image\"/>\n      <xul:label class=\"menubar-text\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\"/>\n      <xul:hbox class=\"menubar-right\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"autocomplete.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"autocompleteBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"autocomplete\"\n           extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content sizetopopup=\"pref\">\n      <children includes=\"image|box\"/>\n\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\">\n        <children/>\n        <html:input anonid=\"input\" class=\"textbox-input\"\n                    allowevents=\"true\"\n                    autocomplete=\"off\"\n                    xbl:inherits=\"value,type=inputtype,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,mozactionhint\"/>\n      </xul:moz-input-box>\n      <children includes=\"hbox\"/>\n\n      <xul:popupset anonid=\"popupset\" class=\"autocomplete-result-popupset\"/>\n    </content>\n\n    <implementation implements=\"nsIAutoCompleteInput, nsIDOMXULMenuListElement\">\n      <field name=\"mController\">null</field>\n      <field name=\"mSearchNames\">null</field>\n      <field name=\"mIgnoreInput\">false</field>\n\n      <field name=\"_searchBeginHandler\">null</field>\n      <field name=\"_searchCompleteHandler\">null</field>\n      <field name=\"_textEnteredHandler\">null</field>\n      <field name=\"_textRevertedHandler\">null</field>\n\n      <constructor><![CDATA[\n        this.mController = Cc[\"@mozilla.org/autocomplete/controller;1\"].\n          getService(Ci.nsIAutoCompleteController);\n\n        this._searchBeginHandler = this.initEventHandler(\"searchbegin\");\n        this._searchCompleteHandler = this.initEventHandler(\"searchcomplete\");\n        this._textEnteredHandler = this.initEventHandler(\"textentered\");\n        this._textRevertedHandler = this.initEventHandler(\"textreverted\");\n\n        // For security reasons delay searches on pasted values.\n        this.inputField.controllers.insertControllerAt(0, this._pasteController);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        this.inputField.controllers.removeController(this._pasteController);\n      ]]></destructor>\n\n      <!-- =================== nsIAutoCompleteInput =================== -->\n\n      <field name=\"_popup\">null</field>\n      <property name=\"popup\" readonly=\"true\">\n        <getter><![CDATA[\n          // Memoize the result in a field rather than replacing this property,\n          // so that it can be reset along with the binding.\n          if (this._popup) {\n            return this._popup;\n          }\n\n          let popup = null;\n          let popupId = this.getAttribute(\"autocompletepopup\");\n          if (popupId) {\n            popup = document.getElementById(popupId);\n          }\n          if (!popup) {\n            popup = document.createXULElement(\"panel\");\n            popup.setAttribute(\"type\", \"autocomplete-richlistbox\");\n            popup.setAttribute(\"noautofocus\", \"true\");\n\n            let popupset = document.getAnonymousElementByAttribute(this, \"anonid\", \"popupset\");\n            popupset.appendChild(popup);\n          }\n          popup.mInput = this;\n\n          return this._popup = popup;\n        ]]></getter>\n      </property>\n\n      <property name=\"controller\" onget=\"return this.mController;\" readonly=\"true\"/>\n\n      <property name=\"popupOpen\"\n                onget=\"return this.popup.popupOpen;\"\n                onset=\"if (val) this.openPopup(); else this.closePopup();\"/>\n\n      <property name=\"disableAutoComplete\"\n                onset=\"this.setAttribute('disableautocomplete', val); return val;\"\n                onget=\"return this.getAttribute('disableautocomplete') == 'true';\"/>\n\n      <property name=\"completeDefaultIndex\"\n                onset=\"this.setAttribute('completedefaultindex', val); return val;\"\n                onget=\"return this.getAttribute('completedefaultindex') == 'true';\"/>\n\n      <property name=\"completeSelectedIndex\"\n                onset=\"this.setAttribute('completeselectedindex', val); return val;\"\n                onget=\"return this.getAttribute('completeselectedindex') == 'true';\"/>\n\n      <property name=\"forceComplete\"\n                onset=\"this.setAttribute('forcecomplete', val); return val;\"\n                onget=\"return this.getAttribute('forcecomplete') == 'true';\"/>\n\n      <property name=\"minResultsForPopup\"\n                onset=\"this.setAttribute('minresultsforpopup', val); return val;\"\n                onget=\"var m = parseInt(this.getAttribute('minresultsforpopup')); return isNaN(m) ? 1 : m;\"/>\n\n      <property name=\"timeout\"\n                onset=\"this.setAttribute('timeout', val); return val;\">\n        <getter><![CDATA[\n          // For security reasons delay searches on pasted values.\n          if (this._valueIsPasted) {\n            let t = parseInt(this.getAttribute(\"pastetimeout\"));\n            return isNaN(t) ? 1000 : t;\n          }\n\n          let t = parseInt(this.getAttribute(\"timeout\"));\n          return isNaN(t) ? 50 : t;\n        ]]></getter>\n      </property>\n\n      <property name=\"searchParam\"\n                onget=\"return this.getAttribute('autocompletesearchparam') || '';\"\n                onset=\"this.setAttribute('autocompletesearchparam', val); return val;\"/>\n\n      <property name=\"searchCount\" readonly=\"true\"\n                onget=\"this.initSearchNames(); return this.mSearchNames.length;\"/>\n\n      <property name=\"PrivateBrowsingUtils\" readonly=\"true\">\n        <getter><![CDATA[\n          let module = {};\n          ChromeUtils.import(\"resource://gre/modules/PrivateBrowsingUtils.jsm\", module);\n          Object.defineProperty(this, \"PrivateBrowsingUtils\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: module.PrivateBrowsingUtils,\n          });\n          return module.PrivateBrowsingUtils;\n        ]]></getter>\n      </property>\n\n      <property name=\"inPrivateContext\" readonly=\"true\"\n                onget=\"return this.PrivateBrowsingUtils.isWindowPrivate(window);\"/>\n\n      <property name=\"noRollupOnCaretMove\" readonly=\"true\"\n                onget=\"return this.popup.getAttribute('norolluponanchor') == 'true'\"/>\n\n      <!-- This is the maximum number of drop-down rows we get when we\n            hit the drop marker beside fields that have it (like the URLbar).-->\n      <field name=\"maxDropMarkerRows\" readonly=\"true\">14</field>\n\n      <method name=\"getSearchAt\">\n        <parameter name=\"aIndex\"/>\n        <body><![CDATA[\n          this.initSearchNames();\n          return this.mSearchNames[aIndex];\n        ]]></body>\n      </method>\n\n      <method name=\"setTextValueWithReason\">\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aReason\"/>\n        <body><![CDATA[\n          if (aReason == Ci.nsIAutoCompleteInput\n                           .TEXTVALUE_REASON_COMPLETEDEFAULT) {\n            this._textValueSetByCompleteDefault = true;\n          }\n          this.textValue = aValue;\n          this._textValueSetByCompleteDefault = false;\n        ]]></body>\n      </method>\n\n      <property name=\"textValue\">\n        <getter><![CDATA[\n          if (typeof this.onBeforeTextValueGet == \"function\") {\n            let result = this.onBeforeTextValueGet();\n            if (result) {\n              return result.value;\n            }\n          }\n          return this.value;\n        ]]></getter>\n        <setter><![CDATA[\n          if (typeof this.onBeforeTextValueSet == \"function\" &&\n              !this._textValueSetByCompleteDefault) {\n            val = this.onBeforeTextValueSet(val);\n          }\n\n          // \"input\" event is automatically dispatched by the editor if\n          // necessary.\n          this._setValueInternal(val, true);\n\n          return this.value;\n        ]]></setter>\n      </property>\n\n      <method name=\"selectTextRange\">\n        <parameter name=\"aStartIndex\"/>\n        <parameter name=\"aEndIndex\"/>\n        <body><![CDATA[\n          this.inputField.setSelectionRange(aStartIndex, aEndIndex);\n        ]]></body>\n      </method>\n\n      <method name=\"onSearchBegin\">\n        <body><![CDATA[\n          if (this.popup && typeof this.popup.onSearchBegin == \"function\")\n            this.popup.onSearchBegin();\n          if (this._searchBeginHandler)\n            this._searchBeginHandler();\n        ]]></body>\n      </method>\n\n      <method name=\"onSearchComplete\">\n        <body><![CDATA[\n          if (this.mController.matchCount == 0)\n            this.setAttribute(\"nomatch\", \"true\");\n          else\n            this.removeAttribute(\"nomatch\");\n\n          if (this.ignoreBlurWhileSearching && !this.focused) {\n            this.handleEnter();\n            this.detachController();\n          }\n\n          if (this._searchCompleteHandler)\n            this._searchCompleteHandler();\n        ]]></body>\n      </method>\n\n      <method name=\"onTextEntered\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let rv = false;\n          if (this._textEnteredHandler) {\n            rv = this._textEnteredHandler(event);\n          }\n          return rv;\n        ]]></body>\n      </method>\n\n      <method name=\"onTextReverted\">\n        <body><![CDATA[\n          if (this._textRevertedHandler)\n            return this._textRevertedHandler();\n          return false;\n        ]]></body>\n      </method>\n\n      <!-- =================== nsIDOMXULMenuListElement =================== -->\n\n      <property name=\"editable\" readonly=\"true\"\n                onget=\"return true;\" />\n\n      <property name=\"crop\"\n                onset=\"this.setAttribute('crop',val); return val;\"\n                onget=\"return this.getAttribute('crop');\"/>\n\n      <property name=\"open\"\n                onget=\"return this.getAttribute('open') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.showHistoryPopup();\n          else\n            this.closePopup();\n        ]]></setter>\n      </property>\n\n      <!-- =================== PUBLIC MEMBERS =================== -->\n\n      <field name=\"valueIsTyped\">false</field>\n      <field name=\"_textValueSetByCompleteDefault\">false</field>\n      <property name=\"value\"\n                onset=\"return this._setValueInternal(val, false);\">\n        <getter><![CDATA[\n          if (typeof this.onBeforeValueGet == \"function\") {\n            var result = this.onBeforeValueGet();\n            if (result)\n              return result.value;\n          }\n          return this.inputField.value;\n        ]]></getter>\n      </property>\n\n      <property name=\"focused\" readonly=\"true\"\n                onget=\"return this.getAttribute('focused') == 'true';\"/>\n\n      <!-- maximum number of rows to display at a time -->\n      <property name=\"maxRows\"\n                onset=\"this.setAttribute('maxrows', val); return val;\"\n                onget=\"return parseInt(this.getAttribute('maxrows')) || 0;\"/>\n\n      <!-- option to allow scrolling through the list via the tab key, rather than\n           tab moving focus out of the textbox -->\n      <property name=\"tabScrolling\"\n                onset=\"this.setAttribute('tabscrolling', val); return val;\"\n                onget=\"return this.getAttribute('tabscrolling') == 'true';\"/>\n\n      <!-- option to completely ignore any blur events while searches are\n           still going on. -->\n      <property name=\"ignoreBlurWhileSearching\"\n                onset=\"this.setAttribute('ignoreblurwhilesearching', val); return val;\"\n                onget=\"return this.getAttribute('ignoreblurwhilesearching') == 'true';\"/>\n\n      <!-- option to highlight entries that don't have any matches -->\n      <property name=\"highlightNonMatches\"\n                onset=\"this.setAttribute('highlightnonmatches', val); return val;\"\n                onget=\"return this.getAttribute('highlightnonmatches') == 'true';\"/>\n\n      <!-- =================== PRIVATE MEMBERS =================== -->\n\n      <!-- ::::::::::::: autocomplete controller ::::::::::::: -->\n\n      <method name=\"attachController\">\n        <body><![CDATA[\n          this.mController.input = this;\n        ]]></body>\n      </method>\n\n      <method name=\"detachController\">\n        <body><![CDATA[\n          if (this.mController.input == this)\n            this.mController.input = null;\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: popup opening ::::::::::::: -->\n\n      <method name=\"openPopup\">\n        <body><![CDATA[\n          if (this.focused)\n            this.popup.openAutocompletePopup(this, this);\n        ]]></body>\n      </method>\n\n      <method name=\"closePopup\">\n        <body><![CDATA[\n          this.popup.closePopup();\n        ]]></body>\n      </method>\n\n      <method name=\"showHistoryPopup\">\n        <body><![CDATA[\n          // Store our \"normal\" maxRows on the popup, so that it can reset the\n          // value when the popup is hidden.\n          this.popup._normalMaxRows = this.maxRows;\n\n          // Increase our maxRows temporarily, since we want the dropdown to\n          // be bigger in this case. The popup's popupshowing/popuphiding\n          // handlers will take care of resetting this.\n          this.maxRows = this.maxDropMarkerRows;\n\n          // Ensure that we have focus.\n          if (!this.focused)\n            this.focus();\n          this.attachController();\n          this.mController.startSearch(\"\");\n        ]]></body>\n      </method>\n\n      <method name=\"toggleHistoryPopup\">\n        <body><![CDATA[\n          if (!this.popup.popupOpen)\n            this.showHistoryPopup();\n          else\n            this.closePopup();\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: event dispatching ::::::::::::: -->\n\n      <method name=\"initEventHandler\">\n        <parameter name=\"aEventType\"/>\n        <body><![CDATA[\n          let handlerString = this.getAttribute(\"on\" + aEventType);\n          if (handlerString) {\n            return (new Function(\"eventType\", \"param\", handlerString)).bind(this, aEventType);\n          }\n          return null;\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: key handling ::::::::::::: -->\n\n      <field name=\"_selectionDetails\">null</field>\n      <method name=\"onKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          return this.handleKeyPress(aEvent);\n        ]]></body>\n      </method>\n\n      <method name=\"handleKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aOptions\"/>\n        <body><![CDATA[\n          if (aEvent.target.localName != \"textbox\")\n            return true; // Let child buttons of autocomplete take input\n\n          // Re: urlbarDeferred, see the comment in urlbarBindings.xml.\n          if (aEvent.defaultPrevented && !aEvent.urlbarDeferred) {\n            return false;\n          }\n\n          const isMac = /Mac/.test(navigator.platform);\n          var cancel = false;\n\n          // Catch any keys that could potentially move the caret. Ctrl can be\n          // used in combination with these keys on Windows and Linux; and Alt\n          // can be used on OS X, so make sure the unused one isn't used.\n          let metaKey = isMac ? aEvent.ctrlKey : aEvent.altKey;\n          if (!metaKey) {\n            switch (aEvent.keyCode) {\n              case KeyEvent.DOM_VK_LEFT:\n              case KeyEvent.DOM_VK_RIGHT:\n              case KeyEvent.DOM_VK_HOME:\n                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);\n                break;\n            }\n          }\n\n          // Handle keys that are not part of a keyboard shortcut (no Ctrl or Alt)\n          if (!aEvent.ctrlKey && !aEvent.altKey) {\n            switch (aEvent.keyCode) {\n              case KeyEvent.DOM_VK_TAB:\n                if (this.tabScrolling && this.popup.popupOpen)\n                  cancel = this.mController.handleKeyNavigation(aEvent.shiftKey ?\n                                                                KeyEvent.DOM_VK_UP :\n                                                                KeyEvent.DOM_VK_DOWN);\n                else if (this.forceComplete && this.mController.matchCount >= 1)\n                  this.mController.handleTab();\n                break;\n              case KeyEvent.DOM_VK_UP:\n              case KeyEvent.DOM_VK_DOWN:\n              case KeyEvent.DOM_VK_PAGE_UP:\n              case KeyEvent.DOM_VK_PAGE_DOWN:\n                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);\n                break;\n            }\n          }\n\n          // Handle readline/emacs-style navigation bindings on Mac.\n          if (isMac &&\n              this.popup.popupOpen &&\n              aEvent.ctrlKey &&\n              (aEvent.key === \"n\" || aEvent.key === \"p\")) {\n\n            const effectiveKey = (aEvent.key === \"p\") ?\n                                 KeyEvent.DOM_VK_UP :\n                                 KeyEvent.DOM_VK_DOWN;\n            cancel = this.mController.handleKeyNavigation(effectiveKey);\n          }\n\n          // Handle keys we know aren't part of a shortcut, even with Alt or\n          // Ctrl.\n          switch (aEvent.keyCode) {\n            case KeyEvent.DOM_VK_ESCAPE:\n              cancel = this.mController.handleEscape();\n              break;\n            case KeyEvent.DOM_VK_RETURN:\n              if (isMac) {\n                // Prevent the default action, since it will beep on Mac\n                if (aEvent.metaKey)\n                  aEvent.preventDefault();\n              }\n              if (this.popup.selectedIndex >= 0) {\n                this._selectionDetails = {\n                  index: this.popup.selectedIndex,\n                  kind: \"key\",\n                };\n              }\n              cancel = this.handleEnter(aEvent, aOptions);\n              break;\n            case KeyEvent.DOM_VK_DELETE:\n              if (isMac && !aEvent.shiftKey) {\n                break;\n              }\n              cancel = this.handleDelete();\n              break;\n            case KeyEvent.DOM_VK_BACK_SPACE:\n              if (isMac && aEvent.shiftKey) {\n                cancel = this.handleDelete();\n              }\n              break;\n            case KeyEvent.DOM_VK_DOWN:\n            case KeyEvent.DOM_VK_UP:\n              if (aEvent.altKey)\n                this.toggleHistoryPopup();\n              break;\n            case KeyEvent.DOM_VK_F4:\n              if (!isMac) {\n                this.toggleHistoryPopup();\n              }\n              break;\n          }\n\n          if (cancel) {\n            aEvent.stopPropagation();\n            aEvent.preventDefault();\n          }\n\n          return true;\n        ]]></body>\n      </method>\n\n      <method name=\"handleEnter\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          return this.mController.handleEnter(false, event || null);\n        ]]></body>\n      </method>\n\n      <method name=\"handleDelete\">\n        <body><![CDATA[\n          return this.mController.handleDelete();\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: miscellaneous ::::::::::::: -->\n\n      <method name=\"initSearchNames\">\n        <body><![CDATA[\n          if (!this.mSearchNames) {\n            var names = this.getAttribute(\"autocompletesearch\");\n            if (!names)\n              this.mSearchNames = [];\n            else\n              this.mSearchNames = names.split(\" \");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_focus\">\n        <!-- doesn't reset this.mController -->\n        <body><![CDATA[\n          this._dontBlur = true;\n          this.focus();\n          this._dontBlur = false;\n        ]]></body>\n      </method>\n\n      <method name=\"resetActionType\">\n        <body><![CDATA[\n          if (this.mIgnoreInput)\n            return;\n          this.removeAttribute(\"actiontype\");\n        ]]></body>\n      </method>\n\n      <field name=\"_valueIsPasted\">false</field>\n      <field name=\"_pasteController\"><![CDATA[\n        ({\n          _autocomplete: this,\n          _kGlobalClipboard: Ci.nsIClipboard.kGlobalClipboard,\n          supportsCommand: aCommand => aCommand == \"cmd_paste\",\n          doCommand(aCommand) {\n            this._autocomplete._valueIsPasted = true;\n            this._autocomplete.editor.paste(this._kGlobalClipboard);\n            this._autocomplete._valueIsPasted = false;\n          },\n          isCommandEnabled(aCommand) {\n            return this._autocomplete.editor.isSelectionEditable &&\n                   this._autocomplete.editor.canPaste(this._kGlobalClipboard);\n          },\n          onEvent() {},\n        })\n      ]]></field>\n\n      <method name=\"_setValueInternal\">\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aIsUserInput\"/>\n        <body><![CDATA[\n          this.mIgnoreInput = true;\n\n          if (typeof this.onBeforeValueSet == \"function\")\n            aValue = this.onBeforeValueSet(aValue);\n\n          if (typeof this.trimValue == \"function\" &&\n              !this._textValueSetByCompleteDefault)\n            aValue = this.trimValue(aValue);\n\n          this.valueIsTyped = false;\n          if (aIsUserInput) {\n            this.inputField.setUserInput(aValue);\n          } else {\n            this.inputField.value = aValue;\n          }\n\n          if (typeof this.formatValue == \"function\")\n            this.formatValue();\n\n          this.mIgnoreInput = false;\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"ValueChange\", true, true);\n          this.inputField.dispatchEvent(event);\n          return aValue;\n        ]]></body>\n      </method>\n\n      <method name=\"onInput\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this.mIgnoreInput && this.mController.input == this) {\n            this.valueIsTyped = true;\n            this.mController.handleText();\n          }\n          this.resetActionType();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"input\"><![CDATA[\n        this.onInput(event);\n      ]]></handler>\n\n      <handler event=\"keypress\" phase=\"capturing\" group=\"system\"\n               action=\"return this.onKeyPress(event);\"/>\n\n      <handler event=\"compositionstart\" phase=\"capturing\"\n               action=\"if (this.mController.input == this) this.mController.handleStartComposition();\"/>\n\n      <handler event=\"compositionend\" phase=\"capturing\"\n               action=\"if (this.mController.input == this) this.mController.handleEndComposition();\"/>\n\n      <handler event=\"focus\" phase=\"capturing\"><![CDATA[\n        this.attachController();\n        if (window.gBrowser && window.gBrowser.selectedBrowser.hasAttribute(\"usercontextid\")) {\n          this.userContextId = parseInt(window.gBrowser.selectedBrowser.getAttribute(\"usercontextid\"));\n        } else {\n          this.userContextId = 0;\n        }\n      ]]></handler>\n\n      <handler event=\"blur\" phase=\"capturing\"><![CDATA[\n        if (!this._dontBlur) {\n          if (this.forceComplete && this.mController.matchCount >= 1) {\n            // If forceComplete is requested, we need to call the enter processing\n            // on blur so the input will be forced to the closest match.\n            // Thunderbird is the only consumer of forceComplete and this is used\n            // to force an recipient's email to the exact address book entry.\n            this.mController.handleEnter(true);\n          }\n          if (!this.ignoreBlurWhileSearching)\n            this.detachController();\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autocomplete-rich-result-popup\" extends=\"chrome://global/content/bindings/popup.xml#popup\">\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\">\n      <xul:richlistbox anonid=\"richlistbox\" class=\"autocomplete-richlistbox\" flex=\"1\"/>\n      <xul:hbox>\n        <children/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIAutoCompletePopup\">\n      <field name=\"mInput\">null</field>\n      <field name=\"mPopupOpen\">false</field>\n      <field name=\"_currentIndex\">0</field>\n\n      <constructor><![CDATA[\n        if (!this.listEvents) {\n          this.listEvents = {\n            handleEvent: event => {\n              if (!this.parentNode) {\n                return;\n              }\n\n              switch (event.type) {\n                case \"mouseup\":\n                  // Don't call onPopupClick for the scrollbar buttons, thumb,\n                  // slider, etc. If we hit the richlistbox and not a\n                  // richlistitem, we ignore the event.\n                  if (event.target.closest(\"richlistbox,richlistitem\")\n                                  .localName == \"richlistitem\") {\n                    this.onPopupClick(event);\n                  }\n                  break;\n                case \"mousemove\":\n                  if (Date.now() - this.mLastMoveTime <= 30) {\n                    return;\n                  }\n\n                  let item = event.target.closest(\"richlistbox,richlistitem\");\n\n                  // If we hit the richlistbox and not a richlistitem, we ignore\n                  // the event.\n                  if (item.localName == \"richlistbox\") {\n                    return;\n                  }\n\n                  let index = this.richlistbox.getIndexOfItem(item);\n\n                  this.mousedOverIndex = index;\n\n                  if (item.selectedByMouseOver) {\n                    this.richlistbox.selectedIndex = index;\n                  }\n\n                  this.mLastMoveTime = Date.now();\n                  break;\n              }\n            },\n          };\n          this.richlistbox.addEventListener(\"mouseup\", this.listEvents);\n          this.richlistbox.addEventListener(\"mousemove\", this.listEvents);\n        }\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        if (this.listEvents) {\n          this.richlistbox.removeEventListener(\"mouseup\", this.listEvents);\n          this.richlistbox.removeEventListener(\"mousemove\", this.listEvents);\n          delete this.listEvents;\n        }\n      ]]></destructor>\n\n      <!-- =================== nsIAutoCompletePopup =================== -->\n\n      <property name=\"input\" readonly=\"true\"\n                onget=\"return this.mInput\"/>\n\n      <property name=\"overrideValue\" readonly=\"true\"\n                onget=\"return null;\"/>\n\n      <property name=\"popupOpen\" readonly=\"true\"\n                onget=\"return this.mPopupOpen;\"/>\n\n      <method name=\"closePopup\">\n        <body>\n          <![CDATA[\n          if (this.mPopupOpen) {\n            this.hidePopup();\n            this.removeAttribute(\"width\");\n          }\n        ]]>\n        </body>\n      </method>\n\n      <!-- This is the default number of rows that we give the autocomplete\n           popup when the textbox doesn't have a \"maxrows\" attribute\n           for us to use. -->\n      <field name=\"defaultMaxRows\" readonly=\"true\">6</field>\n\n      <!-- In some cases (e.g. when the input's dropmarker button is clicked),\n           the input wants to display a popup with more rows. In that case, it\n           should increase its maxRows property and store the \"normal\" maxRows\n           in this field. When the popup is hidden, we restore the input's\n           maxRows to the value stored in this field.\n\n           This field is set to -1 between uses so that we can tell when it's\n           been set by the input and when we need to set it in the popupshowing\n           handler. -->\n      <field name=\"_normalMaxRows\">-1</field>\n\n      <property name=\"maxRows\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n          return (this.mInput && this.mInput.maxRows) || this.defaultMaxRows;\n        ]]>\n        </getter>\n      </property>\n\n      <method name=\"getNextIndex\">\n        <parameter name=\"aReverse\"/>\n        <parameter name=\"aAmount\"/>\n        <parameter name=\"aIndex\"/>\n        <parameter name=\"aMaxRow\"/>\n        <body><![CDATA[\n          if (aMaxRow < 0)\n            return -1;\n\n          var newIdx = aIndex + (aReverse ? -1 : 1) * aAmount;\n          if (aReverse && aIndex == -1 || newIdx > aMaxRow && aIndex != aMaxRow)\n            newIdx = aMaxRow;\n          else if (!aReverse && aIndex == -1 || newIdx < 0 && aIndex != 0)\n            newIdx = 0;\n\n          if (newIdx < 0 && aIndex == 0 || newIdx > aMaxRow && aIndex == aMaxRow)\n            aIndex = -1;\n          else\n            aIndex = newIdx;\n\n          return aIndex;\n        ]]></body>\n      </method>\n\n      <method name=\"onPopupClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          this.input.controller.handleEnter(true, aEvent);\n        ]]></body>\n      </method>\n\n      <property name=\"selectedIndex\"\n                onget=\"return this.richlistbox.selectedIndex;\">\n        <setter>\n          <![CDATA[\n          if (val != this.richlistbox.selectedIndex) {\n            this._previousSelectedIndex = this.richlistbox.selectedIndex;\n          }\n          this.richlistbox.selectedIndex = val;\n          // Since ensureElementIsVisible may cause an expensive Layout flush,\n          // invoke it only if there may be a scrollbar, so if we could fetch\n          // more results than we can show at once.\n          // maxResults is the maximum number of fetched results, maxRows is the\n          // maximum number of rows we show at once, without a scrollbar.\n          if (this.mPopupOpen && this.maxResults > this.maxRows) {\n            // when clearing the selection (val == -1, so selectedItem will be\n            // null), we want to scroll back to the top.  see bug #406194\n            this.richlistbox.ensureElementIsVisible(\n              this.richlistbox.selectedItem || this.richlistbox.firstElementChild);\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <field name=\"_previousSelectedIndex\">-1</field>\n      <field name=\"mLastMoveTime\">Date.now()</field>\n      <field name=\"mousedOverIndex\">-1</field>\n\n      <method name=\"onSearchBegin\">\n        <body><![CDATA[\n          this.mousedOverIndex = -1;\n\n          if (typeof this._onSearchBegin == \"function\") {\n            this._onSearchBegin();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          // until we have \"baseBinding\", (see bug #373652) this allows\n          // us to override openAutocompletePopup(), but still call\n          // the method on the base class\n          this._openAutocompletePopup(aInput, aElement);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          if (!this.mPopupOpen) {\n            // It's possible that the panel is hidden initially\n            // to avoid impacting startup / new window performance\n            aInput.popup.hidden = false;\n\n            this.mInput = aInput;\n            // clear any previous selection, see bugs 400671 and 488357\n            this.selectedIndex = -1;\n\n            var width = aElement.getBoundingClientRect().width;\n            this.setAttribute(\"width\", width > 100 ? width : 100);\n            // invalidate() depends on the width attribute\n            this._invalidate();\n\n            this.openPopup(aElement, \"after_start\", 0, 0, false, false);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"invalidate\">\n        <parameter name=\"reason\"/>\n        <body>\n          <![CDATA[\n          // Don't bother doing work if we're not even showing\n          if (!this.mPopupOpen)\n            return;\n\n          this._invalidate(reason);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_invalidate\">\n        <parameter name=\"reason\"/>\n        <body>\n          <![CDATA[\n          // collapsed if no matches\n          this.richlistbox.collapsed = (this.matchCount == 0);\n\n          // Update the richlistbox height.\n          if (this._adjustHeightRAFToken) {\n            cancelAnimationFrame(this._adjustHeightRAFToken);\n            this._adjustHeightRAFToken = null;\n          }\n\n          if (this.mPopupOpen) {\n            delete this._adjustHeightOnPopupShown;\n            this._adjustHeightRAFToken = requestAnimationFrame(() => this.adjustHeight());\n          } else {\n            this._adjustHeightOnPopupShown = true;\n          }\n\n          this._currentIndex = 0;\n          if (this._appendResultTimeout) {\n            clearTimeout(this._appendResultTimeout);\n          }\n          this._appendCurrentResult(reason);\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"maxResults\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            // This is how many richlistitems will be kept around.\n            // Note, this getter may be overridden, or instances\n            // can have the nomaxresults attribute set to have no\n            // limit.\n            if (this.getAttribute(\"nomaxresults\") == \"true\") {\n              return Infinity;\n            }\n\n            return 20;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"matchCount\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n          return Math.min(this.mInput.controller.matchCount, this.maxResults);\n          ]]>\n        </getter>\n      </property>\n\n      <method name=\"_collapseUnusedItems\">\n        <body>\n          <![CDATA[\n            let existingItemsCount = this.richlistbox.children.length;\n            for (let i = this.matchCount; i < existingItemsCount; ++i) {\n              let item = this.richlistbox.children[i];\n\n              item.collapsed = true;\n              if (typeof item._onCollapse == \"function\") {\n                item._onCollapse();\n              }\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"adjustHeight\">\n        <body>\n          <![CDATA[\n          // Figure out how many rows to show\n          let rows = this.richlistbox.children;\n          let numRows = Math.min(this.matchCount, this.maxRows, rows.length);\n\n          // Default the height to 0 if we have no rows to show\n          let height = 0;\n          if (numRows) {\n            let firstRowRect = rows[0].getBoundingClientRect();\n            if (this._rlbPadding == undefined) {\n              let style = window.getComputedStyle(this.richlistbox);\n              let paddingTop = parseInt(style.paddingTop) || 0;\n              let paddingBottom = parseInt(style.paddingBottom) || 0;\n              this._rlbPadding = paddingTop + paddingBottom;\n            }\n\n            // The class `forceHandleUnderflow` is for the item might need to\n            // handle OverUnderflow or Overflow when the height of an item will\n            // be changed dynamically.\n            for (let i = 0; i < numRows; i++) {\n              if (rows[i].classList.contains(\"forceHandleUnderflow\")) {\n                rows[i].handleOverUnderflow();\n              }\n            }\n\n            let lastRowRect = rows[numRows - 1].getBoundingClientRect();\n            // Calculate the height to have the first row to last row shown\n            height = lastRowRect.bottom - firstRowRect.top +\n                     this._rlbPadding;\n          }\n\n          let currentHeight = this.richlistbox.getBoundingClientRect().height;\n          if (height <= currentHeight) {\n            this._collapseUnusedItems();\n          }\n          this.richlistbox.style.removeProperty(\"height\");\n          this.richlistbox.height = height;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_appendCurrentResult\">\n        <parameter name=\"invalidateReason\"/>\n        <body>\n          <![CDATA[\n          var controller = this.mInput.controller;\n          var matchCount = this.matchCount;\n          var existingItemsCount = this.richlistbox.children.length;\n\n          // Process maxRows per chunk to improve performance and user experience\n          for (let i = 0; i < this.maxRows; i++) {\n            if (this._currentIndex >= matchCount) {\n              break;\n            }\n            let item;\n            let reusable = false;\n            let itemExists = this._currentIndex < existingItemsCount;\n\n            let originalValue, originalText, originalType;\n            let style = controller.getStyleAt(this._currentIndex);\n            let value =\n              style && style.includes(\"autofill\") ?\n              controller.getFinalCompleteValueAt(this._currentIndex) :\n              controller.getValueAt(this._currentIndex);\n            let label = controller.getLabelAt(this._currentIndex);\n            let comment = controller.getCommentAt(this._currentIndex);\n            let image = controller.getImageAt(this._currentIndex);\n            // trim the leading/trailing whitespace\n            let trimmedSearchString = controller.searchString.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n\n            if (itemExists) {\n              item = this.richlistbox.children[this._currentIndex];\n\n              // Url may be a modified version of value, see _adjustAcItem().\n              originalValue = item.getAttribute(\"url\") || item.getAttribute(\"ac-value\");\n              originalText = item.getAttribute(\"ac-text\");\n              originalType = item.getAttribute(\"originaltype\");\n\n              // The styles on the list which have different <content> structure and overrided\n              // _adjustAcItem() are unreusable.\n              const UNREUSEABLE_STYLES = [\n                \"autofill-profile\",\n                \"autofill-footer\",\n                \"autofill-clear-button\",\n                \"autofill-insecureWarning\",\n              ];\n              // Reuse the item when its style is exactly equal to the previous style or\n              // neither of their style are in the UNREUSEABLE_STYLES.\n              reusable = originalType === style ||\n                !(UNREUSEABLE_STYLES.includes(style) || UNREUSEABLE_STYLES.includes(originalType));\n\n            } else {\n              // need to create a new item\n              item = document.createXULElement(\"richlistitem\");\n            }\n\n            item.setAttribute(\"dir\", this.style.direction);\n            item.setAttribute(\"ac-image\", image);\n            item.setAttribute(\"ac-value\", value);\n            item.setAttribute(\"ac-label\", label);\n            item.setAttribute(\"ac-comment\", comment);\n            item.setAttribute(\"ac-text\", trimmedSearchString);\n\n            // Completely reuse the existing richlistitem for invalidation\n            // due to new results, but only when: the item is the same, *OR*\n            // we are about to replace the currently moused-over item, to\n            // avoid surprising the user.\n            let iface = Ci.nsIAutoCompletePopup;\n            if (reusable &&\n                originalText == trimmedSearchString &&\n                invalidateReason == iface.INVALIDATE_REASON_NEW_RESULT &&\n                (originalValue == value ||\n                 this.mousedOverIndex === this._currentIndex)) {\n\n              // try to re-use the existing item\n              let reused = item._reuseAcItem();\n              if (reused) {\n                this._currentIndex++;\n                continue;\n              }\n            } else {\n              if (typeof item._cleanup == \"function\") {\n                item._cleanup();\n              }\n              item.setAttribute(\"originaltype\", style);\n            }\n\n            if (itemExists) {\n              // Adjust only when the result's type is reusable for existing\n              // item's. Otherwise, we might insensibly call old _adjustAcItem()\n              // as new binding has not been attached yet.\n              // We don't need to worry about switching to new binding, since\n              // _adjustAcItem() will fired by its own constructor accordingly.\n              if (reusable) {\n                item._adjustAcItem();\n              }\n              item.collapsed = false;\n            } else {\n              // set the class at the end so we can use the attributes\n              // in the xbl constructor\n              item.className = \"autocomplete-richlistitem\";\n              this.richlistbox.appendChild(item);\n            }\n\n            this._currentIndex++;\n          }\n\n          if (typeof this.onResultsAdded == \"function\") {\n            // The items bindings may not be attached yet, so we must delay this\n            // before we can properly handle items properly without breaking\n            // the richlistbox.\n            Services.tm.dispatchToMainThread(() => this.onResultsAdded());\n          }\n\n          if (this._currentIndex < matchCount) {\n            // yield after each batch of items so that typing the url bar is\n            // responsive\n            this._appendResultTimeout = setTimeout(() => this._appendCurrentResult(), 0);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"overflowPadding\"\n                onget=\"return Number(this.getAttribute('overflowpadding'))\"\n                readonly=\"true\" />\n\n      <method name=\"selectBy\">\n        <parameter name=\"aReverse\"/>\n        <parameter name=\"aPage\"/>\n        <body>\n          <![CDATA[\n          try {\n            var amount = aPage ? 5 : 1;\n\n            // because we collapsed unused items, we can't use this.richlistbox.getRowCount(), we need to use the matchCount\n            this.selectedIndex = this.getNextIndex(aReverse, amount, this.selectedIndex, this.matchCount - 1);\n            if (this.selectedIndex == -1) {\n              this.input._focus();\n            }\n          } catch (ex) {\n            // do nothing - occasionally timer-related js errors happen here\n            // e.g. \"this.selectedIndex has no properties\", when you type fast and hit a\n            // navigation key before this popup has opened\n          }\n            ]]>\n        </body>\n      </method>\n\n      <field name=\"richlistbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"richlistbox\");\n      </field>\n\n      <property name=\"view\"\n                onget=\"return this.mInput.controller;\"\n                onset=\"return val;\"/>\n\n    </implementation>\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // If normalMaxRows wasn't already set by the input, then set it here\n        // so that we restore the correct number when the popup is hidden.\n\n        // Null-check this.mInput; see bug 1017914\n        if (this._normalMaxRows < 0 && this.mInput) {\n          this._normalMaxRows = this.mInput.maxRows;\n        }\n\n        // Set an attribute for styling the popup based on the input.\n        let inputID = \"\";\n        if (this.mInput && this.mInput.ownerDocument &&\n            this.mInput.ownerDocument.documentURIObject.schemeIs(\"chrome\")) {\n          inputID = this.mInput.id;\n          // Take care of elements with no id that are inside xbl bindings\n          if (!inputID) {\n            let bindingParent = this.mInput.ownerDocument.getBindingParent(this.mInput);\n            if (bindingParent) {\n              inputID = bindingParent.id;\n            }\n          }\n        }\n        this.setAttribute(\"autocompleteinput\", inputID);\n\n        this.mPopupOpen = true;\n      ]]></handler>\n\n      <handler event=\"popupshown\">\n        <![CDATA[\n          if (this._adjustHeightOnPopupShown) {\n            delete this._adjustHeightOnPopupShown;\n            this.adjustHeight();\n          }\n      ]]>\n      </handler>\n\n      <handler event=\"popuphiding\"><![CDATA[\n        var isListActive = true;\n        if (this.selectedIndex == -1)\n          isListActive = false;\n        this.input.controller.stopSearch();\n\n        this.removeAttribute(\"autocompleteinput\");\n        this.mPopupOpen = false;\n\n        // Reset the maxRows property to the cached \"normal\" value (if there's\n        // any), and reset normalMaxRows so that we can detect whether it was set\n        // by the input when the popupshowing handler runs.\n\n        // Null-check this.mInput; see bug 1017914\n        if (this.mInput && this._normalMaxRows > 0) {\n          this.mInput.maxRows = this._normalMaxRows;\n        }\n        this._normalMaxRows = -1;\n        // If the list was being navigated and then closed, make sure\n        // we fire accessible focus event back to textbox\n\n        // Null-check this.mInput; see bug 1017914\n        if (isListActive && this.mInput) {\n          this.mInput.mIgnoreFocus = true;\n          this.mInput._focus();\n          this.mInput.mIgnoreFocus = false;\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autocomplete-richlistitem-insecure-field\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-richlistitem\">\n    <content align=\"center\"\n             onoverflow=\"this._onOverflow();\"\n             onunderflow=\"this._onUnderflow();\">\n      <xul:image anonid=\"type-icon\"\n                 class=\"ac-type-icon\"\n                 xbl:inherits=\"selected,current,type\"/>\n      <xul:image anonid=\"site-icon\"\n                 class=\"ac-site-icon\"\n                 xbl:inherits=\"src=image,selected,type\"/>\n      <xul:vbox class=\"ac-title\"\n                align=\"left\"\n                xbl:inherits=\"\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"title-text\"\n                           class=\"ac-title-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:vbox>\n      <xul:hbox anonid=\"tags\"\n                class=\"ac-tags\"\n                align=\"center\"\n                xbl:inherits=\"selected\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"tags-text\"\n                           class=\"ac-tags-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox anonid=\"separator\"\n                class=\"ac-separator\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype,type\">\n        <xul:description class=\"ac-separator-text\">—</xul:description>\n      </xul:hbox>\n      <xul:hbox class=\"ac-url\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"url-text\"\n                           class=\"ac-url-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox class=\"ac-action\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"action-text\"\n                           class=\"ac-action-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n    </content>\n\n    <handlers>\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        let baseURL = this.Services.urlFormatter.formatURLPref(\"app.support.baseURL\");\n        window.openTrustedLinkIn(baseURL + \"insecure-password\", \"tab\", {\n          relatedToCurrent: true,\n        });\n      ]]></handler>\n    </handlers>\n\n    <implementation>\n      <constructor><![CDATA[\n        // Unlike other autocomplete items, the height of the insecure warning\n        // increases by wrapping. So \"forceHandleUnderflow\" is for container to\n        // recalculate an item's height and width.\n        this.classList.add(\"forceHandleUnderflow\");\n      ]]></constructor>\n\n      <property name=\"_learnMoreString\">\n        <getter><![CDATA[\n          if (!this.__learnMoreString) {\n            this.__learnMoreString =\n              this.Services.strings.createBundle(\"chrome://passwordmgr/locale/passwordmgr.properties\").\n              GetStringFromName(\"insecureFieldWarningLearnMore\");\n          }\n          return this.__learnMoreString;\n        ]]></getter>\n      </property>\n\n      <!-- Override _getSearchTokens to have the Learn More text emphasized -->\n      <method name=\"_getSearchTokens\">\n        <parameter name=\"aSearch\"/>\n        <body>\n          <![CDATA[\n            return [this._learnMoreString.toLowerCase()];\n          ]]>\n        </body>\n      </method>\n\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-richlistitem\" extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n\n    <content align=\"center\"\n             onoverflow=\"this._onOverflow();\"\n             onunderflow=\"this._onUnderflow();\">\n      <xul:image anonid=\"type-icon\"\n                 class=\"ac-type-icon\"\n                 xbl:inherits=\"selected,current,type\"/>\n      <xul:image anonid=\"site-icon\"\n                 class=\"ac-site-icon\"\n                 xbl:inherits=\"src=image,selected,type\"/>\n      <xul:hbox class=\"ac-title\"\n                align=\"center\"\n                xbl:inherits=\"selected\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"title-text\"\n                           class=\"ac-title-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox anonid=\"tags\"\n                class=\"ac-tags\"\n                align=\"center\"\n                xbl:inherits=\"selected\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"tags-text\"\n                           class=\"ac-tags-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox anonid=\"separator\"\n                class=\"ac-separator\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype,type\">\n        <xul:description class=\"ac-separator-text\">—</xul:description>\n      </xul:hbox>\n      <xul:hbox class=\"ac-url\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"url-text\"\n                           class=\"ac-url-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox class=\"ac-action\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"action-text\"\n                           class=\"ac-action-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n        <![CDATA[\n          this._typeIcon = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"type-icon\"\n          );\n          this._siteIcon = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"site-icon\"\n          );\n          this._titleText = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"title-text\"\n          );\n          this._tags = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"tags\"\n          );\n          this._tagsText = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"tags-text\"\n          );\n          this._separator = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"separator\"\n          );\n          this._urlText = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"url-text\"\n          );\n          this._actionText = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"action-text\"\n          );\n          this._adjustAcItem();\n        ]]>\n      </constructor>\n\n      <property name=\"Services\" readonly=\"true\">\n        <getter><![CDATA[\n          let module = {};\n          if (window.Services) {\n            module.Services = window.Services;\n          } else {\n            ChromeUtils.import(\"resource://gre/modules/Services.jsm\", module);\n          }\n          Object.defineProperty(this, \"Services\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: module.Services,\n          });\n          return module.Services;\n        ]]></getter>\n      </property>\n\n      <method name=\"_cleanup\">\n        <body>\n        <![CDATA[\n          this.removeAttribute(\"url\");\n          this.removeAttribute(\"image\");\n          this.removeAttribute(\"title\");\n          this.removeAttribute(\"text\");\n          this.removeAttribute(\"displayurl\");\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"label\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            // This property is a string that is read aloud by screen readers,\n            // so it must not contain anything that should not be user-facing.\n\n            let parts = [\n              this.getAttribute(\"title\"),\n              this.getAttribute(\"displayurl\"),\n            ];\n            let label = parts.filter(str => str).join(\" \");\n\n            // allow consumers that have extended popups to override\n            // the label values for the richlistitems\n            let panel = this.parentNode.parentNode;\n            if (panel.createResultLabel) {\n              return panel.createResultLabel(this, label);\n            }\n\n            return label;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"_stringBundle\">\n        <getter><![CDATA[\n          if (!this.__stringBundle) {\n            this.__stringBundle = this.Services.strings.createBundle(\"chrome://global/locale/autocomplete.properties\");\n          }\n          return this.__stringBundle;\n        ]]></getter>\n      </property>\n\n      <field name=\"_boundaryCutoff\">null</field>\n\n      <property name=\"boundaryCutoff\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n          if (!this._boundaryCutoff) {\n            this._boundaryCutoff =\n              Cc[\"@mozilla.org/preferences-service;1\"].\n              getService(Ci.nsIPrefBranch).\n              getIntPref(\"toolkit.autocomplete.richBoundaryCutoff\");\n          }\n          return this._boundaryCutoff;\n          ]]>\n        </getter>\n      </property>\n\n      <field name=\"_inOverflow\">false</field>\n\n      <method name=\"_onOverflow\">\n        <body>\n          <![CDATA[\n          this._inOverflow = true;\n          this._handleOverflow();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_onUnderflow\">\n        <body>\n          <![CDATA[\n          this._inOverflow = false;\n          this._handleOverflow();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_getBoundaryIndices\">\n        <parameter name=\"aText\"/>\n        <parameter name=\"aSearchTokens\"/>\n        <body>\n          <![CDATA[\n          // Short circuit for empty search ([\"\"] == \"\")\n          if (aSearchTokens == \"\")\n            return [0, aText.length];\n\n          // Find which regions of text match the search terms\n          let regions = [];\n          for (let search of Array.prototype.slice.call(aSearchTokens)) {\n            let matchIndex = -1;\n            let searchLen = search.length;\n\n            // Find all matches of the search terms, but stop early for perf\n            let lowerText = aText.substr(0, this.boundaryCutoff).toLowerCase();\n            while ((matchIndex = lowerText.indexOf(search, matchIndex + 1)) >= 0) {\n              regions.push([matchIndex, matchIndex + searchLen]);\n            }\n          }\n\n          // Sort the regions by start position then end position\n          regions = regions.sort((a, b) => {\n            let start = a[0] - b[0];\n            return (start == 0) ? a[1] - b[1] : start;\n          });\n\n          // Generate the boundary indices from each region\n          let start = 0;\n          let end = 0;\n          let boundaries = [];\n          let len = regions.length;\n          for (let i = 0; i < len; i++) {\n            // We have a new boundary if the start of the next is past the end\n            let region = regions[i];\n            if (region[0] > end) {\n              // First index is the beginning of match\n              boundaries.push(start);\n              // Second index is the beginning of non-match\n              boundaries.push(end);\n\n              // Track the new region now that we've stored the previous one\n              start = region[0];\n            }\n\n            // Push back the end index for the current or new region\n            end = Math.max(end, region[1]);\n          }\n\n          // Add the last region\n          boundaries.push(start);\n          boundaries.push(end);\n\n          // Put on the end boundary if necessary\n          if (end < aText.length)\n            boundaries.push(aText.length);\n\n          // Skip the first item because it's always 0\n          return boundaries.slice(1);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_getSearchTokens\">\n        <parameter name=\"aSearch\"/>\n        <body>\n          <![CDATA[\n          let search = aSearch.toLowerCase();\n          return search.split(/\\s+/);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_setUpDescription\">\n        <parameter name=\"aDescriptionElement\"/>\n        <parameter name=\"aText\"/>\n        <parameter name=\"aNoEmphasis\"/>\n        <body>\n          <![CDATA[\n          // Get rid of all previous text\n          if (!aDescriptionElement) {\n            return;\n          }\n          while (aDescriptionElement.hasChildNodes())\n            aDescriptionElement.firstChild.remove();\n\n          // If aNoEmphasis is specified, don't add any emphasis\n          if (aNoEmphasis) {\n            aDescriptionElement.appendChild(document.createTextNode(aText));\n            return;\n          }\n\n          // Get the indices that separate match and non-match text\n          let search = this.getAttribute(\"text\");\n          let tokens = this._getSearchTokens(search);\n          let indices = this._getBoundaryIndices(aText, tokens);\n\n          this._appendDescriptionSpans(indices, aText, aDescriptionElement,\n                                       aDescriptionElement);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_appendDescriptionSpans\">\n        <parameter name=\"indices\"/>\n        <parameter name=\"text\"/>\n        <parameter name=\"spansParentElement\"/>\n        <parameter name=\"descriptionElement\"/>\n        <body>\n          <![CDATA[\n          let next;\n          let start = 0;\n          let len = indices.length;\n          // Even indexed boundaries are matches, so skip the 0th if it's empty\n          for (let i = indices[0] == 0 ? 1 : 0; i < len; i++) {\n            next = indices[i];\n            let spanText = text.substr(start, next - start);\n            start = next;\n\n            if (i % 2 == 0) {\n              // Emphasize the text for even indices\n              let span = spansParentElement.appendChild(\n                document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"span\"));\n              this._setUpEmphasisSpan(span, descriptionElement);\n              span.textContent = spanText;\n            } else {\n              // Otherwise, it's plain text\n              spansParentElement.appendChild(document.createTextNode(spanText));\n            }\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_setUpTags\">\n        <parameter name=\"tags\"/>\n        <body>\n          <![CDATA[\n          while (this._tagsText.hasChildNodes()) {\n            this._tagsText.firstChild.remove();\n          }\n\n          let anyTagsMatch = false;\n\n          // Include only tags that match the search string.\n          for (let tag of tags) {\n            // Check if the tag matches the search string.\n            let search = this.getAttribute(\"text\");\n            let tokens = this._getSearchTokens(search);\n            let indices = this._getBoundaryIndices(tag, tokens);\n\n            if (indices.length == 2 &&\n                indices[0] == 0 &&\n                indices[1] == tag.length) {\n              // The tag doesn't match the search string, so don't include it.\n              continue;\n            }\n\n            anyTagsMatch = true;\n\n            let tagSpan =\n              document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"span\");\n            tagSpan.classList.add(\"ac-tag\");\n            this._tagsText.appendChild(tagSpan);\n\n            this._appendDescriptionSpans(indices, tag, tagSpan, this._tagsText);\n          }\n\n          return anyTagsMatch;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_setUpEmphasisSpan\">\n        <parameter name=\"aSpan\"/>\n        <parameter name=\"aDescriptionElement\"/>\n        <body>\n          <![CDATA[\n          aSpan.classList.add(\"ac-emphasize-text\");\n          switch (aDescriptionElement) {\n            case this._titleText:\n              aSpan.classList.add(\"ac-emphasize-text-title\");\n              break;\n            case this._tagsText:\n              aSpan.classList.add(\"ac-emphasize-text-tag\");\n              break;\n            case this._urlText:\n              aSpan.classList.add(\"ac-emphasize-text-url\");\n              break;\n            case this._actionText:\n              aSpan.classList.add(\"ac-emphasize-text-action\");\n              break;\n          }\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        This will generate an array of emphasis pairs for use with\n        _setUpEmphasisedSections(). Each pair is a tuple (array) that\n        represents a block of text - containing the text of that block, and a\n        boolean for whether that block should have an emphasis styling applied\n        to it.\n\n        These pairs are generated by parsing a localised string (aSourceString)\n        with parameters, in the format that is used by\n        nsIStringBundle.formatStringFromName():\n\n          \"textA %1$S textB textC %2$S\"\n\n        Or:\n\n          \"textA %S\"\n\n        Where \"%1$S\", \"%2$S\", and \"%S\" are intended to be replaced by provided\n        replacement strings. These are specified an array of tuples\n        (aReplacements), each containing the replacement text and a boolean for\n        whether that text should have an emphasis styling applied. This is used\n        as a 1-based array - ie, \"%1$S\" is replaced by the item in the first\n        index of aReplacements, \"%2$S\" by the second, etc. \"%S\" will always\n        match the first index.\n      -->\n      <method name=\"_generateEmphasisPairs\">\n        <parameter name=\"aSourceString\"/>\n        <parameter name=\"aReplacements\"/>\n        <body>\n          <![CDATA[\n            let pairs = [];\n\n            // Split on %S, %1$S, %2$S, etc. ie:\n            //   \"textA %S\"\n            //     becomes [\"textA \", \"%S\"]\n            //   \"textA %1$S textB textC %2$S\"\n            //     becomes [\"textA \", \"%1$S\", \" textB textC \", \"%2$S\"]\n            let parts = aSourceString.split(/(%(?:[0-9]+\\$)?S)/);\n\n            for (let part of parts) {\n              // The above regex will actually give us an empty string at the\n              // end - we don't want that, as we don't want to later generate an\n              // empty text node for it.\n              if (part.length === 0)\n                continue;\n\n              // Determine if this token is a replacement token or a normal text\n              // token. If it is a replacement token, we want to extract the\n              // numerical number. However, we still want to match on \"$S\".\n              let match = part.match(/^%(?:([0-9]+)\\$)?S$/);\n\n              if (match) {\n                // \"%S\" doesn't have a numerical number in it, but will always\n                // be assumed to be 1. Furthermore, the input string specifies\n                // these with a 1-based index, but we want a 0-based index.\n                let index = (match[1] || 1) - 1;\n\n                if (index >= 0 && index < aReplacements.length) {\n                  pairs.push([...aReplacements[index]]);\n                }\n              } else {\n                pairs.push([part]);\n              }\n            }\n\n            return pairs;\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        _setUpEmphasisedSections() has the same use as _setUpDescription,\n        except instead of taking a string and highlighting given tokens, it takes\n        an array of pairs generated by _generateEmphasisPairs(). This allows\n        control over emphasising based on specific blocks of text, rather than\n        search for substrings.\n      -->\n      <method name=\"_setUpEmphasisedSections\">\n        <parameter name=\"aDescriptionElement\"/>\n        <parameter name=\"aTextPairs\"/>\n        <body>\n          <![CDATA[\n          // Get rid of all previous text\n          while (aDescriptionElement.hasChildNodes())\n            aDescriptionElement.firstChild.remove();\n\n          for (let [text, emphasise] of aTextPairs) {\n            if (emphasise) {\n              let span = aDescriptionElement.appendChild(\n                document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"span\"));\n              span.textContent = text;\n              switch (emphasise) {\n                case \"match\":\n                  this._setUpEmphasisSpan(span, aDescriptionElement);\n                  break;\n              }\n            } else {\n              aDescriptionElement.appendChild(document.createTextNode(text));\n            }\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_unescapeUrl\">\n        <parameter name=\"url\"/>\n        <body>\n          <![CDATA[\n          return this.Services.textToSubURI.unEscapeURIForUI(\"UTF-8\", url);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_reuseAcItem\">\n        <body>\n          <![CDATA[\n            let action = this._parseActionUrl(this.getAttribute(\"url\"));\n            let popup = this.parentNode.parentNode;\n\n            // If the item is a searchengine action, then it should\n            // only be reused if the engine name is the same as the\n            // popup's override engine name, if any.\n            if (!action ||\n                action.type != \"searchengine\" ||\n                !popup.overrideSearchEngineName ||\n                action.params.engineName == popup.overrideSearchEngineName) {\n\n              this.collapsed = false;\n\n              // The popup may have changed size between now and the last\n              // time the item was shown, so always handle over/underflow.\n              let dwu = window.windowUtils;\n              let popupWidth = dwu.getBoundsWithoutFlushing(this.parentNode).width;\n              if (!this._previousPopupWidth || this._previousPopupWidth != popupWidth) {\n                this._previousPopupWidth = popupWidth;\n                this.handleOverUnderflow();\n              }\n\n              return true;\n            }\n\n            return false;\n          ]]>\n        </body>\n      </method>\n\n\n      <method name=\"_adjustAcItem\">\n        <body>\n          <![CDATA[\n          let originalUrl = this.getAttribute(\"ac-value\");\n          let title = this.getAttribute(\"ac-comment\");\n          this.setAttribute(\"url\", originalUrl);\n          this.setAttribute(\"image\", this.getAttribute(\"ac-image\"));\n          this.setAttribute(\"title\", title);\n          this.setAttribute(\"text\", this.getAttribute(\"ac-text\"));\n\n          let popup = this.parentNode.parentNode;\n          let titleLooksLikeUrl = false;\n          let displayUrl = originalUrl;\n          let emphasiseUrl = true;\n          let trimDisplayUrl = true;\n\n          let type = this.getAttribute(\"originaltype\");\n          let types = new Set(type.split(/\\s+/));\n          let initialTypes = new Set(types);\n          // Remove types that should ultimately not be in the `type` string.\n          types.delete(\"action\");\n          types.delete(\"autofill\");\n          types.delete(\"heuristic\");\n          type = [...types][0] || \"\";\n\n          let action;\n\n          if (initialTypes.has(\"autofill\") && !initialTypes.has(\"action\")) {\n            // Treat autofills as visiturl actions, unless they are already also\n            // actions.\n            action = {\n              type: \"visiturl\",\n              params: { url: title },\n            };\n          }\n\n          this.removeAttribute(\"actiontype\");\n          this.classList.remove(\n            \"overridable-action\",\n            \"emptySearchQuery\",\n            \"aliasOffer\"\n          );\n\n          // If the type includes an action, set up the item appropriately.\n          if (initialTypes.has(\"action\") || action) {\n            action = action || this._parseActionUrl(originalUrl);\n            this.setAttribute(\"actiontype\", action.type);\n\n            switch (action.type) {\n            case \"switchtab\": {\n              this.classList.add(\"overridable-action\");\n              displayUrl = action.params.url;\n              let desc = this._stringBundle.GetStringFromName(\"switchToTab2\");\n              this._setUpDescription(this._actionText, desc, true);\n              break;\n            }\n            case \"remotetab\": {\n              displayUrl = action.params.url;\n              let desc = action.params.deviceName;\n              this._setUpDescription(this._actionText, desc, true);\n              break;\n            }\n            case \"searchengine\": {\n              emphasiseUrl = false;\n\n              // The order here is not localizable, we default to appending\n              // \"- Search with Engine\" to the search string, to be able to\n              // properly generate emphasis pairs. That said, no localization\n              // changed the order while it was possible, so doesn't look like\n              // there's a strong need for that.\n              let {\n                engineName,\n                searchSuggestion,\n                searchQuery,\n                alias,\n              } = action.params;\n\n              // Override the engine name if the popup defines an override.\n              let override = popup.overrideSearchEngineName;\n              if (override && override != engineName) {\n                engineName = override;\n                action.params.engineName = override;\n                let newURL =\n                  PlacesUtils.mozActionURI(action.type, action.params);\n                this.setAttribute(\"url\", newURL);\n              }\n\n              let engineStr =\n                this._stringBundle.formatStringFromName(\"searchWithEngine\",\n                                                        [engineName], 1);\n              this._setUpDescription(this._actionText, engineStr, true);\n\n              // Make the title by generating an array of pairs and its\n              // corresponding interpolation string (e.g., \"%1$S\") to pass to\n              // _generateEmphasisPairs.\n              let pairs;\n              if (searchSuggestion) {\n                // Check if the search query appears in the suggestion.  It may\n                // not.  If it does, then emphasize the query in the suggestion\n                // and otherwise just include the suggestion without emphasis.\n                let idx = searchSuggestion.indexOf(searchQuery);\n                if (idx >= 0) {\n                  pairs = [\n                    [searchSuggestion.substring(0, idx), \"\"],\n                    [searchQuery, \"match\"],\n                    [searchSuggestion.substring(idx + searchQuery.length), \"\"],\n                  ];\n                } else {\n                  pairs = [\n                    [searchSuggestion, \"\"],\n                  ];\n                }\n              } else if (alias &&\n                         !searchQuery.trim() &&\n                         !initialTypes.has(\"heuristic\")) {\n                // For non-heuristic alias results that have an empty query, we\n                // want to show \"@engine -- Search with Engine\" to make it clear\n                // that the user can search by selecting the result and using\n                // the alias.  Normally we hide the \"Search with Engine\" part\n                // until the result is selected or moused over, but not here.\n                // Add the aliasOffer class so we can detect this in the CSS.\n                this.classList.add(\"aliasOffer\");\n                pairs = [\n                  [alias, \"\"],\n                ];\n              } else {\n                // Add the emptySearchQuery class if the search query is the\n                // empty string.  We use it to hide .ac-separator in CSS.\n                if (!searchQuery.trim()) {\n                  this.classList.add(\"emptySearchQuery\");\n                }\n                pairs = [\n                  [searchQuery, \"\"],\n                ];\n              }\n              let interpStr = pairs.map((pair, i) => `%${i + 1}$S`).join(\"\");\n              title = this._generateEmphasisPairs(interpStr, pairs);\n\n              // If this is a default search match, we remove the image so we\n              // can style it ourselves with a generic search icon.\n              // We don't do this when matching an aliased search engine,\n              // because the icon helps with recognising which engine will be\n              // used (when using the default engine, we don't need that\n              // recognition).\n              if (!action.params.alias && !initialTypes.has(\"favicon\")) {\n                this.removeAttribute(\"image\");\n              }\n              break;\n            }\n            case \"visiturl\": {\n              emphasiseUrl = false;\n              displayUrl = action.params.url;\n              titleLooksLikeUrl = true;\n              let visitStr = this._stringBundle.GetStringFromName(\"visit\");\n              this._setUpDescription(this._actionText, visitStr, true);\n              break;\n            }\n            case \"extension\": {\n              let content = action.params.content;\n              displayUrl = content;\n              trimDisplayUrl = false;\n              this._setUpDescription(this._actionText, content, true);\n              break;\n            }\n            }\n          }\n\n          if (trimDisplayUrl) {\n            let input = popup.input;\n            if (typeof input.trimValue == \"function\")\n              displayUrl = input.trimValue(displayUrl);\n            displayUrl = this._unescapeUrl(displayUrl);\n          }\n          // For performance reasons we may want to limit the displayUrl size.\n          if (popup.textRunsMaxLen && displayUrl) {\n            displayUrl = displayUrl.substr(0, popup.textRunsMaxLen);\n          }\n          this.setAttribute(\"displayurl\", displayUrl);\n\n          // Show the domain as the title if we don't have a title.\n          if (!title) {\n            titleLooksLikeUrl = true;\n            try {\n              let uri = this.Services.io.newURI(originalUrl);\n              // Not all valid URLs have a domain.\n              if (uri.host)\n                title = uri.host;\n            } catch (e) {}\n            if (!title)\n              title = displayUrl;\n          }\n\n          this._tags.setAttribute(\"empty\", \"true\");\n\n          if (type == \"tag\" || type == \"bookmark-tag\") {\n            // The title is separated from the tags by an endash\n            let tags;\n            [, title, tags] = title.match(/^(.+) \\u2013 (.+)$/);\n\n            // Each tag is split by a comma in an undefined order, so sort it\n            let sortedTags = tags.split(/\\s*,\\s*/).sort((a, b) => {\n              return a.localeCompare(a);\n            });\n\n            let anyTagsMatch = this._setUpTags(sortedTags);\n            if (anyTagsMatch) {\n              this._tags.removeAttribute(\"empty\");\n            }\n            if (type == \"bookmark-tag\") {\n              type = \"bookmark\";\n            }\n          } else if (type == \"keyword\") {\n            // Note that this is a moz-action with action.type == keyword.\n            emphasiseUrl = false;\n            let keywordArg = this.getAttribute(\"text\").replace(/^[^\\s]+\\s*/, \"\");\n            if (!keywordArg) {\n              // Treat keyword searches without arguments as visiturl actions.\n              type = \"visiturl\";\n              this.setAttribute(\"actiontype\", \"visiturl\");\n              let visitStr = this._stringBundle.GetStringFromName(\"visit\");\n              this._setUpDescription(this._actionText, visitStr, true);\n            } else {\n              let pairs = [[title, \"\"], [keywordArg, \"match\"]];\n              let interpStr =\n                this._stringBundle.GetStringFromName(\"bookmarkKeywordSearch\");\n              title = this._generateEmphasisPairs(interpStr, pairs);\n              // The action box will be visible since this is a moz-action, but\n              // we want it to appear as if it were not visible, so set its text\n              // to the empty string.\n              this._setUpDescription(this._actionText, \"\", false);\n            }\n          }\n\n          this.setAttribute(\"type\", type);\n\n          if (titleLooksLikeUrl) {\n            this._titleText.setAttribute(\"lookslikeurl\", \"true\");\n          } else {\n            this._titleText.removeAttribute(\"lookslikeurl\");\n          }\n\n          if (Array.isArray(title)) {\n            // For performance reasons we may want to limit the title size.\n            if (popup.textRunsMaxLen) {\n              title.forEach(t => {\n                // Limit all the even items.\n                for (let i = 0; i < t.length; i += 2) {\n                  t[i] = t[i].substr(0, popup.textRunsMaxLen);\n                }\n              });\n            }\n            this._setUpEmphasisedSections(this._titleText, title);\n          } else {\n            // For performance reasons we may want to limit the title size.\n            if (popup.textRunsMaxLen && title) {\n              title = title.substr(0, popup.textRunsMaxLen);\n            }\n            this._setUpDescription(this._titleText, title, false);\n          }\n          this._setUpDescription(this._urlText, displayUrl, !emphasiseUrl);\n\n          // Removing the max-width may be jarring when the item is visible, but\n          // we have no other choice to properly crop the text.\n          // Removing max-widths may cause overflow or underflow events, that\n          // will set the _inOverflow property. In case both the old and the new\n          // text are overflowing, the overflow event won't happen, and we must\n          // enforce an _handleOverflow() call to update the max-widths.\n          let wasInOverflow = this._inOverflow;\n          this._removeMaxWidths();\n          if (wasInOverflow && this._inOverflow) {\n            this._handleOverflow();\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_removeMaxWidths\">\n        <body>\n          <![CDATA[\n          if (this._hasMaxWidths) {\n            this._titleText.style.removeProperty(\"max-width\");\n            this._tagsText.style.removeProperty(\"max-width\");\n            this._urlText.style.removeProperty(\"max-width\");\n            this._actionText.style.removeProperty(\"max-width\");\n            this._hasMaxWidths = false;\n          }\n          ]]>\n        </body>\n      </method>\n\n      <!-- This method truncates the displayed strings as necessary. -->\n      <method name=\"_handleOverflow\">\n        <body><![CDATA[\n          let itemRect = this.parentNode.getBoundingClientRect();\n          let titleRect = this._titleText.getBoundingClientRect();\n          let tagsRect = this._tagsText.getBoundingClientRect();\n          let separatorRect = this._separator.getBoundingClientRect();\n          let urlRect = this._urlText.getBoundingClientRect();\n          let actionRect = this._actionText.getBoundingClientRect();\n          let separatorURLActionWidth =\n            separatorRect.width + Math.max(urlRect.width, actionRect.width);\n\n          // Total width for the title and URL/action is the width of the item\n          // minus the start of the title text minus a little optional extra padding.\n          // This extra padding amount is basically arbitrary but keeps the text\n          // from getting too close to the popup's edge.\n          let dir = this.getAttribute(\"dir\");\n          let titleStart = dir == \"rtl\" ? itemRect.right - titleRect.right\n                                        : titleRect.left - itemRect.left;\n\n          let popup = this.parentNode.parentNode;\n          let itemWidth = itemRect.width - titleStart - popup.overflowPadding -\n                          (popup.margins ? popup.margins.end : 0);\n\n          if (this._tags.hasAttribute(\"empty\")) {\n            // The tags box is not displayed in this case.\n            tagsRect.width = 0;\n          }\n\n          let titleTagsWidth = titleRect.width + tagsRect.width;\n          if (titleTagsWidth + separatorURLActionWidth > itemWidth) {\n            // Title + tags + URL/action overflows the item width.\n\n            // The percentage of the item width allocated to the title and tags.\n            let titleTagsPct = 0.66;\n\n            let titleTagsAvailable = itemWidth - separatorURLActionWidth;\n            let titleTagsMaxWidth = Math.max(\n              titleTagsAvailable,\n              itemWidth * titleTagsPct\n            );\n            if (titleTagsWidth > titleTagsMaxWidth) {\n              // Title + tags overflows the max title + tags width.\n\n              // The percentage of the title + tags width allocated to the\n              // title.\n              let titlePct = 0.33;\n\n              let titleAvailable = titleTagsMaxWidth - tagsRect.width;\n              let titleMaxWidth = Math.max(\n                titleAvailable,\n                titleTagsMaxWidth * titlePct\n              );\n              let tagsAvailable = titleTagsMaxWidth - titleRect.width;\n              let tagsMaxWidth = Math.max(\n                tagsAvailable,\n                titleTagsMaxWidth * (1 - titlePct)\n              );\n              this._titleText.style.maxWidth = titleMaxWidth + \"px\";\n              this._tagsText.style.maxWidth = tagsMaxWidth + \"px\";\n            }\n            let urlActionMaxWidth = Math.max(\n              itemWidth - titleTagsWidth,\n              itemWidth * (1 - titleTagsPct)\n            );\n            urlActionMaxWidth -= separatorRect.width;\n            this._urlText.style.maxWidth = urlActionMaxWidth + \"px\";\n            this._actionText.style.maxWidth = urlActionMaxWidth + \"px\";\n            this._hasMaxWidths = true;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"handleOverUnderflow\">\n        <body>\n          <![CDATA[\n          this._removeMaxWidths();\n          this._handleOverflow();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_parseActionUrl\">\n        <parameter name=\"aUrl\"/>\n        <body><![CDATA[\n          if (!aUrl.startsWith(\"moz-action:\"))\n            return null;\n\n          // URL is in the format moz-action:ACTION,PARAMS\n          // Where PARAMS is a JSON encoded object.\n          let [, type, params] = aUrl.match(/^moz-action:([^,]+),(.*)$/);\n\n          let action = {\n            type,\n          };\n\n          try {\n            action.params = JSON.parse(params);\n            for (let key in action.params) {\n              action.params[key] = decodeURIComponent(action.params[key]);\n            }\n          } catch (e) {\n            // If this failed, we assume that params is not a JSON object, and\n            // is instead just a flat string. This may happen for legacy\n            // search components.\n            action.params = {\n              url: params,\n            };\n          }\n\n          return action;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <!--\n        This overrides listitem's mousedown handler because we want to set the\n        selected item even when the shift or accel keys are pressed.\n      -->\n      <handler event=\"mousedown\"><![CDATA[\n        // Call this.control only once since it's not a simple getter.\n        let control = this.control;\n        if (!control || control.disabled) {\n          return;\n        }\n        if (!this.selected) {\n          control.selectItem(this);\n        }\n        control.currentItem = this;\n      ]]></handler>\n\n      <handler event=\"mouseover\"><![CDATA[\n        // The point of implementing this handler is to allow drags to change\n        // the selected item.  If the user mouses down on an item, it becomes\n        // selected.  If they then drag the mouse to another item, select it.\n        // Handle all three primary mouse buttons: right, left, and wheel, since\n        // all three change the selection on mousedown.\n        let mouseDown = event.buttons & 0b111;\n        if (!mouseDown) {\n          return;\n        }\n        // Call this.control only once since it's not a simple getter.\n        let control = this.control;\n        if (!control || control.disabled) {\n          return;\n        }\n        if (!this.selected) {\n          control.selectItem(this);\n        }\n        control.currentItem = this;\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"button.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"buttonBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"button-base\" extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <implementation implements=\"nsIDOMXULButtonElement\">\n      <property name=\"type\"\n                onget=\"return this.getAttribute('type');\"\n                onset=\"this.setAttribute('type', val); return val;\"/>\n\n      <property name=\"dlgType\"\n                onget=\"return this.getAttribute('dlgtype');\"\n                onset=\"this.setAttribute('dlgtype', val); return val;\"/>\n\n      <property name=\"group\"\n                onget=\"return this.getAttribute('group');\"\n                onset=\"this.setAttribute('group', val); return val;\"/>\n\n      <property name=\"open\" onget=\"return this.hasAttribute('open');\">\n        <setter><![CDATA[\n          if (this.hasMenu()) {\n            this.openMenu(val);\n          } else if (val) {\n            // Fall back to just setting the attribute\n            this.setAttribute(\"open\", \"true\");\n          } else {\n            this.removeAttribute(\"open\");\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"checked\" onget=\"return this.hasAttribute('checked');\">\n        <setter><![CDATA[\n          if (this.type == \"radio\" && val) {\n            var sibs = this.parentNode.getElementsByAttribute(\"group\", this.group);\n            for (var i = 0; i < sibs.length; ++i)\n              sibs[i].removeAttribute(\"checked\");\n          }\n\n          if (val)\n            this.setAttribute(\"checked\", \"true\");\n          else\n            this.removeAttribute(\"checked\");\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <method name =\"filterButtons\">\n        <parameter name=\"node\"/>\n        <body>\n        <![CDATA[\n          // if the node isn't visible, don't descend into it.\n          var cs = node.ownerGlobal.getComputedStyle(node);\n          if (cs.visibility != \"visible\" || cs.display == \"none\") {\n            return NodeFilter.FILTER_REJECT;\n          }\n          // but it may be a popup element, in which case we look at \"state\"...\n          if (cs.display == \"-moz-popup\" && node.state != \"open\") {\n            return NodeFilter.FILTER_REJECT;\n          }\n          // OK - the node seems visible, so it is a candidate.\n          if (node.localName == \"button\" && node.accessKey && !node.disabled)\n            return NodeFilter.FILTER_ACCEPT;\n          return NodeFilter.FILTER_SKIP;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"fireAccessKeyButton\">\n        <parameter name=\"aSubtree\"/>\n        <parameter name=\"aAccessKeyLower\"/>\n        <body>\n        <![CDATA[\n          var iterator = aSubtree.ownerDocument.createTreeWalker(aSubtree,\n                                                                 NodeFilter.SHOW_ELEMENT,\n                                                                 this.filterButtons);\n          while (iterator.nextNode()) {\n            var test = iterator.currentNode;\n            if (test.accessKey.toLowerCase() == aAccessKeyLower &&\n                !test.disabled && !test.collapsed && !test.hidden) {\n              test.focus();\n              test.click();\n              return true;\n            }\n          }\n          return false;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_handleClick\">\n        <body>\n        <![CDATA[\n          if (!this.disabled) {\n            if (this.type == \"checkbox\") {\n              this.checked = !this.checked;\n            } else if (this.type == \"radio\") {\n              this.checked = true;\n            }\n          }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <!-- While it would seem we could do this by handling oncommand, we can't\n           because any external oncommand handlers might get called before ours,\n           and then they would see the incorrect value of checked. Additionally\n           a command attribute would redirect the command events anyway.-->\n      <handler event=\"click\" button=\"0\" action=\"this._handleClick();\"/>\n      <handler event=\"keypress\" key=\" \">\n      <![CDATA[\n        this._handleClick();\n        // Prevent page from scrolling on the space key.\n        event.preventDefault();\n      ]]>\n      </handler>\n\n      <handler event=\"keypress\">\n      <![CDATA[\n        if (this.hasMenu()) {\n          if (this.open)\n            return;\n        } else {\n          if (event.keyCode == KeyEvent.DOM_VK_UP ||\n              (event.keyCode == KeyEvent.DOM_VK_LEFT &&\n                document.defaultView.getComputedStyle(this.parentNode)\n                        .direction == \"ltr\") ||\n              (event.keyCode == KeyEvent.DOM_VK_RIGHT &&\n                document.defaultView.getComputedStyle(this.parentNode)\n                        .direction == \"rtl\")) {\n            event.preventDefault();\n            window.document.commandDispatcher.rewindFocus();\n            return;\n          }\n\n          if (event.keyCode == KeyEvent.DOM_VK_DOWN ||\n              (event.keyCode == KeyEvent.DOM_VK_RIGHT &&\n                document.defaultView.getComputedStyle(this.parentNode)\n                        .direction == \"ltr\") ||\n              (event.keyCode == KeyEvent.DOM_VK_LEFT &&\n                document.defaultView.getComputedStyle(this.parentNode)\n                        .direction == \"rtl\")) {\n            event.preventDefault();\n            window.document.commandDispatcher.advanceFocus();\n            return;\n          }\n        }\n\n        if (event.keyCode || event.charCode <= 32 || event.altKey ||\n            event.ctrlKey || event.metaKey)\n          return; // No printable char pressed, not a potential accesskey\n\n        // Possible accesskey pressed\n        var charPressedLower = String.fromCharCode(event.charCode).toLowerCase();\n\n        // If the accesskey of the current button is pressed, just activate it\n        if (this.accessKey.toLowerCase() == charPressedLower) {\n          this.click();\n          return;\n        }\n\n        // Search for accesskey in the list of buttons for this doc and each subdoc\n        // Get the buttons for the main document and all sub-frames\n        for (var frameCount = -1; frameCount < window.top.frames.length; frameCount++) {\n          var doc = (frameCount == -1) ? window.top.document :\n            window.top.frames[frameCount].document;\n          if (this.fireAccessKeyButton(doc.documentElement, charPressedLower))\n            return;\n        }\n\n        // Test anonymous buttons\n        var dlg = window.top.document;\n        var buttonBox = dlg.getAnonymousElementByAttribute(dlg.documentElement,\n                                                         \"anonid\", \"buttons\");\n        if (buttonBox)\n          this.fireAccessKeyButton(buttonBox, charPressedLower);\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"button\" display=\"xul:button\"\n           extends=\"chrome://global/content/bindings/button.xml#button-base\">\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:hbox class=\"box-inherit button-box\" xbl:inherits=\"align,dir,pack,orient\"\n                align=\"center\" pack=\"center\" flex=\"1\" anonid=\"button-box\">\n        <xul:image class=\"button-icon\" xbl:inherits=\"src=image\"/>\n        <xul:label class=\"button-text\" xbl:inherits=\"value=label,accesskey,crop,highlightable\"/>\n        <xul:label class=\"button-highlightable-text\" xbl:inherits=\"xbl:text=label,accesskey,crop,highlightable\"/>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"menu\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/button.xml#button\">\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:hbox class=\"box-inherit button-box\" xbl:inherits=\"align,dir,pack,orient\"\n                align=\"center\" pack=\"center\" flex=\"1\">\n        <xul:hbox class=\"box-inherit\" xbl:inherits=\"align,dir,pack,orient\"\n                  align=\"center\" pack=\"center\" flex=\"1\">\n          <xul:image class=\"button-icon\" xbl:inherits=\"src=image\"/>\n          <xul:label class=\"button-text\" xbl:inherits=\"value=label,accesskey,crop\"/>\n        </xul:hbox>\n        <xul:dropmarker class=\"button-menu-dropmarker\" xbl:inherits=\"open,disabled,label\"/>\n      </xul:hbox>\n    </content>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\" action=\"this.open = true;\"/>\n      <handler event=\"keypress\" key=\" \">\n      <![CDATA[\n        this.open = true;\n        // Prevent page from scrolling on the space key.\n        event.preventDefault();\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"checkbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"checkboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"checkbox\"\n    extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <content>\n      <xul:image class=\"checkbox-check\" xbl:inherits=\"checked,disabled\"/>\n      <xul:hbox class=\"checkbox-label-box\" flex=\"1\">\n        <xul:image class=\"checkbox-icon\" xbl:inherits=\"src\"/>\n        <xul:label class=\"checkbox-label\" xbl:inherits=\"xbl:text=label,accesskey,crop\" flex=\"1\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <method name=\"setChecked\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          var change = (aValue != (this.getAttribute(\"checked\") == \"true\"));\n          if (aValue)\n            this.setAttribute(\"checked\", \"true\");\n          else\n            this.removeAttribute(\"checked\");\n          if (change) {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"CheckboxStateChange\", true, true);\n            this.dispatchEvent(event);\n          }\n          return aValue;\n        ]]>\n        </body>\n      </method>\n\n      <!-- public implementation -->\n      <property name=\"checked\"    onset=\"return this.setChecked(val);\"\n                                  onget=\"return this.getAttribute('checked') == 'true';\"/>\n    </implementation>\n\n    <handlers>\n      <!-- While it would seem we could do this by handling oncommand, we need can't\n           because any external oncommand handlers might get called before ours, and\n           then they would see the incorrect value of checked. -->\n      <handler event=\"click\" button=\"0\" action=\"if (!this.disabled) this.checked = !this.checked;\"/>\n      <handler event=\"keypress\" key=\" \">\n        <![CDATA[\n          this.checked = !this.checked;\n          // Prevent page from scrolling on the space key.\n          event.preventDefault();\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"dialog.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings [\n  <!ENTITY % globalKeysDTD SYSTEM \"chrome://global/locale/globalKeys.dtd\">\n  %globalKeysDTD;\n]>\n\n<bindings id=\"dialogBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"dialog\">\n    <content>\n      <xul:vbox class=\"box-inherit dialog-content-box\" flex=\"1\">\n        <children/>\n      </xul:vbox>\n\n      <xul:hbox class=\"dialog-button-box\" anonid=\"buttons\"\n                xbl:inherits=\"pack=buttonpack,align=buttonalign,dir=buttondir,orient=buttonorient\"\n\n                pack=\"end\">\n        <xul:button dlgtype=\"extra2\" class=\"dialog-button\" hidden=\"true\"/>\n        <xul:spacer anonid=\"spacer\" flex=\"1\" hidden=\"true\"/>\n        <xul:button dlgtype=\"accept\" class=\"dialog-button\" xbl:inherits=\"disabled=buttondisabledaccept\"/>\n        <xul:button dlgtype=\"extra1\" class=\"dialog-button\" hidden=\"true\"/>\n        <xul:button dlgtype=\"cancel\" class=\"dialog-button\"/>\n        <xul:button dlgtype=\"help\" class=\"dialog-button\" hidden=\"true\"/>\n        <xul:button dlgtype=\"disclosure\" class=\"dialog-button\" hidden=\"true\"/>\n\n      </xul:hbox>\n\n    <xul:keyset>\n      <xul:key phase=\"capturing\" oncommand=\"document.documentElement.openHelp(event)\"\n\n           keycode=\"FROM-DTD.openHelp.commandkey;\"/>\n\n    </xul:keyset>\n\n    </content>\n\n    <implementation>\n      <field name=\"_mStrBundle\">null</field>\n      <field name=\"_closeHandler\">(function(event) {\n        if (!document.documentElement.cancelDialog())\n          event.preventDefault();\n      })</field>\n\n      <property name=\"buttons\"\n                onget=\"return this.getAttribute('buttons');\"\n                onset=\"this._configureButtons(val); return val;\"/>\n\n      <property name=\"defaultButton\">\n        <getter>\n        <![CDATA[\n          if (this.hasAttribute(\"defaultButton\"))\n            return this.getAttribute(\"defaultButton\");\n          return \"accept\"; // default to the accept button\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          this._setDefaultButton(val);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"acceptDialog\">\n        <body>\n        <![CDATA[\n          return this._doButtonCommand(\"accept\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"cancelDialog\">\n        <body>\n        <![CDATA[\n          return this._doButtonCommand(\"cancel\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getButton\">\n        <parameter name=\"aDlgType\"/>\n        <body>\n        <![CDATA[\n          return this._buttons[aDlgType];\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"moveToAlertPosition\">\n        <body>\n        <![CDATA[\n          // hack. we need this so the window has something like its final size\n          if (window.outerWidth == 1) {\n            dump(\"Trying to position a sizeless window; caller should have called sizeToContent() or sizeTo(). See bug 75649.\\n\");\n            sizeToContent();\n          }\n\n          if (opener) {\n            var xOffset = (opener.outerWidth - window.outerWidth) / 2;\n            var yOffset = opener.outerHeight / 5;\n\n            var newX = opener.screenX + xOffset;\n            var newY = opener.screenY + yOffset;\n          } else {\n            newX = (screen.availWidth - window.outerWidth) / 2;\n            newY = (screen.availHeight - window.outerHeight) / 2;\n          }\n\n          // ensure the window is fully onscreen (if smaller than the screen)\n          if (newX < screen.availLeft)\n            newX = screen.availLeft + 20;\n          if ((newX + window.outerWidth) > (screen.availLeft + screen.availWidth))\n            newX = (screen.availLeft + screen.availWidth) - window.outerWidth - 20;\n\n          if (newY < screen.availTop)\n            newY = screen.availTop + 20;\n          if ((newY + window.outerHeight) > (screen.availTop + screen.availHeight))\n            newY = (screen.availTop + screen.availHeight) - window.outerHeight - 60;\n\n          window.moveTo( newX, newY );\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"centerWindowOnScreen\">\n        <body>\n        <![CDATA[\n          var xOffset = screen.availWidth / 2 - window.outerWidth / 2;\n          var yOffset = screen.availHeight / 2 - window.outerHeight / 2;\n\n          xOffset = xOffset > 0 ? xOffset : 0;\n          yOffset = yOffset > 0 ? yOffset : 0;\n          window.moveTo(xOffset, yOffset);\n        ]]>\n        </body>\n      </method>\n\n      <constructor>\n      <![CDATA[\n        this._configureButtons(this.buttons);\n\n        // listen for when window is closed via native close buttons\n        window.addEventListener(\"close\", this._closeHandler);\n\n        // for things that we need to initialize after onload fires\n        window.addEventListener(\"load\", this.postLoadInit);\n\n        window.moveToAlertPosition = this.moveToAlertPosition;\n        window.centerWindowOnScreen = this.centerWindowOnScreen;\n      ]]>\n      </constructor>\n\n      <method name=\"postLoadInit\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          function focusInit() {\n            const dialog = document.documentElement;\n            const defaultButton = dialog.getButton(dialog.defaultButton);\n            // give focus to the first focusable element in the dialog\n            if (!document.commandDispatcher.focusedElement) {\n              document.commandDispatcher.advanceFocusIntoSubtree(dialog);\n\n              var focusedElt = document.commandDispatcher.focusedElement;\n              if (focusedElt) {\n                var initialFocusedElt = focusedElt;\n                while (focusedElt.localName == \"tab\" ||\n                       focusedElt.getAttribute(\"noinitialfocus\") == \"true\") {\n                  document.commandDispatcher.advanceFocusIntoSubtree(focusedElt);\n                  focusedElt = document.commandDispatcher.focusedElement;\n                  if (focusedElt == initialFocusedElt) {\n                    if (focusedElt.getAttribute(\"noinitialfocus\") == \"true\") {\n                      focusedElt.blur();\n                    }\n                    break;\n                  }\n                }\n\n                if (initialFocusedElt.localName == \"tab\") {\n                  if (focusedElt.hasAttribute(\"dlgtype\")) {\n                    // We don't want to focus on anonymous OK, Cancel, etc. buttons,\n                    // so return focus to the tab itself\n                    initialFocusedElt.focus();\n                  }\n                } else if (!/Mac/.test(navigator.platform) &&\n                           focusedElt.hasAttribute(\"dlgtype\") && focusedElt != defaultButton) {\n                  defaultButton.focus();\n                }\n              }\n            }\n\n            try {\n              if (defaultButton)\n                window.notifyDefaultButtonLoaded(defaultButton);\n            } catch (e) { }\n          }\n\n          // Give focus after onload completes, see bug 103197.\n          setTimeout(focusInit, 0);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"openHelp\">\n        <parameter name=\"event\"/>\n        <body>\n        <![CDATA[\n          var helpButton = document.documentElement.getButton(\"help\");\n          if (helpButton.disabled || helpButton.hidden)\n            return;\n          this._fireButtonEvent(\"help\");\n          event.stopPropagation();\n          event.preventDefault();\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"mStrBundle\">\n        <getter>\n        <![CDATA[\n          if (!this._mStrBundle) {\n            // need to create string bundle manually instead of using <xul:stringbundle/>\n            // see bug 63370 for details\n            this._mStrBundle = Cc[\"@mozilla.org/intl/stringbundle;1\"]\n                                 .getService(Ci.nsIStringBundleService)\n                                 .createBundle(\"chrome://global/locale/dialog.properties\");\n          }\n          return this._mStrBundle;\n        ]]></getter>\n      </property>\n\n      <method name=\"_configureButtons\">\n        <parameter name=\"aButtons\"/>\n        <body>\n        <![CDATA[\n          // by default, get all the anonymous button elements\n          var buttons = {};\n          this._buttons = buttons;\n          buttons.accept = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"accept\");\n          buttons.cancel = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"cancel\");\n          buttons.extra1 = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"extra1\");\n          buttons.extra2 = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"extra2\");\n          buttons.help = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"help\");\n          buttons.disclosure = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"disclosure\");\n\n          // look for any overriding explicit button elements\n          var exBtns = this.getElementsByAttribute(\"dlgtype\", \"*\");\n          var dlgtype;\n          var i;\n          for (i = 0; i < exBtns.length; ++i) {\n            dlgtype = exBtns[i].getAttribute(\"dlgtype\");\n            buttons[dlgtype].hidden = true; // hide the anonymous button\n            buttons[dlgtype] = exBtns[i];\n          }\n\n          // add the label and oncommand handler to each button\n          for (dlgtype in buttons) {\n            var button = buttons[dlgtype];\n            button.addEventListener(\"command\", this._handleButtonCommand, true);\n\n            // don't override custom labels with pre-defined labels on explicit buttons\n            if (!button.hasAttribute(\"label\")) {\n              // dialog attributes override the default labels in dialog.properties\n              if (this.hasAttribute(\"buttonlabel\" + dlgtype)) {\n                button.setAttribute(\"label\", this.getAttribute(\"buttonlabel\" + dlgtype));\n                if (this.hasAttribute(\"buttonaccesskey\" + dlgtype))\n                  button.setAttribute(\"accesskey\", this.getAttribute(\"buttonaccesskey\" + dlgtype));\n              } else if (this.hasAttribute(\"buttonid\" + dlgtype)) {\n                document.l10n.setAttributes(button, this.getAttribute(\"buttonid\" + dlgtype));\n              } else if (dlgtype != \"extra1\" && dlgtype != \"extra2\") {\n                button.setAttribute(\"label\", this.mStrBundle.GetStringFromName(\"button-\" + dlgtype));\n                var accessKey = this.mStrBundle.GetStringFromName(\"accesskey-\" + dlgtype);\n                if (accessKey)\n                  button.setAttribute(\"accesskey\", accessKey);\n              }\n            }\n            // allow specifying alternate icons in the dialog header\n            if (!button.hasAttribute(\"icon\")) {\n              // if there's an icon specified, use that\n              if (this.hasAttribute(\"buttonicon\" + dlgtype))\n                button.setAttribute(\"icon\", this.getAttribute(\"buttonicon\" + dlgtype));\n              // otherwise set defaults\n              else\n                switch (dlgtype) {\n                  case \"accept\":\n                    button.setAttribute(\"icon\", \"accept\");\n                    break;\n                  case \"cancel\":\n                    button.setAttribute(\"icon\", \"cancel\");\n                    break;\n                  case \"disclosure\":\n                    button.setAttribute(\"icon\", \"properties\");\n                    break;\n                  case \"help\":\n                    button.setAttribute(\"icon\", \"help\");\n                    break;\n                  default:\n                    break;\n                }\n            }\n          }\n\n          // ensure that hitting enter triggers the default button command\n          this.defaultButton = this.defaultButton;\n\n          // if there is a special button configuration, use it\n          if (aButtons) {\n            // expect a comma delimited list of dlgtype values\n            var list = aButtons.split(\",\");\n\n            // mark shown dlgtypes as true\n            var shown = { accept: false, cancel: false, help: false,\n                          disclosure: false, extra1: false, extra2: false };\n            for (i = 0; i < list.length; ++i)\n              shown[list[i].replace(/ /g, \"\")] = true;\n\n            // hide/show the buttons we want\n            for (dlgtype in buttons)\n              buttons[dlgtype].hidden = !shown[dlgtype];\n\n            // show the spacer on Windows only when the extra2 button is present\n            if (/Win/.test(navigator.platform)) {\n              var spacer = document.getAnonymousElementByAttribute(this, \"anonid\", \"spacer\");\n              spacer.removeAttribute(\"hidden\");\n              spacer.setAttribute(\"flex\", shown.extra2 ? \"1\" : \"0\");\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_setDefaultButton\">\n        <parameter name=\"aNewDefault\"/>\n        <body>\n        <![CDATA[\n          // remove the default attribute from the previous default button, if any\n          var oldDefaultButton = this.getButton(this.defaultButton);\n          if (oldDefaultButton)\n            oldDefaultButton.removeAttribute(\"default\");\n\n          var newDefaultButton = this.getButton(aNewDefault);\n          if (newDefaultButton) {\n            this.setAttribute(\"defaultButton\", aNewDefault);\n            newDefaultButton.setAttribute(\"default\", \"true\");\n          } else {\n            this.setAttribute(\"defaultButton\", \"none\");\n            if (aNewDefault != \"none\")\n              dump(\"invalid new default button: \" + aNewDefault + \", assuming: none\\n\");\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_handleButtonCommand\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          return document.documentElement._doButtonCommand(\n                                        aEvent.target.getAttribute(\"dlgtype\"));\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_doButtonCommand\">\n        <parameter name=\"aDlgType\"/>\n        <body>\n        <![CDATA[\n          var button = this.getButton(aDlgType);\n          if (!button.disabled) {\n            var noCancel = this._fireButtonEvent(aDlgType);\n            if (noCancel) {\n              if (aDlgType == \"accept\" || aDlgType == \"cancel\") {\n                var closingEvent = new CustomEvent(\"dialogclosing\", {\n                  bubbles: true,\n                  detail: { button: aDlgType },\n                });\n                this.dispatchEvent(closingEvent);\n                window.close();\n              }\n            }\n            return noCancel;\n          }\n          return true;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_fireButtonEvent\">\n        <parameter name=\"aDlgType\"/>\n        <body>\n        <![CDATA[\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"dialog\" + aDlgType, true, true);\n\n          // handle dom event handlers\n          var noCancel = this.dispatchEvent(event);\n\n          // handle any xml attribute event handlers\n          var handler = this.getAttribute(\"ondialog\" + aDlgType);\n          if (handler != \"\") {\n            var fn = new Function(\"event\", handler);\n            var returned = fn(event);\n            // eslint-disable-next-line mozilla/no-compare-against-boolean-literals\n            if (returned == false)\n              noCancel = false;\n          }\n\n          return noCancel;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_hitEnter\">\n        <parameter name=\"evt\"/>\n        <body>\n        <![CDATA[\n          if (evt.defaultPrevented)\n            return;\n\n          var btn = this.getButton(this.defaultButton);\n          if (btn)\n            this._doButtonCommand(this.defaultButton);\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\"\n               group=\"system\" action=\"this._hitEnter(event);\"/>\n      <handler event=\"keypress\" keycode=\"VK_ESCAPE\" group=\"system\">\n        if (!event.defaultPrevented)\n          this.cancelDialog();\n      </handler>\n\n      <handler event=\"focus\" phase=\"capturing\">\n        var btn = this.getButton(this.defaultButton);\n        if (btn)\n          btn.setAttribute(\"default\", event.originalTarget == btn ||\n                           !(event.originalTarget.localName == \"button\" ||\n                             event.originalTarget.localName == \"toolbarbutton\"));\n      </handler>\n\n    </handlers>\n\n  </binding>\n\n</bindings>\n"},{"file":"general.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"generalBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"basecontrol\">\n    <implementation implements=\"nsIDOMXULControlElement\">\n      <!-- public implementation -->\n      <property name=\"disabled\" onset=\"if (val) this.setAttribute('disabled', 'true');\n                                       else this.removeAttribute('disabled');\n                                       return val;\"\n                                onget=\"return this.getAttribute('disabled') == 'true';\"/>\n      <property name=\"tabIndex\" onget=\"return parseInt(this.getAttribute('tabindex')) || 0\"\n                                onset=\"if (val) this.setAttribute('tabindex', val);\n                                       else this.removeAttribute('tabindex'); return val;\"/>\n    </implementation>\n  </binding>\n\n  <binding id=\"basetext\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <implementation>\n      <!-- public implementation -->\n      <property name=\"label\"      onset=\"this.setAttribute('label',val); return val;\"\n                                  onget=\"return this.getAttribute('label');\"/>\n      <property name=\"crop\"       onset=\"this.setAttribute('crop',val); return val;\"\n                                  onget=\"return this.getAttribute('crop');\"/>\n      <property name=\"image\"      onset=\"this.setAttribute('image',val); return val;\"\n                                  onget=\"return this.getAttribute('image');\"/>\n      <property name=\"command\"    onset=\"this.setAttribute('command',val); return val;\"\n                                  onget=\"return this.getAttribute('command');\"/>\n      <property name=\"accessKey\">\n        <getter>\n          <![CDATA[\n            return this.labelElement ? this.labelElement.accessKey : this.getAttribute(\"accesskey\");\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            // Always store on the control\n            this.setAttribute(\"accesskey\", val);\n            // If there is a label, change the accesskey on the labelElement\n            // if it's also set there\n            if (this.labelElement) {\n              this.labelElement.accessKey = val;\n            }\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <field name=\"labelElement\"/>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"menu.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n<!-- globals XULMenuElement -->\n\n<bindings id=\"menuitemBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"menuitem-base\"\n           extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <implementation implements=\"nsIDOMXULSelectControlItemElement, nsIDOMXULContainerItemElement\">\n      <property name=\"value\" onset=\"this.setAttribute('value', val); return val;\"\n                             onget=\"return this.getAttribute('value');\"/>\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"selected\" readonly=\"true\"\n                onget=\"return this.getAttribute('selected') == 'true';\"/>\n      <property name=\"control\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var parent = this.parentNode;\n            // Return the parent if it is a menu or menulist.\n            if (parent && parent.parentNode instanceof XULMenuElement) {\n              return parent.parentNode;\n            }\n            return null;\n          ]]>\n        </getter>\n      </property>\n\n      <!-- nsIDOMXULContainerItemElement -->\n      <property name=\"parentContainer\" readonly=\"true\">\n        <getter>\n          for (var parent = this.parentNode; parent; parent = parent.parentNode) {\n            if (parent instanceof XULMenuElement) {\n              return parent;\n            }\n          }\n          return null;\n        </getter>\n      </property>\n    </implementation>\n  </binding>\n\n  <binding id=\"menu-base\"\n           extends=\"chrome://global/content/bindings/menu.xml#menuitem-base\">\n\n    <implementation implements=\"nsIDOMXULContainerElement\">\n      <property name=\"open\" onget=\"return this.hasAttribute('open');\">\n        <setter><![CDATA[\n          this.openMenu(val);\n          return val;\n        ]]></setter>\n      </property>\n\n      <!-- nsIDOMXULContainerElement interface -->\n      <method name=\"appendItem\">\n        <parameter name=\"aLabel\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n          var menupopup = this.menupopup;\n          if (!menupopup) {\n            menupopup = this.ownerDocument.createXULElement(\"menupopup\");\n            this.appendChild(menupopup);\n          }\n\n          var menuitem = this.ownerDocument.createXULElement(\"menuitem\");\n          menuitem.setAttribute(\"label\", aLabel);\n          menuitem.setAttribute(\"value\", aValue);\n\n          return menupopup.appendChild(menuitem);\n        </body>\n      </method>\n\n      <property name=\"itemCount\" readonly=\"true\">\n        <getter>\n          var menupopup = this.menupopup;\n          return menupopup ? menupopup.children.length : 0;\n        </getter>\n      </property>\n\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          var menupopup = this.menupopup;\n          if (menupopup) {\n            var items = menupopup.children;\n            var length = items.length;\n            for (var index = 0; index < length; ++index) {\n              if (items[index] == aItem)\n                return index;\n            }\n          }\n          return -1;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"aIndex\"/>\n        <body>\n        <![CDATA[\n          var menupopup = this.menupopup;\n          if (!menupopup || aIndex < 0 || aIndex >= menupopup.children.length)\n            return null;\n\n          return menupopup.children[aIndex];\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"menupopup\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          const XUL_NS =\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\n          for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\n            if (child.namespaceURI == XUL_NS && child.localName == \"menupopup\")\n              return child;\n          }\n          return null;\n        ]]>\n        </getter>\n      </property>\n    </implementation>\n  </binding>\n\n  <binding id=\"menu\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:label class=\"menu-text\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\"/>\n      <xul:hbox class=\"menu-accel-container\" anonid=\"accel\">\n        <xul:label class=\"menu-accel\" xbl:inherits=\"value=acceltext\"/>\n      </xul:hbox>\n      <xul:hbox align=\"center\" class=\"menu-right\" xbl:inherits=\"_moz-menuactive,disabled\">\n        <xul:image/>\n      </xul:hbox>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menuitem\" extends=\"chrome://global/content/bindings/menu.xml#menuitem-base\">\n    <content>\n      <xul:label class=\"menu-text\" xbl:inherits=\"value=label,accesskey,crop,highlightable\" crop=\"right\"/>\n      <xul:hbox class=\"menu-accel-container\" anonid=\"accel\">\n        <xul:label class=\"menu-accel\" xbl:inherits=\"value=acceltext\"/>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"menu-menubar\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:label class=\"menubar-text\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menu-menubar-iconic\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:image class=\"menubar-left\" xbl:inherits=\"src=image\"/>\n      <xul:label class=\"menubar-text\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menuitem-iconic\" extends=\"chrome://global/content/bindings/menu.xml#menuitem\">\n    <content>\n      <xul:hbox class=\"menu-iconic-left\" align=\"center\" pack=\"center\"\n                xbl:inherits=\"selected,_moz-menuactive,disabled,checked\">\n        <xul:image class=\"menu-iconic-icon\" xbl:inherits=\"src=image,triggeringprincipal=iconloadingprincipal,validate,src\"/>\n      </xul:hbox>\n      <xul:label class=\"menu-iconic-text\" flex=\"1\" xbl:inherits=\"value=label,accesskey,crop,highlightable\" crop=\"right\"/>\n      <xul:label class=\"menu-iconic-highlightable-text\" xbl:inherits=\"xbl:text=label,crop,accesskey,highlightable\" crop=\"right\"/>\n      <children/>\n      <xul:hbox class=\"menu-accel-container\" anonid=\"accel\">\n        <xul:label class=\"menu-iconic-accel\" xbl:inherits=\"value=acceltext\"/>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"menuitem-iconic-noaccel\" extends=\"chrome://global/content/bindings/menu.xml#menuitem\">\n    <content>\n      <xul:hbox class=\"menu-iconic-left\" align=\"center\" pack=\"center\"\n                xbl:inherits=\"selected,disabled,checked\">\n        <xul:image class=\"menu-iconic-icon\" xbl:inherits=\"src=image,validate,src\"/>\n      </xul:hbox>\n      <xul:label class=\"menu-iconic-text\" flex=\"1\" xbl:inherits=\"value=label,accesskey,crop,highlightable\" crop=\"right\"/>\n      <xul:label class=\"menu-iconic-highlightable-text\" xbl:inherits=\"xbl:text=label,crop,accesskey,highlightable\" crop=\"right\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menucaption\" extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:hbox class=\"menu-iconic-left\" align=\"center\" pack=\"center\"\n                xbl:inherits=\"selected,disabled,checked\">\n        <xul:image class=\"menu-iconic-icon\" xbl:inherits=\"src=image,validate,src\"/>\n      </xul:hbox>\n      <xul:label class=\"menu-iconic-text\" flex=\"1\" xbl:inherits=\"value=label,crop,highlightable\" crop=\"right\"/>\n      <xul:label class=\"menu-iconic-highlightable-text\" xbl:inherits=\"xbl:text=label,crop,highlightable\" crop=\"right\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menu-iconic\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:hbox class=\"menu-iconic-left\" align=\"center\" pack=\"center\">\n        <xul:image class=\"menu-iconic-icon\" xbl:inherits=\"src=image\"/>\n      </xul:hbox>\n      <xul:label class=\"menu-iconic-text\" flex=\"1\" xbl:inherits=\"value=label,accesskey,crop,highlightable\" crop=\"right\"/>\n      <xul:label class=\"menu-iconic-highlightable-text\" xbl:inherits=\"xbl:text=label,crop,accesskey,highlightable\" crop=\"right\"/>\n      <xul:hbox class=\"menu-accel-container\" anonid=\"accel\">\n        <xul:label class=\"menu-iconic-accel\" xbl:inherits=\"value=acceltext\"/>\n      </xul:hbox>\n      <xul:hbox align=\"center\" class=\"menu-right\" xbl:inherits=\"_moz-menuactive,disabled\">\n        <xul:image/>\n      </xul:hbox>\n      <children includes=\"menupopup|template\"/>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"menulist.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"menulistBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"menulist\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <content>\n      <xul:hbox class=\"menulist-label-box\" flex=\"1\">\n        <xul:image class=\"menulist-icon\" xbl:inherits=\"src=image\"/>\n        <xul:label class=\"menulist-label\" xbl:inherits=\"value=label,crop,accesskey,highlightable\" crop=\"right\" flex=\"1\"/>\n        <xul:label class=\"menulist-highlightable-label\" xbl:inherits=\"xbl:text=label,crop,accesskey,highlightable\" crop=\"right\" flex=\"1\"/>\n      </xul:hbox>\n      <xul:dropmarker class=\"menulist-dropmarker\" type=\"menu\" xbl:inherits=\"disabled,open\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n\n    <handlers>\n      <handler event=\"command\" phase=\"capturing\"\n        action=\"if (event.target.parentNode.parentNode == this) this.selectedItem = event.target;\"/>\n\n      <handler event=\"popupshowing\">\n        <![CDATA[\n          if (event.target.parentNode == this) {\n            this.activeChild = null;\n            if (this.selectedItem)\n              // Not ready for auto-setting the active child in hierarchies yet.\n              // For now, only do this when the outermost menupopup opens.\n              this.activeChild = this.mSelectedInternal;\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"keypress\" modifiers=\"shift any\" group=\"system\">\n        <![CDATA[\n          if (!event.defaultPrevented &&\n              (event.keyCode == KeyEvent.DOM_VK_UP ||\n               event.keyCode == KeyEvent.DOM_VK_DOWN ||\n               event.keyCode == KeyEvent.DOM_VK_PAGE_UP ||\n               event.keyCode == KeyEvent.DOM_VK_PAGE_DOWN ||\n               event.keyCode == KeyEvent.DOM_VK_HOME ||\n               event.keyCode == KeyEvent.DOM_VK_END ||\n               event.keyCode == KeyEvent.DOM_VK_BACK_SPACE ||\n               event.charCode > 0)) {\n            // Moving relative to an item: start from the currently selected item\n            this.activeChild = this.mSelectedInternal;\n            if (this.handleKeyPress(event)) {\n              this.activeChild.doCommand();\n              event.preventDefault();\n            }\n          }\n        ]]>\n      </handler>\n    </handlers>\n\n    <implementation implements=\"nsIDOMXULMenuListElement\">\n      <constructor>\n        this.mSelectedInternal = null;\n        this.mAttributeObserver = null;\n        this.setInitialSelection();\n      </constructor>\n\n      <method name=\"setInitialSelection\">\n        <body>\n          <![CDATA[\n            var popup = this.menupopup;\n            if (popup) {\n              var arr = popup.getElementsByAttribute(\"selected\", \"true\");\n\n              var editable = this.editable;\n              var value = this.value;\n              if (!arr.item(0) && value)\n                arr = popup.getElementsByAttribute(editable ? \"label\" : \"value\", value);\n\n              if (arr.item(0))\n                this.selectedItem = arr[0];\n              else if (!editable)\n                this.selectedIndex = 0;\n            }\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"value\" onget=\"return this.getAttribute('value');\">\n        <setter>\n          <![CDATA[\n            // if the new value is null, we still need to remove the old value\n            if (val == null)\n              return this.selectedItem = val;\n\n            var arr = null;\n            var popup = this.menupopup;\n            if (popup)\n              arr = popup.getElementsByAttribute(\"value\", val);\n\n            if (arr && arr.item(0))\n              this.selectedItem = arr[0];\n            else {\n              this.selectedItem = null;\n              this.setAttribute(\"value\", val);\n            }\n\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"crop\" onset=\"this.setAttribute('crop',val); return val;\"\n                            onget=\"return this.getAttribute('crop');\"/>\n      <property name=\"image\"  onset=\"this.setAttribute('image',val); return val;\"\n                              onget=\"return this.getAttribute('image');\"/>\n      <property name=\"label\" readonly=\"true\" onget=\"return this.getAttribute('label');\"/>\n      <property name=\"description\" onset=\"this.setAttribute('description',val); return val;\"\n                                   onget=\"return this.getAttribute('description');\"/>\n\n      <property name=\"open\" onset=\"this.openMenu(val); return val;\"\n                            onget=\"return this.hasAttribute('open');\"/>\n\n      <property name=\"itemCount\" readonly=\"true\"\n                onget=\"return this.menupopup ? this.menupopup.children.length : 0\"/>\n\n      <property name=\"menupopup\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var popup = this.firstElementChild;\n            while (popup && popup.localName != \"menupopup\")\n              popup = popup.nextElementSibling;\n            return popup;\n          ]]>\n        </getter>\n      </property>\n\n      <method name=\"contains\">\n        <parameter name=\"item\"/>\n        <body>\n          <![CDATA[\n            if (!item)\n              return false;\n\n            var parent = item.parentNode;\n            return (parent && parent.parentNode == this);\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"selectedIndex\">\n        <getter>\n          <![CDATA[\n            // Quick and dirty. We won't deal with hierarchical menulists yet.\n            if (!this.selectedItem ||\n                !this.mSelectedInternal.parentNode ||\n                this.mSelectedInternal.parentNode.parentNode != this)\n              return -1;\n\n            var children = this.mSelectedInternal.parentNode.children;\n            var i = children.length;\n            while (i--)\n              if (children[i] == this.mSelectedInternal)\n                break;\n\n            return i;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            var popup = this.menupopup;\n            if (popup && 0 <= val) {\n              if (val < popup.children.length)\n                this.selectedItem = popup.children[val];\n            } else\n              this.selectedItem = null;\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedItem\">\n        <getter>\n          <![CDATA[\n            return this.mSelectedInternal;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            var oldval = this.mSelectedInternal;\n            if (oldval == val)\n              return val;\n\n            if (val && !this.contains(val))\n              return val;\n\n            if (oldval) {\n              oldval.removeAttribute(\"selected\");\n              this.mAttributeObserver.disconnect();\n            }\n\n            this.mSelectedInternal = val;\n            let attributeFilter = [\"value\", \"label\", \"image\", \"description\"];\n            if (val) {\n              val.setAttribute(\"selected\", \"true\");\n              for (let attr of attributeFilter) {\n                if (val.hasAttribute(attr)) {\n                  this.setAttribute(attr, val.getAttribute(attr));\n                } else {\n                  this.removeAttribute(attr);\n                }\n              }\n\n              this.mAttributeObserver = new MutationObserver(this.handleMutation.bind(this));\n              this.mAttributeObserver.observe(val, { attributeFilter });\n            } else {\n              for (let attr of attributeFilter) {\n                this.removeAttribute(attr);\n              }\n            }\n\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"select\", true, true);\n            this.dispatchEvent(event);\n\n            event = document.createEvent(\"Events\");\n            event.initEvent(\"ValueChange\", true, true);\n            this.dispatchEvent(event);\n\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"handleMutation\">\n        <parameter name=\"aRecords\"/>\n        <body>\n          <![CDATA[\n            for (let record of aRecords) {\n              let t = record.target;\n              if (t == this.mSelectedInternal) {\n                let attrName = record.attributeName;\n                switch (attrName) {\n                  case \"value\":\n                  case \"label\":\n                  case \"image\":\n                  case \"description\":\n                    if (t.hasAttribute(attrName)) {\n                      this.setAttribute(attrName, t.getAttribute(attrName));\n                    } else {\n                      this.removeAttribute(attrName);\n                    }\n                }\n              }\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"item\"/>\n        <body>\n        <![CDATA[\n          var popup = this.menupopup;\n          if (popup) {\n            var children = popup.children;\n            var i = children.length;\n            while (i--)\n              if (children[i] == item)\n                return i;\n          }\n          return -1;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"index\"/>\n        <body>\n        <![CDATA[\n          var popup = this.menupopup;\n          if (popup) {\n            var children = popup.children;\n            if (index >= 0 && index < children.length)\n              return children[index];\n          }\n          return null;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"appendItem\">\n        <parameter name=\"label\"/>\n        <parameter name=\"value\"/>\n        <parameter name=\"description\"/>\n        <body>\n        <![CDATA[\n          var popup = this.menupopup ||\n                      this.appendChild(document.createXULElement(\"menupopup\"));\n          var item = document.createXULElement(\"menuitem\");\n          item.setAttribute(\"label\", label);\n          item.setAttribute(\"value\", value);\n          if (description)\n            item.setAttribute(\"description\", description);\n\n          popup.appendChild(item);\n          return item;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"removeAllItems\">\n        <body>\n        <![CDATA[\n          this.selectedItem = null;\n          var popup = this.menupopup;\n          if (popup)\n            this.removeChild(popup);\n        ]]>\n        </body>\n      </method>\n\n      <destructor>\n        <![CDATA[\n          if (this.mAttributeObserver) {\n            this.mAttributeObserver.disconnect();\n          }\n        ]]>\n      </destructor>\n    </implementation>\n  </binding>\n\n  <binding id=\"menulist-popuponly\"\n           extends=\"chrome://global/content/bindings/menulist.xml#menulist\">\n    <content>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"notification.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE bindings [\n<!ENTITY % notificationDTD SYSTEM \"chrome://global/locale/notification.dtd\">\n%notificationDTD;\n]>\n\n<bindings id=\"notificationBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:html = \"http://www.w3.org/1999/xhtml\">\n\n  <binding id=\"popup-notification\">\n    <content orient=\"vertical\">\n      <xul:hbox class=\"popup-notification-header-container\">\n        <children includes=\"popupnotificationheader\"/>\n      </xul:hbox>\n      <xul:hbox align=\"start\" class=\"popup-notification-body-container\">\n        <xul:image class=\"popup-notification-icon\"\n                   xbl:inherits=\"popupid,src=icon,class=iconclass\"/>\n        <xul:vbox flex=\"1\" pack=\"start\"\n                  class=\"popup-notification-body\" xbl:inherits=\"popupid\">\n          <xul:hbox align=\"start\">\n            <xul:vbox flex=\"1\">\n              <xul:label class=\"popup-notification-origin header\"\n                         xbl:inherits=\"value=origin,tooltiptext=origin\"\n                         crop=\"center\"/>\n              <!-- These need to be on the same line to avoid creating\n                   whitespace between them (whitespace is added in the\n                   localization file, if necessary). -->\n              <xul:description class=\"popup-notification-description\" xbl:inherits=\"popupid\"><html:span\n                xbl:inherits=\"xbl:text=label,popupid\"/><html:b xbl:inherits=\"xbl:text=name,popupid\"/><html:span\n              xbl:inherits=\"xbl:text=endlabel,popupid\"/><html:b xbl:inherits=\"xbl:text=secondname,popupid\"/><html:span\n              xbl:inherits=\"xbl:text=secondendlabel,popupid\"/></xul:description>\n            </xul:vbox>\n            <xul:toolbarbutton anonid=\"closebutton\"\n                               class=\"messageCloseButton close-icon popup-notification-closebutton tabbable\"\n                               xbl:inherits=\"oncommand=closebuttoncommand,hidden=closebuttonhidden\"\n                               tooltiptext=\"FROM-DTD.closeNotification.tooltip;\"/>\n          </xul:hbox>\n          <children includes=\"popupnotificationcontent\"/>\n          <xul:label class=\"text-link popup-notification-learnmore-link\"\n                     xbl:inherits=\"onclick=learnmoreclick,href=learnmoreurl\">FROM-DTD.learnMore;</xul:label>\n          <xul:checkbox anonid=\"checkbox\"\n                        xbl:inherits=\"hidden=checkboxhidden,checked=checkboxchecked,label=checkboxlabel,oncommand=checkboxcommand\" />\n          <xul:description class=\"popup-notification-warning\" xbl:inherits=\"hidden=warninghidden,xbl:text=warninglabel\"/>\n        </xul:vbox>\n      </xul:hbox>\n      <xul:hbox class=\"popup-notification-footer-container\">\n        <children includes=\"popupnotificationfooter\"/>\n      </xul:hbox>\n      <xul:hbox class=\"popup-notification-button-container panel-footer\">\n        <children includes=\"button\"/>\n        <xul:button anonid=\"secondarybutton\"\n                    class=\"popup-notification-button popup-notification-secondary-button\"\n                    xbl:inherits=\"oncommand=secondarybuttoncommand,label=secondarybuttonlabel,accesskey=secondarybuttonaccesskey,hidden=secondarybuttonhidden\"/>\n        <xul:toolbarseparator xbl:inherits=\"hidden=dropmarkerhidden\"/>\n        <xul:button anonid=\"menubutton\"\n                    type=\"menu\"\n                    class=\"popup-notification-button popup-notification-dropmarker\"\n                    aria-label=\"FROM-DTD.moreActionsButton.accessibleLabel;\"\n                    xbl:inherits=\"onpopupshown=dropmarkerpopupshown,hidden=dropmarkerhidden\">\n          <xul:menupopup anonid=\"menupopup\"\n                         position=\"after_end\"\n                         aria-label=\"FROM-DTD.moreActionsButton.accessibleLabel;\"\n                         xbl:inherits=\"oncommand=menucommand\">\n            <children/>\n          </xul:menupopup>\n        </xul:button>\n        <xul:button anonid=\"button\"\n                    class=\"popup-notification-button popup-notification-primary-button\"\n                    label=\"FROM-DTD.defaultButton.label;\"\n                    accesskey=\"FROM-DTD.defaultButton.accesskey;\"\n                    xbl:inherits=\"oncommand=buttoncommand,label=buttonlabel,accesskey=buttonaccesskey,default=buttonhighlight,disabled=mainactiondisabled\"/>\n      </xul:hbox>\n    </content>\n    <implementation>\n      <field name=\"checkbox\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"checkbox\");\n      </field>\n      <field name=\"closebutton\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"closebutton\");\n      </field>\n      <field name=\"button\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"button\");\n      </field>\n      <field name=\"secondaryButton\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"secondarybutton\");\n      </field>\n      <field name=\"menubutton\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"menubutton\");\n      </field>\n      <field name=\"menupopup\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"menupopup\");\n      </field>\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"popup.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This files relies on these specific Chrome/XBL globals -->\n<!-- globals PopupBoxObject -->\n\n<bindings id=\"popupBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"popup\">\n    <content>\n      <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                          smoothscroll=\"false\">\n        <children/>\n      </xul:arrowscrollbox>\n    </content>\n\n    <implementation>\n      <field name=\"scrollBox\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"class\", \"popup-internal-box\");\n      </field>\n\n      <field name=\"AUTOSCROLL_INTERVAL\">25</field>\n      <field name=\"NOT_DRAGGING\">0</field>\n      <field name=\"DRAG_OVER_BUTTON\">-1</field>\n      <field name=\"DRAG_OVER_POPUP\">1</field>\n\n      <field name=\"_draggingState\">this.NOT_DRAGGING</field>\n      <field name=\"_scrollTimer\">0</field>\n\n      <method name=\"_enableDragScrolling\">\n        <!-- when overItem is true, drag started over menuitem; when false, drag\n             started while the popup was opening.\n          -->\n        <parameter name=\"overItem\"/>\n        <body>\n        <![CDATA[\n          if (!this._draggingState) {\n            this.setCaptureAlways();\n            this._draggingState = overItem ? this.DRAG_OVER_POPUP : this.DRAG_OVER_BUTTON;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_clearScrollTimer\">\n        <body>\n        <![CDATA[\n          if (this._scrollTimer) {\n            this.ownerGlobal.clearInterval(this._scrollTimer);\n            this._scrollTimer = 0;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <constructor><![CDATA[\n        // Enable the drag-to-scroll events only in menulist popups.\n        if (!this.parentNode || this.parentNode.localName != \"menulist\") {\n          return;\n        }\n\n        // XBL bindings might be constructed more than once.\n        if (this.eventListenersAdded) {\n          return;\n        }\n        this.eventListenersAdded = true;\n\n        this.addEventListener(\"popupshown\", () => {\n          // Enable drag scrolling even when the mouse wasn't used. The\n          // mousemove handler will remove it if the mouse isn't down.\n          this._enableDragScrolling(false);\n        });\n\n        this.addEventListener(\"popuphidden\", () => {\n          this._draggingState = this.NOT_DRAGGING;\n          this._clearScrollTimer();\n          this.releaseCapture();\n        });\n\n        this.addEventListener(\"mousedown\", event => {\n          if (event.button != 0) {\n            return;\n          }\n\n          if (this.state == \"open\" &&\n            (event.target.localName == \"menuitem\" ||\n              event.target.localName == \"menu\" ||\n              event.target.localName == \"menucaption\")) {\n            this._enableDragScrolling(true);\n          }\n        });\n\n        this.addEventListener(\"mouseup\", event => {\n          if (event.button != 0) {\n            return;\n          }\n\n          this._draggingState = this.NOT_DRAGGING;\n          this._clearScrollTimer();\n        });\n\n        this.addEventListener(\"mousemove\", event => {\n          if (!this._draggingState) {\n            return;\n          }\n\n          this._clearScrollTimer();\n\n          // If the user released the mouse before the popup opens, we will\n          // still be capturing, so check that the button is still pressed. If\n          // not, release the capture and do nothing else. This also handles if\n          // the dropdown was opened via the keyboard.\n          if (!(event.buttons & 1)) {\n            this._draggingState = this.NOT_DRAGGING;\n            this.releaseCapture();\n            return;\n          }\n\n          // If dragging outside the top or bottom edge of the popup, but within\n          // the popup area horizontally, scroll the list in that direction. The\n          // _draggingState flag is used to ensure that scrolling does not start\n          // until the mouse has moved over the popup first, preventing\n          // scrolling while over the dropdown button.\n          let popupRect = this.getOuterScreenRect();\n          if (event.screenX >= popupRect.left &&\n              event.screenX <= popupRect.right) {\n            if (this._draggingState == this.DRAG_OVER_BUTTON) {\n              if (event.screenY > popupRect.top &&\n                  event.screenY < popupRect.bottom) {\n                this._draggingState = this.DRAG_OVER_POPUP;\n              }\n            }\n\n            if (this._draggingState == this.DRAG_OVER_POPUP &&\n                (event.screenY <= popupRect.top ||\n                 event.screenY >= popupRect.bottom)) {\n              let scrollAmount = event.screenY <= popupRect.top ? -1 : 1;\n              this.scrollBox.scrollByIndex(scrollAmount, true);\n\n              let win = this.ownerGlobal;\n              this._scrollTimer = win.setInterval(() => {\n                this.scrollBox.scrollByIndex(scrollAmount, true);\n              }, this.AUTOSCROLL_INTERVAL);\n            }\n          }\n        });\n      ]]></constructor>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\">\n        <![CDATA[\n          var array = [];\n          var width = 0;\n          for (var menuitem = this.firstElementChild; menuitem; menuitem = menuitem.nextElementSibling) {\n            if (menuitem.localName == \"menuitem\" && menuitem.hasAttribute(\"acceltext\")) {\n              var accel = document.getAnonymousElementByAttribute(menuitem, \"anonid\", \"accel\");\n              if (accel && accel.boxObject) {\n                array.push(accel);\n                if (accel.boxObject.width > width)\n                  width = accel.boxObject.width;\n              }\n            }\n          }\n          for (var i = 0; i < array.length; i++)\n            array[i].width = width;\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"panel\">\n    <implementation>\n      <field name=\"_prevFocus\">0</field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // Capture the previous focus before has a chance to get set inside the panel\n        try {\n          this._prevFocus = Cu\n                            .getWeakReference(document.commandDispatcher.focusedElement);\n          if (this._prevFocus.get())\n            return;\n        } catch (ex) { }\n\n        this._prevFocus = Cu.getWeakReference(document.activeElement);\n      ]]></handler>\n      <handler event=\"popupshown\"><![CDATA[\n        // Fire event for accessibility APIs\n        var alertEvent = document.createEvent(\"Events\");\n        alertEvent.initEvent(\"AlertActive\", true, true);\n        this.dispatchEvent(alertEvent);\n       ]]></handler>\n      <handler event=\"popuphiding\"><![CDATA[\n        try {\n          this._currentFocus = document.commandDispatcher.focusedElement;\n        } catch (e) {\n          this._currentFocus = document.activeElement;\n        }\n      ]]></handler>\n      <handler event=\"popuphidden\"><![CDATA[\n        function doFocus() {\n          // Focus was set on an element inside this panel,\n          // so we need to move it back to where it was previously\n          try {\n            let fm = Cc[\"@mozilla.org/focus-manager;1\"]\n                       .getService(Ci.nsIFocusManager);\n            fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);\n          } catch (e) {\n            prevFocus.focus();\n          }\n        }\n        var currentFocus = this._currentFocus;\n        var prevFocus = this._prevFocus ? this._prevFocus.get() : null;\n        this._currentFocus = null;\n        this._prevFocus = null;\n\n        // Avoid changing focus if focus changed while we hide the popup\n        // (This can happen e.g. if the popup is hiding as a result of a\n        // click/keypress that focused something)\n        let nowFocus;\n        try {\n          nowFocus = document.commandDispatcher.focusedElement;\n        } catch (e) {\n          nowFocus = document.activeElement;\n        }\n        if (nowFocus && nowFocus != currentFocus)\n          return;\n\n        if (prevFocus && this.getAttribute(\"norestorefocus\") != \"true\") {\n          // Try to restore focus\n          try {\n            if (document.commandDispatcher.focusedWindow != window)\n              return; // Focus has already been set to a window outside of this panel\n          } catch (ex) {}\n\n          if (!currentFocus) {\n            doFocus();\n            return;\n          }\n          while (currentFocus) {\n            if (currentFocus == this) {\n              doFocus();\n              return;\n            }\n            currentFocus = currentFocus.parentNode;\n          }\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"arrowpanel\" extends=\"chrome://global/content/bindings/popup.xml#panel\">\n    <resources>\n      <!-- Fixes an issue with the \"test_arrowpanel.xul\" animation on Mac, see bug 1470880. -->\n      <stylesheet src=\"data:text/css,\"/>\n    </resources>\n\n    <content flip=\"both\" side=\"top\" position=\"bottomcenter topleft\" consumeoutsideclicks=\"false\">\n      <xul:vbox anonid=\"container\" class=\"panel-arrowcontainer\" flex=\"1\"\n               xbl:inherits=\"side,panelopen\">\n        <xul:box anonid=\"arrowbox\" class=\"panel-arrowbox\">\n          <xul:image anonid=\"arrow\" class=\"panel-arrow\" xbl:inherits=\"side\"/>\n        </xul:box>\n        <xul:box class=\"panel-arrowcontent\" xbl:inherits=\"side,align,dir,orient,pack\" flex=\"1\">\n          <children/>\n        </xul:box>\n      </xul:vbox>\n    </content>\n    <implementation>\n      <field name=\"_fadeTimer\">null</field>\n      <method name=\"adjustArrowPosition\">\n        <body>\n        <![CDATA[\n        var anchor = this.anchorNode;\n        if (!anchor) {\n          return;\n        }\n\n        var container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n        var arrowbox = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\");\n\n        var position = this.alignmentPosition;\n        var offset = this.alignmentOffset;\n\n        this.setAttribute(\"arrowposition\", position);\n\n        if (position.indexOf(\"start_\") == 0 || position.indexOf(\"end_\") == 0) {\n          container.orient = \"horizontal\";\n          arrowbox.orient = \"vertical\";\n          if (position.indexOf(\"_after\") > 0) {\n            arrowbox.pack = \"end\";\n          } else {\n            arrowbox.pack = \"start\";\n          }\n          arrowbox.style.transform = \"translate(0, \" + -offset + \"px)\";\n\n          // The assigned side stays the same regardless of direction.\n          var isRTL = (window.getComputedStyle(this).direction == \"rtl\");\n\n          if (position.indexOf(\"start_\") == 0) {\n            container.dir = \"reverse\";\n            this.setAttribute(\"side\", isRTL ? \"left\" : \"right\");\n          } else {\n            container.dir = \"\";\n            this.setAttribute(\"side\", isRTL ? \"right\" : \"left\");\n          }\n        } else if (position.indexOf(\"before_\") == 0 || position.indexOf(\"after_\") == 0) {\n          container.orient = \"\";\n          arrowbox.orient = \"\";\n          if (position.indexOf(\"_end\") > 0) {\n            arrowbox.pack = \"end\";\n          } else {\n            arrowbox.pack = \"start\";\n          }\n          arrowbox.style.transform = \"translate(\" + -offset + \"px, 0)\";\n\n          if (position.indexOf(\"before_\") == 0) {\n            container.dir = \"reverse\";\n            this.setAttribute(\"side\", \"bottom\");\n          } else {\n            container.dir = \"\";\n            this.setAttribute(\"side\", \"top\");\n          }\n        }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\">\n      <![CDATA[\n        var arrow = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrow\");\n        arrow.hidden = this.anchorNode == null;\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\")\n                .style.removeProperty(\"transform\");\n\n        if (this.getAttribute(\"animate\") != \"false\") {\n          this.setAttribute(\"animate\", \"open\");\n          // the animating attribute prevents user interaction during transition\n          // it is removed when popupshown fires\n          this.setAttribute(\"animating\", \"true\");\n        }\n\n        // set fading\n        var fade = this.getAttribute(\"fade\");\n        var fadeDelay = 0;\n        if (fade == \"fast\") {\n          fadeDelay = 1;\n        } else if (fade == \"slow\") {\n          fadeDelay = 4000;\n        } else {\n          return;\n        }\n\n        this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);\n      ]]>\n      </handler>\n      <handler event=\"popuphiding\" phase=\"target\">\n        let animate = (this.getAttribute(\"animate\") != \"false\");\n\n        if (this._fadeTimer) {\n          clearTimeout(this._fadeTimer);\n          if (animate) {\n            this.setAttribute(\"animate\", \"fade\");\n          }\n        } else if (animate) {\n          this.setAttribute(\"animate\", \"cancel\");\n        }\n      </handler>\n      <handler event=\"popupshown\" phase=\"target\">\n        this.removeAttribute(\"animating\");\n        this.setAttribute(\"panelopen\", \"true\");\n      </handler>\n      <handler event=\"popuphidden\" phase=\"target\">\n        this.removeAttribute(\"panelopen\");\n        if (this.getAttribute(\"animate\") != \"false\") {\n          this.removeAttribute(\"animate\");\n        }\n      </handler>\n      <handler event=\"popuppositioned\" phase=\"target\">\n        this.adjustArrowPosition();\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"radio.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"radioBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"radio\"\n    extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <content>\n      <xul:image class=\"radio-check\" xbl:inherits=\"disabled,selected\"/>\n      <xul:hbox class=\"radio-label-box\" align=\"center\" flex=\"1\">\n        <xul:image class=\"radio-icon\" xbl:inherits=\"src\"/>\n        <xul:label class=\"radio-label\" xbl:inherits=\"xbl:text=label,accesskey,crop\" flex=\"1\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n        <![CDATA[\n          // Just clear out the parent's cached list of radio children\n          var control = this.control;\n          if (control)\n            control.radioChildConstructed(this);\n        ]]>\n      </constructor>\n      <destructor>\n        <![CDATA[\n          if (!this.control)\n            return;\n\n          var radioList = this.control._radioChildren;\n          if (!radioList)\n            return;\n          for (var i = 0; i < radioList.length; ++i) {\n            if (radioList[i] == this) {\n              radioList.splice(i, 1);\n              return;\n            }\n          }\n        ]]>\n      </destructor>\n      <property name=\"value\" onset=\"this.setAttribute('value', val); return val;\"\n                             onget=\"return this.getAttribute('value');\"/>\n      <property name=\"selected\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            return this.hasAttribute(\"selected\");\n          ]]>\n        </getter>\n      </property>\n      <property name=\"radioGroup\" readonly=\"true\" onget=\"return this.control\"/>\n      <property name=\"control\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          var radiogroup = this.closest(\"radiogroup\");\n          if (radiogroup) {\n            return radiogroup;\n          }\n\n          var group = this.getAttribute(\"group\");\n          if (!group) {\n            return null;\n          }\n\n          var parent = this.ownerDocument.getElementById(group);\n          if (!parent || parent.localName != \"radiogroup\") {\n            parent = null;\n          }\n          return parent;\n        ]]>\n        </getter>\n      </property>\n    </implementation>\n    <handlers>\n      <handler event=\"click\" button=\"0\">\n        <![CDATA[\n          if (!this.disabled)\n            this.control.selectedItem = this;\n         ]]>\n      </handler>\n\n      <handler event=\"mousedown\" button=\"0\">\n        <![CDATA[\n          if (!this.disabled)\n            this.control.focusedItem = this;\n         ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"richlistbox.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This file relies on these specific Chrome/XBL globals -->\n<!-- globals ChromeNodeList -->\n\n<bindings id=\"richlistboxBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"richlistitem\"\n           extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <field name=\"selectedByMouseOver\">false</field>\n\n      <destructor>\n        <![CDATA[\n          var control = this.control;\n          if (!control)\n            return;\n          // When we are destructed and we are current or selected, unselect ourselves\n          // so that richlistbox's selection doesn't point to something not in the DOM.\n          // We don't want to reset last-selected, so we set _suppressOnSelect.\n          if (this.selected) {\n            var suppressSelect = control._suppressOnSelect;\n            control._suppressOnSelect = true;\n            control.removeItemFromSelection(this);\n            control._suppressOnSelect = suppressSelect;\n          }\n          if (this.current)\n            control.currentItem = null;\n        ]]>\n      </destructor>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"label\" readonly=\"true\">\n        <!-- Setter purposely not implemented; the getter returns a\n             concatentation of label text to expose via accessibility APIs -->\n        <getter>\n          <![CDATA[\n            const XULNS =\n              \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n            return Array.map(this.getElementsByTagNameNS(XULNS, \"label\"),\n                             label => label.value)\n                        .join(\" \");\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"searchLabel\">\n        <getter>\n          <![CDATA[\n            return this.hasAttribute(\"searchlabel\") ?\n                   this.getAttribute(\"searchlabel\") : this.label;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            if (val !== null)\n              this.setAttribute(\"searchlabel\", val);\n            else\n              // fall back to the label property (default value)\n              this.removeAttribute(\"searchlabel\");\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"value\" onget=\"return this.getAttribute('value');\"\n                             onset=\"this.setAttribute('value', val); return val;\"/>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"selected\" onget=\"return this.getAttribute('selected') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.setAttribute(\"selected\", \"true\");\n          else\n            this.removeAttribute(\"selected\");\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"control\">\n        <getter><![CDATA[\n          var parent = this.parentNode;\n          while (parent) {\n            if (parent.localName == \"richlistbox\")\n              return parent;\n            parent = parent.parentNode;\n          }\n          return null;\n        ]]></getter>\n      </property>\n\n      <property name=\"current\" onget=\"return this.getAttribute('current') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.setAttribute(\"current\", \"true\");\n          else\n            this.removeAttribute(\"current\");\n          return val;\n        ]]></setter>\n      </property>\n    </implementation>\n\n    <handlers>\n      <!-- If there is no modifier key, we select on mousedown, not\n           click, so that drags work correctly. -->\n      <handler event=\"mousedown\">\n        <![CDATA[\n          var control = this.control;\n          if (!control || control.disabled)\n            return;\n          if ((!event.ctrlKey || (/Mac/.test(navigator.platform) && event.button == 2)) &&\n              !event.shiftKey && !event.metaKey) {\n            if (!this.selected) {\n              control.selectItem(this);\n            }\n            control.currentItem = this;\n          }\n        ]]>\n      </handler>\n\n      <!-- On a click (up+down on the same item), deselect everything\n           except this item. -->\n      <handler event=\"click\" button=\"0\">\n        <![CDATA[\n          var control = this.control;\n          if (!control || control.disabled)\n            return;\n          control._userSelecting = true;\n          if (control.selType != \"multiple\") {\n            control.selectItem(this);\n          } else if (event.ctrlKey || event.metaKey) {\n            control.toggleItemSelection(this);\n            control.currentItem = this;\n          } else if (event.shiftKey) {\n            control.selectItemRange(null, this);\n            control.currentItem = this;\n          } else {\n            /* We want to deselect all the selected items except what was\n              clicked, UNLESS it was a right-click.  We have to do this\n              in click rather than mousedown so that you can drag a\n              selected group of items */\n\n            // use selectItemRange instead of selectItem, because this\n            // doesn't de- and reselect this item if it is selected\n            control.selectItemRange(this, this);\n          }\n          control._userSelecting = false;\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"scrollbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"arrowscrollboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"arrowscrollbox\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <content>\n      <xul:toolbarbutton class=\"scrollbutton-up\"\n                         anonid=\"scrollbutton-up\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtostart\"\n                         onclick=\"_onButtonClick(event);\"\n                         onmousedown=\"_onButtonMouseDown(event, -1);\"\n                         onmouseup=\"_onButtonMouseUp(event);\"\n                         onmouseover=\"_onButtonMouseOver(-1);\"\n                         onmouseout=\"_onButtonMouseOut();\"/>\n      <xul:spacer class=\"arrowscrollbox-overflow-start-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtostart\"/>\n      <xul:scrollbox class=\"arrowscrollbox-scrollbox\"\n                     anonid=\"scrollbox\"\n                     flex=\"1\"\n                     xbl:inherits=\"orient,align,pack,dir,smoothscroll\">\n        <children/>\n      </xul:scrollbox>\n      <xul:spacer class=\"arrowscrollbox-overflow-end-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtoend\"/>\n      <xul:toolbarbutton class=\"scrollbutton-down\"\n                         anonid=\"scrollbutton-down\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtoend\"\n                         onclick=\"_onButtonClick(event);\"\n                         onmousedown=\"_onButtonMouseDown(event, 1);\"\n                         onmouseup=\"_onButtonMouseUp(event);\"\n                         onmouseover=\"_onButtonMouseOver(1);\"\n                         onmouseout=\"_onButtonMouseOut();\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (!this.hasAttribute(\"smoothscroll\")) {\n          this.smoothScroll = this._prefBranch\n                                  .getBoolPref(\"toolkit.scrollbox.smoothScroll\", true);\n        }\n\n        this.setAttribute(\"notoverflowing\", \"true\");\n        this._updateScrollButtonsDisabledState();\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // Release timer to avoid reference cycles.\n        if (this._scrollTimer) {\n          this._scrollTimer.cancel();\n          this._scrollTimer = null;\n        }\n      ]]></destructor>\n\n      <field name=\"scrollbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbox\");\n      </field>\n      <field name=\"_scrollButtonUp\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbutton-up\");\n      </field>\n      <field name=\"_scrollButtonDown\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbutton-down\");\n      </field>\n\n      <field name=\"_scrollIndex\">0</field>\n\n      <field name=\"_arrowScrollAnim\"><![CDATA[({\n        scrollbox: this,\n        requestHandle: 0, /* 0 indicates there is no pending request */\n        start: function arrowSmoothScroll_start() {\n          this.lastFrameTime = window.performance.now();\n          if (!this.requestHandle)\n            this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));\n        },\n        stop: function arrowSmoothScroll_stop() {\n          window.cancelAnimationFrame(this.requestHandle);\n          this.requestHandle = 0;\n        },\n        sample: function arrowSmoothScroll_handleEvent(timeStamp) {\n          const scrollIndex = this.scrollbox._scrollIndex;\n          const timePassed = timeStamp - this.lastFrameTime;\n          this.lastFrameTime = timeStamp;\n\n          const scrollDelta = 0.5 * timePassed * scrollIndex;\n          this.scrollbox.scrollByPixels(scrollDelta, true);\n          this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));\n        },\n      })]]></field>\n\n      <property name=\"_clickToScroll\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.hasAttribute(\"clicktoscroll\");\n        ]]></getter>\n      </property>\n\n      <property name=\"_scrollDelay\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._clickToScroll) {\n            return this._prefBranch.getIntPref(\n                            \"toolkit.scrollbox.clickToScroll.scrollDelay\", 150);\n          }\n\n          // Use the same REPEAT_DELAY as \"nsRepeatService.h\".\n          return /Mac/.test(navigator.platform) ? 25 : 50;\n        ]]></getter>\n      </property>\n\n      <field name=\"__prefBranch\">null</field>\n      <property name=\"_prefBranch\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.__prefBranch === null) {\n            this.__prefBranch = Cc[\"@mozilla.org/preferences-service;1\"]\n                                  .getService(Ci.nsIPrefBranch);\n          }\n          return this.__prefBranch;\n        ]]></getter>\n      </property>\n\n      <field name=\"_scrollIncrement\">null</field>\n      <property name=\"scrollIncrement\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._scrollIncrement === null) {\n            this._scrollIncrement = this._prefBranch\n                                        .getIntPref(\"toolkit.scrollbox.scrollIncrement\", 20);\n          }\n          return this._scrollIncrement;\n        ]]></getter>\n      </property>\n\n      <property name=\"smoothScroll\">\n        <getter><![CDATA[\n          return this.getAttribute(\"smoothscroll\") == \"true\";\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"smoothscroll\", !!val);\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"scrollBoxObject\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.scrollbox.boxObject;\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollClientRect\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.scrollbox.getBoundingClientRect();\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollClientSize\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this.scrollbox.clientHeight :\n                 this.scrollbox.clientWidth;\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollSize\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this.scrollbox.scrollHeight :\n                 this.scrollbox.scrollWidth;\n        ]]></getter>\n      </property>\n\n      <property name=\"lineScrollAmount\" readonly=\"true\">\n        <getter><![CDATA[\n          // line scroll amout should be the width (at horizontal scrollbox) or\n          // the height (at vertical scrollbox) of the scrolled elements.\n          // However, the elements may have different width or height.  So,\n          // for consistent speed, let's use avalage with of the elements.\n          var elements = this._getScrollableElements();\n          return elements.length && (this.scrollSize / elements.length);\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollPosition\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this.scrollbox.scrollTop :\n                 this.scrollbox.scrollLeft;\n        ]]></getter>\n      </property>\n\n      <field name=\"_startEndProps\"><![CDATA[\n        this.orient == \"vertical\" ? [\"top\", \"bottom\"] : [\"left\", \"right\"];\n      ]]></field>\n\n      <field name=\"_isRTLScrollbox\"><![CDATA[\n        this.orient != \"vertical\" &&\n        document.defaultView.getComputedStyle(this.scrollbox).direction == \"rtl\";\n      ]]></field>\n\n      <method name=\"_onButtonClick\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (this._clickToScroll) {\n            this._distanceScroll(event);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseDown\">\n        <parameter name=\"event\"/>\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._clickToScroll && event.button == 0) {\n            this._startScroll(index);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseUp\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (this._clickToScroll && event.button == 0) {\n            this._stopScroll();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseOver\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._clickToScroll) {\n            this._continueScroll(index);\n          } else {\n            this._startScroll(index);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onButtonMouseOut\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._clickToScroll) {\n            this._pauseScroll();\n          } else {\n            this._stopScroll();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_boundsWithoutFlushing\">\n        <parameter name=\"element\"/>\n        <body><![CDATA[\n          if (!(\"_DOMWindowUtils\" in this)) {\n            this._DOMWindowUtils = window.windowUtils;\n          }\n\n          return this._DOMWindowUtils ?\n                 this._DOMWindowUtils.getBoundsWithoutFlushing(element) :\n                 element.getBoundingClientRect();\n        ]]></body>\n      </method>\n\n      <method name=\"_canScrollToElement\">\n        <parameter name=\"element\"/>\n        <body><![CDATA[\n          if (element.hidden) {\n            return false;\n          }\n\n          // See if the element is hidden via CSS without the hidden attribute.\n          // If we get only zeros for the client rect, this means the element\n          // is hidden. As a performance optimization, we don't flush layout\n          // here which means that on the fly changes aren't fully supported.\n          let rect = this._boundsWithoutFlushing(element);\n          return !!(rect.top || rect.left || rect.width || rect.height);\n        ]]></body>\n      </method>\n\n      <field name=\"_ensureElementIsVisibleAnimationFrame\">0</field>\n      <method name=\"ensureElementIsVisible\">\n        <parameter name=\"element\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (!this._canScrollToElement(element))\n            return;\n\n          if (this._ensureElementIsVisibleAnimationFrame) {\n            window.cancelAnimationFrame(this._ensureElementIsVisibleAnimationFrame);\n          }\n          this._ensureElementIsVisibleAnimationFrame = window.requestAnimationFrame(() => {\n            element.scrollIntoView({ block: \"nearest\",\n                                     behavior: aInstant ? \"instant\" : \"auto\" });\n            this._ensureElementIsVisibleAnimationFrame = 0;\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"scrollByIndex\">\n        <parameter name=\"index\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (index == 0)\n            return;\n\n          var rect = this.scrollClientRect;\n          var [start, end] = this._startEndProps;\n          var x = index > 0 ? rect[end] + 1 : rect[start] - 1;\n          var nextElement = this._elementFromPoint(x, index);\n          if (!nextElement)\n            return;\n\n          var targetElement;\n          if (this._isRTLScrollbox)\n            index *= -1;\n          while (index < 0 && nextElement) {\n            if (this._canScrollToElement(nextElement))\n              targetElement = nextElement;\n            nextElement = nextElement.previousElementSibling;\n            index++;\n          }\n          while (index > 0 && nextElement) {\n            if (this._canScrollToElement(nextElement))\n              targetElement = nextElement;\n            nextElement = nextElement.nextElementSibling;\n            index--;\n          }\n          if (!targetElement)\n            return;\n\n          this.ensureElementIsVisible(targetElement, aInstant);\n        ]]></body>\n      </method>\n\n      <method name=\"_getScrollableElements\">\n        <body><![CDATA[\n          var nodes = this.children;\n          if (nodes.length == 1 &&\n              nodes[0].localName == \"children\" &&\n              nodes[0].namespaceURI == \"http://www.mozilla.org/xbl\") {\n            nodes = document.getBindingParent(this).children;\n          }\n\n          return Array.filter(nodes, this._canScrollToElement, this);\n        ]]></body>\n      </method>\n\n      <method name=\"_elementFromPoint\">\n        <parameter name=\"aX\"/>\n        <parameter name=\"aPhysicalScrollDir\"/>\n        <body><![CDATA[\n          var elements = this._getScrollableElements();\n          if (!elements.length)\n            return null;\n\n          if (this._isRTLScrollbox)\n            elements.reverse();\n\n          var [start, end] = this._startEndProps;\n          var low = 0;\n          var high = elements.length - 1;\n\n          if (aX < elements[low].getBoundingClientRect()[start] ||\n              aX > elements[high].getBoundingClientRect()[end])\n            return null;\n\n          var mid, rect;\n          while (low <= high) {\n            mid = Math.floor((low + high) / 2);\n            rect = elements[mid].getBoundingClientRect();\n            if (rect[start] > aX)\n              high = mid - 1;\n            else if (rect[end] < aX)\n              low = mid + 1;\n            else\n              return elements[mid];\n          }\n\n          // There's no element at the requested coordinate, but the algorithm\n          // from above yields an element next to it, in a random direction.\n          // The desired scrolling direction leads to the correct element.\n\n          if (!aPhysicalScrollDir)\n            return null;\n\n          if (aPhysicalScrollDir < 0 && rect[start] > aX)\n            mid = Math.max(mid - 1, 0);\n          else if (aPhysicalScrollDir > 0 && rect[end] < aX)\n            mid = Math.min(mid + 1, elements.length - 1);\n\n          return elements[mid];\n        ]]></body>\n      </method>\n\n      <method name=\"_startScroll\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._isRTLScrollbox) {\n            index *= -1;\n          }\n\n          if (this._clickToScroll) {\n            this._scrollIndex = index;\n            this._mousedown = true;\n\n            if (this.smoothScroll) {\n              this._arrowScrollAnim.start();\n              return;\n            }\n          }\n\n          if (!this._scrollTimer) {\n            this._scrollTimer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n          } else {\n            this._scrollTimer.cancel();\n          }\n\n          let callback;\n          if (this._clickToScroll) {\n            callback = () => {\n              if (!document && this._scrollTimer) {\n                this._scrollTimer.cancel();\n              }\n              this.scrollByIndex(this._scrollIndex);\n            };\n          } else {\n            callback = () => this.scrollByPixels(this.scrollIncrement * index);\n          }\n\n          this._scrollTimer.initWithCallback(callback, this._scrollDelay,\n                                             Ci.nsITimer.TYPE_REPEATING_SLACK);\n\n          callback();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_stopScroll\">\n        <body><![CDATA[\n          if (this._scrollTimer)\n            this._scrollTimer.cancel();\n\n          if (this._clickToScroll) {\n            this._mousedown = false;\n            if (!this._scrollIndex || !this.smoothScroll)\n              return;\n\n            this.scrollByIndex(this._scrollIndex);\n            this._scrollIndex = 0;\n\n            this._arrowScrollAnim.stop();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_pauseScroll\">\n        <body><![CDATA[\n          if (this._mousedown) {\n            this._stopScroll();\n            this._mousedown = true;\n            document.addEventListener(\"mouseup\", this);\n            document.addEventListener(\"blur\", this, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_continueScroll\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._mousedown)\n            this._startScroll(index);\n        ]]></body>\n      </method>\n\n      <method name=\"_distanceScroll\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.detail < 2 || aEvent.detail > 3)\n            return;\n\n          var scrollBack = (aEvent.originalTarget == this._scrollButtonUp);\n          var scrollLeftOrUp = this._isRTLScrollbox ? !scrollBack : scrollBack;\n          var targetElement;\n\n          if (aEvent.detail == 2) {\n            // scroll by the size of the scrollbox\n            let [start, end] = this._startEndProps;\n            let x;\n            if (scrollLeftOrUp)\n              x = this.scrollClientRect[start] - this.scrollClientSize;\n            else\n              x = this.scrollClientRect[end] + this.scrollClientSize;\n            targetElement = this._elementFromPoint(x, scrollLeftOrUp ? -1 : 1);\n\n            // the next partly-hidden element will become fully visible,\n            // so don't scroll too far\n            if (targetElement)\n              targetElement = scrollBack ?\n                              targetElement.nextElementSibling :\n                              targetElement.previousElementSibling;\n          }\n\n          if (!targetElement) {\n            // scroll to the first resp. last element\n            let elements = this._getScrollableElements();\n            targetElement = scrollBack ?\n                            elements[0] :\n                            elements[elements.length - 1];\n          }\n\n          this.ensureElementIsVisible(targetElement);\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.type == \"mouseup\" ||\n              aEvent.type == \"blur\" && aEvent.target == document) {\n            this._mousedown = false;\n            document.removeEventListener(\"mouseup\", this);\n            document.removeEventListener(\"blur\", this, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"scrollByPixels\">\n        <parameter name=\"aPixels\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          let scrollOptions = { behavior: aInstant ? \"instant\" : \"auto\" };\n          scrollOptions[this._startEndProps[0]] = aPixels;\n          this.scrollbox.scrollBy(scrollOptions);\n        ]]></body>\n      </method>\n\n      <field name=\"_prevMouseScrolls\">[null, null]</field>\n\n      <field name=\"_touchStart\">-1</field>\n\n      <field name=\"_scrollButtonUpdatePending\">false</field>\n      <method name=\"_updateScrollButtonsDisabledState\">\n        <body><![CDATA[\n          if (this.hasAttribute(\"notoverflowing\")) {\n            this.setAttribute(\"scrolledtoend\", \"true\");\n            this.setAttribute(\"scrolledtostart\", \"true\");\n            return;\n          }\n\n          if (this._scrollButtonUpdatePending) {\n            return;\n          }\n          this._scrollButtonUpdatePending = true;\n\n          // Wait until after the next paint to get current layout data from\n          // getBoundsWithoutFlushing.\n          window.requestAnimationFrame(() => {\n            setTimeout(() => {\n              if (!this._startEndProps) {\n                // We've been destroyed in the meantime.\n                return;\n              }\n\n              this._scrollButtonUpdatePending = false;\n\n              let scrolledToStart = false;\n              let scrolledToEnd = false;\n\n              if (this.hasAttribute(\"notoverflowing\")) {\n                scrolledToStart = true;\n                scrolledToEnd = true;\n              } else {\n                let [leftOrTop, rightOrBottom] = this._startEndProps;\n                let leftOrTopEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[leftOrTop]);\n                let rightOrBottomEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[rightOrBottom]);\n\n                let elements = this._getScrollableElements();\n                let [leftOrTopElement, rightOrBottomElement] = [elements[0], elements[elements.length - 1]];\n                if (this._isRTLScrollbox) {\n                  [leftOrTopElement, rightOrBottomElement] = [rightOrBottomElement, leftOrTopElement];\n                }\n\n                if (leftOrTopElement &&\n                    leftOrTopEdge(leftOrTopElement) >= leftOrTopEdge(this.scrollbox)) {\n                  scrolledToStart = !this._isRTLScrollbox;\n                  scrolledToEnd = this._isRTLScrollbox;\n                } else if (rightOrBottomElement &&\n                           rightOrBottomEdge(rightOrBottomElement) <= rightOrBottomEdge(this.scrollbox)) {\n                  scrolledToStart = this._isRTLScrollbox;\n                  scrolledToEnd = !this._isRTLScrollbox;\n                }\n              }\n\n              if (scrolledToEnd) {\n                this.setAttribute(\"scrolledtoend\", \"true\");\n              } else {\n                this.removeAttribute(\"scrolledtoend\");\n              }\n\n              if (scrolledToStart) {\n                this.setAttribute(\"scrolledtostart\", \"true\");\n              } else {\n                this.removeAttribute(\"scrolledtostart\");\n              }\n            }, 0);\n          });\n        ]]></body>\n      </method>\n\n      <field name=\"_isScrolling\">false</field>\n      <field name=\"_destination\">0</field>\n      <field name=\"_direction\">0</field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"wheel\"><![CDATA[\n        // Don't consume the event if we can't scroll.\n        if (this.hasAttribute(\"notoverflowing\")) {\n          return;\n        }\n\n        let doScroll = false;\n        let instant;\n        let scrollAmount = 0;\n        if (this.orient == \"vertical\") {\n          doScroll = true;\n          if (event.deltaMode == event.DOM_DELTA_PIXEL)\n            scrollAmount = event.deltaY;\n          else if (event.deltaMode == event.DOM_DELTA_PAGE)\n            scrollAmount = event.deltaY * this.scrollClientSize;\n          else\n            scrollAmount = event.deltaY * this.lineScrollAmount;\n        } else {\n          // We allow vertical scrolling to scroll a horizontal scrollbox\n          // because many users have a vertical scroll wheel but no\n          // horizontal support.\n          // Because of this, we need to avoid scrolling chaos on trackpads\n          // and mouse wheels that support simultaneous scrolling in both axes.\n          // We do this by scrolling only when the last two scroll events were\n          // on the same axis as the current scroll event.\n          // For diagonal scroll events we only respect the dominant axis.\n          let isVertical = Math.abs(event.deltaY) > Math.abs(event.deltaX);\n          let delta = isVertical ? event.deltaY : event.deltaX;\n          let scrollByDelta = isVertical && this._isRTLScrollbox ? -delta : delta;\n\n          if (this._prevMouseScrolls.every(prev => prev == isVertical)) {\n            doScroll = true;\n            if (event.deltaMode == event.DOM_DELTA_PIXEL) {\n              scrollAmount = scrollByDelta;\n              instant = true;\n            } else if (event.deltaMode == event.DOM_DELTA_PAGE) {\n              scrollAmount = scrollByDelta * this.scrollClientSize;\n            } else {\n              scrollAmount = scrollByDelta * this.lineScrollAmount;\n            }\n          }\n\n          if (this._prevMouseScrolls.length > 1)\n            this._prevMouseScrolls.shift();\n          this._prevMouseScrolls.push(isVertical);\n        }\n\n        if (doScroll) {\n          let direction = scrollAmount < 0 ? -1 : 1;\n          let startPos = this.scrollPosition;\n\n          if (!this._isScrolling || this._direction != direction) {\n            this._destination = startPos + scrollAmount;\n            this._direction = direction;\n          } else {\n            // We were already in the process of scrolling in this direction\n            this._destination = this._destination + scrollAmount;\n            scrollAmount = this._destination - startPos;\n          }\n          this.scrollByPixels(scrollAmount, instant);\n        }\n\n        event.stopPropagation();\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"touchstart\"><![CDATA[\n        if (event.touches.length > 1) {\n          // Multiple touch points detected, abort. In particular this aborts\n          // the panning gesture when the user puts a second finger down after\n          // already panning with one finger. Aborting at this point prevents\n          // the pan gesture from being resumed until all fingers are lifted\n          // (as opposed to when the user is back down to one finger).\n          this._touchStart = -1;\n        } else {\n          this._touchStart = (this.orient == \"vertical\"\n                ? event.touches[0].screenY\n                : event.touches[0].screenX);\n        }\n      ]]></handler>\n\n      <handler event=\"touchmove\"><![CDATA[\n        if (event.touches.length == 1 &&\n            this._touchStart >= 0) {\n          var touchPoint = (this.orient == \"vertical\"\n                ? event.touches[0].screenY\n                : event.touches[0].screenX);\n          var delta = this._touchStart - touchPoint;\n          if (Math.abs(delta) > 0) {\n            this.scrollByPixels(delta, true);\n            this._touchStart = touchPoint;\n          }\n          event.preventDefault();\n        }\n      ]]></handler>\n\n      <handler event=\"touchend\"><![CDATA[\n        this._touchStart = -1;\n      ]]></handler>\n\n      <handler event=\"underflow\" phase=\"capturing\"><![CDATA[\n        // Ignore underflow events:\n        // - from nested scrollable elements\n        // - corresponding to an overflow event that we ignored\n        if (event.target != this ||\n            this.hasAttribute(\"notoverflowing\")) {\n          return;\n        }\n\n        // Ignore events that doesn't match our orientation.\n        // Scrollport event orientation:\n        //   0: vertical\n        //   1: horizontal\n        //   2: both\n        if (this.orient == \"vertical\") {\n          if (event.detail == 1)\n            return;\n        } else if (event.detail == 0) {\n          // horizontal scrollbox\n          return;\n        }\n\n        this.setAttribute(\"notoverflowing\", \"true\");\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"overflow\" phase=\"capturing\"><![CDATA[\n        // Ignore overflow events:\n        // - from nested scrollable elements\n        if (event.target != this) {\n          return;\n        }\n\n        // Ignore events that doesn't match our orientation.\n        // Scrollport event orientation:\n        //   0: vertical\n        //   1: horizontal\n        //   2: both\n        if (this.orient == \"vertical\") {\n          if (event.detail == 1)\n            return;\n        } else if (event.detail == 0) {\n          // horizontal scrollbox\n          return;\n        }\n\n        this.removeAttribute(\"notoverflowing\");\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"scroll\"><![CDATA[\n        this._isScrolling = true;\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"scrollend\"><![CDATA[\n        this._isScrolling = false;\n        this._destination = 0;\n        this._direction = 0;\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"tabbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"tabBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n  <binding id=\"tabs\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <content>\n      <xul:spacer class=\"tabs-left\"/>\n      <children/>\n      <xul:spacer class=\"tabs-right\" flex=\"1\"/>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlElement, nsIDOMXULRelatedElement\">\n      <constructor>\n      <![CDATA[\n\n        if (!this.hasAttribute(\"orient\"))\n          this.setAttribute(\"orient\", \"horizontal\");\n\n        if (this.tabbox && this.tabbox.hasAttribute(\"selectedIndex\")) {\n          let selectedIndex = parseInt(this.tabbox.getAttribute(\"selectedIndex\"));\n          this.selectedIndex = selectedIndex > 0 ? selectedIndex : 0;\n          return;\n        }\n\n        var children = this.children;\n        var length = children.length;\n        for (var i = 0; i < length; i++) {\n          if (children[i].getAttribute(\"selected\") == \"true\") {\n            this.selectedIndex = i;\n            return;\n          }\n        }\n\n        var value = this.value;\n        if (value)\n          this.value = value;\n        else\n          this.selectedIndex = 0;\n      ]]>\n      </constructor>\n\n      <!-- nsIDOMXULRelatedElement -->\n      <method name=\"getRelatedElement\">\n        <parameter name=\"aTabElm\"/>\n        <body>\n        <![CDATA[\n          if (!aTabElm)\n            return null;\n\n          let tabboxElm = this.tabbox;\n          if (!tabboxElm)\n            return null;\n\n          let tabpanelsElm = tabboxElm.tabpanels;\n          if (!tabpanelsElm)\n            return null;\n\n          // Get linked tab panel by 'linkedpanel' attribute on the given tab\n          // element.\n          let linkedPanelId = aTabElm.linkedPanel;\n          if (linkedPanelId) {\n            let ownerDoc = this.ownerDocument;\n\n            // XXX bug 565858: if XUL tab element is anonymous element then\n            // suppose linked tab panel is hosted within the same XBL binding\n            // and search it by ID attribute inside an anonymous content of\n            // the binding. This is not robust assumption since tab elements may\n            // live outside a tabbox element so that for example tab elements\n            // can be explicit content but tab panels can be anonymous.\n\n            let bindingParent = ownerDoc.getBindingParent(aTabElm);\n            if (bindingParent)\n              return ownerDoc.getAnonymousElementByAttribute(bindingParent,\n                                                             \"id\",\n                                                             linkedPanelId);\n\n            return ownerDoc.getElementById(linkedPanelId);\n          }\n\n          // otherwise linked tabpanel element has the same index as the given\n          // tab element.\n          let tabElmIdx = this.getIndexOfItem(aTabElm);\n          return tabpanelsElm.children[tabElmIdx];\n        ]]>\n        </body>\n      </method>\n\n      <!-- nsIDOMXULSelectControlElement -->\n      <property name=\"itemCount\" readonly=\"true\"\n                onget=\"return this.children.length\"/>\n\n      <property name=\"value\" onget=\"return this.getAttribute('value');\">\n        <setter>\n          <![CDATA[\n            this.setAttribute(\"value\", val);\n            var children = this.children;\n            for (var c = children.length - 1; c >= 0; c--) {\n              if (children[c].value == val) {\n                this.selectedIndex = c;\n                break;\n              }\n            }\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <field name=\"_tabbox\">null</field>\n      <property name=\"tabbox\" readonly=\"true\">\n        <getter><![CDATA[\n          // Memoize the result in a field rather than replacing this property,\n          // so that it can be reset along with the binding.\n          if (this._tabbox) {\n            return this._tabbox;\n          }\n\n          let parent = this.parentNode;\n          while (parent) {\n            if (parent.localName == \"tabbox\") {\n              break;\n            }\n            parent = parent.parentNode;\n          }\n\n          return this._tabbox = parent;\n        ]]></getter>\n      </property>\n\n      <!-- _tabbox is deprecated, it exists only for backwards compatibility. -->\n      <field name=\"_tabbox\" readonly=\"true\"><![CDATA[\n        this.tabbox;\n      ]]></field>\n\n      <field name=\"_prefService\" readonly=\"true\"><![CDATA[\n        Cc[\"@mozilla.org/preferences-service;1\"].getService(Ci.nsIPrefBranch);\n      ]]></field>\n\n      <property name=\"selectedIndex\">\n        <getter>\n        <![CDATA[\n          const tabs = this.children;\n          for (var i = 0; i < tabs.length; i++) {\n            if (tabs[i].selected)\n              return i;\n          }\n          return -1;\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          var tab = this.getItemAtIndex(val);\n          if (tab) {\n            Array.forEach(this.children, function(aTab) {\n              if (aTab.selected && aTab != tab)\n                aTab._selected = false;\n            });\n            tab._selected = true;\n\n            this.setAttribute(\"value\", tab.value);\n\n            let linkedPanel = this.getRelatedElement(tab);\n            if (linkedPanel) {\n              this.tabbox.setAttribute(\"selectedIndex\", val);\n\n              // This will cause an onselect event to fire for the tabpanel\n              // element.\n              this.tabbox.tabpanels.selectedPanel = linkedPanel;\n            }\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedItem\">\n        <getter>\n        <![CDATA[\n          const tabs = this.children;\n          for (var i = 0; i < tabs.length; i++) {\n            if (tabs[i].selected)\n              return tabs[i];\n          }\n          return null;\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          if (val && !val.selected)\n            // The selectedIndex setter ignores invalid values\n            // such as -1 if |val| isn't one of our child nodes.\n            this.selectedIndex = this.getIndexOfItem(val);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <field name=\"ACTIVE_DESCENDANT_ID\" readonly=\"true\"><![CDATA[\n        \"keyboard-focused-tab-\" + Math.trunc(Math.random() * 1000000);\n      ]]></field>\n\n      <property name=\"ariaFocusedIndex\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          const tabs = this.children;\n          for (var i = 0; i < tabs.length; i++) {\n            if (tabs[i].id == this.ACTIVE_DESCENDANT_ID)\n              return i;\n          }\n          return -1;\n        ]]>\n        </getter>\n      </property>\n\n      <property name=\"ariaFocusedItem\">\n        <getter>\n        <![CDATA[\n          return document.getElementById(this.ACTIVE_DESCENDANT_ID);\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          let setNewItem = val && this.getIndexOfItem(val) != -1;\n          let clearExistingItem = this.ariaFocusedItem && (!val || setNewItem);\n          if (clearExistingItem) {\n            let ariaFocusedItem = this.ariaFocusedItem;\n            ariaFocusedItem.classList.remove(\"keyboard-focused-tab\");\n            ariaFocusedItem.id = \"\";\n            this.selectedItem.removeAttribute(\"aria-activedescendant\");\n          }\n\n          if (setNewItem) {\n            this.ariaFocusedItem = null;\n            val.id = this.ACTIVE_DESCENDANT_ID;\n            val.classList.add(\"keyboard-focused-tab\");\n            this.selectedItem.setAttribute(\"aria-activedescendant\", this.ACTIVE_DESCENDANT_ID);\n          }\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"item\"/>\n        <body>\n        <![CDATA[\n          return Array.indexOf(this.children, item);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"index\"/>\n        <body>\n        <![CDATA[\n          return this.children.item(index);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_selectNewTab\">\n        <parameter name=\"aNewTab\"/>\n        <parameter name=\"aFallbackDir\"/>\n        <parameter name=\"aWrap\"/>\n        <body>\n        <![CDATA[\n          this.ariaFocusedItem = null;\n\n          var requestedTab = aNewTab;\n          while (aNewTab.hidden || aNewTab.disabled || !this._canAdvanceToTab(aNewTab)) {\n            aNewTab = aFallbackDir == -1 ? aNewTab.previousElementSibling : aNewTab.nextElementSibling;\n            if (!aNewTab && aWrap)\n              aNewTab = aFallbackDir == -1 ? this.children[this.children.length - 1] :\n                                             this.children[0];\n            if (!aNewTab || aNewTab == requestedTab)\n              return;\n          }\n\n          var isTabFocused = false;\n          try {\n            isTabFocused =\n              (document.commandDispatcher.focusedElement == this.selectedItem);\n          } catch (e) {}\n          this.selectedItem = aNewTab;\n          if (isTabFocused) {\n            aNewTab.focus();\n          } else if (this.getAttribute(\"setfocus\") != \"false\") {\n            let selectedPanel = this.tabbox.selectedPanel;\n            document.commandDispatcher.advanceFocusIntoSubtree(selectedPanel);\n\n            // Make sure that the focus doesn't move outside the tabbox\n            if (this.tabbox) {\n              try {\n                let el = document.commandDispatcher.focusedElement;\n                while (el && el != this.tabbox.tabpanels) {\n                  if (el == this.tabbox || el == selectedPanel)\n                    return;\n                  el = el.parentNode;\n                }\n                aNewTab.focus();\n              } catch (e) {\n              }\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_canAdvanceToTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          return true;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"advanceSelectedTab\">\n        <parameter name=\"aDir\"/>\n        <parameter name=\"aWrap\"/>\n        <body>\n        <![CDATA[\n          var startTab = this.ariaFocusedItem || this.selectedItem;\n          var next = startTab[(aDir == -1 ? \"previous\" : \"next\") + \"ElementSibling\"];\n          if (!next && aWrap) {\n            next = aDir == -1 ? this.children[this.children.length - 1] :\n                                this.children[0];\n          }\n          if (next && next != startTab) {\n            this._selectNewTab(next, aDir, aWrap);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"appendItem\">\n        <parameter name=\"label\"/>\n        <parameter name=\"value\"/>\n        <body>\n        <![CDATA[\n          var tab = document.createXULElement(\"tab\");\n          tab.setAttribute(\"label\", label);\n          tab.setAttribute(\"value\", value);\n          this.appendChild(tab);\n          return tab;\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"DOMMouseScroll\">\n      <![CDATA[\n        if (this._prefService.getBoolPref(\"toolkit.tabbox.switchByScrolling\")) {\n          if (event.detail > 0) {\n            this.advanceSelectedTab(1, false);\n          } else {\n            this.advanceSelectedTab(-1, false);\n          }\n          event.stopPropagation();\n        }\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"tab\"\n           extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <content>\n      <xul:hbox class=\"tab-middle box-inherit\" xbl:inherits=\"align,dir,pack,orient,selected,visuallyselected\" flex=\"1\">\n        <xul:image class=\"tab-icon\"\n                   xbl:inherits=\"validate,src=image\"\n                   role=\"presentation\"/>\n        <xul:label class=\"tab-text\"\n                   xbl:inherits=\"value=label,accesskey,crop,disabled\"\n                   flex=\"1\"\n                   role=\"presentation\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <property name=\"value\" onset=\"this.setAttribute('value', val); return val;\"\n                             onget=\"return this.getAttribute('value');\"/>\n      <property name=\"control\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var parent = this.parentNode;\n            return (parent.localName == \"tabs\") ? parent : null;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"selected\" readonly=\"true\"\n                onget=\"return this.getAttribute('selected') == 'true';\"/>\n\n      <property name=\"_selected\">\n        <setter><![CDATA[\n          if (val) {\n            this.setAttribute(\"selected\", \"true\");\n            this.setAttribute(\"visuallyselected\", \"true\");\n          } else {\n            this.removeAttribute(\"selected\");\n            this.removeAttribute(\"visuallyselected\");\n          }\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"linkedPanel\" onget=\"return this.getAttribute('linkedpanel')\"\n                                   onset=\"this.setAttribute('linkedpanel', val); return val;\"/>\n\n      <field name=\"arrowKeysShouldWrap\" readonly=\"true\">\n        /Mac/.test(navigator.platform)\n      </field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"mousedown\" button=\"0\">\n      <![CDATA[\n        if (this.disabled)\n          return;\n\n        this.parentNode.ariaFocusedItem = null;\n\n        if (this != this.parentNode.selectedItem) { // Not selected yet\n          let stopwatchid = this.parentNode.getAttribute(\"stopwatchid\");\n          if (stopwatchid) {\n            TelemetryStopwatch.start(stopwatchid);\n          }\n\n          // Call this before setting the 'ignorefocus' attribute because this\n          // will pass on focus if the formerly selected tab was focused as well.\n          this.parentNode._selectNewTab(this);\n\n          var isTabFocused = false;\n          try {\n            isTabFocused = (document.commandDispatcher.focusedElement == this);\n          } catch (e) {}\n\n          // Set '-moz-user-focus' to 'ignore' so that PostHandleEvent() can't\n          // focus the tab; we only want tabs to be focusable by the mouse if\n          // they are already focused. After a short timeout we'll reset\n          // '-moz-user-focus' so that tabs can be focused by keyboard again.\n          if (!isTabFocused) {\n            this.setAttribute(\"ignorefocus\", \"true\");\n            setTimeout(tab => tab.removeAttribute(\"ignorefocus\"), 0, this);\n          }\n\n          if (stopwatchid) {\n            TelemetryStopwatch.finish(stopwatchid);\n          }\n        }\n        // Otherwise this tab is already selected and we will fall\n        // through to mousedown behavior which sets focus on the current tab,\n        // Only a click on an already selected tab should focus the tab itself.\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_LEFT\" preventdefault=\"true\">\n      <![CDATA[\n        var direction = window.getComputedStyle(this.parentNode).direction;\n        this.parentNode.advanceSelectedTab(direction == \"ltr\" ? -1 : 1, this.arrowKeysShouldWrap);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_RIGHT\" preventdefault=\"true\">\n      <![CDATA[\n        var direction = window.getComputedStyle(this.parentNode).direction;\n        this.parentNode.advanceSelectedTab(direction == \"ltr\" ? 1 : -1, this.arrowKeysShouldWrap);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_UP\" preventdefault=\"true\">\n      <![CDATA[\n        this.parentNode.advanceSelectedTab(-1, this.arrowKeysShouldWrap);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_DOWN\" preventdefault=\"true\">\n      <![CDATA[\n        this.parentNode.advanceSelectedTab(1, this.arrowKeysShouldWrap);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_HOME\" preventdefault=\"true\">\n      <![CDATA[\n        this.parentNode._selectNewTab(this.parentNode.children[0]);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_END\" preventdefault=\"true\">\n      <![CDATA[\n        var tabs = this.parentNode.children;\n        this.parentNode._selectNewTab(tabs[tabs.length - 1], -1);\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"text.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"textBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\">\n\n  <binding id=\"label-control\">\n    <content>\n      <children/><html:span anonid=\"accessKeyParens\"></html:span>\n    </content>\n    <implementation>\n      <constructor>\n        <![CDATA[\n          this.formatAccessKey(true);\n        ]]>\n      </constructor>\n\n      <method name=\"formatAccessKey\">\n        <parameter name=\"firstTime\"/>\n        <body>\n          <![CDATA[\n            var control = this.labeledControlElement;\n            if (!control) {\n              var bindingParent = document.getBindingParent(this);\n              if (\"accessKey\" in bindingParent) {\n                control = bindingParent; // For controls that make the <label> an anon child\n              }\n            }\n            if (control) {\n              control.labelElement = this;\n              var controlAccessKey = control.getAttribute(\"accesskey\");\n              if (controlAccessKey) {\n                this.setAttribute(\"accesskey\", controlAccessKey);\n              }\n            }\n\n            var accessKey = this.accessKey;\n            // No need to remove existing formatting the first time.\n            if (firstTime && !accessKey)\n              return;\n\n            if (this.mInsertSeparator === undefined) {\n              try {\n                var prefs = Cc[\"@mozilla.org/preferences-service;1\"].\n                                       getService(Ci.nsIPrefBranch);\n                this.mUnderlineAccesskey = (prefs.getIntPref(\"ui.key.menuAccessKey\") != 0);\n\n                const nsIPrefLocalizedString =\n                  Ci.nsIPrefLocalizedString;\n\n                const prefNameInsertSeparator =\n                  \"intl.menuitems.insertseparatorbeforeaccesskeys\";\n                const prefNameAlwaysAppendAccessKey =\n                  \"intl.menuitems.alwaysappendaccesskeys\";\n\n                var val = prefs.getComplexValue(prefNameInsertSeparator,\n                                                nsIPrefLocalizedString).data;\n                this.mInsertSeparator = (val == \"true\");\n\n                val = prefs.getComplexValue(prefNameAlwaysAppendAccessKey,\n                                            nsIPrefLocalizedString).data;\n                this.mAlwaysAppendAccessKey = (val == \"true\");\n              } catch (e) {\n                this.mInsertSeparator = true;\n              }\n            }\n\n            if (!this.mUnderlineAccesskey)\n              return;\n\n            var afterLabel = document.getAnonymousElementByAttribute(this, \"anonid\", \"accessKeyParens\");\n            afterLabel.textContent = \"\";\n\n            var oldAccessKey = this.getElementsByAttribute(\"class\", \"accesskey\").item(0);\n            if (oldAccessKey) { // Clear old accesskey\n              this.mergeElement(oldAccessKey);\n            }\n\n            var oldHiddenSpan =\n              this.getElementsByAttribute(\"class\", \"hiddenColon\").item(0);\n            if (oldHiddenSpan) {\n              this.mergeElement(oldHiddenSpan);\n            }\n\n            var labelText = this.textContent;\n            if (!accessKey || !labelText || !control) {\n              return;\n            }\n            var accessKeyIndex = -1;\n            if (!this.mAlwaysAppendAccessKey) {\n              accessKeyIndex = labelText.indexOf(accessKey);\n              if (accessKeyIndex < 0) { // Try again in upper case\n                accessKeyIndex =\n                  labelText.toUpperCase().indexOf(accessKey.toUpperCase());\n              }\n            } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {\n              accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.\n            }\n\n            const HTML_NS = \"http://www.w3.org/1999/xhtml\";\n            var span = document.createElementNS(HTML_NS, \"span\");\n            span.className = \"accesskey\";\n\n            // Note that if you change the following code, see the comment of\n            // nsTextBoxFrame::UpdateAccessTitle.\n\n            // If accesskey is not in string, append in parentheses\n            if (accessKeyIndex < 0) {\n              // If end is colon, we should insert before colon.\n              // i.e., \"label:\" -> \"label(X):\"\n              var colonHidden = false;\n              if (/:$/.test(labelText)) {\n                labelText = labelText.slice(0, -1);\n                var hiddenSpan = document.createElementNS(HTML_NS, \"span\");\n                hiddenSpan.className = \"hiddenColon\";\n                hiddenSpan.style.display = \"none\";\n                // Hide the last colon by using span element.\n                // I.e., label<span style=\"display:none;\">:</span>\n                this.wrapChar(hiddenSpan, labelText.length);\n                colonHidden = true;\n              }\n              // If end is space(U+20),\n              // we should not add space before parentheses.\n              var endIsSpace = false;\n              if (/ $/.test(labelText)) {\n                endIsSpace = true;\n              }\n              if (this.mInsertSeparator && !endIsSpace)\n                afterLabel.textContent = \" (\";\n              else\n                afterLabel.textContent = \"(\";\n              span.textContent = accessKey.toUpperCase();\n              afterLabel.appendChild(span);\n              if (!colonHidden)\n                afterLabel.appendChild(document.createTextNode(\")\"));\n              else\n                afterLabel.appendChild(document.createTextNode(\"):\"));\n              return;\n            }\n            this.wrapChar(span, accessKeyIndex);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"wrapChar\">\n        <parameter name=\"element\"/>\n        <parameter name=\"index\"/>\n        <body>\n          <![CDATA[\n             var treeWalker = document.createTreeWalker(this,\n                                                        NodeFilter.SHOW_TEXT,\n                                                        null);\n             var node = treeWalker.nextNode();\n             while (index >= node.length) {\n               index -= node.length;\n               node = treeWalker.nextNode();\n             }\n             if (index) {\n               node = node.splitText(index);\n             }\n             node.parentNode.insertBefore(element, node);\n             if (node.length > 1) {\n               node.splitText(1);\n             }\n             element.appendChild(node);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"mergeElement\">\n        <parameter name=\"element\"/>\n        <body>\n          <![CDATA[\n            if (element.previousSibling instanceof Text) {\n              element.previousSibling.appendData(element.textContent);\n            } else {\n              element.parentNode.insertBefore(element.firstChild, element);\n            }\n            element.remove();\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"mUnderlineAccesskey\">\n        !/Mac/.test(navigator.platform)\n      </field>\n      <field name=\"mInsertSeparator\"/>\n      <field name=\"mAlwaysAppendAccessKey\">false</field>\n\n      <property name=\"accessKey\">\n        <getter>\n          <![CDATA[\n            var accessKey = this.getAttribute(\"accesskey\");\n            return accessKey ? accessKey[0] : null;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            // If this label already has an accesskey attribute store it here as well\n            if (this.hasAttribute(\"accesskey\")) {\n              this.setAttribute(\"accesskey\", val);\n            }\n            var control = this.labeledControlElement;\n            if (control) {\n              control.setAttribute(\"accesskey\", val);\n            }\n            this.formatAccessKey(false);\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"labeledControlElement\" readonly=\"true\"\n                onget=\"var control = this.control; return control ? document.getElementById(control) : null;\" />\n\n      <property name=\"control\" onget=\"return this.getAttribute('control');\">\n        <setter>\n          <![CDATA[\n            var control = this.labeledControlElement;\n            if (control) {\n              control.labelElement = null; // No longer pointed to be this label\n            }\n            this.setAttribute(\"control\", val);\n            this.formatAccessKey(false);\n            return val;\n          ]]>\n        </setter>\n      </property>\n    </implementation>\n\n    <handlers>\n      <handler event=\"click\"><![CDATA[\n        if (this.disabled) {\n          return;\n        }\n        var controlElement = this.labeledControlElement;\n        if (!controlElement) {\n          return;\n        }\n        controlElement.focus();\n        const XUL_NS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\n        if (controlElement.namespaceURI != XUL_NS) {\n          return;\n        }\n        if (controlElement.localName == \"checkbox\") {\n          controlElement.checked = !controlElement.checked;\n        } else if (controlElement.localName == \"radio\") {\n          controlElement.control.selectedItem = controlElement;\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"text-link\">\n    <implementation>\n      <property name=\"href\" onget=\"return this.getAttribute('href');\"\n                            onset=\"this.setAttribute('href', val); return val;\" />\n      <method name=\"open\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          var href = this.href;\n          if (!href || this.disabled || aEvent.defaultPrevented)\n            return;\n\n          var uri = null;\n          try {\n            const nsISSM = Ci.nsIScriptSecurityManager;\n            const secMan =\n                     Cc[\"@mozilla.org/scriptsecuritymanager;1\"]\n                       .getService(nsISSM);\n\n            const ioService =\n                     Cc[\"@mozilla.org/network/io-service;1\"]\n                       .getService(Ci.nsIIOService);\n\n            uri = ioService.newURI(href);\n\n            let principal;\n            if (this.getAttribute(\"useoriginprincipal\") == \"true\") {\n              principal = this.nodePrincipal;\n            } else {\n              principal = secMan.createNullPrincipal({});\n            }\n            try {\n              secMan.checkLoadURIWithPrincipal(principal, uri,\n                                               nsISSM.DISALLOW_INHERIT_PRINCIPAL);\n            } catch (ex) {\n              var msg = \"Error: Cannot open a \" + uri.scheme + \": link using \\\n                         the text-link binding.\";\n              Cu.reportError(msg);\n              return;\n            }\n\n            const cID = \"@mozilla.org/uriloader/external-protocol-service;1\";\n            const nsIEPS = Ci.nsIExternalProtocolService;\n            var protocolSvc = Cc[cID].getService(nsIEPS);\n\n            // if the scheme is not an exposed protocol, then opening this link\n            // should be deferred to the system's external protocol handler\n            if (!protocolSvc.isExposedProtocol(uri.scheme)) {\n              protocolSvc.loadURI(uri);\n              aEvent.preventDefault();\n              return;\n            }\n\n          } catch (ex) {\n            Cu.reportError(ex);\n          }\n\n          aEvent.preventDefault();\n          href = uri ? uri.spec : href;\n\n          // Try handing off the link to the host application, e.g. for\n          // opening it in a tabbed browser.\n          var linkHandled = Cc[\"@mozilla.org/supports-PRBool;1\"]\n                              .createInstance(Ci.nsISupportsPRBool);\n          linkHandled.data = false;\n          let {shiftKey, ctrlKey, metaKey, altKey, button} = aEvent;\n          let data = {shiftKey, ctrlKey, metaKey, altKey, button, href};\n          Cc[\"@mozilla.org/observer-service;1\"]\n            .getService(Ci.nsIObserverService)\n            .notifyObservers(linkHandled, \"handle-xul-text-link\", JSON.stringify(data));\n          if (linkHandled.data)\n            return;\n\n          // otherwise, fall back to opening the anchor directly\n          var win = window;\n          if (window.isChromeWindow) {\n            while (win.opener && !win.opener.closed)\n              win = win.opener;\n          }\n          win.open(href);\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"click\" phase=\"capturing\" button=\"0\" action=\"this.open(event)\"/>\n      <handler event=\"click\" phase=\"capturing\" button=\"1\" action=\"this.open(event)\"/>\n      <handler event=\"keypress\" preventdefault=\"true\" keycode=\"VK_RETURN\" action=\"this.click()\" />\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"textbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This files relies on these specific Chrome/XBL globals -->\n<!-- globals ChromeWindow -->\n\n\n<!DOCTYPE bindings [\n  <!ENTITY % textcontextDTD SYSTEM \"chrome://global/locale/textcontext.dtd\" >\n  %textcontextDTD;\n]>\n\n<bindings id=\"textboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"textbox\">\n    <content>\n      <children/>\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\" xbl:inherits=\"context,spellcheck\">\n        <html:input class=\"textbox-input\" anonid=\"input\"\n                    xbl:inherits=\"value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,noinitialfocus,mozactionhint,spellcheck\"/>\n      </xul:moz-input-box>\n    </content>\n\n    <implementation>\n      <!-- nsIDOMXULLabeledControlElement -->\n      <field name=\"crop\">\"\"</field>\n      <field name=\"image\">\"\"</field>\n      <field name=\"command\">\"\"</field>\n      <field name=\"accessKey\">\"\"</field>\n\n      <field name=\"mInputField\">null</field>\n      <field name=\"mIgnoreClick\">false</field>\n      <field name=\"mIgnoreFocus\">false</field>\n      <field name=\"mEditor\">null</field>\n\n      <property name=\"inputField\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.mInputField)\n            this.mInputField = document.getAnonymousElementByAttribute(this, \"anonid\", \"input\");\n          return this.mInputField;\n        ]]></getter>\n      </property>\n\n      <property name=\"value\"      onset=\"this.inputField.value = val; return val;\"\n                                  onget=\"return this.inputField.value;\"/>\n      <property name=\"defaultValue\" onset=\"this.inputField.defaultValue = val; return val;\"\n                                  onget=\"return this.inputField.defaultValue;\"/>\n      <property name=\"label\"      onset=\"this.setAttribute('label', val); return val;\"\n                                  onget=\"return this.getAttribute('label') ||\n                                                (this.labelElement ? this.labelElement.value :\n                                                 this.placeholder);\"/>\n      <property name=\"placeholder\" onset=\"this.inputField.placeholder = val; return val;\"\n                                  onget=\"return this.inputField.placeholder;\"/>\n      <property name=\"emptyText\"  onset=\"this.placeholder = val; return val;\"\n                                  onget=\"return this.placeholder;\"/>\n      <property name=\"type\"       onset=\"if (val) this.setAttribute('type', val);\n                                         else this.removeAttribute('type'); return val;\"\n                                  onget=\"return this.getAttribute('type');\"/>\n      <property name=\"maxLength\"  onset=\"this.inputField.maxLength = val; return val;\"\n                                  onget=\"return this.inputField.maxLength;\"/>\n      <property name=\"disabled\"   onset=\"this.inputField.disabled = val;\n                                         if (val) this.setAttribute('disabled', 'true');\n                                         else this.removeAttribute('disabled'); return val;\"\n                                  onget=\"return this.inputField.disabled;\"/>\n      <property name=\"tabIndex\"   onget=\"return parseInt(this.getAttribute('tabindex'));\"\n                                  onset=\"this.inputField.tabIndex = val;\n                                         if (val) this.setAttribute('tabindex', val);\n                                         else this.removeAttribute('tabindex'); return val;\"/>\n      <property name=\"size\"       onset=\"this.inputField.size = val; return val;\"\n                                  onget=\"return this.inputField.size;\"/>\n      <property name=\"readOnly\"   onset=\"this.inputField.readOnly = val;\n                                         if (val) this.setAttribute('readonly', 'true');\n                                         else this.removeAttribute('readonly'); return val;\"\n                                  onget=\"return this.inputField.readOnly;\"/>\n      <property name=\"clickSelectsAll\"\n                onget=\"return this.getAttribute('clickSelectsAll') == 'true';\"\n                onset=\"if (val) this.setAttribute('clickSelectsAll', 'true');\n                       else this.removeAttribute('clickSelectsAll'); return val;\" />\n\n      <property name=\"editor\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.mEditor) {\n            this.mEditor = this.inputField.editor;\n          }\n          return this.mEditor;\n        ]]></getter>\n      </property>\n\n      <method name=\"reset\">\n        <body><![CDATA[\n          this.value = this.defaultValue;\n          try {\n            this.editor.transactionManager.clear();\n            return true;\n          } catch (e) {}\n          return false;\n        ]]></body>\n      </method>\n\n      <method name=\"select\">\n        <body>\n          this.inputField.select();\n        </body>\n      </method>\n\n      <method name=\"setUserInput\">\n        <parameter name=\"value\"/>\n        <body><![CDATA[\n          this.inputField.setUserInput(value);\n        ]]></body>\n      </method>\n\n      <property name=\"controllers\"    readonly=\"true\" onget=\"return this.inputField.controllers\"/>\n      <property name=\"textLength\"     readonly=\"true\"\n                                      onget=\"return this.inputField.textLength;\"/>\n      <property name=\"selectionStart\" onset=\"this.inputField.selectionStart = val; return val;\"\n                                      onget=\"return this.inputField.selectionStart;\"/>\n      <property name=\"selectionEnd\"   onset=\"this.inputField.selectionEnd = val; return val;\"\n                                      onget=\"return this.inputField.selectionEnd;\"/>\n\n      <method name=\"setSelectionRange\">\n        <parameter name=\"aSelectionStart\"/>\n        <parameter name=\"aSelectionEnd\"/>\n        <body>\n          // According to https://html.spec.whatwg.org/#do-not-apply,\n          // setSelectionRange() is only available on a limited set of input types.\n          if (this.inputField.type == \"text\" ||\n              this.inputField.tagName == \"html:textarea\") {\n            this.inputField.setSelectionRange( aSelectionStart, aSelectionEnd );\n          }\n        </body>\n      </method>\n\n      <method name=\"_setNewlineHandling\">\n        <body><![CDATA[\n          var str = this.getAttribute(\"newlines\");\n          if (str && this.editor) {\n            const nsIPlaintextEditor = Ci.nsIPlaintextEditor;\n            for (var x in nsIPlaintextEditor) {\n              if (/^eNewlines/.test(x)) {\n                if (str == RegExp.rightContext.toLowerCase()) {\n                  this.editor.QueryInterface(nsIPlaintextEditor)\n                      .newlineHandling = nsIPlaintextEditor[x];\n                  break;\n                }\n              }\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_maybeSelectAll\">\n        <body><![CDATA[\n          if (!this.mIgnoreClick && this.clickSelectsAll &&\n              document.activeElement == this.inputField &&\n              this.inputField.selectionStart == this.inputField.selectionEnd)\n            this.editor.selectAll();\n        ]]></body>\n      </method>\n\n      <constructor><![CDATA[\n        var str = this.boxObject.getProperty(\"value\");\n        if (str) {\n          this.inputField.value = str;\n          this.boxObject.removeProperty(\"value\");\n        }\n\n        this._setNewlineHandling();\n\n        if (this.hasAttribute(\"emptytext\"))\n          this.placeholder = this.getAttribute(\"emptytext\");\n      ]]></constructor>\n\n      <destructor>\n        <![CDATA[\n          var field = this.inputField;\n          if (field && field.value)\n            this.boxObject.setProperty(\"value\", field.value);\n          this.mInputField = null;\n        ]]>\n      </destructor>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"focus\" phase=\"capturing\">\n        <![CDATA[\n          if (this.hasAttribute(\"focused\"))\n            return;\n\n          switch (event.originalTarget) {\n            case this:\n              // Forward focus to actual HTML input\n              this.inputField.focus();\n              this.setAttribute(\"focused\", \"true\");\n              break;\n            case this.inputField:\n              if (this.mIgnoreFocus) {\n                this.mIgnoreFocus = false;\n              } else if (this.clickSelectsAll) {\n                try {\n                  if (!this.editor || !this.editor.composing)\n                    this.editor.selectAll();\n                } catch (e) {}\n              }\n              this.setAttribute(\"focused\", \"true\");\n              break;\n            default:\n              // Otherwise, allow other children (e.g. URL bar buttons) to get focus\n              break;\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"blur\" phase=\"capturing\">\n        <![CDATA[\n          this.removeAttribute(\"focused\");\n\n          // don't trigger clickSelectsAll when switching application windows\n          if (window == window.top &&\n              window.isChromeWindow &&\n              document.activeElement == this.inputField)\n            this.mIgnoreFocus = true;\n        ]]>\n      </handler>\n\n      <handler event=\"mousedown\">\n        <![CDATA[\n          this.mIgnoreClick = this.hasAttribute(\"focused\");\n\n          if (!this.mIgnoreClick) {\n            this.mIgnoreFocus = true;\n            this.setSelectionRange(0, 0);\n            if (event.originalTarget == this ||\n                event.originalTarget == this.inputField.parentNode)\n              this.inputField.focus();\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"click\" action=\"this._maybeSelectAll();\"/>\n\n\n    </handlers>\n  </binding>\n\n  <binding id=\"search-textbox\" extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content>\n      <children/>\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\" xbl:inherits=\"context,spellcheck\" align=\"center\">\n        <xul:image class=\"textbox-search-sign\"/>\n        <html:input class=\"textbox-input\" anonid=\"input\" mozactionhint=\"search\"\n                    xbl:inherits=\"value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,mozactionhint,spellcheck\"/>\n        <xul:deck class=\"textbox-search-icons\" anonid=\"search-icons\">\n          <xul:image class=\"textbox-search-icon\" anonid=\"searchbutton-icon\"\n                     xbl:inherits=\"src=image,label=searchbuttonlabel,searchbutton,disabled\"/>\n          <xul:image class=\"textbox-search-clear\"\n                     onclick=\"document.getBindingParent(this)._clearSearch();\"\n                     label=\"FROM-DTD.searchTextBox.clear.label;\"\n                     xbl:inherits=\"disabled\"/>\n        </xul:deck>\n      </xul:moz-input-box>\n    </content>\n    <implementation>\n      <field name=\"_timer\">null</field>\n      <field name=\"_searchIcons\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"search-icons\");\n      </field>\n      <field name=\"_searchButtonIcon\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"searchbutton-icon\");\n      </field>\n      <property name=\"timeout\"\n                onset=\"this.setAttribute('timeout', val); return val;\"\n                onget=\"return parseInt(this.getAttribute('timeout')) || 500;\"/>\n      <property name=\"searchButton\"\n                onget=\"return this.getAttribute('searchbutton') == 'true';\">\n        <setter><![CDATA[\n          if (val) {\n            this.setAttribute(\"searchbutton\", \"true\");\n            this.removeAttribute(\"aria-autocomplete\");\n            // Hack for the button to get the right accessible:\n            this._searchButtonIcon.setAttribute(\"onclick\", \"true\");\n          } else {\n            this.removeAttribute(\"searchbutton\");\n            this._searchButtonIcon.removeAttribute(\"onclick\");\n            this.setAttribute(\"aria-autocomplete\", \"list\");\n          }\n          return val;\n        ]]></setter>\n      </property>\n      <property name=\"value\"\n                onget=\"return this.inputField.value;\">\n        <setter><![CDATA[\n          this.inputField.value = val;\n\n          if (val)\n            this._searchIcons.selectedIndex = this.searchButton ? 0 : 1;\n          else\n            this._searchIcons.selectedIndex = 0;\n\n          if (this._timer)\n            clearTimeout(this._timer);\n\n          return val;\n        ]]></setter>\n      </property>\n      <constructor><![CDATA[\n        // Ensure the button state is up to date:\n        this.searchButton = this.searchButton;\n        this._searchButtonIcon.addEventListener(\"click\", (e) => this._iconClick(e));\n      ]]></constructor>\n      <method name=\"_fireCommand\">\n        <parameter name=\"me\"/>\n        <body><![CDATA[\n          if (me._timer)\n            clearTimeout(me._timer);\n          me._timer = null;\n          me.doCommand();\n        ]]></body>\n      </method>\n      <method name=\"_iconClick\">\n        <body><![CDATA[\n          if (this.searchButton)\n            this._enterSearch();\n          else\n            this.focus();\n        ]]></body>\n      </method>\n      <method name=\"_enterSearch\">\n        <body><![CDATA[\n          if (this.disabled)\n            return;\n          if (this.searchButton && this.value && !this.readOnly)\n            this._searchIcons.selectedIndex = 1;\n          this._fireCommand(this);\n        ]]></body>\n      </method>\n      <method name=\"_clearSearch\">\n        <body><![CDATA[\n          if (!this.disabled && !this.readOnly && this.value) {\n            this.value = \"\";\n            this._fireCommand(this);\n            this._searchIcons.selectedIndex = 0;\n            return true;\n          }\n          return false;\n        ]]></body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"input\">\n        <![CDATA[\n          if (this.searchButton) {\n            this._searchIcons.selectedIndex = 0;\n            return;\n          }\n          if (this._timer)\n            clearTimeout(this._timer);\n          this._timer = this.timeout && setTimeout(this._fireCommand, this.timeout, this);\n          this._searchIcons.selectedIndex = this.value ? 1 : 0;\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_ESCAPE\">\n        <![CDATA[\n          if (this._clearSearch()) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\">\n        <![CDATA[\n          this._enterSearch();\n          event.preventDefault();\n          event.stopPropagation();\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"textarea\" extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content>\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\" xbl:inherits=\"context,spellcheck\">\n        <html:textarea class=\"textbox-textarea\" anonid=\"input\"\n                       xbl:inherits=\"xbl:text=value,disabled,tabindex,rows,cols,readonly,wrap,placeholder,mozactionhint,spellcheck\"><children/></html:textarea>\n      </xul:moz-input-box>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"toolbarbutton.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"toolbarbuttonBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"toolbarbutton\" display=\"xul:button\"\n           extends=\"chrome://global/content/bindings/button.xml#button-base\">\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:image class=\"toolbarbutton-icon\" xbl:inherits=\"validate,src=image,label,type,consumeanchor,triggeringprincipal=iconloadingprincipal\"/>\n      <xul:label class=\"toolbarbutton-text\" crop=\"right\" flex=\"1\"\n                 xbl:inherits=\"value=label,accesskey,crop,dragover-top,wrap\"/>\n      <xul:label class=\"toolbarbutton-multiline-text\" flex=\"1\"\n                 xbl:inherits=\"xbl:text=label,accesskey,wrap\"/>\n      <children includes=\"box\"/>\n      <xul:dropmarker anonid=\"dropmarker\" type=\"menu\"\n                      class=\"toolbarbutton-menu-dropmarker\" xbl:inherits=\"disabled,label\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menu\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton\">\n  </binding>\n\n  <binding id=\"toolbarbutton-badged\"\n           extends=\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton\">\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:stack class=\"toolbarbutton-badge-stack\">\n        <children/>\n        <xul:image class=\"toolbarbutton-icon\" xbl:inherits=\"validate,src=image,label,consumeanchor\"/>\n        <xul:label class=\"toolbarbutton-badge\" xbl:inherits=\"value=badge,style=badgeStyle\" top=\"0\" end=\"0\" crop=\"none\"/>\n      </xul:stack>\n      <xul:label class=\"toolbarbutton-text\" crop=\"right\" flex=\"1\"\n                 xbl:inherits=\"value=label,accesskey,crop,wrap\"/>\n      <xul:label class=\"toolbarbutton-multiline-text\" flex=\"1\"\n                 xbl:inherits=\"xbl:text=label,accesskey,wrap\"/>\n      <xul:dropmarker anonid=\"dropmarker\" type=\"menu\"\n                      class=\"toolbarbutton-menu-dropmarker\" xbl:inherits=\"disabled,label\"/>\n    </content>\n  </binding>\n\n  <binding id=\"toolbarbutton-badged-menu\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton-badged\">\n  </binding>\n</bindings>\n"},{"file":"tree.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE bindings [\n<!ENTITY % treeDTD SYSTEM \"chrome://global/locale/tree.dtd\">\n%treeDTD;\n]>\n\n<bindings id=\"treeBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"tree\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <content hidevscroll=\"true\" hidehscroll=\"true\" clickthrough=\"never\">\n      <children includes=\"treecols\"/>\n      <xul:stack class=\"tree-stack\" flex=\"1\">\n        <xul:hbox class=\"tree-rows\" flex=\"1\">\n          <xul:hbox flex=\"1\" class=\"tree-bodybox\">\n            <children/>\n          </xul:hbox>\n          <xul:scrollbar height=\"0\" minwidth=\"0\" minheight=\"0\" orient=\"vertical\" xbl:inherits=\"collapsed=hidevscroll\" style=\"position:relative; z-index:2147483647;\"\n            oncontextmenu=\"event.stopPropagation(); event.preventDefault();\"\n            onclick=\"event.stopPropagation(); event.preventDefault();\"\n            ondblclick=\"event.stopPropagation();\"\n            oncommand=\"event.stopPropagation();\"/>\n          </xul:hbox>\n        <xul:textbox anonid=\"input\" class=\"tree-input\" left=\"0\" top=\"0\" hidden=\"true\"/>\n      </xul:stack>\n      <xul:hbox xbl:inherits=\"collapsed=hidehscroll\">\n        <xul:scrollbar orient=\"horizontal\" flex=\"1\" increment=\"16\" style=\"position:relative; z-index:2147483647;\"\n          oncontextmenu=\"event.stopPropagation(); event.preventDefault();\"\n          onclick=\"event.stopPropagation(); event.preventDefault();\"\n          ondblclick=\"event.stopPropagation();\"\n          oncommand=\"event.stopPropagation();\"/>\n        <xul:scrollcorner xbl:inherits=\"collapsed=hidevscroll\"\n          oncontextmenu=\"event.stopPropagation(); event.preventDefault();\"\n          onclick=\"event.stopPropagation(); event.preventDefault();\"\n          ondblclick=\"event.stopPropagation();\"\n          oncommand=\"event.stopPropagation();\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULMultiSelectControlElement\">\n      <property name=\"body\"\n                onget=\"return this.treeBody;\"/>\n\n      <property name=\"editable\"\n                onget=\"return this.getAttribute('editable') == 'true';\"\n                onset=\"if (val) this.setAttribute('editable', 'true');\n                       else this.removeAttribute('editable'); return val;\"/>\n\n      <!-- ///////////////// nsIDOMXULSelectControlElement ///////////////// -->\n\n      <!-- ///////////////// nsIDOMXULMultiSelectControlElement ///////////////// -->\n\n      <property name=\"selType\"\n                onget=\"return this.getAttribute('seltype')\"\n                onset=\"this.setAttribute('seltype', val); return val;\"/>\n\n      <property name=\"currentIndex\"\n                onget=\"return this.view ? this.view.selection.currentIndex: - 1;\"\n                onset=\"if (this.view) return this.view.selection.currentIndex = val; return val;\"/>\n\n      <field name=\"pageUpOrDownMovesSelection\">\n        !/Mac/.test(navigator.platform)\n      </field>\n      <property name=\"keepCurrentInView\"\n                onget=\"return (this.getAttribute('keepcurrentinview') == 'true');\"\n                onset=\"if (val) this.setAttribute('keepcurrentinview', 'true');\n                       else this.removeAttribute('keepcurrentinview'); return val;\"/>\n\n      <property name=\"enableColumnDrag\"\n                onget=\"return this.hasAttribute('enableColumnDrag');\"\n                onset=\"if (val) this.setAttribute('enableColumnDrag', 'true');\n                       else this.removeAttribute('enableColumnDrag'); return val;\"/>\n\n      <field name=\"_inputField\">null</field>\n\n      <property name=\"inputField\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._inputField)\n            this._inputField = document.getAnonymousElementByAttribute(this, \"anonid\", \"input\");\n          return this._inputField;\n        ]]></getter>\n      </property>\n\n     <property name=\"disableKeyNavigation\"\n                onget=\"return this.hasAttribute('disableKeyNavigation');\"\n                onset=\"if (val) this.setAttribute('disableKeyNavigation', 'true');\n                       else this.removeAttribute('disableKeyNavigation'); return val;\"/>\n\n      <field name=\"_editingRow\">-1</field>\n      <field name=\"_editingColumn\">null</field>\n\n      <property name=\"editingRow\" readonly=\"true\"\n                onget=\"return this._editingRow;\"/>\n      <property name=\"editingColumn\" readonly=\"true\"\n                onget=\"return this._editingColumn;\"/>\n\n      <property name=\"_selectDelay\"\n                onset=\"this.setAttribute('_selectDelay', val);\"\n                onget=\"return this.getAttribute('_selectDelay') || 50;\"/>\n      <field name=\"_columnsDirty\">true</field>\n      <field name=\"_lastKeyTime\">0</field>\n      <field name=\"_incrementalString\">\"\"</field>\n\n      <field name=\"_touchY\">-1</field>\n\n      <method name=\"_ensureColumnOrder\">\n        <body><![CDATA[\n          if (!this._columnsDirty)\n            return;\n\n          if (this.columns) {\n            // update the ordinal position of each column to assure that it is\n            // an odd number and 2 positions above its next sibling\n            var cols = [];\n            var i;\n            for (var col = this.columns.getFirstColumn(); col; col = col.getNext())\n              cols.push(col.element);\n            for (i = 0; i < cols.length; ++i)\n              cols[i].setAttribute(\"ordinal\", (i * 2) + 1);\n\n            // update the ordinal positions of splitters to even numbers, so that\n            // they are in between columns\n            var splitters = this.getElementsByTagName(\"splitter\");\n            for (i = 0; i < splitters.length; ++i)\n              splitters[i].setAttribute(\"ordinal\", (i + 1) * 2);\n          }\n          this._columnsDirty = false;\n        ]]></body>\n      </method>\n\n      <method name=\"_reorderColumn\">\n        <parameter name=\"aColMove\"/>\n        <parameter name=\"aColBefore\"/>\n        <parameter name=\"aBefore\"/>\n        <body><![CDATA[\n          this._ensureColumnOrder();\n\n          var i;\n          var cols = [];\n          var col = this.columns.getColumnFor(aColBefore);\n          if (parseInt(aColBefore.ordinal) < parseInt(aColMove.ordinal)) {\n            if (aBefore)\n              cols.push(aColBefore);\n            for (col = col.getNext(); col.element != aColMove;\n                 col = col.getNext())\n              cols.push(col.element);\n\n            aColMove.ordinal = cols[0].ordinal;\n            for (i = 0; i < cols.length; ++i)\n              cols[i].ordinal = parseInt(cols[i].ordinal) + 2;\n          } else if (aColBefore.ordinal != aColMove.ordinal) {\n            if (!aBefore)\n              cols.push(aColBefore);\n            for (col = col.getPrevious(); col.element != aColMove;\n                 col = col.getPrevious())\n              cols.push(col.element);\n\n            aColMove.ordinal = cols[0].ordinal;\n            for (i = 0; i < cols.length; ++i)\n              cols[i].ordinal = parseInt(cols[i].ordinal) - 2;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_getColumnAtX\">\n        <parameter name=\"aX\"/>\n        <parameter name=\"aThresh\"/>\n        <parameter name=\"aPos\"/>\n        <body><![CDATA[\n          var isRTL = document.defaultView.getComputedStyle(this)\n                              .direction == \"rtl\";\n\n          if (aPos)\n            aPos.value = isRTL ? \"after\" : \"before\";\n\n          var columns = [];\n          var col = this.columns.getFirstColumn();\n          while (col) {\n            columns.push(col);\n            col = col.getNext();\n          }\n          if (isRTL)\n            columns.reverse();\n          var currentX = this.boxObject.x;\n          var adjustedX = aX + this.horizontalPosition;\n          for (var i = 0; i < columns.length; ++i) {\n            col = columns[i];\n            var cw = col.element.boxObject.width;\n            if (cw > 0) {\n              currentX += cw;\n              if (currentX - (cw * aThresh) > adjustedX)\n                return col.element;\n            }\n          }\n\n          if (aPos)\n            aPos.value = isRTL ? \"before\" : \"after\";\n          return columns.pop().element;\n        ]]></body>\n      </method>\n\n      <method name=\"changeOpenState\">\n        <parameter name=\"row\"/>\n        <!-- Optional parameter openState == true or false to set.\n             No openState param == toggle -->\n        <parameter name=\"openState\"/>\n        <body><![CDATA[\n          if (row < 0 || !this.view.isContainer(row)) {\n            return false;\n          }\n\n          if (this.view.isContainerOpen(row) != openState) {\n            this.view.toggleOpenState(row);\n            if (row == this.currentIndex) {\n              // Only fire event when current row is expanded or collapsed\n              // because that's all the assistive technology really cares about.\n              var event = document.createEvent(\"Events\");\n              event.initEvent(\"OpenStateChange\", true, true);\n              this.dispatchEvent(event);\n            }\n            return true;\n          }\n          return false;\n        ]]></body>\n      </method>\n\n      <method name=\"_keyNavigate\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          var key = String.fromCharCode(event.charCode).toLowerCase();\n          if (event.timeStamp - this._lastKeyTime > 1000)\n            this._incrementalString = key;\n          else\n            this._incrementalString += key;\n          this._lastKeyTime = event.timeStamp;\n\n          var length = this._incrementalString.length;\n          var incrementalString = this._incrementalString;\n          var charIndex = 1;\n          while (charIndex < length && incrementalString[charIndex] == incrementalString[charIndex - 1])\n            charIndex++;\n          // If all letters in incremental string are same, just try to match the first one\n          if (charIndex == length) {\n            length = 1;\n            incrementalString = incrementalString.substring(0, length);\n          }\n\n          var keyCol = this.columns.getKeyColumn();\n          var rowCount = this.view.rowCount;\n          var start = 1;\n\n          var c = this.currentIndex;\n          if (length > 1) {\n            start = 0;\n            if (c < 0)\n              c = 0;\n          }\n\n          for (var i = 0; i < rowCount; i++) {\n            var l = (i + start + c) % rowCount;\n            var cellText = this.view.getCellText(l, keyCol);\n            cellText = cellText.substring(0, length).toLowerCase();\n            if (cellText == incrementalString)\n              return l;\n          }\n          return -1;\n        ]]></body>\n      </method>\n\n      <method name=\"startEditing\">\n        <parameter name=\"row\"/>\n        <parameter name=\"column\"/>\n        <body>\n          <![CDATA[\n            if (!this.editable)\n              return false;\n            if (row < 0 || row >= this.view.rowCount || !column)\n              return false;\n            if (column.type != window.TreeColumn.TYPE_TEXT &&\n                column.type != window.TreeColumn.TYPE_PASSWORD)\n              return false;\n            if (column.cycler || !this.view.isEditable(row, column))\n              return false;\n\n            // Beyond this point, we are going to edit the cell.\n            if (this._editingColumn)\n              this.stopEditing();\n\n            var input = this.inputField;\n\n            this.ensureCellIsVisible(row, column);\n\n            // Get the coordinates of the text inside the cell.\n            var textRect = this.getCoordsForCellItem(row, column, \"text\");\n\n            // Get the coordinates of the cell itself.\n            var cellRect = this.getCoordsForCellItem(row, column, \"cell\");\n\n            // Calculate the top offset of the textbox.\n            var style = window.getComputedStyle(input);\n            var topadj = parseInt(style.borderTopWidth) + parseInt(style.paddingTop);\n            input.top = textRect.y - topadj;\n\n            // The leftside of the textbox is aligned to the left side of the text\n            // in LTR mode, and left side of the cell in RTL mode.\n            var left, widthdiff;\n            if (style.direction == \"rtl\") {\n              left = cellRect.x;\n              widthdiff = cellRect.x - textRect.x;\n            } else {\n              left = textRect.x;\n              widthdiff = textRect.x - cellRect.x;\n            }\n\n            input.left = left;\n            input.height = textRect.height + topadj +\n                           parseInt(style.borderBottomWidth) +\n                           parseInt(style.paddingBottom);\n            input.width = cellRect.width - widthdiff;\n            input.hidden = false;\n\n            input.value = this.view.getCellText(row, column);\n\n            input.select();\n            input.inputField.focus();\n\n            this._editingRow = row;\n            this._editingColumn = column;\n            this.setAttribute(\"editing\", \"true\");\n\n            this.invalidateCell(row, column);\n            return true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"stopEditing\">\n        <parameter name=\"accept\"/>\n        <body>\n          <![CDATA[\n            if (!this._editingColumn)\n              return;\n\n            var input = this.inputField;\n            var editingRow = this._editingRow;\n            var editingColumn = this._editingColumn;\n            this._editingRow = -1;\n            this._editingColumn = null;\n\n            if (accept) {\n              var value = input.value;\n              this.view.setCellText(editingRow, editingColumn, value);\n            }\n            input.hidden = true;\n            input.value = \"\";\n            this.removeAttribute(\"editing\");\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByOffset\">\n        <parameter name=\"offset\"/>\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (event.getModifierState(\"Accel\") && this.view.selection.single) {\n              this.scrollByLines(offset);\n              return;\n            }\n\n            var c = this.currentIndex + offset;\n            if (offset > 0 ? c > edge : c < edge) {\n              if (this.view.selection.isSelected(edge) && this.view.selection.count <= 1)\n                return;\n              c = edge;\n            }\n\n            if (!event.getModifierState(\"Accel\"))\n              this.view.selection.timedSelect(c, this._selectDelay);\n            else // Ctrl+Up/Down moves the anchor without selecting\n              this.currentIndex = c;\n            this.ensureRowIsVisible(c);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByOffsetShift\">\n        <parameter name=\"offset\"/>\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.view.selection.single) {\n              this.scrollByLines(offset);\n              return;\n            }\n\n            if (this.view.rowCount == 1 && !this.view.selection.isSelected(0)) {\n              this.view.selection.timedSelect(0, this._selectDelay);\n              return;\n            }\n\n            var c = this.currentIndex;\n            if (c == -1)\n                c = 0;\n\n            if (c == edge) {\n              if (this.view.selection.isSelected(c))\n                return;\n            }\n\n            // Extend the selection from the existing pivot, if any\n            this.view.selection.rangedSelect(-1, c + offset,\n                                             event.getModifierState(\"Accel\"));\n            this.ensureRowIsVisible(c + offset);\n\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByPage\">\n        <parameter name=\"offset\"/>\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.pageUpOrDownMovesSelection == event.getModifierState(\"Accel\")) {\n               this.scrollByPages(offset);\n               return;\n            }\n\n            if (this.view.rowCount == 1 && !this.view.selection.isSelected(0)) {\n              this.view.selection.timedSelect(0, this._selectDelay);\n              return;\n            }\n\n            var c = this.currentIndex;\n            if (c == -1)\n              return;\n\n            if (c == edge && this.view.selection.isSelected(c)) {\n              this.ensureRowIsVisible(c);\n              return;\n            }\n            var i = this.getFirstVisibleRow();\n            var p = this.getPageLength();\n\n            if (offset > 0) {\n              i += p - 1;\n              if (c >= i) {\n                 i = c + p;\n                 this.ensureRowIsVisible(i > edge ? edge : i);\n              }\n              i = i > edge ? edge : i;\n\n            } else if (c <= i) {\n               i = c <= p ? 0 : c - p;\n               this.ensureRowIsVisible(i);\n            }\n            this.view.selection.timedSelect(i, this._selectDelay);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByPageShift\">\n        <parameter name=\"offset\"/>\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.view.rowCount == 1 && !this.view.selection.isSelected(0) &&\n                !(this.pageUpOrDownMovesSelection == event.getModifierState(\"Accel\"))) {\n              this.view.selection.timedSelect(0, this._selectDelay);\n              return;\n            }\n\n            if (this.view.selection.single)\n              return;\n\n            var c = this.currentIndex;\n            if (c == -1)\n              return;\n            if (c == edge && this.view.selection.isSelected(c)) {\n              this.ensureRowIsVisible(edge);\n              return;\n            }\n            var i = this.getFirstVisibleRow();\n            var p = this.getPageLength();\n\n            if (offset > 0) {\n              i += p - 1;\n              if (c >= i) {\n                 i = c + p;\n                 this.ensureRowIsVisible(i > edge ? edge : i);\n              }\n              // Extend the selection from the existing pivot, if any\n              this.view.selection.rangedSelect(-1, i > edge ? edge : i, event.getModifierState(\"Accel\"));\n\n            } else {\n\n              if (c <= i) {\n                 i = c <= p ? 0 : c - p;\n                 this.ensureRowIsVisible(i);\n              }\n              // Extend the selection from the existing pivot, if any\n              this.view.selection.rangedSelect(-1, i, event.getModifierState(\"Accel\"));\n            }\n\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveToEdge\">\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.view.selection.isSelected(edge) && this.view.selection.count == 1) {\n              this.currentIndex = edge;\n              return;\n            }\n\n            // Normal behaviour is to select the first/last row\n            if (!event.getModifierState(\"Accel\"))\n              this.view.selection.timedSelect(edge, this._selectDelay);\n\n            // In a multiselect tree Ctrl+Home/End moves the anchor\n            else if (!this.view.selection.single)\n              this.currentIndex = edge;\n\n            this.ensureRowIsVisible(edge);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveToEdgeShift\">\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.view.rowCount == 1 && !this.view.selection.isSelected(0)) {\n              this.view.selection.timedSelect(0, this._selectDelay);\n              return;\n            }\n\n            if (this.view.selection.single ||\n                (this.view.selection.isSelected(edge)) && this.view.selection.isSelected(this.currentIndex))\n              return;\n\n            // Extend the selection from the existing pivot, if any.\n            // -1 doesn't work here, so using currentIndex instead\n            this.view.selection.rangedSelect(this.currentIndex, edge, event.getModifierState(\"Accel\"));\n\n            this.ensureRowIsVisible(edge);\n          ]]>\n        </body>\n      </method>\n      <method name=\"_handleEnter\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (this._editingColumn) {\n            this.stopEditing(true);\n            this.focus();\n            return true;\n          }\n\n          return this.changeOpenState(this.currentIndex);\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"underflow\">\n        <![CDATA[\n          // Scrollport event orientation\n          // 0: vertical\n          // 1: horizontal\n          // 2: both (not used)\n          if (event.target.tagName != \"treechildren\")\n            return;\n          if (event.detail == 1)\n            this.setAttribute(\"hidehscroll\", \"true\");\n          else if (event.detail == 0)\n            this.setAttribute(\"hidevscroll\", \"true\");\n          event.stopPropagation();\n        ]]>\n      </handler>\n      <handler event=\"overflow\">\n        <![CDATA[\n          if (event.target.tagName != \"treechildren\")\n            return;\n          if (event.detail == 1)\n            this.removeAttribute(\"hidehscroll\");\n          else if (event.detail == 0)\n            this.removeAttribute(\"hidevscroll\");\n          event.stopPropagation();\n        ]]>\n      </handler>\n      <handler event=\"touchstart\">\n        <![CDATA[\n          function isScrollbarElement(target) {\n            return (target.localName == \"thumb\" || target.localName == \"slider\")\n                && target.namespaceURI == \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          }\n          if (event.touches.length > 1 || isScrollbarElement(event.touches[0].target)) {\n            // Multiple touch points detected, abort. In particular this aborts\n            // the panning gesture when the user puts a second finger down after\n            // already panning with one finger. Aborting at this point prevents\n            // the pan gesture from being resumed until all fingers are lifted\n            // (as opposed to when the user is back down to one finger).\n            // Additionally, if the user lands on the scrollbar don't use this\n            // code for scrolling, instead allow gecko to handle scrollbar\n            // interaction normally.\n            this._touchY = -1;\n          } else {\n            this._touchY = event.touches[0].screenY;\n          }\n        ]]>\n      </handler>\n      <handler event=\"touchmove\">\n        <![CDATA[\n          if (event.touches.length == 1 &&\n              this._touchY >= 0) {\n            var deltaY = this._touchY - event.touches[0].screenY;\n            var lines = Math.trunc(deltaY / this.rowHeight);\n            if (Math.abs(lines) > 0) {\n              this.scrollByLines(lines);\n              deltaY -= lines * this.rowHeight;\n              this._touchY = event.touches[0].screenY + deltaY;\n            }\n            event.preventDefault();\n          }\n        ]]>\n      </handler>\n      <handler event=\"touchend\">\n        <![CDATA[\n          this._touchY = -1;\n        ]]>\n      </handler>\n      <handler event=\"MozMousePixelScroll\">\n        <![CDATA[\n          if (!(this.getAttribute(\"allowunderflowscroll\") == \"true\" &&\n                this.getAttribute(\"hidevscroll\") == \"true\"))\n            event.preventDefault();\n        ]]>\n      </handler>\n      <handler event=\"DOMMouseScroll\">\n        <![CDATA[\n          if (!(this.getAttribute(\"allowunderflowscroll\") == \"true\" &&\n                this.getAttribute(\"hidevscroll\") == \"true\"))\n            event.preventDefault();\n\n          if (this._editingColumn)\n            return;\n          if (event.axis == event.HORIZONTAL_AXIS)\n            return;\n\n          var rows = event.detail;\n          if (rows == UIEvent.SCROLL_PAGE_UP)\n            this.scrollByPages(-1);\n          else if (rows == UIEvent.SCROLL_PAGE_DOWN)\n            this.scrollByPages(1);\n          else\n            this.scrollByLines(rows);\n        ]]>\n      </handler>\n      <handler event=\"MozSwipeGesture\" preventdefault=\"true\">\n        <![CDATA[\n          // Figure out which row to show\n          let targetRow = 0;\n\n          // Only handle swipe gestures up and down\n          switch (event.direction) {\n            case event.DIRECTION_DOWN:\n              targetRow = this.view.rowCount - 1;\n              // Fall through for actual action\n            case event.DIRECTION_UP:\n              this.ensureRowIsVisible(targetRow);\n              break;\n          }\n        ]]>\n      </handler>\n      <handler event=\"select\" phase=\"target\"\n               action=\"if (event.originalTarget == this) this.stopEditing(true);\"/>\n      <handler event=\"focus\">\n        <![CDATA[\n          this.focused = true;\n          if (this.currentIndex == -1 && this.view.rowCount > 0) {\n            this.currentIndex = this.getFirstVisibleRow();\n          }\n        ]]>\n      </handler>\n      <handler event=\"blur\" action=\"this.focused = false;\"/>\n      <handler event=\"blur\" phase=\"capturing\"\n               action=\"if (event.originalTarget == this.inputField.inputField) this.stopEditing(true);\"/>\n      <handler event=\"keydown\" keycode=\"VK_RETURN\">\n        if (this._handleEnter(event)) {\n          event.stopPropagation();\n          event.preventDefault();\n        }\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_ESCAPE\">\n        <![CDATA[\n          if (this._editingColumn) {\n            this.stopEditing(false);\n            this.focus();\n            event.stopPropagation();\n            event.preventDefault();\n          }\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_LEFT\">\n        <![CDATA[\n         if (this._editingColumn)\n           return;\n\n         var row = this.currentIndex;\n         if (row < 0)\n           return;\n\n         if (this.changeOpenState(this.currentIndex, false)) {\n           event.preventDefault();\n           return;\n         }\n         var parentIndex = this.view.getParentIndex(this.currentIndex);\n         if (parentIndex >= 0) {\n           this.view.selection.select(parentIndex);\n           this.ensureRowIsVisible(parentIndex);\n           event.preventDefault();\n         }\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_RIGHT\">\n        <![CDATA[\n         if (this._editingColumn)\n           return;\n\n          var row = this.currentIndex;\n          if (row < 0)\n            return;\n\n          if (this.changeOpenState(row, true)) {\n            event.preventDefault();\n            return;\n          }\n          var c = row + 1;\n          var view = this.view;\n          if (c < view.rowCount &&\n              view.getParentIndex(c) == row) {\n            // If already opened, select the first child.\n            // The getParentIndex test above ensures that the children\n            // are already populated and ready.\n            this.view.selection.timedSelect(c, this._selectDelay);\n            this.ensureRowIsVisible(c);\n            event.preventDefault();\n          }\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_UP\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByOffset(-1, 0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_DOWN\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByOffset(1, this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_UP\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByOffsetShift(-1, 0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_DOWN\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByOffsetShift(1, this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_PAGE_UP\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByPage(-1, 0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_PAGE_DOWN\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByPage(1, this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_PAGE_UP\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByPageShift(-1, 0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_PAGE_DOWN\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByPageShift(1, this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_HOME\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveToEdge(0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_END\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveToEdge(this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_HOME\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveToEdgeShift(0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_END\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveToEdgeShift(this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keypress\">\n        <![CDATA[\n         if (this._editingColumn)\n           return;\n\n         if (event.charCode == \" \".charCodeAt(0)) {\n           var c = this.currentIndex;\n           if (!this.view.selection.isSelected(c) ||\n               (!this.view.selection.single && event.getModifierState(\"Accel\"))) {\n             this.view.selection.toggleSelect(c);\n             event.preventDefault();\n           }\n         } else if (!this.disableKeyNavigation && event.charCode > 0 &&\n                    !event.altKey && !event.getModifierState(\"Accel\") &&\n                    !event.metaKey && !event.ctrlKey) {\n           var l = this._keyNavigate(event);\n           if (l >= 0) {\n             this.view.selection.timedSelect(l, this._selectDelay);\n             this.ensureRowIsVisible(l);\n           }\n           event.preventDefault();\n         }\n         ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"wizard.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE bindings [\n  <!ENTITY % wizardDTD SYSTEM \"chrome://global/locale/wizard.dtd\">\n  %wizardDTD;\n]>\n\n<bindings id=\"wizardBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"wizard\">\n    <content>\n      <xul:hbox class=\"wizard-header\" anonid=\"Header\"/>\n\n      <xul:deck class=\"wizard-page-box\" flex=\"1\" anonid=\"Deck\">\n        <children includes=\"wizardpage\"/>\n      </xul:deck>\n      <children/>\n\n      <xul:hbox class=\"wizard-buttons\" anonid=\"Buttons\" xbl:inherits=\"pagestep,firstpage,lastpage\"/>\n    </content>\n\n    <implementation>\n      <property name=\"title\" onget=\"return document.title;\"\n                             onset=\"return document.title = val;\"/>\n\n      <property name=\"canAdvance\" onget=\"return this._canAdvance;\"\n                                  onset=\"this._nextButton.disabled = !val; return this._canAdvance = val;\"/>\n      <property name=\"canRewind\" onget=\"return this._canRewind;\"\n                                 onset=\"this._backButton.disabled = !val; return this._canRewind = val;\"/>\n\n      <property name=\"pageStep\" readonly=\"true\" onget=\"return this._pageStack.length\"/>\n\n      <field name=\"pageCount\">0</field>\n\n      <field name=\"_accessMethod\">null</field>\n      <field name=\"_pageStack\">null</field>\n      <field name=\"_currentPage\">null</field>\n\n      <property name=\"wizardPages\">\n        <getter>\n        <![CDATA[\n          var xulns = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          return this.getElementsByTagNameNS(xulns, \"wizardpage\");\n        ]]>\n        </getter>\n      </property>\n\n      <property name=\"currentPage\" onget=\"return this._currentPage\">\n        <setter>\n        <![CDATA[\n          if (!val)\n            return val;\n\n          this._currentPage = val;\n\n          // Setting this attribute allows wizard's clients to dynamically\n          // change the styles of each page based on purpose of the page.\n          this.setAttribute(\"currentpageid\", val.pageid);\n          if (this.onFirstPage) {\n            this.canRewind = false;\n            this.setAttribute(\"firstpage\", \"true\");\n            if (/Linux/.test(navigator.platform)) {\n              this._backButton.setAttribute('hidden', 'true');\n            }\n          } else {\n            this.canRewind = true;\n            this.setAttribute(\"firstpage\", \"false\");\n            if (/Linux/.test(navigator.platform)) {\n              this._backButton.setAttribute('hidden', 'false');\n            }\n          }\n\n          if (this.onLastPage) {\n            this.canAdvance = true;\n            this.setAttribute(\"lastpage\", \"true\");\n          } else {\n            this.setAttribute(\"lastpage\", \"false\");\n          }\n\n          this._deck.setAttribute(\"selectedIndex\", val.pageIndex);\n          this._advanceFocusToPage(val);\n\n          this._adjustWizardHeader();\n          this._wizardButtons.onPageChange();\n\n          this._fireEvent(val, \"pageshow\");\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"pageIndex\"\n                onget=\"return this._currentPage ? this._currentPage.pageIndex : -1;\">\n        <setter>\n        <![CDATA[\n          if (val < 0 || val >= this.pageCount)\n            return val;\n\n          var page = this.wizardPages[val];\n          this._pageStack[this._pageStack.length-1] = page;\n          this.currentPage = page;\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"onFirstPage\" readonly=\"true\"\n                onget=\"return this._pageStack.length == 1;\"/>\n\n      <property name=\"onLastPage\" readonly=\"true\">\n        <getter><![CDATA[\n          var cp = this.currentPage;\n          return cp && ((this._accessMethod == \"sequential\" && cp.pageIndex == this.pageCount-1) ||\n                       (this._accessMethod == \"random\" && cp.next == \"\"));\n         ]]></getter>\n      </property>\n\n      <method name=\"getButton\">\n        <parameter name=\"aDlgType\"/>\n        <body>\n        <![CDATA[\n          var btns = this.getElementsByAttribute(\"dlgtype\", aDlgType);\n          return btns.item(0) ? btns[0] : document.getAnonymousElementByAttribute(this._wizardButtons, \"dlgtype\", aDlgType);\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"_canAdvance\"/>\n      <field name=\"_canRewind\"/>\n      <field name=\"_wizardHeader\"/>\n      <field name=\"_wizardButtons\"/>\n      <field name=\"_deck\"/>\n      <field name=\"_backButton\"/>\n      <field name=\"_nextButton\"/>\n      <field name=\"_cancelButton\"/>\n\n      <!-- functions to be added as oncommand listeners to the wizard buttons -->\n      <field name=\"_backFunc\">(function() { document.documentElement.rewind(); })</field>\n      <field name=\"_nextFunc\">(function() { document.documentElement.advance(); })</field>\n      <field name=\"_finishFunc\">(function() { document.documentElement.advance(); })</field>\n      <field name=\"_cancelFunc\">(function() { document.documentElement.cancel(); })</field>\n      <field name=\"_extra1Func\">(function() { document.documentElement.extra1(); })</field>\n      <field name=\"_extra2Func\">(function() { document.documentElement.extra2(); })</field>\n\n      <field name=\"_closeHandler\">(function(event) {\n        if (document.documentElement.cancel())\n          event.preventDefault();\n      })</field>\n\n      <constructor><![CDATA[\n        this._canAdvance = true;\n        this._canRewind = false;\n        this._hasLoaded = false;\n\n        this._pageStack = [];\n\n        try {\n          // need to create string bundle manually instead of using <xul:stringbundle/>\n          // see bug 63370 for details\n          this._bundle = Cc[\"@mozilla.org/intl/stringbundle;1\"]\n                           .getService(Ci.nsIStringBundleService)\n                           .createBundle(\"chrome://global/locale/wizard.properties\");\n        } catch (e) {\n          // This fails in remote XUL, which has to provide titles for all pages\n          // see bug 142502\n        }\n\n        // get anonymous content references\n        this._wizardHeader = document.getAnonymousElementByAttribute(this, \"anonid\", \"Header\");\n        this._wizardButtons = document.getAnonymousElementByAttribute(this, \"anonid\", \"Buttons\");\n        this._deck = document.getAnonymousElementByAttribute(this, \"anonid\", \"Deck\");\n\n        this._initWizardButton(\"back\");\n        this._initWizardButton(\"next\");\n        this._initWizardButton(\"finish\");\n        this._initWizardButton(\"cancel\");\n        this._initWizardButton(\"extra1\");\n        this._initWizardButton(\"extra2\");\n\n        this._initPages();\n\n        window.addEventListener(\"close\", this._closeHandler);\n\n        // start off on the first page\n        this.pageCount = this.wizardPages.length;\n        this.advance();\n\n        // give focus to the first focusable element in the dialog\n        window.addEventListener(\"load\", this._setInitialFocus);\n      ]]></constructor>\n\n      <method name=\"getPageById\">\n        <parameter name=\"aPageId\"/>\n        <body><![CDATA[\n          var els = this.getElementsByAttribute(\"pageid\", aPageId);\n          return els.item(0);\n        ]]></body>\n      </method>\n\n      <method name=\"extra1\">\n        <body><![CDATA[\n          if (this.currentPage)\n            this._fireEvent(this.currentPage, \"extra1\");\n        ]]></body>\n      </method>\n\n      <method name=\"extra2\">\n        <body><![CDATA[\n          if (this.currentPage)\n            this._fireEvent(this.currentPage, \"extra2\");\n        ]]></body>\n      </method>\n\n      <method name=\"rewind\">\n        <body><![CDATA[\n          if (!this.canRewind)\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pagehide\"))\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pagerewound\"))\n            return;\n\n          if (!this._fireEvent(this, \"wizardback\"))\n            return;\n\n\n          this._pageStack.pop();\n          this.currentPage = this._pageStack[this._pageStack.length-1];\n          this.setAttribute(\"pagestep\", this._pageStack.length);\n        ]]></body>\n      </method>\n\n      <method name=\"advance\">\n        <parameter name=\"aPageId\"/>\n        <body><![CDATA[\n          if (!this.canAdvance)\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pagehide\"))\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pageadvanced\"))\n            return;\n\n          if (this.onLastPage && !aPageId) {\n            if (this._fireEvent(this, \"wizardfinish\"))\n              window.setTimeout(function() {window.close();}, 1);\n          } else {\n            if (!this._fireEvent(this, \"wizardnext\"))\n              return;\n\n            var page;\n            if (aPageId)\n              page = this.getPageById(aPageId);\n            else {\n              if (this.currentPage) {\n                if (this._accessMethod == \"random\")\n                  page = this.getPageById(this.currentPage.next);\n                else\n                  page = this.wizardPages[this.currentPage.pageIndex+1];\n              } else\n                page = this.wizardPages[0];\n            }\n\n            if (page) {\n              this._pageStack.push(page);\n              this.setAttribute(\"pagestep\", this._pageStack.length);\n\n              this.currentPage = page;\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"goTo\">\n        <parameter name=\"aPageId\"/>\n        <body><![CDATA[\n          var page = this.getPageById(aPageId);\n          if (page) {\n            this._pageStack[this._pageStack.length-1] = page;\n            this.currentPage = page;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"cancel\">\n        <body><![CDATA[\n          if (!this._fireEvent(this, \"wizardcancel\"))\n            return true;\n\n          window.close();\n          window.setTimeout(function() {window.close();}, 1);\n          return false;\n        ]]></body>\n      </method>\n\n      <method name=\"_setInitialFocus\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          document.documentElement._hasLoaded = true;\n          var focusInit =\n            function() {\n              // give focus to the first focusable element in the dialog\n              if (!document.commandDispatcher.focusedElement)\n                document.commandDispatcher.advanceFocusIntoSubtree(document.documentElement);\n\n              try {\n                var button =\n                      document.documentElement._wizardButtons.defaultButton;\n                if (button)\n                  window.notifyDefaultButtonLoaded(button);\n              } catch (e) { }\n            };\n\n          // Give focus after onload completes, see bug 103197.\n          setTimeout(focusInit, 0);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_advanceFocusToPage\">\n        <parameter name=\"aPage\"/>\n        <body>\n        <![CDATA[\n          if (!this._hasLoaded)\n            return;\n\n          document.commandDispatcher.advanceFocusIntoSubtree(aPage);\n\n          // if advanceFocusIntoSubtree tries to focus one of our\n          // dialog buttons, then remove it and put it on the root\n          var focused = document.commandDispatcher.focusedElement;\n          if (focused && focused.hasAttribute(\"dlgtype\"))\n            this.focus();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_initPages\">\n        <body><![CDATA[\n          var meth = \"sequential\";\n          var pages = this.wizardPages;\n          for (var i = 0; i < pages.length; ++i) {\n            var page = pages[i];\n            page.pageIndex = i;\n            if (page.next != \"\")\n              meth = \"random\";\n          }\n          this._accessMethod = meth;\n        ]]></body>\n      </method>\n\n      <method name=\"_initWizardButton\">\n        <parameter name=\"aName\"/>\n        <body><![CDATA[\n         var btn = document.getAnonymousElementByAttribute(this._wizardButtons, \"dlgtype\", aName);\n         if (btn) {\n           btn.addEventListener(\"command\", this[\"_\"+aName+\"Func\"]);\n           this[\"_\"+aName+\"Button\"] = btn;\n         }\n         return btn;\n        ]]></body>\n      </method>\n\n      <method name=\"_adjustWizardHeader\">\n        <body><![CDATA[\n          var label = this.currentPage.getAttribute(\"label\");\n          if (!label && this.onFirstPage && this._bundle) {\n            if (/Mac/.test(navigator.platform)) {\n              label = this._bundle.GetStringFromName(\"default-first-title-mac\");\n            } else {\n              label = this._bundle.formatStringFromName(\"default-first-title\", [this.title], 1);\n            }\n          } else if (!label && this.onLastPage && this._bundle) {\n            if (/Mac/.test(navigator.platform)) {\n              label = this._bundle.GetStringFromName(\"default-last-title-mac\");\n            } else {\n              label = this._bundle.formatStringFromName(\"default-last-title\", [this.title], 1);\n            }\n          }\n          this._wizardHeader.setAttribute(\"label\", label);\n          this._wizardHeader.setAttribute(\"description\", this.currentPage.getAttribute(\"description\"));\n        ]]></body>\n      </method>\n\n      <method name=\"_hitEnter\">\n        <parameter name=\"evt\"/>\n        <body>\n        <![CDATA[\n          if (!evt.defaultPrevented)\n            this.advance();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_fireEvent\">\n        <parameter name=\"aTarget\"/>\n        <parameter name=\"aType\"/>\n        <body>\n        <![CDATA[\n          var event = document.createEvent(\"Events\");\n          event.initEvent(aType, true, true);\n\n          // handle dom event handlers\n          var noCancel = aTarget.dispatchEvent(event);\n\n          // handle any xml attribute event handlers\n          var handler = aTarget.getAttribute(\"on\"+aType);\n          if (handler != \"\") {\n            var fn = new Function(\"event\", handler);\n            var returned = fn.apply(aTarget, [event]);\n            if (returned == false)\n              noCancel = false;\n          }\n\n          return noCancel;\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\"\n               group=\"system\" action=\"this._hitEnter(event)\"/>\n      <handler event=\"keypress\" keycode=\"VK_ESCAPE\" group=\"system\">\n        if (!event.defaultPrevented)\n          this.cancel();\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"wizardpage\">\n    <implementation>\n      <field name=\"pageIndex\">-1</field>\n\n      <property name=\"pageid\" onget=\"return this.getAttribute('pageid');\"\n                              onset=\"this.setAttribute('pageid', val);\"/>\n\n      <property name=\"next\"   onget=\"return this.getAttribute('next');\"\n                              onset=\"this.setAttribute('next', val);\n                                     this.parentNode._accessMethod = 'random';\n                                     return val;\"/>\n    </implementation>\n  </binding>\n\n\n\n  <binding id=\"wizard-header\">\n    <content>\n      <xul:hbox class=\"wizard-header-box-1\" flex=\"1\">\n        <xul:vbox class=\"wizard-header-box-text\" flex=\"1\">\n          <xul:label class=\"wizard-header-label\" xbl:inherits=\"xbl:text=label\"/>\n          <xul:label class=\"wizard-header-description\" xbl:inherits=\"xbl:text=description\"/>\n        </xul:vbox>\n        <xul:image class=\"wizard-header-icon\" xbl:inherits=\"src=iconsrc\"/>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"wizard-buttons\">\n    <content>\n      <xul:vbox class=\"wizard-buttons-box-1\" flex=\"1\">\n        <xul:separator class=\"wizard-buttons-separator groove\"/>\n        <xul:hbox class=\"wizard-buttons-box-2\">\n          <xul:button class=\"wizard-button\" dlgtype=\"extra1\" hidden=\"true\"/>\n          <xul:button class=\"wizard-button\" dlgtype=\"extra2\" hidden=\"true\"/>\n          <xul:spacer flex=\"1\" anonid=\"spacer\"/>\n\n          <xul:button label=\"FROM-DTD.button-back-win.label;\" accesskey=\"FROM-DTD.button-back-win.accesskey;\"\n                      class=\"wizard-button\" dlgtype=\"back\"/>\n          <xul:deck class=\"wizard-next-deck\" anonid=\"WizardButtonDeck\">\n            <xul:hbox>\n              <xul:button label=\"FROM-DTD.button-finish-win.label;\" class=\"wizard-button\"\n                          dlgtype=\"finish\" default=\"true\" flex=\"1\"/>\n            </xul:hbox>\n            <xul:hbox>\n              <xul:button label=\"FROM-DTD.button-next-win.label;\" accesskey=\"FROM-DTD.button-next-win.accesskey;\"\n                          class=\"wizard-button\" dlgtype=\"next\" \n                          default=\"true\" flex=\"1\"/>\n            </xul:hbox>\n          </xul:deck>\n          <xul:button label=\"FROM-DTD.button-cancel-win.label;\" class=\"wizard-button\"\n                      dlgtype=\"cancel\"/>\n\n        </xul:hbox>\n      </xul:vbox>\n    </content>\n\n    <implementation>\n      <field name=\"_wizardButtonDeck\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"WizardButtonDeck\");\n      </field>\n\n      <method name=\"onPageChange\">\n        <body><![CDATA[\n          if (this.getAttribute(\"lastpage\") == \"true\") {\n            this._wizardButtonDeck.setAttribute(\"selectedIndex\", 0);\n          } else {\n            this._wizardButtonDeck.setAttribute(\"selectedIndex\", 1);\n          }\n        ]]></body>\n      </method>\n\n      <property name=\"defaultButton\" readonly=\"true\">\n        <getter><![CDATA[\n          const kXULNS =\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          var buttons = this._wizardButtonDeck.selectedPanel\n                            .getElementsByTagNameNS(kXULNS, \"button\");\n          for (var i = 0; i < buttons.length; i++) {\n            if (buttons[i].getAttribute(\"default\") == \"true\" &&\n                !buttons[i].hidden && !buttons[i].disabled)\n              return buttons[i];\n          }\n          return null;\n        ]]></getter>\n      </property>\n    </implementation>\n  </binding>\n\n\n</bindings>\n"},{"file":"blocklist.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings [\n  <!ENTITY % blocklistDTD SYSTEM \"chrome://mozapps/locale/extensions/blocklist.dtd\" >\n  %blocklistDTD;\n]>\n\n<bindings id=\"blocklistBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"hardblockedaddon\">\n    <content align=\"start\">\n      <xul:image xbl:inherits=\"src=icon\"/>\n      <xul:vbox flex=\"1\">\n        <xul:hbox class=\"addon-name-version\">\n          <xul:label class=\"addonName\" crop=\"end\" xbl:inherits=\"value=name\"/>\n          <xul:label class=\"addonVersion\" xbl:inherits=\"value=version\"/>\n        </xul:hbox>\n        <xul:hbox>\n          <xul:spacer flex=\"1\"/>\n          <xul:label class=\"blockedLabel\" value=\"FROM-DTD.blocklist.blocked.label;\"/>\n        </xul:hbox>\n      </xul:vbox>\n    </content>\n  </binding>\n\n  <binding id=\"softblockedaddon\">\n    <content align=\"start\">\n      <xul:image xbl:inherits=\"src=icon\"/>\n      <xul:vbox flex=\"1\">\n        <xul:hbox class=\"addon-name-version\">\n          <xul:label class=\"addonName\" crop=\"end\" xbl:inherits=\"value=name\"/>\n          <xul:label class=\"addonVersion\" xbl:inherits=\"value=version\"/>\n        </xul:hbox>\n        <xul:hbox>\n          <xul:spacer flex=\"1\"/>\n          <xul:checkbox class=\"disableCheckbox\" checked=\"true\" label=\"FROM-DTD.blocklist.checkbox.label;\"/>\n        </xul:hbox>\n      </xul:vbox>\n    </content>\n    <implementation>\n      <field name=\"_checkbox\">\n        document.getAnonymousElementByAttribute(this, \"class\", \"disableCheckbox\")\n      </field>\n      <property name=\"checked\" readonly=\"true\">\n        <getter>\n          return this._checkbox.checked;\n        </getter>\n      </property>\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"extensions.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE page [\n<!ENTITY % extensionsDTD SYSTEM \"chrome://mozapps/locale/extensions/extensions.dtd\">\n%extensionsDTD;\n]>\n\n<!-- import-globals-from extensions.js -->\n\n<bindings id=\"addonBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\">\n\n\n  <!-- Rating - displays current/average rating, allows setting user rating -->\n  <binding id=\"rating\">\n    <content>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(1);\"\n                 onclick=\"document.getBindingParent(this).userRating = 1;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(2);\"\n                 onclick=\"document.getBindingParent(this).userRating = 2;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(3);\"\n                 onclick=\"document.getBindingParent(this).userRating = 3;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(4);\"\n                 onclick=\"document.getBindingParent(this).userRating = 4;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(5);\"\n                 onclick=\"document.getBindingParent(this).userRating = 5;\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._updateStars();\n      ]]></constructor>\n\n      <property name=\"stars\" readonly=\"true\">\n        <getter><![CDATA[\n          return document.getAnonymousNodes(this);\n        ]]></getter>\n      </property>\n\n      <property name=\"averageRating\">\n        <getter><![CDATA[\n          if (this.hasAttribute(\"averagerating\"))\n            return this.getAttribute(\"averagerating\");\n          return -1;\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"averagerating\", val);\n          if (this.showRating == \"average\")\n            this._updateStars();\n        ]]></setter>\n      </property>\n\n      <property name=\"userRating\">\n        <getter><![CDATA[\n          if (this.hasAttribute(\"userrating\"))\n            return this.getAttribute(\"userrating\");\n          return -1;\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.showRating != \"user\")\n            return;\n          this.setAttribute(\"userrating\", val);\n          if (this.showRating == \"user\")\n            this._updateStars();\n        ]]></setter>\n      </property>\n\n      <property name=\"showRating\">\n        <getter><![CDATA[\n          if (this.hasAttribute(\"showrating\"))\n            return this.getAttribute(\"showrating\");\n          return \"average\";\n        ]]></getter>\n        <setter><![CDATA[\n          if (val != \"average\" || val != \"user\")\n            throw Components.Exception(\"Invalid value\", Cr.NS_ERROR_ILLEGAL_VALUE);\n          this.setAttribute(\"showrating\", val);\n          this._updateStars();\n        ]]></setter>\n      </property>\n\n      <method name=\"_updateStars\">\n        <body><![CDATA[\n          var stars = this.stars;\n          var rating = this[this.showRating + \"Rating\"];\n          // average ratings can be non-whole numbers, round them so they\n          // match to their closest star\n          rating = Math.round(rating);\n          for (let i = 0; i < stars.length; i++)\n            stars[i].setAttribute(\"on\", rating > i);\n        ]]></body>\n      </method>\n\n      <method name=\"_hover\">\n        <parameter name=\"aScore\"/>\n        <body><![CDATA[\n          if (this.showRating != \"user\")\n            return;\n          var stars = this.stars;\n          for (let i = 0; i < stars.length; i++)\n            stars[i].setAttribute(\"on\", i <= (aScore - 1));\n        ]]></body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"mouseout\">\n        this._updateStars();\n      </handler>\n    </handlers>\n  </binding>\n\n  <!-- Download progress - shows graphical progress of download and any\n       related status message. -->\n  <binding id=\"download-progress\">\n    <content>\n      <xul:stack flex=\"1\">\n        <xul:hbox flex=\"1\">\n          <xul:hbox class=\"start-cap\"/>\n          <html:progress anonid=\"progress\" class=\"progress\" max=\"100\"/>\n          <xul:hbox class=\"end-cap\"/>\n        </xul:hbox>\n        <xul:hbox class=\"status-container\">\n          <xul:spacer flex=\"1\"/>\n          <xul:label anonid=\"status\" class=\"status\"/>\n          <xul:spacer flex=\"1\"/>\n          <xul:button anonid=\"cancel-btn\" class=\"cancel\"\n                      tooltiptext=\"FROM-DTD.progress.cancel.tooltip;\"\n                      oncommand=\"document.getBindingParent(this).cancel();\"/>\n        </xul:hbox>\n      </xul:stack>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        var progress = 0;\n        if (this.hasAttribute(\"progress\"))\n          progress = parseInt(this.getAttribute(\"progress\"));\n        this.progress = progress;\n      ]]></constructor>\n\n      <field name=\"_progress\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"progress\");\n      </field>\n      <field name=\"_cancel\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"cancel-btn\");\n      </field>\n      <field name=\"_status\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"status\");\n      </field>\n\n      <property name=\"progress\">\n        <setter><![CDATA[\n          // This property is always updated after maxProgress.\n          if (this.getAttribute(\"mode\") == \"determined\") {\n            this._progress.value = val;\n          }\n          if (val == this._progress.max)\n            this.setAttribute(\"complete\", true);\n          else\n            this.removeAttribute(\"complete\");\n        ]]></setter>\n      </property>\n\n      <property name=\"maxProgress\">\n        <setter><![CDATA[\n          if (val == -1) {\n            this.setAttribute(\"mode\", \"undetermined\");\n            this._progress.removeAttribute(\"value\");\n          } else {\n            this.setAttribute(\"mode\", \"determined\");\n            this._progress.setAttribute(\"max\", val);\n          }\n        ]]></setter>\n      </property>\n\n      <property name=\"status\">\n        <getter><![CDATA[\n          return this._status.value;\n        ]]></getter>\n        <setter><![CDATA[\n          this._status.value = val;\n        ]]></setter>\n      </property>\n\n      <method name=\"cancel\">\n        <body><![CDATA[\n          this.mInstall.cancel();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n  <!-- Category item - an item in the category list. -->\n  <binding id=\"category\"\n           extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <content align=\"center\">\n      <xul:image anonid=\"icon\" class=\"category-icon\"/>\n      <xul:label anonid=\"name\" class=\"category-name\" crop=\"end\" flex=\"1\" xbl:inherits=\"value=name\"/>\n      <xul:label anonid=\"badge\" class=\"category-badge\" xbl:inherits=\"value=count\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (!this.hasAttribute(\"count\"))\n          this.setAttribute(\"count\", 0);\n      ]]></constructor>\n\n      <property name=\"badgeCount\">\n        <getter><![CDATA[\n          return this.getAttribute(\"count\");\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.getAttribute(\"count\") == val)\n            return;\n\n          this.setAttribute(\"count\", val);\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"CategoryBadgeUpdated\", true, true);\n          this.dispatchEvent(event);\n        ]]></setter>\n      </property>\n    </implementation>\n  </binding>\n\n\n  <!-- Creator link - Name of a user/developer, providing a link if relevant. -->\n  <binding id=\"creator-link\">\n    <content>\n      <xul:label anonid=\"label\" value=\"FROM-DTD.addon.createdBy.label;\"/>\n      <xul:label anonid=\"creator-link\" class=\"creator-link text-link\"/>\n      <xul:label anonid=\"creator-name\" class=\"creator-name\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (this.hasAttribute(\"nameonly\") &&\n            this.getAttribute(\"nameonly\") == \"true\") {\n          this._label.hidden = true;\n        }\n      ]]></constructor>\n\n      <field name=\"_label\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"label\");\n      </field>\n      <field name=\"_creatorLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"creator-link\");\n      </field>\n      <field name=\"_creatorName\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"creator-name\");\n      </field>\n\n      <method name=\"setCreator\">\n        <parameter name=\"aCreator\"/>\n        <parameter name=\"aHomepageURL\"/>\n        <body><![CDATA[\n          if (!aCreator) {\n            this.collapsed = true;\n            return;\n          }\n          this.collapsed = false;\n          var url = aCreator.url || aHomepageURL;\n          var showLink = !!url;\n          if (showLink) {\n            this._creatorLink.value = aCreator.name;\n            this._creatorLink.href = url;\n          } else {\n            this._creatorName.value = aCreator.name;\n          }\n          this._creatorLink.hidden = !showLink;\n          this._creatorName.hidden = showLink;\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Install status - Displays the status of an install/upgrade. -->\n  <binding id=\"install-status\">\n    <content>\n      <xul:label anonid=\"message\"/>\n      <xul:box anonid=\"progress\" class=\"download-progress\"/>\n      <xul:button anonid=\"install-remote-btn\" hidden=\"true\"\n                  class=\"addon-control install\" label=\"FROM-DTD.addon.install.label;\"\n                  tooltiptext=\"FROM-DTD.addon.install.tooltip;\"\n                  oncommand=\"document.getBindingParent(this).installRemote();\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (this.mInstall)\n          this.initWithInstall(this.mInstall);\n        else if (this.mControl.mAddon.install)\n          this.initWithInstall(this.mControl.mAddon.install);\n        else\n          this.refreshState();\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        if (this.mInstall)\n          this.mInstall.removeListener(this);\n      ]]></destructor>\n\n      <field name=\"_message\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"message\");\n      </field>\n      <field name=\"_progress\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"progress\");\n      </field>\n      <field name=\"_installRemote\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"install-remote-btn\");\n      </field>\n      <field name=\"_undo\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"undo-btn\");\n      </field>\n\n      <method name=\"initWithInstall\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          if (this.mInstall) {\n            this.mInstall.removeListener(this);\n            this.mInstall = null;\n          }\n          this.mInstall = aInstall;\n          this._progress.mInstall = aInstall;\n          this.refreshState();\n          this.mInstall.addListener(this);\n        ]]></body>\n      </method>\n\n      <method name=\"refreshState\">\n        <body><![CDATA[\n          var showInstallRemote = false;\n\n          if (this.mInstall) {\n\n            switch (this.mInstall.state) {\n              case AddonManager.STATE_AVAILABLE:\n                if (this.mControl.getAttribute(\"remote\") != \"true\")\n                  break;\n\n                this._progress.hidden = true;\n                showInstallRemote = true;\n                break;\n              case AddonManager.STATE_DOWNLOADING:\n                this.showMessage(\"installDownloading\");\n                break;\n              case AddonManager.STATE_CHECKING:\n                this.showMessage(\"installVerifying\");\n                break;\n              case AddonManager.STATE_DOWNLOADED:\n                this.showMessage(\"installDownloaded\");\n                break;\n              case AddonManager.STATE_DOWNLOAD_FAILED:\n                // XXXunf expose what error occured (bug 553487)\n                this.showMessage(\"installDownloadFailed\", true);\n                break;\n              case AddonManager.STATE_INSTALLING:\n                this.showMessage(\"installInstalling\");\n                break;\n              case AddonManager.STATE_INSTALL_FAILED:\n                // XXXunf expose what error occured (bug 553487)\n                this.showMessage(\"installFailed\", true);\n                break;\n              case AddonManager.STATE_CANCELLED:\n                this.showMessage(\"installCancelled\", true);\n                break;\n            }\n\n          }\n\n          this._installRemote.hidden = !showInstallRemote;\n\n          if (\"refreshInfo\" in this.mControl)\n            this.mControl.refreshInfo();\n        ]]></body>\n      </method>\n\n      <method name=\"showMessage\">\n        <parameter name=\"aMsgId\"/>\n        <parameter name=\"aHideProgress\"/>\n        <body><![CDATA[\n          this._message.setAttribute(\"hidden\", !aHideProgress);\n          this._progress.setAttribute(\"hidden\", !!aHideProgress);\n\n          var msg = gStrings.ext.GetStringFromName(aMsgId);\n          if (aHideProgress)\n            this._message.value = msg;\n          else\n            this._progress.status = msg;\n        ]]></body>\n      </method>\n\n      <method name=\"installRemote\">\n        <body><![CDATA[\n          if (this.mControl.getAttribute(\"remote\") != \"true\")\n            return;\n\n          delete this.mControl.mAddon;\n          this.mControl.mInstall = this.mInstall;\n          this.mControl.setAttribute(\"status\", \"installing\");\n          let prompt = Services.prefs.getBoolPref(\"extensions.webextPermissionPrompts\", false);\n          if (prompt) {\n            this.mInstall.promptHandler = info => new Promise((resolve, reject) => {\n              // Skip prompts for non-webextensions\n              if (!info.addon.userPermissions) {\n                resolve();\n                return;\n              }\n              let subject = {\n                wrappedJSObject: {\n                  target: window.docShell.chromeEventHandler,\n                  info: {\n                    addon: info.addon,\n                    source: \"AMO\",\n                    icon: info.addon.iconURL,\n                    permissions: info.addon.userPermissions,\n                    resolve,\n                    reject,\n                  },\n                },\n              };\n              Services.obs.notifyObservers(subject, \"webextension-permission-prompt\");\n            });\n          }\n          this.mInstall.install();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadStarted\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadEnded\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadFailed\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadProgress\">\n        <body><![CDATA[\n          this._progress.maxProgress = this.mInstall.maxProgress;\n          this._progress.progress = this.mInstall.progress;\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallStarted\">\n        <body><![CDATA[\n          this._progress.progress = 0;\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallEnded\">\n        <body><![CDATA[\n          this.refreshState();\n          if (\"onInstallCompleted\" in this.mControl)\n            this.mControl.onInstallCompleted();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallFailed\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Addon - base - parent binding of any item representing an addon. -->\n  <binding id=\"addon-base\"\n           extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <implementation>\n      <property name=\"isLegacy\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.mAddon.install) {\n            return false;\n          }\n          return isLegacyExtension(this.mAddon);\n        ]]></getter>\n      </property>\n\n      <method name=\"hasPermission\">\n        <parameter name=\"aPerm\"/>\n        <body><![CDATA[\n          var perm = AddonManager[\"PERM_CAN_\" + aPerm.toUpperCase()];\n          return !!(this.mAddon.permissions & perm);\n        ]]></body>\n      </method>\n\n      <method name=\"isPending\">\n        <parameter name=\"aAction\"/>\n        <body><![CDATA[\n          var action = AddonManager[\"PENDING_\" + aAction.toUpperCase()];\n          return !!(this.mAddon.pendingOperations & action);\n        ]]></body>\n      </method>\n\n      <method name=\"typeHasFlag\">\n        <parameter name=\"aFlag\"/>\n        <body><![CDATA[\n          let flag = AddonManager[\"TYPE_\" + aFlag];\n          let type = AddonManager.addonTypes[this.mAddon.type];\n\n          return !!(type.flags & flag);\n        ]]></body>\n      </method>\n\n      <method name=\"onUninstalled\">\n        <body><![CDATA[\n          this.remove();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Addon - generic - A normal addon item, or an update to one -->\n  <binding id=\"addon-generic\"\n           extends=\"chrome://mozapps/content/extensions/extensions.xml#addon-base\">\n    <content tooltiptext=\"FROM-DTD.addon.details.tooltip;\">\n      <xul:hbox anonid=\"warning-container\"\n                class=\"warning\">\n        <xul:image class=\"warning-icon\"/>\n        <xul:label anonid=\"warning\" flex=\"1\"/>\n        <xul:label anonid=\"warning-link\" class=\"text-link\"/>\n        <xul:button anonid=\"warning-btn\" class=\"button-link\" hidden=\"true\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n      <xul:hbox anonid=\"error-container\"\n                class=\"error\">\n        <xul:image class=\"error-icon\"/>\n        <xul:label anonid=\"error\" flex=\"1\"/>\n        <xul:label anonid=\"error-link\" class=\"text-link\" hidden=\"true\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n      <xul:hbox anonid=\"pending-container\"\n                class=\"pending\">\n        <xul:image class=\"pending-icon\"/>\n        <xul:label anonid=\"pending\" flex=\"1\"/>\n        <xul:button anonid=\"undo-btn\" class=\"button-link\"\n                    label=\"FROM-DTD.addon.undoAction.label;\"\n                    tooltipText=\"FROM-DTD.addon.undoAction.tooltip;\"\n                    oncommand=\"document.getBindingParent(this).undo();\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n\n      <xul:image class=\"card-heading-image\" anonid=\"theme-screenshot\" xbl:inherits=\"src=previewURL\"/>\n\n      <xul:hbox class=\"content-container\" align=\"center\">\n        <xul:vbox class=\"icon-container\">\n          <xul:image anonid=\"icon\" class=\"icon\"/>\n        </xul:vbox>\n        <xul:vbox class=\"content-inner-container\" flex=\"1\">\n          <xul:hbox class=\"basicinfo-container\">\n              <xul:hbox class=\"name-container\">\n                <xul:label anonid=\"name\" class=\"name\" crop=\"end\" flex=\"1\"\n                           tooltip=\"addonitem-tooltip\" xbl:inherits=\"xbl:text=name\"/>\n                <xul:label anonid=\"legacy\" class=\"legacy-warning text-link\" value=\"FROM-DTD.addon.legacy.label;\"/>\n                <xul:label class=\"disabled-postfix\" value=\"FROM-DTD.addon.disabled.postfix;\"/>\n                <xul:label class=\"update-postfix\" value=\"FROM-DTD.addon.update.postfix;\"/>\n                <xul:spacer flex=\"5000\"/> <!-- Necessary to make the name crop -->\n              </xul:hbox>\n            <xul:label anonid=\"date-updated\" class=\"date-updated\"\n                       unknown=\"FROM-DTD.addon.unknownDate;\"/>\n          </xul:hbox>\n\n          <xul:hbox class=\"advancedinfo-container\" flex=\"1\">\n            <xul:vbox class=\"description-outer-container\" flex=\"1\">\n              <xul:hbox class=\"description-container\">\n                <xul:label anonid=\"description\" class=\"description\" crop=\"end\" flex=\"1\"/>\n                <xul:spacer flex=\"5000\"/> <!-- Necessary to make the description crop -->\n              </xul:hbox>\n              <xul:hbox class=\"relnotes-toggle-container\">\n                <xul:button anonid=\"relnotes-toggle-btn\" class=\"relnotes-toggle\"\n                            hidden=\"true\" label=\"FROM-DTD.cmd.showReleaseNotes.label;\"\n                            tooltiptext=\"FROM-DTD.cmd.showReleaseNotes.tooltip;\"\n                            showlabel=\"FROM-DTD.cmd.showReleaseNotes.label;\"\n                            showtooltip=\"FROM-DTD.cmd.showReleaseNotes.tooltip;\"\n                            hidelabel=\"FROM-DTD.cmd.hideReleaseNotes.label;\"\n                            hidetooltip=\"FROM-DTD.cmd.hideReleaseNotes.tooltip;\"\n                            oncommand=\"document.getBindingParent(this).toggleReleaseNotes();\"/>\n              </xul:hbox>\n              <xul:vbox anonid=\"relnotes-container\" class=\"relnotes-container\">\n                <xul:label class=\"relnotes-header\" value=\"FROM-DTD.addon.releaseNotes.label;\"/>\n                <xul:label anonid=\"relnotes-loading\" value=\"FROM-DTD.addon.loadingReleaseNotes.label;\"/>\n                <xul:label anonid=\"relnotes-error\" hidden=\"true\"\n                           value=\"FROM-DTD.addon.errorLoadingReleaseNotes.label;\"/>\n                <xul:vbox anonid=\"relnotes\" class=\"relnotes\"/>\n              </xul:vbox>\n            </xul:vbox>\n          </xul:hbox>\n        </xul:vbox>\n        <xul:vbox class=\"status-control-wrapper\">\n          <xul:hbox class=\"status-container\">\n            <xul:hbox anonid=\"checking-update\" hidden=\"true\">\n              <xul:image class=\"spinner\"/>\n              <xul:label value=\"FROM-DTD.addon.checkingForUpdates.label;\"/>\n            </xul:hbox>\n            <xul:vbox anonid=\"update-available\" class=\"update-available\"\n                      hidden=\"true\">\n              <xul:checkbox anonid=\"include-update\" class=\"include-update\"\n                            label=\"FROM-DTD.addon.includeUpdate.label;\" checked=\"true\"\n                            oncommand=\"document.getBindingParent(this).onIncludeUpdateChanged();\"/>\n              <xul:hbox class=\"update-info-container\">\n                <xul:label class=\"update-available-notice\"\n                           value=\"FROM-DTD.addon.updateAvailable.label;\"/>\n                <xul:button anonid=\"update-btn\" class=\"addon-control update\"\n                            label=\"FROM-DTD.addon.updateNow.label;\"\n                            tooltiptext=\"FROM-DTD.addon.updateNow.tooltip;\"\n                            oncommand=\"document.getBindingParent(this).upgrade();\"/>\n              </xul:hbox>\n            </xul:vbox>\n            <xul:hbox anonid=\"install-status\" class=\"install-status\"\n                      hidden=\"true\"/>\n          </xul:hbox>\n          <xul:hbox anonid=\"control-container\" class=\"control-container\" flex=\"1\">\n            <xul:button anonid=\"preferences-btn\"\n                        class=\"addon-control preferences\"\n\n                        label=\"FROM-DTD.cmd.showPreferencesWin.label;\"\n                        tooltiptext=\"FROM-DTD.cmd.showPreferencesWin.tooltip;\"\n\n                        oncommand=\"document.getBindingParent(this).showPreferences();\"/>\n            <xul:button anonid=\"enable-btn\"  class=\"addon-control enable\"\n                        label=\"FROM-DTD.cmd.enableAddon.label;\"\n                        oncommand=\"document.getBindingParent(this).userDisabled = false;\"/>\n            <xul:button anonid=\"disable-btn\" class=\"addon-control disable\"\n                        label=\"FROM-DTD.cmd.disableAddon.label;\"\n                        oncommand=\"document.getBindingParent(this).userDisabled = true;\"/>\n            <xul:button anonid=\"replacement-btn\" class=\"addon-control replacement\"\n                        label=\"FROM-DTD.cmd.findReplacement.label;\"\n                        oncommand=\"document.getBindingParent(this).findReplacement();\"/>\n            <xul:button anonid=\"remove-btn\" class=\"addon-control remove\"\n                        label=\"FROM-DTD.cmd.uninstallAddon.label;\"\n                        oncommand=\"document.getBindingParent(this).uninstall();\"/>\n            <xul:menulist anonid=\"state-menulist\"\n                          class=\"addon-control state\"\n                          flex=\"1\"\n                          tooltiptext=\"FROM-DTD.cmd.stateMenu.tooltip;\">\n              <xul:menupopup>\n                <xul:menuitem anonid=\"ask-to-activate-menuitem\"\n                              class=\"addon-control\"\n                              label=\"FROM-DTD.cmd.askToActivate.label;\"\n                              tooltiptext=\"FROM-DTD.cmd.askToActivate.tooltip;\"\n                              oncommand=\"document.getBindingParent(this).userDisabled = AddonManager.STATE_ASK_TO_ACTIVATE;\"/>\n                <xul:menuitem anonid=\"always-activate-menuitem\"\n                              class=\"addon-control\"\n                              label=\"FROM-DTD.cmd.alwaysActivate.label;\"\n                              tooltiptext=\"FROM-DTD.cmd.alwaysActivate.tooltip;\"\n                              oncommand=\"document.getBindingParent(this).userDisabled = false;\"/>\n                <xul:menuitem anonid=\"never-activate-menuitem\"\n                              class=\"addon-control\"\n                              label=\"FROM-DTD.cmd.neverActivate.label;\"\n                              tooltiptext=\"FROM-DTD.cmd.neverActivate.tooltip;\"\n                              oncommand=\"document.getBindingParent(this).userDisabled = true;\"/>\n              </xul:menupopup>\n            </xul:menulist>\n          </xul:hbox>\n        </xul:vbox>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._installStatus = document.getAnonymousElementByAttribute(this, \"anonid\", \"install-status\");\n        this._installStatus.mControl = this;\n\n        this.setAttribute(\"contextmenu\", \"addonitem-popup\");\n\n        this._showStatus(\"none\");\n\n        this._initWithAddon(this.mAddon);\n\n        gEventManager.registerAddonListener(this, this.mAddon.id);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        gEventManager.unregisterAddonListener(this, this.mAddon.id);\n      ]]></destructor>\n\n      <field name=\"_warningContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning-container\");\n      </field>\n      <field name=\"_warning\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning\");\n      </field>\n      <field name=\"_warningLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning-link\");\n      </field>\n      <field name=\"_warningBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning-btn\");\n      </field>\n      <field name=\"_errorContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"error-container\");\n      </field>\n      <field name=\"_error\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"error\");\n      </field>\n      <field name=\"_errorLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"error-link\");\n      </field>\n      <field name=\"_pendingContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"pending-container\");\n      </field>\n      <field name=\"_pending\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"pending\");\n      </field>\n      <field name=\"_infoContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"info-container\");\n      </field>\n      <field name=\"_info\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"info\");\n      </field>\n      <field name=\"_icon\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"icon\");\n      </field>\n      <field name=\"_dateUpdated\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"date-updated\");\n      </field>\n      <field name=\"_description\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"description\");\n      </field>\n      <field name=\"_stateMenulist\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"state-menulist\");\n      </field>\n      <field name=\"_askToActivateMenuitem\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"ask-to-activate-menuitem\");\n      </field>\n      <field name=\"_alwaysActivateMenuitem\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"always-activate-menuitem\");\n      </field>\n      <field name=\"_neverActivateMenuitem\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"never-activate-menuitem\");\n      </field>\n      <field name=\"_preferencesBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"preferences-btn\");\n      </field>\n      <field name=\"_enableBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"enable-btn\");\n      </field>\n      <field name=\"_disableBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"disable-btn\");\n      </field>\n      <field name=\"_removeBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"remove-btn\");\n      </field>\n      <field name=\"_updateBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"update-btn\");\n      </field>\n      <field name=\"_controlContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"control-container\");\n      </field>\n      <field name=\"_installStatus\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"install-status\");\n      </field>\n      <field name=\"_checkingUpdate\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"checking-update\");\n      </field>\n      <field name=\"_updateAvailable\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"update-available\");\n      </field>\n      <field name=\"_includeUpdate\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"include-update\");\n      </field>\n      <field name=\"_relNotesLoaded\">false</field>\n      <field name=\"_relNotesToggle\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-toggle-btn\");\n      </field>\n      <field name=\"_relNotesLoading\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-loading\");\n      </field>\n      <field name=\"_relNotesError\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-error\");\n      </field>\n      <field name=\"_relNotesContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-container\");\n      </field>\n      <field name=\"_relNotes\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes\");\n      </field>\n\n      <property name=\"userDisabled\">\n        <getter><![CDATA[\n          return this.mAddon.userDisabled;\n        ]]></getter>\n        <setter><![CDATA[\n          if (val === true) {\n            gViewController.commands.cmd_disableItem.doCommand(this.mAddon);\n          } else if (val === false) {\n            gViewController.commands.cmd_enableItem.doCommand(this.mAddon);\n          } else {\n            this.mAddon.userDisabled = val;\n          }\n        ]]></setter>\n      </property>\n\n      <property name=\"includeUpdate\">\n        <getter><![CDATA[\n          return this._includeUpdate.checked && !!this.mManualUpdate;\n        ]]></getter>\n        <setter><![CDATA[\n          // XXXunf Eventually, we'll want to persist this for individual\n          //        updates - see bug 594619.\n          this._includeUpdate.checked = !!val;\n        ]]></setter>\n      </property>\n\n      <method name=\"_initWithAddon\">\n        <parameter name=\"aAddon\"/>\n        <body><![CDATA[\n          this.mAddon = aAddon;\n\n          this._installStatus.mAddon = this.mAddon;\n          this._updateDates();\n          this._updateState();\n\n          this.setAttribute(\"name\", aAddon.name);\n\n          var iconURL = AddonManager.getPreferredIconURL(aAddon, 24, window);\n          if (iconURL)\n            this._icon.src = iconURL;\n          else\n            this._icon.src = \"\";\n\n          if (this.mAddon.description)\n            this._description.value = this.mAddon.description;\n          else\n            this._description.hidden = true;\n\n          // Set a previewURL for themes if one exists.\n          let previewURL = this.mAddon.type == \"theme\" &&\n            this.mAddon.screenshots &&\n            this.mAddon.screenshots[0] &&\n            this.mAddon.screenshots[0].url;\n          this.setAttribute(\"previewURL\", previewURL ? previewURL : \"\");\n          this.setAttribute(\"hasPreview\", previewURL ? \"true\" : \"fase\");\n\n          let legacyWarning = legacyExtensionsEnabled && !this.mAddon.install &&\n            isLegacyExtension(this.mAddon);\n          this.setAttribute(\"legacy\", legacyWarning);\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"legacy\").href = SUPPORT_URL + \"webextensions\";\n\n          if (!(\"applyBackgroundUpdates\" in this.mAddon) ||\n              (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DISABLE ||\n               (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DEFAULT &&\n                !AddonManager.autoUpdateDefault))) {\n            AddonManager.getAllInstalls().then(aInstallsList => {\n              // This can return after the binding has been destroyed,\n              // so try to detect that and return early\n              if (!(\"onNewInstall\" in this))\n                return;\n              for (let install of aInstallsList) {\n                if (install.existingAddon &&\n                    install.existingAddon.id == this.mAddon.id &&\n                    install.state == AddonManager.STATE_AVAILABLE) {\n                  this.onNewInstall(install);\n                  this.onIncludeUpdateChanged();\n                }\n              }\n            });\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_showStatus\">\n        <parameter name=\"aType\"/>\n        <body><![CDATA[\n          this._controlContainer.hidden = aType != \"none\" &&\n                                          !(aType == \"update-available\" && !this.hasAttribute(\"upgrade\"));\n\n          this._installStatus.hidden = aType != \"progress\";\n          if (aType == \"progress\")\n            this._installStatus.refreshState();\n          this._checkingUpdate.hidden = aType != \"checking-update\";\n          this._updateAvailable.hidden = aType != \"update-available\";\n          this._relNotesToggle.hidden = !(this.mManualUpdate ?\n                                          this.mManualUpdate.releaseNotesURI :\n                                          this.mAddon.releaseNotesURI);\n        ]]></body>\n      </method>\n\n      <method name=\"_updateDates\">\n        <body><![CDATA[\n          function formatDate(aDate) {\n            const dtOptions = { year: \"numeric\", month: \"long\", day: \"numeric\" };\n            return aDate.toLocaleDateString(undefined, dtOptions);\n          }\n\n          if (this.mAddon.updateDate)\n            this._dateUpdated.value = formatDate(this.mAddon.updateDate);\n          else\n            this._dateUpdated.value = this._dateUpdated.getAttribute(\"unknown\");\n        ]]></body>\n      </method>\n\n      <method name=\"_updateState\">\n        <body><![CDATA[\n          if (this.parentNode.selectedItem == this)\n            gViewController.updateCommands();\n\n          var pending = this.mAddon.pendingOperations;\n          if (pending & AddonManager.PENDING_UNINSTALL) {\n            this.removeAttribute(\"notification\");\n\n            // We don't care about pending operations other than uninstall.\n            // They're transient, and cannot be undone.\n            this.setAttribute(\"pending\", \"uninstall\");\n            this._pending.textContent = gStrings.ext.formatStringFromName(\n              \"notification.restartless-uninstall\",\n              [this.mAddon.name], 1);\n          } else {\n            this.removeAttribute(\"pending\");\n\n            var isUpgrade = this.hasAttribute(\"upgrade\");\n            var install = this._installStatus.mInstall;\n\n            if (install && install.state == AddonManager.STATE_DOWNLOAD_FAILED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.downloadError\",\n                [this.mAddon.name], 1\n              );\n              this._warningBtn.label = gStrings.ext.GetStringFromName(\"notification.downloadError.retry\");\n              this._warningBtn.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n              this._warningBtn.setAttribute(\"oncommand\", \"document.getBindingParent(this).retryInstall();\");\n              this._warningBtn.hidden = false;\n              this._warningLink.hidden = true;\n            } else if (install && install.state == AddonManager.STATE_INSTALL_FAILED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.installError\",\n                [this.mAddon.name], 1\n              );\n              this._warningBtn.label = gStrings.ext.GetStringFromName(\"notification.installError.retry\");\n              this._warningBtn.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n              this._warningBtn.setAttribute(\"oncommand\", \"document.getBindingParent(this).retryInstall();\");\n              this._warningBtn.hidden = false;\n              this._warningLink.hidden = true;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_BLOCKED) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.blocked\",\n                [this.mAddon.name], 1\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.blocked.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._errorLink.href = url;\n                this._errorLink.hidden = false;\n              });\n            } else if (!isUpgrade && isDisabledUnsigned(this.mAddon)) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.unsignedAndDisabled\", [this.mAddon.name, gStrings.brandShortName], 2\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.unsigned.link\");\n              this._errorLink.href = SUPPORT_URL + \"unsigned-addons\";\n              this._errorLink.hidden = false;\n            } else if ((!isUpgrade && !this.mAddon.isCompatible) && (AddonManager.checkCompatibility\n            || (this.mAddon.blocklistState != Ci.nsIBlocklistService.STATE_SOFTBLOCKED))) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.incompatible\",\n                [this.mAddon.name, gStrings.brandShortName, gStrings.appVersion], 3\n              );\n              this._warningLink.hidden = true;\n              this._warningBtn.hidden = true;\n            } else if (!isUpgrade && !isCorrectlySigned(this.mAddon)) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.unsigned\", [this.mAddon.name, gStrings.brandShortName], 2\n              );\n              this._warningLink.value = gStrings.ext.GetStringFromName(\"notification.unsigned.link\");\n              this._warningLink.href = SUPPORT_URL + \"unsigned-addons\";\n              this._warningLink.hidden = false;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_SOFTBLOCKED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.softblocked\",\n                [this.mAddon.name], 1\n              );\n              this._warningLink.value = gStrings.ext.GetStringFromName(\"notification.softblocked.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._warningLink.href = url;\n                this._warningLink.hidden = false;\n              });\n              this._warningBtn.hidden = true;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_OUTDATED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.outdated\",\n                [this.mAddon.name], 1\n              );\n              this._warningLink.value = gStrings.ext.GetStringFromName(\"notification.outdated.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._warningLink.href = url;\n                this._warningLink.hidden = false;\n              });\n              this._warningBtn.hidden = true;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_VULNERABLE_UPDATE_AVAILABLE) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.vulnerableUpdatable\",\n                [this.mAddon.name], 1\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.vulnerableUpdatable.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._errorLink.href = url;\n                this._errorLink.hidden = false;\n              });\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_VULNERABLE_NO_UPDATE) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.vulnerableNoUpdate\",\n                [this.mAddon.name], 1\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.vulnerableNoUpdate.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._errorLink.href = url;\n                this._errorLink.hidden = false;\n              });\n            } else if (this.mAddon.isGMPlugin && !this.mAddon.isInstalled &&\n                       this.mAddon.isActive) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent =\n                gStrings.ext.formatStringFromName(\"notification.gmpPending\",\n                                                  [this.mAddon.name], 1);\n            } else {\n              this.removeAttribute(\"notification\");\n            }\n          }\n\n          this._preferencesBtn.hidden = !this.mAddon.optionsType && this.mAddon.type != \"plugin\";\n\n          if (this.typeHasFlag(\"SUPPORTS_ASK_TO_ACTIVATE\")) {\n            this._enableBtn.disabled = true;\n            this._disableBtn.disabled = true;\n            this._askToActivateMenuitem.disabled = !this.hasPermission(\"ask_to_activate\");\n            this._alwaysActivateMenuitem.disabled = !this.hasPermission(\"enable\");\n            this._neverActivateMenuitem.disabled = !this.hasPermission(\"disable\");\n            if (!this.mAddon.isActive) {\n              this._stateMenulist.selectedItem = this._neverActivateMenuitem;\n            } else if (this.mAddon.userDisabled == AddonManager.STATE_ASK_TO_ACTIVATE) {\n              this._stateMenulist.selectedItem = this._askToActivateMenuitem;\n            } else {\n              this._stateMenulist.selectedItem = this._alwaysActivateMenuitem;\n            }\n            let hasActivatePermission =\n              [\"ask_to_activate\", \"enable\", \"disable\"].some(perm => this.hasPermission(perm));\n            this._stateMenulist.disabled = !hasActivatePermission;\n            this._stateMenulist.hidden = false;\n            this._stateMenulist.classList.add(\"no-auto-hide\");\n          } else {\n            this._stateMenulist.hidden = true;\n\n            let enableTooltip = gViewController.commands.cmd_enableItem\n                                               .getTooltip(this.mAddon);\n            this._enableBtn.setAttribute(\"tooltiptext\", enableTooltip);\n            if (this.hasPermission(\"enable\")) {\n              this._enableBtn.hidden = false;\n            } else {\n              this._enableBtn.hidden = true;\n            }\n\n            let disableTooltip = gViewController.commands.cmd_disableItem\n                                                .getTooltip(this.mAddon);\n            this._disableBtn.setAttribute(\"tooltiptext\", disableTooltip);\n            if (this.hasPermission(\"disable\")) {\n              this._disableBtn.hidden = false;\n            } else {\n              this._disableBtn.hidden = true;\n            }\n          }\n\n          let uninstallTooltip = gViewController.commands.cmd_uninstallItem\n                                                .getTooltip(this.mAddon);\n          this._removeBtn.setAttribute(\"tooltiptext\", uninstallTooltip);\n          if (this.hasPermission(\"uninstall\")) {\n            this._removeBtn.hidden = false;\n          } else {\n            this._removeBtn.hidden = true;\n          }\n\n          this.setAttribute(\"active\", this.mAddon.isActive);\n\n          var showProgress = (this.mAddon.install &&\n                              this.mAddon.install.state != AddonManager.STATE_INSTALLED);\n          this._showStatus(showProgress ? \"progress\" : \"none\");\n        ]]></body>\n      </method>\n\n      <method name=\"_fetchReleaseNotes\">\n        <parameter name=\"aURI\"/>\n        <body><![CDATA[\n          if (!aURI || this._relNotesLoaded) {\n            sendToggleEvent();\n            return;\n          }\n\n          var relNotesData = null, transformData = null;\n\n          this._relNotesLoaded = true;\n          this._relNotesLoading.hidden = false;\n          this._relNotesError.hidden = true;\n\n          let sendToggleEvent = () => {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"RelNotesToggle\", true, true);\n            this.dispatchEvent(event);\n          };\n\n          let showRelNotes = () => {\n            if (!relNotesData || !transformData)\n              return;\n\n            this._relNotesLoading.hidden = true;\n\n            var processor = new XSLTProcessor();\n            processor.flags |= XSLTProcessor.DISABLE_ALL_LOADS;\n\n            processor.importStylesheet(transformData);\n            var fragment = processor.transformToFragment(relNotesData, document);\n            this._relNotes.appendChild(fragment);\n            if (this.hasAttribute(\"show-relnotes\")) {\n              var container = this._relNotesContainer;\n              container.style.height = container.scrollHeight + \"px\";\n            }\n            sendToggleEvent();\n          };\n\n          let handleError = () => {\n            dataReq.abort();\n            styleReq.abort();\n            this._relNotesLoading.hidden = true;\n            this._relNotesError.hidden = false;\n            this._relNotesLoaded = false; // allow loading to be re-tried\n            sendToggleEvent();\n          };\n\n          function handleResponse(aEvent) {\n            var req = aEvent.target;\n            var ct = req.getResponseHeader(\"content-type\");\n            if ((!ct || !ct.includes(\"text/html\")) &&\n                req.responseXML &&\n                req.responseXML.documentElement.namespaceURI != XMLURI_PARSE_ERROR) {\n              if (req == dataReq)\n                relNotesData = req.responseXML;\n              else\n                transformData = req.responseXML;\n              showRelNotes();\n            } else {\n              handleError();\n            }\n          }\n\n          var dataReq = new XMLHttpRequest();\n          dataReq.open(\"GET\", aURI.spec, true);\n          dataReq.responseType = \"document\";\n          dataReq.addEventListener(\"load\", handleResponse);\n          dataReq.addEventListener(\"error\", handleError);\n          dataReq.send(null);\n\n          var styleReq = new XMLHttpRequest();\n          styleReq.open(\"GET\", UPDATES_RELEASENOTES_TRANSFORMFILE, true);\n          styleReq.responseType = \"document\";\n          styleReq.addEventListener(\"load\", handleResponse);\n          styleReq.addEventListener(\"error\", handleError);\n          styleReq.send(null);\n        ]]></body>\n      </method>\n\n      <method name=\"toggleReleaseNotes\">\n        <body><![CDATA[\n          if (this.hasAttribute(\"show-relnotes\")) {\n            this._relNotesContainer.style.height = \"0px\";\n            this.removeAttribute(\"show-relnotes\");\n            this._relNotesToggle.setAttribute(\n              \"label\",\n              this._relNotesToggle.getAttribute(\"showlabel\")\n            );\n            this._relNotesToggle.setAttribute(\n              \"tooltiptext\",\n              this._relNotesToggle.getAttribute(\"showtooltip\")\n            );\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"RelNotesToggle\", true, true);\n            this.dispatchEvent(event);\n          } else {\n            this._relNotesContainer.style.height = this._relNotesContainer.scrollHeight +\n                                                   \"px\";\n            this.setAttribute(\"show-relnotes\", true);\n            this._relNotesToggle.setAttribute(\n              \"label\",\n              this._relNotesToggle.getAttribute(\"hidelabel\")\n            );\n            this._relNotesToggle.setAttribute(\n              \"tooltiptext\",\n              this._relNotesToggle.getAttribute(\"hidetooltip\")\n            );\n            var uri = this.mManualUpdate ?\n                      this.mManualUpdate.releaseNotesURI :\n                      this.mAddon.releaseNotesURI;\n            this._fetchReleaseNotes(uri);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"undo\">\n        <body><![CDATA[\n          gViewController.commands.cmd_cancelOperation.doCommand(this.mAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"uninstall\">\n        <body><![CDATA[\n          // If the type doesn't support undoing of restartless uninstalls,\n          // then we fake it by just disabling it it, and doing the real\n          // uninstall later.\n          if (this.typeHasFlag(\"SUPPORTS_UNDO_RESTARTLESS_UNINSTALL\")) {\n            this.mAddon.uninstall(true);\n          } else {\n            this.setAttribute(\"wasDisabled\", this.mAddon.userDisabled);\n\n            // We must set userDisabled to true first, this will call\n            // _updateState which will clear any pending attribute set.\n            this.mAddon.disable().then(() => {\n              // This won't update any other add-on manager views (bug 582002)\n              this.setAttribute(\"pending\", \"uninstall\");\n            });\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"showPreferences\">\n        <body><![CDATA[\n          gViewController.doCommand(\"cmd_showItemPreferences\", this.mAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"upgrade\">\n        <body><![CDATA[\n          var install = this.mManualUpdate;\n          delete this.mManualUpdate;\n          install.install();\n        ]]></body>\n      </method>\n\n      <method name=\"retryInstall\">\n        <body><![CDATA[\n          var install = this._installStatus.mInstall;\n          if (!install)\n            return;\n          if (install.state != AddonManager.STATE_DOWNLOAD_FAILED &&\n              install.state != AddonManager.STATE_INSTALL_FAILED)\n            return;\n          install.install();\n        ]]></body>\n      </method>\n\n      <method name=\"showInDetailView\">\n        <body><![CDATA[\n          gViewController.loadView(\"addons://detail/\" +\n                                   encodeURIComponent(this.mAddon.id));\n        ]]></body>\n      </method>\n\n      <method name=\"findReplacement\">\n        <body><![CDATA[\n          let url = (this.mAddon.type == \"theme\") ?\n            SUPPORT_URL + \"complete-themes\" :\n            `https://addons.mozilla.org/find-replacement/?guid=${this.mAddon.id}`;\n            openURL(url);\n        ]]></body>\n      </method>\n\n      <method name=\"onIncludeUpdateChanged\">\n        <body><![CDATA[\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"IncludeUpdateChanged\", true, true);\n          this.dispatchEvent(event);\n        ]]></body>\n      </method>\n\n      <method name=\"onEnabling\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onEnabled\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDisabling\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDisabled\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onUninstalling\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onOperationCancelled\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onPropertyChanged\">\n        <parameter name=\"aProperties\"/>\n        <body><![CDATA[\n          if (aProperties.includes(\"appDisabled\") ||\n              aProperties.includes(\"signedState\") ||\n              aProperties.includes(\"userDisabled\"))\n            this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onNoUpdateAvailable\">\n        <body><![CDATA[\n          this._showStatus(\"none\");\n        ]]></body>\n      </method>\n\n      <method name=\"onCheckingUpdate\">\n        <body><![CDATA[\n          this._showStatus(\"checking-update\");\n        ]]></body>\n      </method>\n\n      <method name=\"onCompatibilityUpdateAvailable\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onExternalInstall\">\n        <parameter name=\"aAddon\"/>\n        <parameter name=\"aExistingAddon\"/>\n        <body><![CDATA[\n          if (aExistingAddon.id != this.mAddon.id)\n            return;\n\n          this._initWithAddon(aAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"onNewInstall\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          if (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_ENABLE)\n            return;\n          if (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DEFAULT &&\n              AddonManager.autoUpdateDefault)\n            return;\n\n          this.mManualUpdate = aInstall;\n          this._showStatus(\"update-available\");\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadStarted\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          this._updateState();\n          this._showStatus(\"progress\");\n          this._installStatus.initWithInstall(aInstall);\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallStarted\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          this._updateState();\n          this._showStatus(\"progress\");\n          this._installStatus.initWithInstall(aInstall);\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallEnded\">\n        <parameter name=\"aInstall\"/>\n        <parameter name=\"aAddon\"/>\n        <body><![CDATA[\n          this._initWithAddon(aAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadFailed\">\n        <body><![CDATA[\n            this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallFailed\">\n        <body><![CDATA[\n            this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallCancelled\">\n        <body><![CDATA[\n            this._updateState();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        if (![\"button\", \"checkbox\", \"menulist\", \"menuitem\"].includes(event.originalTarget.localName) &&\n            !event.originalTarget.classList.contains(\"text-link\") &&\n            // Treat the relnotes container as embedded text instead of a click target.\n            !event.originalTarget.closest(\".relnotes-container\")) {\n          this.showInDetailView();\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n\n  <!-- Addon - uninstalled - An uninstalled addon that can be re-installed. -->\n  <binding id=\"addon-uninstalled\"\n           extends=\"chrome://mozapps/content/extensions/extensions.xml#addon-base\">\n    <content>\n      <xul:hbox class=\"pending\">\n        <xul:image class=\"pending-icon\"/>\n        <xul:label anonid=\"notice\" flex=\"1\"/>\n        <xul:button anonid=\"undo-btn\" class=\"button-link\"\n                    label=\"FROM-DTD.addon.undoRemove.label;\"\n                    tooltiptext=\"FROM-DTD.addon.undoRemove.tooltip;\"\n                    oncommand=\"document.getBindingParent(this).cancelUninstall();\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._notice.textContent = gStrings.ext.formatStringFromName(\"uninstallNotice\",\n                                                                     [this.mAddon.name],\n                                                                     1);\n\n        gEventManager.registerAddonListener(this, this.mAddon.id);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        gEventManager.unregisterAddonListener(this, this.mAddon.id);\n      ]]></destructor>\n\n      <field name=\"_notice\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"notice\");\n      </field>\n\n      <method name=\"cancelUninstall\">\n        <body><![CDATA[\n          // This assumes that disabling does not require a restart when\n          // uninstalling doesn't. Things will still work if not, the add-on\n          // will just still be active until finally getting uninstalled.\n\n          if (this.isPending(\"uninstall\"))\n            this.mAddon.cancelUninstall();\n          else if (this.getAttribute(\"wasDisabled\") != \"true\")\n            this.mAddon.enable();\n\n          this.removeAttribute(\"pending\");\n        ]]></body>\n      </method>\n\n      <method name=\"onExternalInstall\">\n        <parameter name=\"aAddon\"/>\n        <parameter name=\"aExistingAddon\"/>\n        <body><![CDATA[\n          if (aExistingAddon.id != this.mAddon.id)\n            return;\n\n          // Make sure any newly installed add-on has the correct disabled state\n          if (this.hasAttribute(\"wasDisabled\")) {\n            if (this.getAttribute(\"wasDisabled\") == \"true\")\n              aAddon.disable();\n            else\n              aAddon.enable();\n          }\n\n          this.mAddon = aAddon;\n\n          this.removeAttribute(\"pending\");\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallStarted\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          // Make sure any newly installed add-on has the correct disabled state\n          if (this.hasAttribute(\"wasDisabled\")) {\n            if (this.getAttribute(\"wasDisabled\") == \"true\")\n              aInstall.addon.disable();\n            else\n              aInstall.addon.enable();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallEnded\">\n        <parameter name=\"aInstall\"/>\n        <parameter name=\"aAddon\"/>\n        <body><![CDATA[\n          this.mAddon = aAddon;\n\n          this.removeAttribute(\"pending\");\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Addon - installing - an addon item that is currently being installed -->\n  <binding id=\"addon-installing\"\n           extends=\"chrome://mozapps/content/extensions/extensions.xml#addon-base\">\n    <content>\n      <xul:hbox anonid=\"warning-container\" class=\"warning\">\n        <xul:image class=\"warning-icon\"/>\n        <xul:label anonid=\"warning\" flex=\"1\"/>\n        <xul:button anonid=\"warning-link\" class=\"button-link\"\n                   oncommand=\"document.getBindingParent(this).retryInstall();\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n      <xul:hbox class=\"content-container\">\n        <xul:vbox class=\"icon-outer-container\">\n          <xul:vbox class=\"icon-container\">\n            <xul:image anonid=\"icon\" class=\"icon\"/>\n          </xul:vbox>\n        </xul:vbox>\n        <xul:vbox class=\"fade name-outer-container\" flex=\"1\">\n          <xul:hbox class=\"name-container\">\n            <xul:label anonid=\"name\" class=\"name\" crop=\"end\" tooltip=\"addonitem-tooltip\"/>\n          </xul:hbox>\n        </xul:vbox>\n        <xul:vbox class=\"install-status-container\">\n          <xul:hbox anonid=\"install-status\" class=\"install-status\"/>\n        </xul:vbox>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._installStatus.mControl = this;\n        this._installStatus.mInstall = this.mInstall;\n        this.refreshInfo();\n      ]]></constructor>\n\n      <field name=\"_icon\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"icon\");\n      </field>\n      <field name=\"_name\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"name\");\n      </field>\n      <field name=\"_warning\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"warning\");\n      </field>\n      <field name=\"_warningLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"warning-link\");\n      </field>\n      <field name=\"_installStatus\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"install-status\");\n      </field>\n\n      <method name=\"onInstallCompleted\">\n        <body><![CDATA[\n          this.mAddon = this.mInstall.addon;\n          this.setAttribute(\"name\", this.mAddon.name);\n          this.setAttribute(\"value\", this.mAddon.id);\n          this.setAttribute(\"status\", \"installed\");\n        ]]></body>\n      </method>\n\n      <method name=\"refreshInfo\">\n        <body><![CDATA[\n          this.mAddon = this.mAddon || this.mInstall.addon;\n          if (this.mAddon) {\n            this._icon.src = this.mAddon.iconURL ||\n                             (this.mInstall ? this.mInstall.iconURL : \"\");\n            this._name.value = this.mAddon.name;\n          } else {\n            this._icon.src = this.mInstall.iconURL;\n            // AddonInstall.name isn't always available - fallback to filename\n            if (this.mInstall.name) {\n              this._name.value = this.mInstall.name;\n            } else if (this.mInstall.sourceURI) {\n              var url = Cc[\"@mozilla.org/network/standard-url-mutator;1\"]\n                          .createInstance(Ci.nsIStandardURLMutator)\n                          .init(Ci.nsIStandardURL.URLTYPE_STANDARD,\n                                80, this.mInstall.sourceURI.spec,\n                                null, null)\n                          .finalize()\n                          .QueryInterface(Ci.nsIURL);\n              this._name.value = url.fileName;\n            }\n          }\n\n          if (this.mInstall.state == AddonManager.STATE_DOWNLOAD_FAILED) {\n            this.setAttribute(\"notification\", \"warning\");\n            this._warning.textContent = gStrings.ext.formatStringFromName(\n              \"notification.downloadError\",\n              [this._name.value], 1\n            );\n            this._warningLink.label = gStrings.ext.GetStringFromName(\"notification.downloadError.retry\");\n            this._warningLink.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n          } else if (this.mInstall.state == AddonManager.STATE_INSTALL_FAILED) {\n            this.setAttribute(\"notification\", \"warning\");\n            this._warning.textContent = gStrings.ext.formatStringFromName(\n              \"notification.installError\",\n              [this._name.value], 1\n            );\n            this._warningLink.label = gStrings.ext.GetStringFromName(\"notification.installError.retry\");\n            this._warningLink.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n          } else {\n            this.removeAttribute(\"notification\");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"retryInstall\">\n        <body><![CDATA[\n          this.mInstall.install();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"detail-row\">\n    <content>\n      <xul:label class=\"detail-row-label\" xbl:inherits=\"value=label\"/>\n      <xul:label class=\"detail-row-value\" xbl:inherits=\"value\"/>\n    </content>\n\n    <implementation>\n      <property name=\"value\">\n        <getter><![CDATA[\n          return this.getAttribute(\"value\");\n        ]]></getter>\n        <setter><![CDATA[\n          if (!val)\n            this.removeAttribute(\"value\");\n          else\n            this.setAttribute(\"value\", val);\n        ]]></setter>\n      </property>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"handler.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"hanlder-bindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"handler\"\n           extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n\n    <content>\n      <xul:vbox pack=\"center\">\n        <xul:image xbl:inherits=\"src=image\" height=\"32\" width=\"32\"/>\n      </xul:vbox>\n      <xul:vbox flex=\"1\">\n        <xul:label class=\"name\" xbl:inherits=\"value=name\"/>\n        <xul:label class=\"description\" xbl:inherits=\"value=description\"/>\n      </xul:vbox>\n    </content>\n    <implementation>\n      <property name=\"label\" onget=\"return this.getAttribute('name') + ' ' + this.getAttribute('description');\"/>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"updates.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"updatesBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"updateheader\" extends=\"chrome://global/content/bindings/wizard.xml#wizard-header\">\n    <content>\n      <xul:hbox class=\"wizard-header update-header\" flex=\"1\">\n        <xul:vbox class=\"wizard-header-box-1\">\n          <xul:vbox class=\"wizard-header-box-text\">\n            <xul:label class=\"wizard-header-label\" xbl:inherits=\"value=label\"/>\n          </xul:vbox>\n        </xul:vbox>\n      </xul:hbox>\n    </content>\n  </binding>\n</bindings>\n"}];
    </script>
  </head>
  <body>
  <main>
  <header>
  <div id="links">
    <a href="../">Home</a>
    <a href="https://github.com/bgrins/xbl-analysis">Code</a>
  </div>
  <h1>XBL To Custom Element Converter</h1>
  </header>
  <div id="converter">
    <ul>
    <li><a href='#' data-index=0>tabbrowser.xml</a></li>
<li><a href='#' data-index=1>urlbarBindings.xml</a></li>
<li><a href='#' data-index=2>menu.xml</a></li>
<li><a href='#' data-index=3>tree.xml</a></li>
<li><a href='#' data-index=4>search.xml</a></li>
<li><a href='#' data-index=5>formautofill.xml</a></li>
<li><a href='#' data-index=6>organizer.xml</a></li>
<li><a href='#' data-index=7>autocomplete.xml</a></li>
<li><a href='#' data-index=8>button.xml</a></li>
<li><a href='#' data-index=9>checkbox.xml</a></li>
<li><a href='#' data-index=10>dialog.xml</a></li>
<li><a href='#' data-index=11>general.xml</a></li>
<li><a href='#' data-index=12>menu.xml</a></li>
<li><a href='#' data-index=13>menulist.xml</a></li>
<li><a href='#' data-index=14>notification.xml</a></li>
<li><a href='#' data-index=15>popup.xml</a></li>
<li><a href='#' data-index=16>radio.xml</a></li>
<li><a href='#' data-index=17>richlistbox.xml</a></li>
<li><a href='#' data-index=18>scrollbox.xml</a></li>
<li><a href='#' data-index=19>tabbox.xml</a></li>
<li><a href='#' data-index=20>text.xml</a></li>
<li><a href='#' data-index=21>textbox.xml</a></li>
<li><a href='#' data-index=22>toolbarbutton.xml</a></li>
<li><a href='#' data-index=23>tree.xml</a></li>
<li><a href='#' data-index=24>wizard.xml</a></li>
<li><a href='#' data-index=25>blocklist.xml</a></li>
<li><a href='#' data-index=26>extensions.xml</a></li>
<li><a href='#' data-index=27>handler.xml</a></li>
<li><a href='#' data-index=28>updates.xml</a></li>
    </ul>
    <textarea>
    <?xml version="1.0"?>

<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!-- import-globals-from controller.js -->
<!-- import-globals-from treeView.js -->

<bindings id="placesTreeBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="places-tree" extends="chrome://global/content/bindings/tree.xml#tree">
    <implementation>
      <constructor><![CDATA[
        // Force an initial build.
        if (this.place)
          this.place = this.place;
      ]]></constructor>

      <destructor><![CDATA[
        // Break the treeviewer->result->treeviewer cycle.
        // Note: unsetting the result's viewer also unsets
        // the viewer's reference to our tree.
        var result = this.result;
        if (result) {
          result.root.containerOpen = false;
        }

        // Unregister the controllber before unlinking the view, otherwise it
        // may still try to update commands on a view with a null result.
        if (this._controller) {
          this._controller.terminate();
          this.controllers.removeController(this._controller);
        }

        if (this.view) {
          this.view.uninit();
        }
        this.view = null;
      ]]></destructor>

      <property name="controller"
                readonly="true"
                onget="return this._controller"/>

      <property name="disableUserActions"
                onget="return this.getAttribute('disableUserActions') == 'true';"
                onset="if (val) this.setAttribute('disableUserActions', 'true');
                       else this.removeAttribute('disableUserActions'); return val;"/>

      <!-- overriding -->
      <property name="view">
        <getter><![CDATA[
          try {
            /* eslint-disable no-undef */
            return Object.getOwnPropertyDescriptor(XULTreeElement.prototype, "view").get.
                          call(this).wrappedJSObject || null;
            /* eslint-enable no-undef */
          } catch (e) {
            return null;
          }
        ]]></getter>
        <setter><![CDATA[
          /* eslint-disable no-undef */
          return Object.getOwnPropertyDescriptor(XULTreeElement.prototype, "view").set.call(this, val);
          /* eslint-enable no-undef */
        ]]></setter>
      </property>

      <property name="associatedElement"
                readonly="true"
                onget="return this"/>

      <method name="applyFilter">
        <parameter name="filterString"/>
        <parameter name="folderRestrict"/>
        <parameter name="includeHidden"/>
        <body><![CDATA[
          // preserve grouping
          var queryNode = PlacesUtils.asQuery(this.result.root);
          var options = queryNode.queryOptions.clone();

          // Make sure we're getting uri results.
          // We do not yet support searching into grouped queries or into
          // tag containers, so we must fall to the default case.
          if (PlacesUtils.nodeIsHistoryContainer(queryNode) ||
              PlacesUtils.nodeIsTagQuery(queryNode) ||
              options.resultType == options.RESULTS_AS_TAGS_ROOT ||
              options.resultType == options.RESULTS_AS_ROOTS_QUERY)
            options.resultType = options.RESULTS_AS_URI;

          var query = PlacesUtils.history.getNewQuery();
          query.searchTerms = filterString;

          if (folderRestrict) {
            query.setParents(folderRestrict, folderRestrict.length);
            options.queryType = options.QUERY_TYPE_BOOKMARKS;
          }

          options.includeHidden = !!includeHidden;

          this.load(query, options);
        ]]></body>
      </method>

      <method name="load">
        <parameter name="query"/>
        <parameter name="options"/>
        <body><![CDATA[
          let result = PlacesUtils.history
                                  .executeQuery(query, options);
          let callback;
          if (this.flatList) {
            let onOpenFlatContainer = this.onOpenFlatContainer;
            if (onOpenFlatContainer)
              callback = new Function("aContainer", onOpenFlatContainer);
          }

          if (!this._controller) {
            this._controller = new PlacesController(this);
            this._controller.disableUserActions = this.disableUserActions;
            this.controllers.appendController(this._controller);
          }

          let treeView = new PlacesTreeView(this.flatList, callback, this._controller);

          // Observer removal is done within the view itself.  When the tree
          // goes away, view.setTree(null) is called, which then
          // calls removeObserver.
          result.addObserver(treeView);
          this.view = treeView;

          if (this.getAttribute("selectfirstnode") == "true" && treeView.rowCount > 0) {
            treeView.selection.select(0);
          }

          this._cachedInsertionPoint = undefined;
        ]]></body>
      </method>

      <property name="flatList">
        <getter><![CDATA[
          return this.getAttribute("flatList") == "true";
        ]]></getter>
        <setter><![CDATA[
          if (this.flatList != val) {
            this.setAttribute("flatList", val);
            // reload with the last place set
            if (this.place)
              this.place = this.place;
          }
          return val;
        ]]></setter>
      </property>

      <property name="onOpenFlatContainer">
        <getter><![CDATA[
          return this.getAttribute("onopenflatcontainer");
        ]]></getter>
        <setter><![CDATA[
          if (this.onOpenFlatContainer != val) {
            this.setAttribute("onopenflatcontainer", val);
            // reload with the last place set
            if (this.place)
              this.place = this.place;
          }
          return val;
        ]]></setter>
      </property>

      <!--
        Causes a particular node represented by the specified placeURI to be
        selected in the tree. All containers above the node in the hierarchy
        will be opened, so that the node is visible.
        -->
      <method name="selectPlaceURI">
        <parameter name="placeURI"/>
        <body><![CDATA[
          // Do nothing if a node matching the given uri is already selected
          if (this.hasSelection && this.selectedNode.uri == placeURI)
            return;

          function findNode(container, nodesURIChecked) {
            var containerURI = container.uri;
            if (containerURI == placeURI)
              return container;
            if (nodesURIChecked.includes(containerURI))
              return null;

            // never check the contents of the same query
            nodesURIChecked.push(containerURI);

            var wasOpen = container.containerOpen;
            if (!wasOpen)
              container.containerOpen = true;
            for (var i = 0; i < container.childCount; ++i) {
              var child = container.getChild(i);
              var childURI = child.uri;
              if (childURI == placeURI)
                return child;
              else if (PlacesUtils.nodeIsContainer(child)) {
                var nested = findNode(PlacesUtils.asContainer(child), nodesURIChecked);
                if (nested)
                  return nested;
              }
            }

            if (!wasOpen)
              container.containerOpen = false;

            return null;
          }

          var container = this.result.root;
          console.assert(container, "No result, cannot select place URI!");
          if (!container)
            return;

          var child = findNode(container, []);
          if (child)
            this.selectNode(child);
          else {
            // If the specified child could not be located, clear the selection
            var selection = this.view.selection;
            selection.clearSelection();
          }
        ]]></body>
      </method>

      <!--
        Causes a particular node to be selected in the tree, resulting in all
        containers above the node in the hierarchy to be opened, so that the
        node is visible.
        -->
      <method name="selectNode">
        <parameter name="node"/>
        <body><![CDATA[
          var view = this.view;

          var parent = node.parent;
          if (parent && !parent.containerOpen) {
            // Build a list of all of the nodes that are the parent of this one
            // in the result.
            var parents = [];
            var root = this.result.root;
            while (parent && parent != root) {
              parents.push(parent);
              parent = parent.parent;
            }

            // Walk the list backwards (opening from the root of the hierarchy)
            // opening each folder as we go.
            for (var i = parents.length - 1; i >= 0; --i) {
              let index = view.treeIndexForNode(parents[i]);
              if (index != -1 &&
                  view.isContainer(index) && !view.isContainerOpen(index))
                view.toggleOpenState(index);
            }
            // Select the specified node...
          }

          let index = view.treeIndexForNode(node);
          if (index == -1)
            return;

          view.selection.select(index);
          // ... and ensure it's visible, not scrolled off somewhere.
          this.ensureRowIsVisible(index);
        ]]></body>
      </method>

      <!-- nsIPlacesView -->
      <property name="result">
        <getter><![CDATA[
          try {
            return this.view.QueryInterface(Ci.nsINavHistoryResultObserver).result;
          } catch (e) {
            return null;
          }
        ]]></getter>
      </property>

      <!-- nsIPlacesView -->
      <property name="place">
        <getter><![CDATA[
          return this.getAttribute("place");
        ]]></getter>
        <setter><![CDATA[
          this.setAttribute("place", val);

          let query = {}, options = {};
          PlacesUtils.history.queryStringToQuery(val, query, options);
          this.load(query.value, options.value);

          return val;
        ]]></setter>
      </property>

      <!-- nsIPlacesView -->
      <property name="hasSelection">
        <getter><![CDATA[
          return this.view && this.view.selection.count >= 1;
        ]]></getter>
      </property>

      <!-- nsIPlacesView -->
      <property name="selectedNodes">
        <getter><![CDATA[
          let nodes = [];
          if (!this.hasSelection)
            return nodes;

          let selection = this.view.selection;
          let rc = selection.getRangeCount();
          let resultview = this.view;
          for (let i = 0; i < rc; ++i) {
            let min = { }, max = { };
            selection.getRangeAt(i, min, max);
            for (let j = min.value; j <= max.value; ++j) {
              nodes.push(resultview.nodeForTreeIndex(j));
            }
          }
          return nodes;
        ]]></getter>
      </property>

      <method name="toggleCutNode">
        <parameter name="aNode"/>
        <parameter name="aValue"/>
        <body><![CDATA[
          this.view.toggleCutNode(aNode, aValue);
        ]]></body>
      </method>

      <!-- nsIPlacesView -->
      <property name="removableSelectionRanges">
        <getter><![CDATA[
          // This property exists in addition to selectedNodes because it
          // encodes selection ranges (which only occur in list views) into
          // the return value. For each removed range, the index at which items
          // will be re-inserted upon the remove transaction being performed is
          // the first index of the range, so that the view updates correctly.
          //
          // For example, if we remove rows 2,3,4 and 7,8 from a list, when we
          // undo that operation, if we insert what was at row 3 at row 3 again,
          // it will show up _after_ the item that was at row 5. So we need to
          // insert all items at row 2, and the tree view will update correctly.
          //
          // Also, this function collapses the selection to remove redundant
          // data, e.g. when deleting this selection:
          //
          //      http://www.foo.com/
          //  (-) Some Folder
          //        http://www.bar.com/
          //
          // ... returning http://www.bar.com/ as part of the selection is
          // redundant because it is implied by removing "Some Folder". We
          // filter out all such redundancies since some partial amount of
          // the folder's children may be selected.
          //
          let nodes = [];
          if (!this.hasSelection)
            return nodes;

          var selection = this.view.selection;
          var rc = selection.getRangeCount();
          var resultview = this.view;
          // This list is kept independently of the range selected (i.e. OUTSIDE
          // the for loop) since the row index of a container is unique for the
          // entire view, and we could have some really wacky selection and we
          // don't want to blow up.
          var containers = { };
          for (var i = 0; i < rc; ++i) {
            var range = [];
            var min = { }, max = { };
            selection.getRangeAt(i, min, max);

            for (var j = min.value; j <= max.value; ++j) {
              if (this.view.isContainer(j))
                containers[j] = true;
              if (!(this.view.getParentIndex(j) in containers))
                range.push(resultview.nodeForTreeIndex(j));
            }
            nodes.push(range);
          }
          return nodes;
        ]]></getter>
      </property>

      <!-- nsIPlacesView -->
      <property name="draggableSelection"
                onget="return this.selectedNodes"/>

      <!-- nsIPlacesView -->
      <property name="selectedNode">
        <getter><![CDATA[
          var view = this.view;
          if (!view || view.selection.count != 1)
            return null;

          var selection = view.selection;
          var min = { }, max = { };
          selection.getRangeAt(0, min, max);

          return this.view.nodeForTreeIndex(min.value);
        ]]></getter>
      </property>

      <!-- nsIPlacesView -->
      <property name="insertionPoint">
        <getter><![CDATA[
          // invalidated on selection and focus changes
          if (this._cachedInsertionPoint !== undefined)
            return this._cachedInsertionPoint;

          // there is no insertion point for history queries
          // so bail out now and save a lot of work when updating commands
          var resultNode = this.result.root;
          if (PlacesUtils.nodeIsQuery(resultNode) &&
              PlacesUtils.asQuery(resultNode).queryOptions.queryType ==
                Ci.nsINavHistoryQueryOptions.QUERY_TYPE_HISTORY)
              return this._cachedInsertionPoint = null;

          var orientation = Ci.nsITreeView.DROP_BEFORE;
          // If there is no selection, insert at the end of the container.
          if (!this.hasSelection) {
            var index = this.view.rowCount - 1;
            this._cachedInsertionPoint =
              this._getInsertionPoint(index, orientation);
            return this._cachedInsertionPoint;
          }

          // This is a two-part process. The first part is determining the drop
          // orientation.
          // * The default orientation is to drop _before_ the selected item.
          // * If the selected item is a container, the default orientation
          //   is to drop _into_ that container.
          //
          // Warning: It may be tempting to use tree indexes in this code, but
          //          you must not, since the tree is nested and as your tree
          //          index may change when folders before you are opened and
          //          closed. You must convert your tree index to a node, and
          //          then use getChildIndex to find your absolute index in
          //          the parent container instead.
          //
          var resultView = this.view;
          var selection = resultView.selection;
          var rc = selection.getRangeCount();
          var min = { }, max = { };
          selection.getRangeAt(rc - 1, min, max);

          // If the sole selection is a container, and we are not in
          // a flatlist, insert into it.
          // Note that this only applies to _single_ selections,
          // if the last element within a multi-selection is a
          // container, insert _adjacent_ to the selection.
          //
          // If the sole selection is the bookmarks toolbar folder, we insert
          // into it even if it is not opened
          if (selection.count == 1 && resultView.isContainer(max.value) &&
              !this.flatList)
            orientation = Ci.nsITreeView.DROP_ON;

          this._cachedInsertionPoint =
            this._getInsertionPoint(max.value, orientation);
          return this._cachedInsertionPoint;
        ]]></getter>
      </property>

      <method name="_getInsertionPoint">
        <parameter name="index"/>
        <parameter name="orientation"/>
        <body><![CDATA[
          var result = this.result;
          var resultview = this.view;
          var container = result.root;
          var dropNearNode = null;
          console.assert(container, "null container");
          // When there's no selection, assume the container is the container
          // the view is populated from (i.e. the result's itemId).
          if (index != -1) {
            var lastSelected = resultview.nodeForTreeIndex(index);
            if (resultview.isContainer(index) && orientation == Ci.nsITreeView.DROP_ON) {
              // If the last selected item is an open container, append _into_
              // it, rather than insert adjacent to it.
              container = lastSelected;
              index = -1;
            } else if (lastSelected.containerOpen &&
                       orientation == Ci.nsITreeView.DROP_AFTER &&
                       lastSelected.hasChildren) {
             // If the last selected item is an open container and the user is
             // trying to drag into it as a first item, really insert into it.
             container = lastSelected;
             orientation = Ci.nsITreeView.DROP_ON;
             index = 0;
            } else {
              // Use the last-selected node's container.
              container = lastSelected.parent;

              // See comment in the treeView.js's copy of this method
              if (!container || !container.containerOpen)
                return null;

              // Avoid the potentially expensive call to getChildIndex
              // if we know this container doesn't allow insertion
              if (this.controller.disallowInsertion(container))
                return null;

              var queryOptions = PlacesUtils.asQuery(result.root).queryOptions;
              if (queryOptions.sortingMode !=
                    Ci.nsINavHistoryQueryOptions.SORT_BY_NONE) {
                // If we are within a sorted view, insert at the end
                index = -1;
              } else if (queryOptions.excludeItems ||
                         queryOptions.excludeQueries) {
                // Some item may be invisible, insert near last selected one.
                // We don't replace index here to avoid requests to the db,
                // instead it will be calculated later by the controller.
                index = -1;
                dropNearNode = lastSelected;
              } else {
                var lsi = container.getChildIndex(lastSelected);
                index = orientation == Ci.nsITreeView.DROP_BEFORE ? lsi : lsi + 1;
              }
            }
          }

          if (this.controller.disallowInsertion(container))
            return null;

          let tagName = PlacesUtils.nodeIsTagQuery(container) ?
                          PlacesUtils.asQuery(container).query.tags[0] : null;

          return new PlacesInsertionPoint({
            parentId: PlacesUtils.getConcreteItemId(container),
            parentGuid: PlacesUtils.getConcreteItemGuid(container),
            index, orientation, tagName, dropNearNode,
          });
        ]]></body>
      </method>

      <!-- nsIPlacesView -->
      <method name="selectAll">
        <body><![CDATA[
          this.view.selection.selectAll();
        ]]></body>
      </method>

      <!-- This method will select the first node in the tree that matches
           each given item guid. It will open any folder nodes that it needs
           to in order to show the selected items.
      -->
      <method name="selectItems">
        <parameter name="aGuids"/>
        <parameter name="aOpenContainers"/>
        <body><![CDATA[
          // Never open containers in flat lists.
          if (this.flatList)
            aOpenContainers = false;
          // By default, we do search and select within containers which were
          // closed (note that containers in which nodes were not found are
          // closed).
          if (aOpenContainers === undefined)
            aOpenContainers = true;

          var guids = aGuids; // don't manipulate the caller's array

          // Array of nodes found by findNodes which are to be selected
          var nodes = [];

          // Array of nodes found by findNodes which should be opened
          var nodesToOpen = [];

          // A set of GUIDs of container-nodes that were previously searched,
          // and thus shouldn't be searched again. This is empty at the initial
          // start of the recursion and gets filled in as the recursion
          // progresses.
          var checkedGuidsSet = new Set();

          /**
           * Recursively search through a node's children for items
           * with the given GUIDs. When a matching item is found, remove its GUID
           * from the GUIDs array, and add the found node to the nodes dictionary.
           *
           * NOTE: This method will leave open any node that had matching items
           * in its subtree.
           */
          function findNodes(node) {
            var foundOne = false;
            // See if node matches an ID we wanted; add to results.
            // For simple folder queries, check both itemId and the concrete
            // item id.
            var index = guids.indexOf(node.bookmarkGuid);
            if (index == -1) {
              let concreteGuid = PlacesUtils.getConcreteItemGuid(node);
              if (concreteGuid != node.bookmarkGuid) {
                index = guids.indexOf(concreteGuid);
              }
            }

            if (index != -1) {
              nodes.push(node);
              foundOne = true;
              guids.splice(index, 1);
            }

            var concreteGuid = PlacesUtils.getConcreteItemGuid(node);
            if (guids.length == 0 || !PlacesUtils.nodeIsContainer(node) ||
                checkedGuidsSet.has(concreteGuid))
              return foundOne;

            // Only follow a query if it has been been explicitly opened by the
            // caller. We support the "AllBookmarks" case to allow callers to
            // specify just the top-level bookmark folders.
            let shouldOpen = aOpenContainers && (PlacesUtils.nodeIsFolder(node) ||
              (PlacesUtils.nodeIsQuery(node) && node.bookmarkGuid == PlacesUIUtils.virtualAllBookmarksGuid));

            PlacesUtils.asContainer(node);
            if (!node.containerOpen && !shouldOpen)
              return foundOne;

            checkedGuidsSet.add(concreteGuid);

            // Remember the beginning state so that we can re-close
            // this node if we don't find any additional results here.
            var previousOpenness = node.containerOpen;
            node.containerOpen = true;
            for (var child = 0; child < node.childCount && guids.length > 0; child++) {
              var childNode = node.getChild(child);
              var found = findNodes(childNode);
              if (!foundOne)
                foundOne = found;
            }

            // If we didn't find any additional matches in this node's
            // subtree, revert the node to its previous openness.
            if (foundOne)
              nodesToOpen.unshift(node);
            node.containerOpen = previousOpenness;
            return foundOne;
          }

          // Disable notifications while looking for nodes.
          let result = this.result;
          let didSuppressNotifications = result.suppressNotifications;
          if (!didSuppressNotifications)
            result.suppressNotifications = true;
          try {
            findNodes(this.result.root);
          } finally {
            if (!didSuppressNotifications)
              result.suppressNotifications = false;
          }

          // For all the nodes we've found, highlight the corresponding
          // index in the tree.
          var resultview = this.view;
          var selection = this.view.selection;
          selection.selectEventsSuppressed = true;
          selection.clearSelection();
          // Open nodes containing found items
          for (let i = 0; i < nodesToOpen.length; i++) {
            nodesToOpen[i].containerOpen = true;
          }
          for (let i = 0; i < nodes.length; i++) {
            var index = resultview.treeIndexForNode(nodes[i]);
            if (index == -1)
              continue;
            selection.rangedSelect(index, index, true);
          }
          selection.selectEventsSuppressed = false;
        ]]></body>
      </method>

      <field name="_contextMenuShown">false</field>

      <method name="buildContextMenu">
        <parameter name="aPopup"/>
        <body><![CDATA[
          this._contextMenuShown = true;
          return this.controller.buildContextMenu(aPopup);
        ]]></body>
      </method>

      <method name="destroyContextMenu">
        <parameter name="aPopup"/>
          this._contextMenuShown = false;
        <body/>
      </method>

      <property name="ownerWindow"
                readonly="true"
                onget="return window;"/>

      <field name="_active">true</field>
      <property name="active"
                onget="return this._active"
                onset="return this._active = val"/>

    </implementation>
    <handlers>
      <handler event="focus"><![CDATA[
        this._cachedInsertionPoint = undefined;

        // See select handler. We need the sidebar's places commandset to be
        // updated as well
        document.commandDispatcher.updateCommands("focus");
      ]]></handler>
      <handler event="select"><![CDATA[
        this._cachedInsertionPoint = undefined;

        // This additional complexity is here for the sidebars
        var win = window;
        while (true) {
          win.document.commandDispatcher.updateCommands("focus");
          if (win == window.top)
            break;

          win = win.parent;
        }
      ]]></handler>

      <handler event="dragstart"><![CDATA[
        if (event.target.localName != "treechildren")
          return;

        if (this.disableUserActions) {
          event.preventDefault();
          event.stopPropagation();
          return;
        }

        let nodes = this.selectedNodes;
        for (let i = 0; i < nodes.length; i++) {
          let node = nodes[i];

          // Disallow dragging the root node of a tree.
          if (!node.parent) {
            event.preventDefault();
            event.stopPropagation();
            return;
          }

          // If this node is child of a readonly container or cannot be moved,
          // we must force a copy.
          if (!this.controller.canMoveNode(node)) {
            event.dataTransfer.effectAllowed = "copyLink";
            break;
          }
        }

        this._controller.setDataTransfer(event);
        event.stopPropagation();
      ]]></handler>

      <handler event="dragover"><![CDATA[
        if (event.target.localName != "treechildren")
          return;

        let cell = this.getCellAt(event.clientX, event.clientY);
        let node = cell.row != -1 ?
                   this.view.nodeForTreeIndex(cell.row) :
                   this.result.root;
        // cache the dropTarget for the view
        PlacesControllerDragHelper.currentDropTarget = node;

        // We have to calculate the orientation since view.canDrop will use
        // it and we want to be consistent with the dropfeedback.
        let rowHeight = this.rowHeight;
        let eventY = event.clientY - this.treeBody.boxObject.y -
                     rowHeight * (cell.row - this.getFirstVisibleRow());

        let orientation = Ci.nsITreeView.DROP_BEFORE;

        if (cell.row == -1) {
          // If the row is not valid we try to insert inside the resultNode.
          orientation = Ci.nsITreeView.DROP_ON;
        } else if (PlacesUtils.nodeIsContainer(node) &&
                 eventY > rowHeight * 0.75) {
          // If we are below the 75% of a container the treeview we try
          // to drop after the node.
          orientation = Ci.nsITreeView.DROP_AFTER;
        } else if (PlacesUtils.nodeIsContainer(node) &&
                 eventY > rowHeight * 0.25) {
          // If we are below the 25% of a container the treeview we try
          // to drop inside the node.
          orientation = Ci.nsITreeView.DROP_ON;
        }

        if (!this.view.canDrop(cell.row, orientation, event.dataTransfer))
          return;

        event.preventDefault();
        event.stopPropagation();
      ]]></handler>

      <handler event="dragend"><![CDATA[
        PlacesControllerDragHelper.currentDropTarget = null;
      ]]></handler>

    </handlers>
  </binding>

</bindings>

    </textarea>
    <pre></pre>
  </div>
  </main>
    <script>
    function getJSForBinding(binding) {
  let js = [];
  let elementName = binding.attrs.id;
  let className = 'Moz' + titleCase(elementName);
  let hasExtends = !!formatExtends(binding.attrs.extends);
  js.push(`class ${className} `);
  if (hasExtends) {
    js.push(`extends Moz${formatExtends(binding.attrs.extends)} `);
  } else {
    js.push(`extends MozXULElement `);
  }

  js.push('{')

  let childMarkup = [];
  let content = binding.find("content");
  if (content.length === 0) {
    content = binding.find("xbl:content");
  }
  if (content.length > 1) {
    throw "Unexpected second content field";
  } else if (content.length === 1) {
    function printChild(child, depth) {
      let attrs = '';
      for (var attr in child.attrs) {
        attrs += ' ' + attr.replace('xbl:', '') + '="' + child.attrs[attr].replace('"', '\"').replace(/xbl\:/g, '') + '"';
      }
      let name = child.name.replace('xul:', '');
      let padding = (new Array(depth + 3)).join("  ");
      childMarkup.push(`\n${padding}<${name}${attrs}>`);
      child.children.forEach(c => printChild(c, depth+1));
      let closePadding = child.children.length ? `\n${padding}` : '';
      childMarkup.push(`${closePadding}</${name}>`);
    }
    content[0].children.forEach(c => printChild(c, 1));
  } else {
    console.log("No content for binding", binding.attrs.id);
  }

  let innerHTML = "";

  if (content.length) {
    innerHTML += 'this.textContent = "";\n';
    innerHTML += "this.appendChild(MozXULElement.parseXULToFragment(`" + childMarkup.join('') + "\n    `));\n";

    if (childMarkup.join("").includes("inherits=")) {
      innerHTML += "// XXX: Implement `this.inheritAttribute()` for the [inherits] attribute in the markup above!\n";
    }
  }

  let xblconstructor = (binding.find("constructor") || [])[0];
  let xblconstructorComment = xblconstructor ? formatComment(xblconstructor.comment) : null;
  xblconstructor = xblconstructor ? `${xblconstructor.cdata || xblconstructor.value}` : '';
  if (xblconstructorComment) {
    xblconstructor = xblconstructorComment + "\n" + xblconstructor;
  }
  // Or, try / catch since many components will fail when loaded in a tab due to chrome references
  // xblconstructor = xblconstructor ? `try { ${xblconstructor.cdata} } catch(e) { }` : '';

  let xbldestructor = (binding.find("destructor") || [])[0];
  let xbldestructorComment = xbldestructor ? formatComment(xbldestructor.comment) : null;
  xbldestructor = xbldestructor ? `${xbldestructor.cdata || xbldestructor.value}` : '';
  // Or, try / catch since many components will fail when loaded in a tab due to chrome references
  // xbldestructor = xbldestructor ? `try { ${xbldestructor.cdata} } catch(e) { }` : '';
  if (xbldestructor != '') {
    xbldestructor = `disconnectedCallback() { ${xbldestructor} }`
    if (xblconstructorComment) {
      xbldestructor = xblconstructorComment + "\n" + xbldestructor;
    }
  }

  let handlers = [];
console.log(binding.attrs.id);
if (binding.attrs.id == "browser") {
  console.log("BROWSER", binding.find('handler').length);
}
  // <handler>
  for (let handler of binding.find('handler')) {
    let comment = formatComment(handler.comment);
    if (comment) {
      handlers.push(comment);
    }

    let secondParam = "";
    let isCapturing = handler.attrs.phase === "capturing";
    if (handler.attrs.group === "system") {
      if (isCapturing) {
        secondParam = `, { capture: true, mozSystemGroup: true }`;
      } else {
        secondParam = `, { mozSystemGroup: true }`;
      }
    } else if (isCapturing) {
      secondParam = ", true";
    }
    let keycode = handler.attrs.keycode ?
`
if (event.keyCode != KeyEvent.DOM_${handler.attrs.keycode}) {
  return;
}
` : "";
    let button = handler.attrs.button ?
`
if (event.button != ${handler.attrs.button}) {
  return;
}
` : "";

// console.log("BROWSER", binding.attrs.id);
// if (binding.attrs.id == "browser") {
//   console.log("BROWSER", keycode);
// }
    handlers.push(`this.addEventListener("${handler.attrs.event}", (event) => {${keycode}${button} ${handler.cdata || handler.value || handler.attrs.action}}${secondParam});\n`);
  }


  // <field>
  let fields = [];
  for (let field of binding.find('field')) {
    // Work around fields like _weekStart in the datepicker where the value is coming from a dtd.
    // Just print an empty string in that case.
    let data = (field.cdata || field.value || "").trim();
    if (data.startsWith("FROM-DTD")) {
      data = `"${data}"`
    }
    data = (data.length === 0) ? '""' : data;

    // Remove leading comments, which would cause the 'return' to be on a different line
    // than the expression.
    let leadingComments = [];
    let expressions = data.split("\n");
    for (var i = 0; i < expressions.length; i++) {
      if (expressions[i].trim().startsWith("//")) {
        leadingComments.push(expressions[i]);
      } else {
        expressions = expressions.slice(i);
        break;
      }
    }

    let expr = expressions.join("\n");
    if (expr[expr.length - 1] !== ";") {
      expr += ";";
    }
    // Strip away parens that were only needed for XBL
    if (expr[0] === "(" && expr[expr.length - 2] === ")") {
      expr = expr.substring(1, expr.length - 2) + ";";
    }

    let comment = formatComment(field.comment);
    if (comment) {
      fields.push(comment);
    }

    if (leadingComments.length) {
      fields.push(leadingComments.join("\n"));
    }

    fields.push(`this.${field.attrs.name} = ${expr}\n`);

    // let setter = field.attrs.readonly ? '' :
    // `set(val) {
    //     delete this.${field.attrs.name};
    //     return this.${field.attrs.name} = val;
    // },`;

    // fields.push(`Object.defineProperty(this, "${field.attrs.name}", {
    //   configurable: true,
    //   enumerable: true,
    //   get() {
    //     ${comments.join('\n')}
    //     delete this.${field.attrs.name};
    //     return this.${field.attrs.name} = ${expressions.join('\n')}
    //   },
    //   ${setter}
    // })`);
  }

  if (handlers.length) {
    js.push(`
      constructor() {
        super();

        ${handlers.join("\n")}
      }
    `)
  }

  js.push(`
    connectedCallback() {
      if (this.delayConnectedCallback()) {
        return;
      }
      ${innerHTML}
      ${fields.join("\n")}

      ${xblconstructor}
    }
  `);

  // <property>
  for (let property of binding.find('property')) {
    let comment = formatComment(property.comment);
    if (comment) {
      js.push(comment);
    }
    if (property.attrs.onset) {
      js.push(`
        set ${property.attrs.name}(val) {
          ${property.attrs.onset}
        }
      `);
    } else if(property.find('setter').length) {
      js.push(`
        set ${property.attrs.name}(val) {${property.find('setter')[0].cdata || property.find('setter')[0].value}}
      `);
    }
    if (property.attrs.onget) {
      js.push(`
        get ${property.attrs.name}() {
          ${property.attrs.onget}
        }
      `);
    } else if(property.find('getter').length) {
      js.push(`
        get ${property.attrs.name}() {${property.find('getter')[0].cdata || property.find('getter')[0].value}}
      `);
    }
  }

  // <method>
  for (let method of binding.find('method')) {
    js.push('\n');
    let comment = formatComment(method.comment);
    if (comment) {
      js.push(comment);
    }
    js.push(`${method.attrs.name}(`);
    js.push(`${method.find('parameter').map(p => p.attrs.name).join(',')}`);
    js.push(`) {`);
    js.push(method.find('body')[0].cdata || method.find('body')[0].value);
    js.push(`}\n`);
  }

  js.push(`${xbldestructor}`);

  js.push("}\n\n");

  let implements =
    binding.find("implementation").length &&
    binding.find("implementation")[0].attrs.implements
  if (implements) {
    implements = implements.split(",").map(i=>"Ci." + i.trim()).join(", ");
    js.push(`MozXULElement.implementCustomInterface(${className}, [${implements}]);`)
  }



  js.push(`customElements.define("${elementName}", ${className});
  `)
  return js.join(' ');
}
    function titleCase(str) {
  if (str == "basecontrol") {
    // Special case so we don't end up with Basecontrol:
    return "BaseControl";
  }
  return str[0].toUpperCase() + str.substr(1).replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
}
    function formatExtends(ext) {
  if (!ext || ext.startsWith("xul:")) {
    return null;
  }
  return titleCase(ext.split('#')[1]);
}
    function formatComment(comment, spaces = 2) {
  if (!comment) {
    return '';
  }

  let spacesStr = new Array(spaces).join(" ");
  let commentArr = comment.split("\n").map(s=> s.trim());
  if (!commentArr[0]) { commentArr.shift(); }
  if (!commentArr[commentArr.length - 1]) { commentArr.pop(); }
  let commentFormatted = commentArr
    .map(s => (s ? `${spacesStr}* ${s}` : `${spacesStr}*`))
    .join("\n");

  return `${spacesStr}/**\n${commentFormatted}\n${spacesStr}*/`;
}
    function getFormattedJSForBinding(binding) {
  let js = [];
  js.push(
`/* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

"use strict";

// This is loaded into all XUL windows. Wrap in a block to prevent
// leaking to window scope.
{

`);

  js.push(js_beautify(
    getJSForBinding(binding),
    {
      indent_size: 2,
      // preserve_newlines: false,
      max_preserve_newlines: 2,
      brace_style: "preserve-inline"
      // keep_array_indentation: true
    }
  ));

  js.push(`

}
`);

  return js.join("");
}

    var textarea = document.querySelector("textarea");
    var pre = document.querySelector("pre");
    function createPreview() {
      var body = textarea.value;
      body = body.replace(/&([a-z0-9-]+);/gi, "FROM-DTD-$1"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2-$3"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2-$3-$4"); // Replace DTD entities
      var parsed = xmlom.parseString(body, {
        xmlns: true,
      });
      parsed.then(doc => {
        console.log(doc, doc.find("binding"));
        let js = doc.find("binding").map(binding => {
          return getFormattedJSForBinding(binding);
        }).join("\n");
        pre.textContent = js;
      }).catch(e => {
        pre.textContent =  "Error parsing XML:\n" + e;
      });
    }
    textarea.addEventListener("input", createPreview);
    createPreview();

    document.querySelector("ul").addEventListener("click", function(e) {
      if (e.originalTarget.localName === "a") {
        e.preventDefault();
        textarea.value = files[e.originalTarget.dataset.index].body;
        createPreview();
      }
    });
    </script>
  </body>
  </html>
