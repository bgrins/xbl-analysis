
  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8">
    <title>XBL To Custom Element Converter</title>
    <link rel="stylesheet" href="../static/styles.css" />
    <script src="../static/xmlom.js"></script>
    <script src="../static/beautify.js"></script>
    <style>
    main {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
      width: 100vw;
      position: absolute;
      top: 0;
      left: 0;
    }
    #converter {
      font-family: monospace;
      display: grid;
      overflow: hidden;
      grid-template-columns: auto 1fr 1fr;
      grid-gap: 10px;
    }
    textarea, pre {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: monospace;
      font-size: 12px;
    }
    ul {
      min-width: 100px;
      margin: 0;
      padding: 0;
      overflow: scroll;
      font-size: smaller;
    }
    li {
      margin: 0;
      padding: 0;
      list-style: none;
      word-break: keep-all;
    }
    </style>
    <script>
      var files = [{"file":"tabbrowser.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"tabBrowserBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"tabbrowser-arrowscrollbox\" extends=\"chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll\">\n    <implementation>\n      <!-- Override scrollbox.xml method, since our scrollbox's children are\n           inherited from the binding parent -->\n      <method name=\"_getScrollableElements\">\n        <body><![CDATA[\n          return Array.filter(document.getBindingParent(this).children,\n                              this._canScrollToElement, this);\n        ]]></body>\n      </method>\n      <method name=\"_canScrollToElement\">\n        <parameter name=\"tab\"/>\n        <body><![CDATA[\n          return !tab._pinnedUnscrollable && !tab.hidden;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"underflow\" phase=\"capturing\"><![CDATA[\n        // Ignore underflow events:\n        // - from nested scrollable elements\n        // - for vertical orientation\n        // - corresponding to an overflow event that we ignored\n        let tabs = document.getBindingParent(this);\n        if (event.originalTarget != this._scrollbox ||\n            event.detail == 0 ||\n            !tabs.hasAttribute(\"overflow\")) {\n          return;\n        }\n\n        tabs.removeAttribute(\"overflow\");\n\n        if (tabs._lastTabClosedByMouse) {\n          tabs._expandSpacerBy(this._scrollButtonDown.clientWidth);\n        }\n\n        for (let tab of Array.from(gBrowser._removingTabs)) {\n          gBrowser.removeTab(tab);\n        }\n\n        tabs._positionPinnedTabs();\n      ]]></handler>\n      <handler event=\"overflow\"><![CDATA[\n        // Ignore overflow events:\n        // - from nested scrollable elements\n        // - for vertical orientation\n        if (event.originalTarget != this._scrollbox ||\n            event.detail == 0) {\n          return;\n        }\n\n        var tabs = document.getBindingParent(this);\n        tabs.setAttribute(\"overflow\", \"true\");\n        tabs._positionPinnedTabs();\n        tabs._handleTabSelect(true);\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"tabbrowser-tabs\"\n           extends=\"chrome://global/content/bindings/tabbox.xml#tabs\">\n    <content>\n      <xul:hbox class=\"tab-drop-indicator-box\">\n        <xul:image class=\"tab-drop-indicator\" anonid=\"tab-drop-indicator\" collapsed=\"true\"/>\n      </xul:hbox>\n      <xul:arrowscrollbox anonid=\"arrowscrollbox\" orient=\"horizontal\" flex=\"1\"\n                          style=\"min-width: 1px;\"\n                          clicktoscroll=\"true\"\n                          class=\"tabbrowser-arrowscrollbox\">\n<!--\n This is a hack to circumvent bug 472020, otherwise the tabs show up on the\n right of the newtab button.\n-->\n        <children includes=\"tab\"/>\n<!--\n  This is to ensure anything extensions put here will go before the newtab\n  button, necessary due to the previous hack.\n-->\n        <children/>\n        <xul:toolbarbutton class=\"tabs-newtab-button toolbarbutton-1\"\n                           anonid=\"tabs-newtab-button\"\n                           command=\"cmd_newNavigatorTab\"\n                           onclick=\"checkForMiddleClick(this, event);\"\n                           tooltip=\"dynamic-shortcut-tooltip\"/>\n        <xul:spacer class=\"closing-tabs-spacer\" anonid=\"closing-tabs-spacer\"\n                    style=\"width: 0;\"/>\n      </xul:arrowscrollbox>\n    </content>\n\n    <implementation implements=\"nsIObserver\">\n      <constructor>\n        <![CDATA[\n          this._tabClipWidth = Services.prefs.getIntPref(\"browser.tabs.tabClipWidth\");\n          this._hiddenSoundPlayingTabs = new Set();\n\n          let strId = PrivateBrowsingUtils.isWindowPrivate(window) ?\n              \"emptyPrivateTabTitle\" : \"emptyTabTitle\";\n          this.emptyTabTitle = gTabBrowserBundle.GetStringFromName(\"tabs.\" + strId);\n\n          var tab = this.firstElementChild;\n          tab.label = this.emptyTabTitle;\n\n          window.addEventListener(\"resize\", this);\n\n          Services.prefs.addObserver(\"privacy.userContext\", this);\n          this.observe(null, \"nsPref:changed\", \"privacy.userContext.enabled\");\n\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"_tabMinWidthPref\",\n            \"browser.tabs.tabMinWidth\", null,\n            (pref, prevValue, newValue) => this._tabMinWidth = newValue,\n            newValue => {\n              const LIMIT = 50;\n              return Math.max(newValue, LIMIT);\n            },\n          );\n\n          this._tabMinWidth = this._tabMinWidthPref;\n\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"_multiselectEnabledPref\",\n            \"browser.tabs.multiselect\", null,\n            (pref, prevValue, newValue) => this._multiselectEnabled = newValue);\n          this._multiselectEnabled = this._multiselectEnabledPref;\n\n          this._setPositionalAttributes();\n\n          CustomizableUI.addListener(this);\n          this._updateNewTabVisibility();\n\n          XPCOMUtils.defineLazyPreferenceGetter(this, \"_closeTabByDblclick\",\n            \"browser.tabs.closeTabByDblclick\", false);\n\n          if (gMultiProcessBrowser) {\n            this.tabbox.tabpanels.setAttribute(\"async\", \"true\");\n          }\n        ]]>\n      </constructor>\n\n      <destructor>\n        <![CDATA[\n          Services.prefs.removeObserver(\"privacy.userContext\", this);\n\n          CustomizableUI.removeListener(this);\n        ]]>\n      </destructor>\n\n      <field name=\"tabbox\" readonly=\"true\">\n        document.getElementById(\"tabbrowser-tabbox\");\n      </field>\n\n      <field name=\"contextMenu\" readonly=\"true\">\n        document.getElementById(\"tabContextMenu\");\n      </field>\n\n      <field name=\"arrowScrollbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowscrollbox\");\n      </field>\n\n      <field name=\"_firstTab\">null</field>\n      <field name=\"_lastTab\">null</field>\n      <field name=\"_beforeSelectedTab\">null</field>\n      <field name=\"_beforeHoveredTab\">null</field>\n      <field name=\"_afterHoveredTab\">null</field>\n      <field name=\"_hoveredTab\">null</field>\n\n      <property name=\"_tabMinWidth\">\n        <setter>\n          this.style.setProperty(\"--tab-min-width\", val + \"px\");\n          return val;\n        </setter>\n      </property>\n\n      <property name=\"_multiselectEnabled\">\n        <setter>\n          // Unlike boolean HTML attributes, the value of boolean ARIA attributes actually matters.\n          this.setAttribute(\"aria-multiselectable\", !!val);\n          return val;\n        </setter>\n        <getter>\n          return this.getAttribute(\"aria-multiselectable\") == \"true\";\n        </getter>\n      </property>\n\n      <method name=\"observe\">\n        <parameter name=\"aSubject\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aData\"/>\n        <body><![CDATA[\n          switch (aTopic) {\n            case \"nsPref:changed\":\n              // This is has to deal with changes in\n              // privacy.userContext.enabled and\n              // privacy.userContext.longPressBehavior.\n              let containersEnabled = Services.prefs.getBoolPref(\"privacy.userContext.enabled\")\n                                        && !PrivateBrowsingUtils.isWindowPrivate(window);\n\n              // This pref won't change so often, so just recreate the menu.\n              let longPressBehavior = Services.prefs.getIntPref(\"privacy.userContext.longPressBehavior\");\n\n              // If longPressBehavior pref is set to 0 (or any invalid value)\n              // long press menu is disabled.\n              if (containersEnabled && (longPressBehavior <= 0 || longPressBehavior > 2)) {\n                containersEnabled = false;\n              }\n\n              const newTab = document.getElementById(\"new-tab-button\");\n              const newTab2 = document.getAnonymousElementByAttribute(this, \"anonid\", \"tabs-newtab-button\");\n\n              for (let parent of [newTab, newTab2]) {\n                if (!parent)\n                  continue;\n\n                gClickAndHoldListenersOnElement.remove(parent);\n                parent.removeAttribute(\"type\");\n                if (parent.firstElementChild) {\n                  parent.firstElementChild.remove();\n                }\n\n                if (containersEnabled) {\n                  let popup = document.createElementNS(\n                                \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\",\n                                \"menupopup\");\n                  if (parent.id) {\n                    popup.id = \"newtab-popup\";\n                  } else {\n                    popup.setAttribute(\"anonid\", \"newtab-popup\");\n                  }\n                  popup.className = \"new-tab-popup\";\n                  popup.setAttribute(\"position\", \"after_end\");\n                  popup.addEventListener(\"popupshowing\", event => {\n                    createUserContextMenu(event, {\n                      useAccessKeys: false,\n                      showDefaultTab: Services.prefs.getIntPref(\"privacy.userContext.longPressBehavior\") == 1,\n                    });\n                  });\n                  parent.appendChild(popup);\n\n                  // longPressBehavior == 2 means that the menu is shown after X\n                  // millisecs. Otherwise, with 1, the menu is open immediatelly.\n                  if (longPressBehavior == 2) {\n                    gClickAndHoldListenersOnElement.add(parent);\n                  }\n\n                  parent.setAttribute(\"type\", \"menu\");\n                }\n              }\n\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <property name=\"_isCustomizing\" readonly=\"true\">\n        <getter><![CDATA[\n          return document.documentElement.getAttribute(\"customizing\") == \"true\";\n        ]]></getter>\n      </property>\n\n      <method name=\"_getVisibleTabs\">\n        <body><![CDATA[\n          // Cannot access gBrowser before it's initialized.\n          if (!gBrowser) {\n            return [ this.firstElementChild ];\n          }\n\n          return gBrowser.visibleTabs;\n        ]]></body>\n      </method>\n\n      <method name=\"_setPositionalAttributes\">\n        <body><![CDATA[\n          let visibleTabs = this._getVisibleTabs();\n          if (!visibleTabs.length) {\n            return;\n          }\n          let selectedTab = this.selectedItem;\n          let selectedIndex = visibleTabs.indexOf(selectedTab);\n          if (this._beforeSelectedTab) {\n            this._beforeSelectedTab.removeAttribute(\"beforeselected-visible\");\n          }\n\n          if (selectedTab.closing || selectedIndex <= 0) {\n            this._beforeSelectedTab = null;\n          } else {\n            let beforeSelectedTab = visibleTabs[selectedIndex - 1];\n            let separatedByScrollButton = this.getAttribute(\"overflow\") == \"true\" &&\n              beforeSelectedTab.pinned && !selectedTab.pinned;\n            if (!separatedByScrollButton) {\n              this._beforeSelectedTab = beforeSelectedTab;\n              this._beforeSelectedTab.setAttribute(\"beforeselected-visible\",\n                                                   \"true\");\n            }\n          }\n\n          if (this._firstTab)\n            this._firstTab.removeAttribute(\"first-visible-tab\");\n          this._firstTab = visibleTabs[0];\n          this._firstTab.setAttribute(\"first-visible-tab\", \"true\");\n          if (this._lastTab)\n            this._lastTab.removeAttribute(\"last-visible-tab\");\n          this._lastTab = visibleTabs[visibleTabs.length - 1];\n          this._lastTab.setAttribute(\"last-visible-tab\", \"true\");\n\n          let hoveredTab = this._hoveredTab;\n          if (hoveredTab) {\n            hoveredTab._mouseleave();\n          }\n          hoveredTab = this.querySelector(\"tab:hover\");\n          if (hoveredTab) {\n            hoveredTab._mouseenter();\n          }\n\n          // Update before-multiselected attributes.\n          // gBrowser may not be initialized yet, so avoid using it\n          for (let i = 0; i < visibleTabs.length - 1; i++) {\n            let tab = visibleTabs[i];\n            let nextTab = visibleTabs[i + 1];\n            tab.removeAttribute(\"before-multiselected\");\n            if (nextTab.multiselected) {\n              tab.setAttribute(\"before-multiselected\", \"true\");\n            }\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_blockDblClick\">false</field>\n\n      <field name=\"_tabDropIndicator\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"tab-drop-indicator\");\n      </field>\n\n      <field name=\"_dragOverDelay\">350</field>\n      <field name=\"_dragTime\">0</field>\n\n      <field name=\"_closeButtonsUpdatePending\">false</field>\n      <method name=\"_updateCloseButtons\">\n        <body><![CDATA[\n          // If we're overflowing, tabs are at their minimum widths.\n          if (this.getAttribute(\"overflow\") == \"true\") {\n            this.setAttribute(\"closebuttons\", \"activetab\");\n            return;\n          }\n\n          if (this._closeButtonsUpdatePending) {\n            return;\n          }\n          this._closeButtonsUpdatePending = true;\n\n          // Wait until after the next paint to get current layout data from\n          // getBoundsWithoutFlushing.\n          window.requestAnimationFrame(() => {\n            window.requestAnimationFrame(() => {\n              this._closeButtonsUpdatePending = false;\n\n              // The scrollbox may have started overflowing since we checked\n              // overflow earlier, so check again.\n              if (this.getAttribute(\"overflow\") == \"true\") {\n                this.setAttribute(\"closebuttons\", \"activetab\");\n                return;\n              }\n\n              // Check if tab widths are below the threshold where we want to\n              // remove close buttons from background tabs so that people don't\n              // accidentally close tabs by selecting them.\n              let rect = ele => {\n                return window.windowUtils.getBoundsWithoutFlushing(ele);\n              };\n              let tab = this._getVisibleTabs()[gBrowser._numPinnedTabs];\n              if (tab && rect(tab).width <= this._tabClipWidth) {\n                this.setAttribute(\"closebuttons\", \"activetab\");\n              } else {\n                this.removeAttribute(\"closebuttons\");\n              }\n            });\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"_updateHiddenTabsStatus\">\n        <body><![CDATA[\n          if (gBrowser.visibleTabs.length < gBrowser.tabs.length) {\n            this.setAttribute(\"hashiddentabs\", \"true\");\n          } else {\n            this.removeAttribute(\"hashiddentabs\");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_handleTabSelect\">\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          let selectedTab = this.selectedItem;\n          if (this.getAttribute(\"overflow\") == \"true\")\n            this.arrowScrollbox.ensureElementIsVisible(selectedTab, aInstant);\n\n          selectedTab._notselectedsinceload = false;\n        ]]></body>\n      </method>\n\n      <field name=\"_closingTabsSpacer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"closing-tabs-spacer\");\n      </field>\n\n      <field name=\"_tabDefaultMaxWidth\">NaN</field>\n      <field name=\"_lastTabClosedByMouse\">false</field>\n      <field name=\"_hasTabTempMaxWidth\">false</field>\n\n      <!-- Try to keep the active tab's close button under the mouse cursor -->\n      <method name=\"_lockTabSizing\">\n        <parameter name=\"aTab\"/>\n        <parameter name=\"aTabWidth\"/>\n        <body><![CDATA[\n          let tabs = this._getVisibleTabs();\n          if (!tabs.length) {\n            return;\n          }\n\n          var isEndTab = (aTab._tPos > tabs[tabs.length - 1]._tPos);\n\n          if (!this._tabDefaultMaxWidth) {\n            this._tabDefaultMaxWidth =\n              parseFloat(window.getComputedStyle(aTab).maxWidth);\n          }\n          this._lastTabClosedByMouse = true;\n\n          if (this.getAttribute(\"overflow\") == \"true\") {\n            // Don't need to do anything if we're in overflow mode and aren't scrolled\n            // all the way to the right, or if we're closing the last tab.\n            if (isEndTab || !this.arrowScrollbox._scrollButtonDown.disabled) {\n              return;\n            }\n            // If the tab has an owner that will become the active tab, the owner will\n            // be to the left of it, so we actually want the left tab to slide over.\n            // This can't be done as easily in non-overflow mode, so we don't bother.\n            if (aTab.owner) {\n              return;\n            }\n            this._expandSpacerBy(aTabWidth);\n          } else { // non-overflow mode\n            // Locking is neither in effect nor needed, so let tabs expand normally.\n            if (isEndTab && !this._hasTabTempMaxWidth) {\n              return;\n            }\n            let numPinned = gBrowser._numPinnedTabs;\n            // Force tabs to stay the same width, unless we're closing the last tab,\n            // which case we need to let them expand just enough so that the overall\n            // tabbar width is the same.\n            if (isEndTab) {\n              let numNormalTabs = tabs.length - numPinned;\n              aTabWidth = aTabWidth * (numNormalTabs + 1) / numNormalTabs;\n              if (aTabWidth > this._tabDefaultMaxWidth) {\n                aTabWidth = this._tabDefaultMaxWidth;\n              }\n            }\n            aTabWidth += \"px\";\n            let tabsToReset = [];\n            for (let i = numPinned; i < tabs.length; i++) {\n              let tab = tabs[i];\n              tab.style.setProperty(\"max-width\", aTabWidth, \"important\");\n              if (!isEndTab) { // keep tabs the same width\n                tab.style.transition = \"none\";\n                tabsToReset.push(tab);\n              }\n            }\n\n            if (tabsToReset.length) {\n              window.promiseDocumentFlushed(() => {}).then(() => {\n                window.requestAnimationFrame(() => {\n                  for (let tab of tabsToReset) {\n                    tab.style.transition = \"\";\n                  }\n                });\n              });\n            }\n\n            this._hasTabTempMaxWidth = true;\n            gBrowser.addEventListener(\"mousemove\", this);\n            window.addEventListener(\"mouseout\", this);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_expandSpacerBy\">\n        <parameter name=\"pixels\"/>\n        <body><![CDATA[\n          let spacer = this._closingTabsSpacer;\n          spacer.style.width = parseFloat(spacer.style.width) + pixels + \"px\";\n          this.setAttribute(\"using-closing-tabs-spacer\", \"true\");\n          gBrowser.addEventListener(\"mousemove\", this);\n          window.addEventListener(\"mouseout\", this);\n        ]]></body>\n      </method>\n\n      <method name=\"_unlockTabSizing\">\n        <body><![CDATA[\n          gBrowser.removeEventListener(\"mousemove\", this);\n          window.removeEventListener(\"mouseout\", this);\n\n          if (this._hasTabTempMaxWidth) {\n            this._hasTabTempMaxWidth = false;\n            let tabs = this._getVisibleTabs();\n            for (let i = 0; i < tabs.length; i++) {\n              tabs[i].style.maxWidth = \"\";\n            }\n          }\n\n          if (this.hasAttribute(\"using-closing-tabs-spacer\")) {\n            this.removeAttribute(\"using-closing-tabs-spacer\");\n            this._closingTabsSpacer.style.width = 0;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"uiDensityChanged\">\n        <body><![CDATA[\n          this._positionPinnedTabs();\n          this._updateCloseButtons();\n          this._handleTabSelect(true);\n        ]]></body>\n      </method>\n\n      <field name=\"_lastNumPinned\">0</field>\n      <field name=\"_pinnedTabsLayoutCache\">null</field>\n      <method name=\"_positionPinnedTabs\">\n        <body><![CDATA[\n          let numPinned = gBrowser._numPinnedTabs;\n          let doPosition = this.getAttribute(\"overflow\") == \"true\" &&\n                           this._getVisibleTabs().length > numPinned &&\n                           numPinned > 0;\n\n          if (doPosition) {\n            this.setAttribute(\"positionpinnedtabs\", \"true\");\n\n            let layoutData = this._pinnedTabsLayoutCache;\n            let uiDensity = document.documentElement.getAttribute(\"uidensity\");\n            if (!layoutData ||\n                layoutData.uiDensity != uiDensity) {\n              let arrowScrollbox = this.arrowScrollbox;\n              layoutData = this._pinnedTabsLayoutCache = {\n                uiDensity,\n                pinnedTabWidth: this.children[0].getBoundingClientRect().width,\n                scrollButtonWidth: arrowScrollbox._scrollButtonDown.getBoundingClientRect().width,\n              };\n            }\n\n            let width = 0;\n            for (let i = numPinned - 1; i >= 0; i--) {\n              let tab = this.children[i];\n              width += layoutData.pinnedTabWidth;\n              tab.style.setProperty(\"margin-inline-start\",\n                -(width + layoutData.scrollButtonWidth) + \"px\", \"important\");\n              tab._pinnedUnscrollable = true;\n            }\n            this.style.paddingInlineStart = width + \"px\";\n          } else {\n            this.removeAttribute(\"positionpinnedtabs\");\n\n            for (let i = 0; i < numPinned; i++) {\n              let tab = this.children[i];\n              tab.style.marginInlineStart = \"\";\n              tab._pinnedUnscrollable = false;\n            }\n\n            this.style.paddingInlineStart = \"\";\n          }\n\n          if (this._lastNumPinned != numPinned) {\n            this._lastNumPinned = numPinned;\n            this._handleTabSelect(true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_animateTabMove\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);\n          let movingTabs = draggedTab._dragData.movingTabs;\n\n          if (this.getAttribute(\"movingtab\") != \"true\") {\n            this.setAttribute(\"movingtab\", \"true\");\n            this.parentNode.setAttribute(\"movingtab\", \"true\");\n            if (!draggedTab.multiselected)\n              this.selectedItem = draggedTab;\n          }\n\n          if (!(\"animLastScreenX\" in draggedTab._dragData))\n            draggedTab._dragData.animLastScreenX = draggedTab._dragData.screenX;\n\n          let screenX = event.screenX;\n          if (screenX == draggedTab._dragData.animLastScreenX)\n            return;\n\n          // Direction of the mouse movement.\n          let ltrMove = screenX > draggedTab._dragData.animLastScreenX;\n\n          draggedTab._dragData.animLastScreenX = screenX;\n\n          let rtl = (window.getComputedStyle(this).direction == \"rtl\");\n          let pinned = draggedTab.pinned;\n          let numPinned = gBrowser._numPinnedTabs;\n          let tabs = this._getVisibleTabs()\n                         .slice(pinned ? 0 : numPinned,\n                                pinned ? numPinned : undefined);\n\n          if (rtl) {\n            tabs.reverse();\n            // Copy moving tabs array to avoid infinite reversing.\n            movingTabs = [...movingTabs].reverse();\n          }\n          let tabWidth = draggedTab.getBoundingClientRect().width;\n          let shiftWidth = tabWidth * movingTabs.length;\n          draggedTab._dragData.tabWidth = tabWidth;\n\n          // Move the dragged tab based on the mouse position.\n\n          let leftTab = tabs[0];\n          let rightTab = tabs[tabs.length - 1];\n          let rightMovingTabScreenX = movingTabs[movingTabs.length - 1].boxObject.screenX;\n          let leftMovingTabScreenX = movingTabs[0].boxObject.screenX;\n          let translateX = screenX - draggedTab._dragData.screenX;\n          if (!pinned) {\n            translateX += this.arrowScrollbox._scrollbox.scrollLeft - draggedTab._dragData.scrollX;\n          }\n          let leftBound = leftTab.boxObject.screenX - leftMovingTabScreenX;\n          let rightBound = (rightTab.boxObject.screenX + rightTab.boxObject.width) -\n                           (rightMovingTabScreenX + tabWidth);\n          translateX = Math.min(Math.max(translateX, leftBound), rightBound);\n\n          for (let tab of movingTabs) {\n            tab.style.transform = \"translateX(\" + translateX + \"px)\";\n          }\n\n          draggedTab._dragData.translateX = translateX;\n\n          // Determine what tab we're dragging over.\n          // * Single tab dragging: Point of reference is the center of the dragged tab. If that\n          //   point touches a background tab, the dragged tab would take that\n          //   tab's position when dropped.\n          // * Multiple tabs dragging: All dragged tabs are one \"giant\" tab with two\n          //   points of reference (center of tabs on the extremities). When\n          //   mouse is moving from left to right, the right reference gets activated,\n          //   otherwise the left reference will be used. Everything else works the same\n          //   as single tab dragging.\n          // * We're doing a binary search in order to reduce the amount of\n          //   tabs we need to check.\n\n          tabs = tabs.filter(t => !movingTabs.includes(t) || t == draggedTab);\n          let leftTabCenter = leftMovingTabScreenX + translateX + tabWidth / 2;\n          let rightTabCenter = rightMovingTabScreenX + translateX + tabWidth / 2;\n          let tabCenter = ltrMove ? rightTabCenter : leftTabCenter;\n          let newIndex = -1;\n          let oldIndex = \"animDropIndex\" in draggedTab._dragData ?\n                         draggedTab._dragData.animDropIndex : movingTabs[0]._tPos;\n          let low = 0;\n          let high = tabs.length - 1;\n          while (low <= high) {\n            let mid = Math.floor((low + high) / 2);\n            if (tabs[mid] == draggedTab && ++mid > high)\n              break;\n            let boxObject = tabs[mid].boxObject;\n            screenX = boxObject.screenX + getTabShift(tabs[mid], oldIndex);\n            if (screenX > tabCenter) {\n              high = mid - 1;\n            } else if (screenX + boxObject.width < tabCenter) {\n              low = mid + 1;\n            } else {\n              newIndex = tabs[mid]._tPos;\n              break;\n            }\n          }\n          if (newIndex >= oldIndex)\n            newIndex++;\n          if (newIndex < 0 || newIndex == oldIndex)\n            return;\n          draggedTab._dragData.animDropIndex = newIndex;\n\n          // Shift background tabs to leave a gap where the dragged tab\n          // would currently be dropped.\n\n          for (let tab of tabs) {\n            if (tab != draggedTab) {\n              let shift = getTabShift(tab, newIndex);\n              tab.style.transform = shift ? \"translateX(\" + shift + \"px)\" : \"\";\n            }\n          }\n\n          function getTabShift(tab, dropIndex) {\n            if (tab._tPos < draggedTab._tPos && tab._tPos >= dropIndex)\n              return (rtl ? -shiftWidth : shiftWidth);\n            if (tab._tPos > draggedTab._tPos && tab._tPos < dropIndex)\n              return (rtl ? shiftWidth : -shiftWidth);\n            return 0;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_finishAnimateTabMove\">\n        <body><![CDATA[\n          if (this.getAttribute(\"movingtab\") != \"true\") {\n            return;\n          }\n\n          for (let tab of this._getVisibleTabs()) {\n            tab.style.transform = \"\";\n          }\n\n          this.removeAttribute(\"movingtab\");\n          this.parentNode.removeAttribute(\"movingtab\");\n\n          this._handleTabSelect();\n        ]]></body>\n      </method>\n\n      <!--  Regroup all selected tabs around the\n            tab in param  -->\n      <method name=\"_groupSelectedTabs\">\n        <parameter name=\"tab\"/>\n        <body><![CDATA[\n          let draggedTabPos = tab._tPos;\n          let selectedTabs = gBrowser.selectedTabs;\n          let animate = gBrowser.animationsEnabled;\n\n          tab.groupingTabsData = {\n            finished: !animate,\n          };\n\n\n          // Animate left selected tabs\n\n          let insertAtPos = draggedTabPos - 1;\n          for (let i = selectedTabs.indexOf(tab) - 1; i > -1; i--) {\n            let movingTab = selectedTabs[i];\n            insertAtPos = newIndex(movingTab, insertAtPos);\n\n            if (animate) {\n              movingTab.groupingTabsData = {};\n              addAnimationData(movingTab, insertAtPos, \"left\");\n            } else {\n              gBrowser.moveTabTo(movingTab, insertAtPos);\n            }\n            insertAtPos--;\n          }\n\n          // Animate right selected tabs\n\n          insertAtPos = draggedTabPos + 1;\n          for (let i = selectedTabs.indexOf(tab) + 1; i < selectedTabs.length; i++) {\n            let movingTab = selectedTabs[i];\n            insertAtPos = newIndex(movingTab, insertAtPos);\n\n            if (animate) {\n              movingTab.groupingTabsData = {};\n              addAnimationData(movingTab, insertAtPos, \"right\");\n            } else {\n              gBrowser.moveTabTo(movingTab, insertAtPos);\n            }\n            insertAtPos++;\n          }\n\n          // Slide the relevant tabs to their new position.\n          let rtl = Services.locale.isAppLocaleRTL ? -1 : 1;\n          for (let t of this._getVisibleTabs()) {\n            if (t.groupingTabsData && t.groupingTabsData.translateX) {\n              let translateX = rtl * t.groupingTabsData.translateX;\n              t.style.transform = \"translateX(\" + translateX + \"px)\";\n            }\n          }\n\n          function newIndex(aTab, index) {\n            // Don't allow mixing pinned and unpinned tabs.\n            if (aTab.pinned) {\n              return Math.min(index, gBrowser._numPinnedTabs - 1);\n            }\n            return Math.max(index, gBrowser._numPinnedTabs);\n          }\n\n          function addAnimationData(movingTab, movingTabNewIndex, side) {\n            let movingTabOldIndex = movingTab._tPos;\n\n            if (movingTabOldIndex == movingTabNewIndex) {\n              // movingTab is already at the right position\n              // and thus don't need to be animated.\n              return;\n            }\n\n            let movingTabWidth = movingTab.boxObject.width;\n            let shift = (movingTabNewIndex - movingTabOldIndex) * movingTabWidth;\n\n            movingTab.groupingTabsData.animate = true;\n            movingTab.setAttribute(\"tab-grouping\", \"true\");\n\n            movingTab.groupingTabsData.translateX = shift;\n\n            let onTransitionEnd = transitionendEvent => {\n              if (transitionendEvent.propertyName != \"transform\" ||\n                  transitionendEvent.originalTarget != movingTab) {\n                return;\n              }\n              movingTab.removeEventListener(\"transitionend\", onTransitionEnd);\n              movingTab.groupingTabsData.newIndex = movingTabNewIndex;\n              movingTab.groupingTabsData.animate = false;\n            };\n\n            movingTab.addEventListener(\"transitionend\", onTransitionEnd);\n\n            // Add animation data for tabs between movingTab (selected\n            // tab moving towards the dragged tab) and draggedTab.\n            // Those tabs in the middle should move in\n            // the opposite direction of movingTab.\n\n            let lowerIndex = Math.min(movingTabOldIndex, draggedTabPos);\n            let higherIndex = Math.max(movingTabOldIndex, draggedTabPos);\n\n            for (let i = lowerIndex + 1; i < higherIndex; i++) {\n              let middleTab = gBrowser.visibleTabs[i];\n\n              if (middleTab.pinned != movingTab.pinned) {\n                // Don't mix pinned and unpinned tabs\n                break;\n              }\n\n              if (middleTab.multiselected) {\n                // Skip because this selected tab should\n                // be shifted towards the dragged Tab.\n                continue;\n              }\n\n              if (!middleTab.groupingTabsData || !middleTab.groupingTabsData.translateX) {\n                middleTab.groupingTabsData = { translateX: 0};\n              }\n              if (side == \"left\") {\n                middleTab.groupingTabsData.translateX -= movingTabWidth;\n              } else {\n                middleTab.groupingTabsData.translateX += movingTabWidth;\n              }\n\n              middleTab.setAttribute(\"tab-grouping\", \"true\");\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_finishGroupSelectedTabs\">\n        <parameter name=\"tab\"/>\n        <body><![CDATA[\n          if (!tab.groupingTabsData || tab.groupingTabsData.finished)\n            return;\n\n          tab.groupingTabsData.finished = true;\n\n          let selectedTabs = gBrowser.selectedTabs;\n          let tabIndex = selectedTabs.indexOf(tab);\n\n          // Moving left tabs\n          for (let i = tabIndex - 1; i > -1; i--) {\n            let movingTab = selectedTabs[i];\n            if (movingTab.groupingTabsData.newIndex) {\n              gBrowser.moveTabTo(movingTab, movingTab.groupingTabsData.newIndex);\n            }\n          }\n\n          // Moving right tabs\n          for (let i = tabIndex + 1; i < selectedTabs.length; i++) {\n            let movingTab = selectedTabs[i];\n            if (movingTab.groupingTabsData.newIndex) {\n              gBrowser.moveTabTo(movingTab, movingTab.groupingTabsData.newIndex);\n            }\n          }\n\n          for (let t of this._getVisibleTabs()) {\n            t.style.transform = \"\";\n            t.removeAttribute(\"tab-grouping\");\n            delete t.groupingTabsData;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_isGroupTabsAnimationOver\">\n        <body><![CDATA[\n          for (let tab of gBrowser.selectedTabs) {\n            if (tab.groupingTabsData && tab.groupingTabsData.animate)\n              return false;\n          }\n          return true;\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.type) {\n            case \"resize\":\n              if (aEvent.target != window)\n                break;\n\n              this._updateCloseButtons();\n              this._handleTabSelect(true);\n              break;\n            case \"mouseout\":\n              // If the \"related target\" (the node to which the pointer went) is not\n              // a child of the current document, the mouse just left the window.\n              let relatedTarget = aEvent.relatedTarget;\n              if (relatedTarget && relatedTarget.ownerDocument == document)\n                break;\n            case \"mousemove\":\n              if (document.getElementById(\"tabContextMenu\").state != \"open\")\n                this._unlockTabSizing();\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_animateElement\">\n        this.arrowScrollbox._scrollButtonDown;\n      </field>\n\n      <method name=\"_notifyBackgroundTab\">\n        <parameter name=\"aTab\"/>\n        <body><![CDATA[\n          if (aTab.pinned || aTab.hidden)\n            return;\n\n          var scrollRect = this.arrowScrollbox.scrollClientRect;\n          var tab = aTab.getBoundingClientRect();\n\n          // DOMRect left/right properties are immutable.\n          tab = {left: tab.left, right: tab.right};\n\n          // Is the new tab already completely visible?\n          if (scrollRect.left <= tab.left && tab.right <= scrollRect.right)\n            return;\n\n          if (this.arrowScrollbox.smoothScroll) {\n            let selectedTab = this.selectedItem;\n            let selected = !selectedTab.pinned &&\n                           selectedTab.getBoundingClientRect();\n\n            // Can we make both the new tab and the selected tab completely visible?\n            if (!selected ||\n                Math.max(tab.right - selected.left, selected.right - tab.left) <=\n                  scrollRect.width) {\n              this.arrowScrollbox.ensureElementIsVisible(aTab);\n              return;\n            }\n\n            this.arrowScrollbox.scrollByPixels(this.arrowScrollbox._isRTLScrollbox ?\n                                                 selected.right - scrollRect.right :\n                                                 selected.left - scrollRect.left);\n          }\n\n          if (!this._animateElement.hasAttribute(\"highlight\")) {\n            this._animateElement.setAttribute(\"highlight\", \"true\");\n            setTimeout(function(ele) {\n              ele.removeAttribute(\"highlight\");\n            }, 150, this._animateElement);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_getDragTargetTab\">\n        <parameter name=\"event\"/>\n        <parameter name=\"isLink\"/>\n        <body><![CDATA[\n          let tab = event.target.localName == \"tab\" ? event.target : null;\n          if (tab && isLink) {\n            let boxObject = tab.boxObject;\n            if (event.screenX < boxObject.screenX + boxObject.width * .25 ||\n                event.screenX > boxObject.screenX + boxObject.width * .75)\n              return null;\n          }\n          return tab;\n        ]]></body>\n      </method>\n\n      <method name=\"_getDropIndex\">\n        <parameter name=\"event\"/>\n        <parameter name=\"isLink\"/>\n        <body><![CDATA[\n          var tabs = this.children;\n          var tab = this._getDragTargetTab(event, isLink);\n          if (window.getComputedStyle(this).direction == \"ltr\") {\n            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)\n              if (event.screenX < tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)\n                return i;\n          } else {\n            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)\n              if (event.screenX > tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)\n                return i;\n          }\n          return tabs.length;\n        ]]></body>\n      </method>\n\n      <method name=\"_getDropEffectForTabDrag\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          var dt = event.dataTransfer;\n\n          let isMovingTabs = dt.mozItemCount > 0;\n          for (let i = 0; i < dt.mozItemCount; i++) {\n            // tabs are always added as the first type\n            let types = dt.mozTypesAt(0);\n            if (types[0] != TAB_DROP_TYPE) {\n              isMovingTabs = false;\n              break;\n            }\n          }\n\n          if (isMovingTabs) {\n            let sourceNode = dt.mozGetDataAt(TAB_DROP_TYPE, 0);\n            if (sourceNode instanceof XULElement &&\n                sourceNode.localName == \"tab\" &&\n                sourceNode.ownerGlobal.isChromeWindow &&\n                sourceNode.ownerDocument.documentElement.getAttribute(\"windowtype\") == \"navigator:browser\" &&\n                sourceNode.ownerGlobal.gBrowser.tabContainer == sourceNode.parentNode) {\n              // Do not allow transfering a private tab to a non-private window\n              // and vice versa.\n              if (PrivateBrowsingUtils.isWindowPrivate(window) !=\n                  PrivateBrowsingUtils.isWindowPrivate(sourceNode.ownerGlobal))\n                return \"none\";\n\n              if (window.gMultiProcessBrowser !=\n                  sourceNode.ownerGlobal.gMultiProcessBrowser)\n                return \"none\";\n\n              return dt.dropEffect == \"copy\" ? \"copy\" : \"move\";\n            }\n          }\n\n          if (browserDragAndDrop.canDropLink(event)) {\n            return \"link\";\n          }\n          return \"none\";\n        ]]></body>\n      </method>\n\n      <method name=\"_handleNewTab\">\n        <parameter name=\"tab\"/>\n        <body><![CDATA[\n          if (tab.parentNode != this) {\n            return;\n          }\n          tab._fullyOpen = true;\n          gBrowser.tabAnimationsInProgress--;\n\n          this._updateCloseButtons();\n\n          if (tab.getAttribute(\"selected\") == \"true\") {\n            this._handleTabSelect();\n          } else if (!tab.hasAttribute(\"skipbackgroundnotify\")) {\n            this._notifyBackgroundTab(tab);\n          }\n\n          // XXXmano: this is a temporary workaround for bug 345399\n          // We need to manually update the scroll buttons disabled state\n          // if a tab was inserted to the overflow area or removed from it\n          // without any scrolling and when the tabbar has already\n          // overflowed.\n          this.arrowScrollbox._updateScrollButtonsDisabledState();\n\n          // Preload the next about:newtab if there isn't one already.\n          gBrowser._createPreloadBrowser();\n        ]]></body>\n      </method>\n\n      <method name=\"_canAdvanceToTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          return !aTab.closing;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getRelatedElement\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          if (!aTab) {\n            return null;\n          }\n\n          // Cannot access gBrowser before it's initialized.\n          if (!gBrowser) {\n            return this.tabbox.tabpanels.firstElementChild;\n          }\n\n          // If the tab's browser is lazy, we need to `_insertBrowser` in order\n          // to have a linkedPanel.  This will also serve to bind the browser\n          // and make it ready to use when the tab is selected.\n          gBrowser._insertBrowser(aTab);\n          return document.getElementById(aTab.linkedPanel);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_updateNewTabVisibility\">\n        <body><![CDATA[\n          // Helper functions to help deal with customize mode wrapping some items\n          let wrap = n => n.parentNode.localName == \"toolbarpaletteitem\" ? n.parentNode : n;\n          let unwrap = n => n && n.localName == \"toolbarpaletteitem\" ? n.firstElementChild : n;\n\n          // Starting from the tabs element, find the next sibling that:\n          // - isn't hidden; and\n          // - isn't one of the titlebar placeholder elements; and\n          // - isn't the all-tabs button.\n          // If it's the new tab button, consider the new tab button adjacent to the tabs.\n          // If the new tab button is marked as adjacent and the tabstrip doesn't\n          // overflow, we'll display the 'new tab' button inline in the tabstrip.\n          // In all other cases, the separate new tab button is displayed in its\n          // customized location.\n          let sib = this;\n          do {\n            sib = unwrap(wrap(sib).nextElementSibling);\n          } while (sib && (sib.hidden ||\n                           sib.getAttribute(\"skipintoolbarset\") == \"true\" ||\n                           sib.id == \"alltabs-button\"));\n\n          const kAttr = \"hasadjacentnewtabbutton\";\n          if (sib && sib.id == \"new-tab-button\") {\n            this.setAttribute(kAttr, \"true\");\n          } else {\n            this.removeAttribute(kAttr);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onWidgetAfterDOMChange\">\n        <parameter name=\"aNode\"/>\n        <parameter name=\"aNextNode\"/>\n        <parameter name=\"aContainer\"/>\n        <body><![CDATA[\n          if (aContainer.ownerDocument == document &&\n              aContainer.id == \"TabsToolbar\") {\n            this._updateNewTabVisibility();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onAreaNodeRegistered\">\n        <parameter name=\"aArea\"/>\n        <parameter name=\"aContainer\"/>\n        <body><![CDATA[\n          if (aContainer.ownerDocument == document &&\n              aArea == \"TabsToolbar\") {\n            this._updateNewTabVisibility();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onAreaReset\">\n        <parameter name=\"aArea\"/>\n        <parameter name=\"aContainer\"/>\n        <body><![CDATA[\n          this.onAreaNodeRegistered(aArea, aContainer);\n        ]]></body>\n      </method>\n\n      <method name=\"_hiddenSoundPlayingStatusChanged\">\n        <parameter name=\"tab\"/>\n        <parameter name=\"opts\"/>\n        <body><![CDATA[\n          let closed = opts && opts.closed;\n          if (!closed && tab.soundPlaying && tab.hidden) {\n            this._hiddenSoundPlayingTabs.add(tab);\n            this.setAttribute(\"hiddensoundplaying\", \"true\");\n          } else {\n            this._hiddenSoundPlayingTabs.delete(tab);\n            if (this._hiddenSoundPlayingTabs.size == 0) {\n              this.removeAttribute(\"hiddensoundplaying\");\n            }\n          }\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"TabSelect\"><![CDATA[\n        this._handleTabSelect();\n      ]]></handler>\n\n      <handler event=\"TabClose\"><![CDATA[\n        this._hiddenSoundPlayingStatusChanged(event.target, {closed: true});\n      ]]></handler>\n\n      <handler event=\"TabAttrModified\"><![CDATA[\n        if (event.detail.changed.includes(\"soundplaying\") && event.target.hidden) {\n          this._hiddenSoundPlayingStatusChanged(event.target);\n        }\n      ]]></handler>\n\n      <handler event=\"TabHide\"><![CDATA[\n        if (event.target.soundPlaying) {\n          this._hiddenSoundPlayingStatusChanged(event.target);\n        }\n      ]]></handler>\n\n      <handler event=\"TabShow\"><![CDATA[\n        if (event.target.soundPlaying) {\n          this._hiddenSoundPlayingStatusChanged(event.target);\n        }\n      ]]></handler>\n\n      <handler event=\"transitionend\"><![CDATA[\n        if (event.propertyName != \"max-width\") {\n          return;\n        }\n\n        var tab = event.target;\n\n        if (tab.getAttribute(\"fadein\") == \"true\") {\n          if (tab._fullyOpen) {\n            this._updateCloseButtons();\n          } else {\n            this._handleNewTab(tab);\n          }\n        } else if (tab.closing) {\n          gBrowser._endRemoveTab(tab);\n        }\n      ]]></handler>\n\n      <handler event=\"dblclick\"><![CDATA[\n        // When the tabbar has an unified appearance with the titlebar\n        // and menubar, a double-click in it should have the same behavior\n        // as double-clicking the titlebar\n        if (TabsInTitlebar.enabled || this.parentNode._dragBindingAlive)\n          return;\n\n        if (event.button != 0 ||\n            event.originalTarget.localName != \"box\")\n          return;\n\n        if (!this._blockDblClick)\n          BrowserOpenTab();\n\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"click\" button=\"0\" phase=\"capturing\"><![CDATA[\n        /* Catches extra clicks meant for the in-tab close button.\n         * Placed here to avoid leaking (a temporary handler added from the\n         * in-tab close button binding would close over the tab and leak it\n         * until the handler itself was removed). (bug 897751)\n         *\n         * The only sequence in which a second click event (i.e. dblclik)\n         * can be dispatched on an in-tab close button is when it is shown\n         * after the first click (i.e. the first click event was dispatched\n         * on the tab). This happens when we show the close button only on\n         * the active tab. (bug 352021)\n         * The only sequence in which a third click event can be dispatched\n         * on an in-tab close button is when the tab was opened with a\n         * double click on the tabbar. (bug 378344)\n         * In both cases, it is most likely that the close button area has\n         * been accidentally clicked, therefore we do not close the tab.\n         *\n         * We don't want to ignore processing of more than one click event,\n         * though, since the user might actually be repeatedly clicking to\n         * close many tabs at once.\n         */\n        let target = event.originalTarget;\n        if (target.classList.contains(\"tab-close-button\")) {\n          // We preemptively set this to allow the closing-multiple-tabs-\n          // in-a-row case.\n          if (this._blockDblClick) {\n            target._ignoredCloseButtonClicks = true;\n          } else if (event.detail > 1 && !target._ignoredCloseButtonClicks) {\n            target._ignoredCloseButtonClicks = true;\n            event.stopPropagation();\n            return;\n          } else {\n            // Reset the \"ignored click\" flag\n            target._ignoredCloseButtonClicks = false;\n          }\n        }\n\n        /* Protects from close-tab-button errant doubleclick:\n         * Since we're removing the event target, if the user\n         * double-clicks the button, the dblclick event will be dispatched\n         * with the tabbar as its event target (and explicit/originalTarget),\n         * which treats that as a mouse gesture for opening a new tab.\n         * In this context, we're manually blocking the dblclick event.\n         */\n        if (this._blockDblClick) {\n          if (!(\"_clickedTabBarOnce\" in this)) {\n            this._clickedTabBarOnce = true;\n            return;\n          }\n          delete this._clickedTabBarOnce;\n          this._blockDblClick = false;\n        }\n      ]]></handler>\n\n      <handler event=\"click\"><![CDATA[\n        if (event.button != 1) {\n          return;\n        }\n\n        if (event.target.localName == \"tab\") {\n          gBrowser.removeTab(event.target, {\n            animate: true,\n            byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE,\n          });\n        } else if (event.originalTarget.localName == \"box\") {\n          // The user middleclicked an open space on the tabstrip. This could\n          // be because they intend to open a new tab, but it could also be\n          // because they just removed a tab and they now middleclicked on the\n          // resulting space while that tab is closing. In that case, we don't\n          // want to open a tab. So if we're removing one or more tabs, and\n          // the tab click is before the end of the last visible tab, we do\n          // nothing.\n          if (gBrowser._removingTabs.length) {\n            let visibleTabs = this._getVisibleTabs();\n            let ltr = (window.getComputedStyle(this).direction == \"ltr\");\n            let lastTab = visibleTabs[visibleTabs.length - 1];\n            let endOfTab = lastTab.getBoundingClientRect()[ltr ? \"right\" : \"left\"];\n            if ((ltr && event.clientX > endOfTab) ||\n                (!ltr && event.clientX < endOfTab)) {\n              BrowserOpenTab();\n            }\n          } else {\n            BrowserOpenTab();\n          }\n        } else {\n          return;\n        }\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"keydown\" group=\"system\"><![CDATA[\n        let {altKey, shiftKey} = event;\n        let [accel, nonAccel] = AppConstants.platform == \"macosx\" ? [event.metaKey, event.ctrlKey] : [event.ctrlKey, event.metaKey];\n\n        let keyComboForMove = accel && shiftKey && !altKey && !nonAccel;\n        let keyComboForFocus = accel && !shiftKey && !altKey && !nonAccel;\n\n        if (!keyComboForMove && !keyComboForFocus) {\n          return;\n        }\n\n        // Don't check if the event was already consumed because tab navigation\n        // should work always for better user experience.\n        let {visibleTabs, selectedTab} = gBrowser;\n        let {arrowKeysShouldWrap} = this;\n        let focusedTabIndex = this.ariaFocusedIndex;\n        if (focusedTabIndex == -1) {\n          focusedTabIndex = visibleTabs.indexOf(selectedTab);\n        }\n        let lastFocusedTabIndex = focusedTabIndex;\n        switch (event.keyCode) {\n          case KeyEvent.DOM_VK_UP:\n            if (keyComboForMove) {\n              gBrowser.moveTabBackward();\n            } else {\n              focusedTabIndex--;\n            }\n            break;\n          case KeyEvent.DOM_VK_DOWN:\n            if (keyComboForMove) {\n              gBrowser.moveTabForward();\n            } else {\n              focusedTabIndex++;\n            }\n            break;\n          case KeyEvent.DOM_VK_RIGHT:\n          case KeyEvent.DOM_VK_LEFT:\n            if (keyComboForMove) {\n              gBrowser.moveTabOver(event);\n            } else {\n              let isRTL = Services.locale.isAppLocaleRTL;\n              if ((!isRTL && event.keyCode == KeyEvent.DOM_VK_RIGHT) ||\n                  (isRTL && event.keyCode == KeyEvent.DOM_VK_LEFT)) {\n                focusedTabIndex++;\n              } else {\n                focusedTabIndex--;\n              }\n            }\n            break;\n          case KeyEvent.DOM_VK_HOME:\n            if (keyComboForMove) {\n              gBrowser.moveTabToStart();\n            } else {\n              focusedTabIndex = 0;\n            }\n            break;\n          case KeyEvent.DOM_VK_END:\n            if (keyComboForMove) {\n              gBrowser.moveTabToEnd();\n            } else {\n              focusedTabIndex = visibleTabs.length - 1;\n            }\n            break;\n          case KeyEvent.DOM_VK_SPACE:\n            if (visibleTabs[lastFocusedTabIndex].multiselected) {\n              gBrowser.removeFromMultiSelectedTabs(visibleTabs[lastFocusedTabIndex]);\n            } else {\n              gBrowser.addToMultiSelectedTabs(visibleTabs[lastFocusedTabIndex], false);\n            }\n            break;\n          default:\n            // Consume the keydown event for the above keyboard\n            // shortcuts only.\n            return;\n        }\n\n        if (arrowKeysShouldWrap) {\n          if (focusedTabIndex >= visibleTabs.length) {\n            focusedTabIndex = 0;\n          } else if (focusedTabIndex < 0) {\n            focusedTabIndex = visibleTabs.length - 1;\n          }\n        } else {\n          focusedTabIndex = Math.min(visibleTabs.length - 1, Math.max(0, focusedTabIndex));\n        }\n\n        if (keyComboForFocus &&\n            focusedTabIndex != lastFocusedTabIndex) {\n          this.ariaFocusedItem = visibleTabs[focusedTabIndex];\n        }\n\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        var tab = this._getDragTargetTab(event, false);\n        if (!tab || this._isCustomizing)\n          return;\n\n        let selectedTabs = gBrowser.selectedTabs;\n        let otherSelectedTabs = selectedTabs.filter(selectedTab => selectedTab != tab);\n        let dataTransferOrderedTabs = [tab].concat(otherSelectedTabs);\n\n        let dt = event.dataTransfer;\n        for (let i = 0; i < dataTransferOrderedTabs.length; i++) {\n          let dtTab = dataTransferOrderedTabs[i];\n\n          dt.mozSetDataAt(TAB_DROP_TYPE, dtTab, i);\n          let dtBrowser = dtTab.linkedBrowser;\n\n          // We must not set text/x-moz-url or text/plain data here,\n          // otherwise trying to detach the tab by dropping it on the desktop\n          // may result in an \"internet shortcut\"\n          dt.mozSetDataAt(\"text/x-moz-text-internal\", dtBrowser.currentURI.spec, i);\n        }\n\n        // Set the cursor to an arrow during tab drags.\n        dt.mozCursor = \"default\";\n\n        // Set the tab as the source of the drag, which ensures we have a stable\n        // node to deliver the `dragend` event.  See bug 1345473.\n        dt.addElement(tab);\n\n        if (tab.multiselected) {\n          this._groupSelectedTabs(tab);\n        }\n\n        // Create a canvas to which we capture the current tab.\n        // Until canvas is HiDPI-aware (bug 780362), we need to scale the desired\n        // canvas size (in CSS pixels) to the window's backing resolution in order\n        // to get a full-resolution drag image for use on HiDPI displays.\n        let windowUtils = window.windowUtils;\n        let scale = windowUtils.screenPixelsPerCSSPixel / windowUtils.fullZoom;\n        let canvas = this._dndCanvas;\n        if (!canvas) {\n          this._dndCanvas = canvas =\n            document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n          canvas.style.width = \"100%\";\n          canvas.style.height = \"100%\";\n          canvas.mozOpaque = true;\n        }\n\n        canvas.width = 160 * scale;\n        canvas.height = 90 * scale;\n        let toDrag = canvas;\n        let dragImageOffset = -16;\n        let browser = tab.linkedBrowser;\n        if (gMultiProcessBrowser) {\n          var context = canvas.getContext(\"2d\");\n          context.fillStyle = \"white\";\n          context.fillRect(0, 0, canvas.width, canvas.height);\n\n          let captureListener;\n          let platform = AppConstants.platform;\n          // On Windows and Mac we can update the drag image during a drag\n          // using updateDragImage. On Linux, we can use a panel.\n          if (platform == \"win\" || platform == \"macosx\") {\n            captureListener = function() {\n              dt.updateDragImage(canvas, dragImageOffset, dragImageOffset);\n            };\n          } else {\n            // Create a panel to use it in setDragImage\n            // which will tell xul to render a panel that follows\n            // the pointer while a dnd session is on.\n            if (!this._dndPanel) {\n              this._dndCanvas = canvas;\n              this._dndPanel = document.createXULElement(\"panel\");\n              this._dndPanel.className = \"dragfeedback-tab\";\n              this._dndPanel.setAttribute(\"type\", \"drag\");\n              let wrapper = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"div\");\n              wrapper.style.width = \"160px\";\n              wrapper.style.height = \"90px\";\n              wrapper.appendChild(canvas);\n              this._dndPanel.appendChild(wrapper);\n              document.documentElement.appendChild(this._dndPanel);\n            }\n            toDrag = this._dndPanel;\n          }\n          // PageThumb is async with e10s but that's fine\n          // since we can update the image during the dnd.\n          PageThumbs.captureToCanvas(browser, canvas, captureListener);\n        } else {\n          // For the non e10s case we can just use PageThumbs\n          // sync, so let's use the canvas for setDragImage.\n          PageThumbs.captureToCanvas(browser, canvas);\n          dragImageOffset = dragImageOffset * scale;\n        }\n        dt.setDragImage(toDrag, dragImageOffset, dragImageOffset);\n\n        // _dragData.offsetX/Y give the coordinates that the mouse should be\n        // positioned relative to the corner of the new window created upon\n        // dragend such that the mouse appears to have the same position\n        // relative to the corner of the dragged tab.\n        function clientX(ele) {\n          return ele.getBoundingClientRect().left;\n        }\n        let tabOffsetX = clientX(tab) - clientX(this);\n        tab._dragData = {\n          offsetX: event.screenX - window.screenX - tabOffsetX,\n          offsetY: event.screenY - window.screenY,\n          scrollX: this.arrowScrollbox._scrollbox.scrollLeft,\n          screenX: event.screenX,\n          movingTabs: (tab.multiselected ? gBrowser.selectedTabs : [tab])\n                      .filter(t => t.pinned == tab.pinned),\n        };\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        var effects = this._getDropEffectForTabDrag(event);\n\n        var ind = this._tabDropIndicator;\n        if (effects == \"\" || effects == \"none\") {\n          ind.collapsed = true;\n          return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n\n        var arrowScrollbox = this.arrowScrollbox;\n        var ltr = (window.getComputedStyle(this).direction == \"ltr\");\n\n        // autoscroll the tab strip if we drag over the scroll\n        // buttons, even if we aren't dragging a tab, but then\n        // return to avoid drawing the drop indicator\n        var pixelsToScroll = 0;\n        if (this.getAttribute(\"overflow\") == \"true\") {\n          var targetAnonid = event.originalTarget.getAttribute(\"anonid\");\n          switch (targetAnonid) {\n            case \"scrollbutton-up\":\n              pixelsToScroll = arrowScrollbox.scrollIncrement * -1;\n              break;\n            case \"scrollbutton-down\":\n              pixelsToScroll = arrowScrollbox.scrollIncrement;\n              break;\n          }\n          if (pixelsToScroll)\n            arrowScrollbox.scrollByPixels((ltr ? 1 : -1) * pixelsToScroll, true);\n        }\n\n        let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);\n        if ((effects == \"move\" || effects == \"copy\") &&\n            this == draggedTab.parentNode) {\n          ind.collapsed = true;\n\n          if (!this._isGroupTabsAnimationOver()) {\n            // Wait for grouping tabs animation to finish\n            return;\n          }\n          this._finishGroupSelectedTabs(draggedTab);\n\n          if (effects == \"move\") {\n            this._animateTabMove(event);\n            return;\n          }\n        }\n\n        this._finishAnimateTabMove();\n\n        if (effects == \"link\") {\n          let tab = this._getDragTargetTab(event, true);\n          if (tab) {\n            if (!this._dragTime)\n              this._dragTime = Date.now();\n            if (Date.now() >= this._dragTime + this._dragOverDelay)\n              this.selectedItem = tab;\n            ind.collapsed = true;\n            return;\n          }\n        }\n\n        var rect = arrowScrollbox.getBoundingClientRect();\n        var newMargin;\n        if (pixelsToScroll) {\n          // if we are scrolling, put the drop indicator at the edge\n          // so that it doesn't jump while scrolling\n          let scrollRect = arrowScrollbox.scrollClientRect;\n          let minMargin = scrollRect.left - rect.left;\n          let maxMargin = Math.min(minMargin + scrollRect.width,\n                                   scrollRect.right);\n          if (!ltr)\n            [minMargin, maxMargin] = [this.clientWidth - maxMargin,\n                                      this.clientWidth - minMargin];\n          newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;\n        } else {\n          let newIndex = this._getDropIndex(event, effects == \"link\");\n          if (newIndex == this.children.length) {\n            let tabRect = this.children[newIndex - 1].getBoundingClientRect();\n            if (ltr)\n              newMargin = tabRect.right - rect.left;\n            else\n              newMargin = rect.right - tabRect.left;\n          } else {\n            let tabRect = this.children[newIndex].getBoundingClientRect();\n            if (ltr)\n              newMargin = tabRect.left - rect.left;\n            else\n              newMargin = rect.right - tabRect.right;\n          }\n        }\n\n        ind.collapsed = false;\n\n        newMargin += ind.clientWidth / 2;\n        if (!ltr)\n          newMargin *= -1;\n\n        ind.style.transform = \"translate(\" + Math.round(newMargin) + \"px)\";\n        ind.style.marginInlineStart = (-ind.clientWidth) + \"px\";\n      ]]></handler>\n\n      <handler event=\"drop\"><![CDATA[\n        var dt = event.dataTransfer;\n        var dropEffect = dt.dropEffect;\n        var draggedTab;\n        let movingTabs;\n        if (dt.mozTypesAt(0)[0] == TAB_DROP_TYPE) { // tab copy or move\n          draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);\n          // not our drop then\n          if (!draggedTab)\n            return;\n          movingTabs = draggedTab._dragData.movingTabs;\n          draggedTab.parentNode._finishGroupSelectedTabs(draggedTab);\n        }\n\n        this._tabDropIndicator.collapsed = true;\n        event.stopPropagation();\n        if (draggedTab && dropEffect == \"copy\") {\n          // copy the dropped tab (wherever it's from)\n          let newIndex = this._getDropIndex(event, false);\n          let draggedTabCopy;\n          for (let tab of movingTabs) {\n            let newTab = gBrowser.duplicateTab(tab);\n            gBrowser.moveTabTo(newTab, newIndex++);\n            if (tab == draggedTab)\n              draggedTabCopy = newTab;\n          }\n          if (draggedTab.parentNode != this || event.shiftKey) {\n            this.selectedItem = draggedTabCopy;\n          }\n        } else if (draggedTab && draggedTab.parentNode == this) {\n          let oldTranslateX = Math.round(draggedTab._dragData.translateX);\n          let tabWidth = Math.round(draggedTab._dragData.tabWidth);\n          let translateOffset = oldTranslateX % tabWidth;\n          let newTranslateX = oldTranslateX - translateOffset;\n          if (oldTranslateX > 0 && translateOffset > tabWidth / 2) {\n            newTranslateX += tabWidth;\n          } else if (oldTranslateX < 0 && -translateOffset > tabWidth / 2) {\n            newTranslateX -= tabWidth;\n          }\n\n          let dropIndex = \"animDropIndex\" in draggedTab._dragData &&\n                          draggedTab._dragData.animDropIndex;\n          let incrementDropIndex = true;\n          if (dropIndex && dropIndex > movingTabs[0]._tPos) {\n            dropIndex--;\n            incrementDropIndex = false;\n          }\n\n          let animate = gBrowser.animationsEnabled;\n          if (oldTranslateX && oldTranslateX != newTranslateX && animate) {\n            for (let tab of movingTabs) {\n              tab.setAttribute(\"tabdrop-samewindow\", \"true\");\n              tab.style.transform = \"translateX(\" + newTranslateX + \"px)\";\n              let onTransitionEnd = transitionendEvent => {\n                if (transitionendEvent.propertyName != \"transform\" ||\n                    transitionendEvent.originalTarget != tab) {\n                  return;\n                }\n                tab.removeEventListener(\"transitionend\", onTransitionEnd);\n\n                tab.removeAttribute(\"tabdrop-samewindow\");\n\n                this._finishAnimateTabMove();\n                if (dropIndex !== false) {\n                  gBrowser.moveTabTo(tab, dropIndex);\n                  if (incrementDropIndex)\n                    dropIndex++;\n                }\n\n                gBrowser.syncThrobberAnimations(tab);\n              };\n              tab.addEventListener(\"transitionend\", onTransitionEnd);\n            }\n          } else {\n            this._finishAnimateTabMove();\n            if (dropIndex !== false) {\n              for (let tab of movingTabs) {\n                gBrowser.moveTabTo(tab, dropIndex);\n                if (incrementDropIndex)\n                  dropIndex++;\n              }\n            }\n          }\n        } else if (draggedTab) {\n          let newIndex = this._getDropIndex(event, false);\n          let newTabs = [];\n          for (let tab of movingTabs) {\n            let newTab = gBrowser.adoptTab(tab, newIndex++, tab == draggedTab);\n            newTabs.push(newTab);\n          }\n\n          // Restore tab selection\n          gBrowser.addRangeToMultiSelectedTabs(newTabs[0], newTabs[newTabs.length - 1]);\n        } else {\n          // Pass true to disallow dropping javascript: or data: urls\n          let links;\n          try {\n            links = browserDragAndDrop.dropLinks(event, true);\n          } catch (ex) {}\n\n          if (!links || links.length === 0)\n            return;\n\n          let inBackground = Services.prefs.getBoolPref(\"browser.tabs.loadInBackground\");\n          if (event.shiftKey)\n            inBackground = !inBackground;\n\n          let targetTab = this._getDragTargetTab(event, true);\n          let userContextId = this.selectedItem.getAttribute(\"usercontextid\");\n          let replace = !!targetTab;\n          let newIndex = this._getDropIndex(event, true);\n          let urls = links.map(link => link.url);\n\n          let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(event);\n\n          (async () => {\n            if (urls.length >= Services.prefs.getIntPref(\"browser.tabs.maxOpenBeforeWarn\")) {\n              // Sync dialog cannot be used inside drop event handler.\n              let answer = await OpenInTabsUtils.promiseConfirmOpenInTabs(urls.length,\n                                                                          window);\n              if (!answer) {\n                return;\n              }\n            }\n\n            gBrowser.loadTabs(urls, {\n              inBackground,\n              replace,\n              allowThirdPartyFixup: true,\n              targetTab,\n              newIndex,\n              userContextId,\n              triggeringPrincipal,\n            });\n          })();\n        }\n\n        if (draggedTab) {\n          delete draggedTab._dragData;\n        }\n      ]]></handler>\n\n      <handler event=\"dragend\"><![CDATA[\n        var dt = event.dataTransfer;\n        var draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);\n\n        // Prevent this code from running if a tabdrop animation is\n        // running since calling _finishAnimateTabMove would clear\n        // any CSS transition that is running.\n        if (draggedTab.hasAttribute(\"tabdrop-samewindow\"))\n          return;\n\n        this._finishGroupSelectedTabs(draggedTab);\n        this._finishAnimateTabMove();\n\n        if (dt.mozUserCancelled || dt.dropEffect != \"none\" || this._isCustomizing) {\n          delete draggedTab._dragData;\n          return;\n        }\n\n        // Disable detach within the browser toolbox\n        var eX = event.screenX;\n        var eY = event.screenY;\n        var wX = window.screenX;\n        // check if the drop point is horizontally within the window\n        if (eX > wX && eX < (wX + window.outerWidth)) {\n          // also avoid detaching if the the tab was dropped too close to\n          // the tabbar (half a tab)\n          let rect = window.windowUtils.getBoundsWithoutFlushing(this.arrowScrollbox);\n          let detachTabThresholdY = window.screenY + rect.top + 1.5 * rect.height;\n          if (eY < detachTabThresholdY && eY > window.screenY)\n            return;\n        }\n\n        // screen.availLeft et. al. only check the screen that this window is on,\n        // but we want to look at the screen the tab is being dropped onto.\n        var screen = Cc[\"@mozilla.org/gfx/screenmanager;1\"]\n                       .getService(Ci.nsIScreenManager)\n                       .screenForRect(eX, eY, 1, 1);\n        var fullX = {}, fullY = {}, fullWidth = {}, fullHeight = {};\n        var availX = {}, availY = {}, availWidth = {}, availHeight = {};\n        // get full screen rect and available rect, both in desktop pix\n        screen.GetRectDisplayPix(fullX, fullY, fullWidth, fullHeight);\n        screen.GetAvailRectDisplayPix(availX, availY, availWidth, availHeight);\n\n        // scale factor to convert desktop pixels to CSS px\n        var scaleFactor =\n          screen.contentsScaleFactor / screen.defaultCSSScaleFactor;\n        // synchronize CSS-px top-left coordinates with the screen's desktop-px\n        // coordinates, to ensure uniqueness across multiple screens\n        // (compare the equivalent adjustments in nsGlobalWindow::GetScreenXY()\n        // and related methods)\n        availX.value = (availX.value - fullX.value) * scaleFactor + fullX.value;\n        availY.value = (availY.value - fullY.value) * scaleFactor + fullY.value;\n        availWidth.value *= scaleFactor;\n        availHeight.value *= scaleFactor;\n\n        // ensure new window entirely within screen\n        var winWidth = Math.min(window.outerWidth, availWidth.value);\n        var winHeight = Math.min(window.outerHeight, availHeight.value);\n        var left = Math.min(Math.max(eX - draggedTab._dragData.offsetX, availX.value),\n                            availX.value + availWidth.value - winWidth);\n        var top = Math.min(Math.max(eY - draggedTab._dragData.offsetY, availY.value),\n                           availY.value + availHeight.value - winHeight);\n\n        delete draggedTab._dragData;\n\n        if (gBrowser.tabs.length == 1) {\n          // resize _before_ move to ensure the window fits the new screen.  if\n          // the window is too large for its screen, the window manager may do\n          // automatic repositioning.\n          window.resizeTo(winWidth, winHeight);\n          window.moveTo(left, top);\n          window.focus();\n        } else {\n          let props = { screenX: left, screenY: top, suppressanimation: 1 };\n          if (AppConstants.platform != \"win\") {\n            props.outerWidth = winWidth;\n            props.outerHeight = winHeight;\n          }\n          gBrowser.replaceTabsWithWindow(draggedTab, props);\n        }\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragexit\"><![CDATA[\n        this._dragTime = 0;\n\n        // This does not work at all (see bug 458613)\n        var target = event.relatedTarget;\n        while (target && target != this)\n          target = target.parentNode;\n        if (target)\n          return;\n\n        this._tabDropIndicator.collapsed = true;\n        event.stopPropagation();\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"tabbrowser-tab\" display=\"xul:hbox\"\n           extends=\"chrome://global/content/bindings/tabbox.xml#tab\">\n    <content context=\"tabContextMenu\">\n      <xul:stack class=\"tab-stack\" flex=\"1\">\n        <xul:vbox xbl:inherits=\"selected=visuallyselected,fadein\"\n                  class=\"tab-background\">\n          <xul:hbox xbl:inherits=\"selected=visuallyselected,multiselected,before-multiselected\"\n                    class=\"tab-line\"/>\n          <xul:spacer flex=\"1\"/>\n          <xul:hbox class=\"tab-bottom-line\"/>\n        </xul:vbox>\n        <xul:hbox xbl:inherits=\"pinned,bursting,notselectedsinceload\"\n                  anonid=\"tab-loading-burst\"\n                  class=\"tab-loading-burst\"/>\n        <xul:hbox xbl:inherits=\"pinned,selected=visuallyselected,titlechanged,attention\"\n                  class=\"tab-content\" align=\"center\">\n          <xul:hbox xbl:inherits=\"fadein,pinned,busy,progress,selected=visuallyselected\"\n                    anonid=\"tab-throbber\"\n                    class=\"tab-throbber\"\n                    layer=\"true\"/>\n          <xul:image xbl:inherits=\"fadein,pinned,busy,progress,selected=visuallyselected\"\n                     class=\"tab-throbber-fallback\"\n                     role=\"presentation\"\n                     layer=\"true\"/>\n          <xul:hbox xbl:inherits=\"fadein,pinned,busy,progress,selected=visuallyselected,pendingicon\"\n                    anonid=\"tab-icon-pending\"\n                    class=\"tab-icon-pending\"/>\n          <xul:image xbl:inherits=\"src=image,triggeringprincipal=iconloadingprincipal,requestcontextid,fadein,pinned,selected=visuallyselected,busy,crashed,sharing\"\n                     anonid=\"tab-icon-image\"\n                     class=\"tab-icon-image\"\n                     validate=\"never\"\n                     role=\"presentation\"/>\n          <xul:image xbl:inherits=\"sharing,selected=visuallyselected,pinned\"\n                     anonid=\"sharing-icon\"\n                     class=\"tab-sharing-icon-overlay\"\n                     role=\"presentation\"/>\n          <xul:image xbl:inherits=\"crashed,busy,soundplaying,soundplaying-scheduledremoval,pinned,muted,blocked,selected=visuallyselected,activemedia-blocked\"\n                     anonid=\"overlay-icon\"\n                     class=\"tab-icon-overlay\"\n                     role=\"presentation\"/>\n          <xul:hbox class=\"tab-label-container\"\n                    xbl:inherits=\"pinned,selected=visuallyselected,labeldirection\"\n                    onoverflow=\"this.setAttribute('textoverflow', 'true');\"\n                    onunderflow=\"this.removeAttribute('textoverflow');\"\n                    flex=\"1\">\n            <xul:label class=\"tab-text tab-label\" anonid=\"tab-label\"\n                       xbl:inherits=\"xbl:text=label,accesskey,fadein,pinned,selected=visuallyselected,attention\"\n                       role=\"presentation\"/>\n          </xul:hbox>\n          <xul:image xbl:inherits=\"soundplaying,soundplaying-scheduledremoval,pinned,muted,blocked,selected=visuallyselected,activemedia-blocked\"\n                     anonid=\"soundplaying-icon\"\n                     class=\"tab-icon-sound\"\n                     role=\"presentation\"/>\n          <xul:image anonid=\"close-button\"\n                     xbl:inherits=\"fadein,pinned,selected=visuallyselected\"\n                     class=\"tab-close-button close-icon\"\n                     role=\"presentation\"/>\n        </xul:hbox>\n      </xul:stack>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (!(\"_lastAccessed\" in this)) {\n          this.updateLastAccessed();\n        }\n      ]]></constructor>\n\n      <property name=\"_visuallySelected\">\n        <setter>\n          <![CDATA[\n          if (val == (this.getAttribute(\"visuallyselected\") == \"true\")) {\n            return val;\n          }\n\n          if (val) {\n            this.setAttribute(\"visuallyselected\", \"true\");\n          } else {\n            this.removeAttribute(\"visuallyselected\");\n          }\n          gBrowser._tabAttrModified(this, [\"visuallyselected\"]);\n\n          return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"_selected\">\n        <setter>\n          <![CDATA[\n          // in e10s we want to only pseudo-select a tab before its rendering is done, so that\n          // the rest of the system knows that the tab is selected, but we don't want to update its\n          // visual status to selected until after we receive confirmation that its content has painted.\n          if (val)\n            this.setAttribute(\"selected\", \"true\");\n          else\n            this.removeAttribute(\"selected\");\n\n          // If we're non-e10s we should update the visual selection as well at the same time,\n          // *or* if we're e10s and the visually selected tab isn't changing, in which case the\n          // tab switcher code won't run and update anything else (like the before- and after-\n          // selected attributes).\n          if (!gMultiProcessBrowser || (val && this.hasAttribute(\"visuallyselected\"))) {\n            this._visuallySelected = val;\n          }\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n      <field name=\"_selectedOnFirstMouseDown\">false</field>\n\n      <property name=\"pinned\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"pinned\") == \"true\";\n        </getter>\n      </property>\n      <property name=\"hidden\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"hidden\") == \"true\";\n        </getter>\n      </property>\n      <property name=\"muted\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"muted\") == \"true\";\n        </getter>\n      </property>\n      <property name=\"multiselected\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"multiselected\") == \"true\";\n        </getter>\n      </property>\n      <property name=\"beforeMultiselected\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"before-multiselected\") == \"true\";\n        </getter>\n      </property>\n      <!--\n      Describes how the tab ended up in this mute state. May be any of:\n\n       - undefined: The tabs mute state has never changed.\n       - null: The mute state was last changed through the UI.\n       - Any string: The ID was changed through an extension API. The string\n                     must be the ID of the extension which changed it.\n      -->\n      <field name=\"muteReason\">undefined</field>\n\n      <property name=\"userContextId\" readonly=\"true\">\n        <getter>\n          return this.hasAttribute(\"usercontextid\")\n                   ? parseInt(this.getAttribute(\"usercontextid\"))\n                   : 0;\n        </getter>\n      </property>\n\n      <property name=\"soundPlaying\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"soundplaying\") == \"true\";\n        </getter>\n      </property>\n\n      <property name=\"activeMediaBlocked\" readonly=\"true\">\n        <getter>\n          return this.getAttribute(\"activemedia-blocked\") == \"true\";\n        </getter>\n      </property>\n\n      <property name=\"lastAccessed\">\n        <getter>\n          return this._lastAccessed == Infinity ? Date.now() : this._lastAccessed;\n        </getter>\n      </property>\n      <method name=\"updateLastAccessed\">\n        <parameter name=\"aDate\"/>\n        <body><![CDATA[\n          this._lastAccessed = this.selected ? Infinity : (aDate || Date.now());\n        ]]></body>\n      </method>\n\n      <field name=\"mOverCloseButton\">false</field>\n      <property name=\"_overPlayingIcon\" readonly=\"true\">\n        <getter><![CDATA[\n          let iconVisible = this.hasAttribute(\"soundplaying\") ||\n                            this.hasAttribute(\"muted\") ||\n                            this.hasAttribute(\"activemedia-blocked\");\n          let soundPlayingIcon =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"soundplaying-icon\");\n          let overlayIcon =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"overlay-icon\");\n\n          return soundPlayingIcon && soundPlayingIcon.matches(\":hover\") ||\n                 (overlayIcon && overlayIcon.matches(\":hover\") && iconVisible);\n        ]]></getter>\n      </property>\n      <field name=\"mCorrespondingMenuitem\">null</field>\n\n      <!--\n      While it would make sense to track this in a field, the field will get nuked\n      once the node is gone from the DOM, which causes us to think the tab is not\n      closed, which causes us to make wrong decisions. So we use an expando instead.\n      <field name=\"closing\">false</field>\n      -->\n\n      <method name=\"_mouseenter\">\n        <body><![CDATA[\n          if (this.hidden || this.closing) {\n            return;\n          }\n\n          let tabContainer = this.parentNode;\n          let visibleTabs = tabContainer._getVisibleTabs();\n          let tabIndex = visibleTabs.indexOf(this);\n\n          if (this.selected)\n            tabContainer._handleTabSelect();\n\n          if (tabIndex == 0) {\n            tabContainer._beforeHoveredTab = null;\n          } else {\n            let candidate = visibleTabs[tabIndex - 1];\n            let separatedByScrollButton =\n              tabContainer.getAttribute(\"overflow\") == \"true\" &&\n              candidate.pinned && !this.pinned;\n            if (!candidate.selected && !separatedByScrollButton) {\n              tabContainer._beforeHoveredTab = candidate;\n              candidate.setAttribute(\"beforehovered\", \"true\");\n            }\n          }\n\n          if (tabIndex == visibleTabs.length - 1) {\n            tabContainer._afterHoveredTab = null;\n          } else {\n            let candidate = visibleTabs[tabIndex + 1];\n            if (!candidate.selected) {\n              tabContainer._afterHoveredTab = candidate;\n              candidate.setAttribute(\"afterhovered\", \"true\");\n            }\n          }\n\n          tabContainer._hoveredTab = this;\n          if (this.linkedPanel && !this.selected) {\n            this.linkedBrowser.unselectedTabHover(true);\n            this.startUnselectedTabHoverTimer();\n          }\n\n          // Prepare connection to host beforehand.\n          SessionStore.speculativeConnectOnTabHover(this);\n\n          let tabToWarm = this;\n          if (this.mOverCloseButton) {\n            tabToWarm = gBrowser._findTabToBlurTo(this);\n          }\n          gBrowser.warmupTab(tabToWarm);\n        ]]></body>\n      </method>\n\n      <method name=\"_mouseleave\">\n        <body><![CDATA[\n          let tabContainer = this.parentNode;\n          if (tabContainer._beforeHoveredTab) {\n            tabContainer._beforeHoveredTab.removeAttribute(\"beforehovered\");\n            tabContainer._beforeHoveredTab = null;\n          }\n          if (tabContainer._afterHoveredTab) {\n            tabContainer._afterHoveredTab.removeAttribute(\"afterhovered\");\n            tabContainer._afterHoveredTab = null;\n          }\n\n          tabContainer._hoveredTab = null;\n          if (this.linkedPanel && !this.selected) {\n            this.linkedBrowser.unselectedTabHover(false);\n            this.cancelUnselectedTabHoverTimer();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"startUnselectedTabHoverTimer\">\n        <body><![CDATA[\n          // Only record data when we need to.\n          if (!this.linkedBrowser.shouldHandleUnselectedTabHover) {\n            return;\n          }\n\n          if (!TelemetryStopwatch.running(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this)) {\n            TelemetryStopwatch.start(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this);\n          }\n\n          if (this._hoverTabTimer) {\n            clearTimeout(this._hoverTabTimer);\n            this._hoverTabTimer = null;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"cancelUnselectedTabHoverTimer\">\n        <body><![CDATA[\n          // Since we're listening \"mouseout\" event, instead of \"mouseleave\".\n          // Every time the cursor is moving from the tab to its child node (icon),\n          // it would dispatch \"mouseout\"(for tab) first and then dispatch\n          // \"mouseover\" (for icon, eg: close button, speaker icon) soon.\n          // It causes we would cancel present TelemetryStopwatch immediately\n          // when cursor is moving on the icon, and then start a new one.\n          // In order to avoid this situation, we could delay cancellation and\n          // remove it if we get \"mouseover\" within very short period.\n          this._hoverTabTimer = setTimeout(() => {\n            if (TelemetryStopwatch.running(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this)) {\n              TelemetryStopwatch.cancel(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this);\n            }\n          }, 100);\n        ]]></body>\n      </method>\n\n      <method name=\"finishUnselectedTabHoverTimer\">\n        <body><![CDATA[\n          // Stop timer when the tab is opened.\n          if (TelemetryStopwatch.running(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this)) {\n            TelemetryStopwatch.finish(\"HOVER_UNTIL_UNSELECTED_TAB_OPENED\", this);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"startMediaBlockTimer\">\n        <body><![CDATA[\n          TelemetryStopwatch.start(\"TAB_MEDIA_BLOCKING_TIME_MS\", this);\n        ]]></body>\n      </method>\n\n       <method name=\"finishMediaBlockTimer\">\n        <body><![CDATA[\n          TelemetryStopwatch.finish(\"TAB_MEDIA_BLOCKING_TIME_MS\", this);\n        ]]></body>\n      </method>\n\n      <method name=\"toggleMuteAudio\">\n        <parameter name=\"aMuteReason\"/>\n        <body>\n        <![CDATA[\n          let browser = this.linkedBrowser;\n          let modifiedAttrs = [];\n          let hist = Services.telemetry.getHistogramById(\"TAB_AUDIO_INDICATOR_USED\");\n\n          if (this.hasAttribute(\"activemedia-blocked\")) {\n            this.removeAttribute(\"activemedia-blocked\");\n            modifiedAttrs.push(\"activemedia-blocked\");\n\n            browser.resumeMedia();\n            hist.add(3 /* unblockByClickingIcon */);\n            this.finishMediaBlockTimer();\n          } else {\n            if (browser.audioMuted) {\n              if (this.linkedPanel) {\n                // \"Lazy Browser\" should not invoke its unmute method\n                browser.unmute();\n              }\n              this.removeAttribute(\"muted\");\n              hist.add(1 /* unmute */);\n            } else {\n              if (this.linkedPanel) {\n                // \"Lazy Browser\" should not invoke its mute method\n                browser.mute();\n              }\n              this.setAttribute(\"muted\", \"true\");\n              hist.add(0 /* mute */);\n            }\n            this.muteReason = aMuteReason || null;\n            modifiedAttrs.push(\"muted\");\n          }\n          gBrowser._tabAttrModified(this, modifiedAttrs);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setUserContextId\">\n        <parameter name=\"aUserContextId\"/>\n        <body>\n        <![CDATA[\n          if (aUserContextId) {\n            if (this.linkedBrowser) {\n              this.linkedBrowser.setAttribute(\"usercontextid\", aUserContextId);\n            }\n            this.setAttribute(\"usercontextid\", aUserContextId);\n          } else {\n            if (this.linkedBrowser) {\n              this.linkedBrowser.removeAttribute(\"usercontextid\");\n            }\n            this.removeAttribute(\"usercontextid\");\n          }\n\n          ContextualIdentityService.setTabStyle(this);\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"mouseover\"><![CDATA[\n        if (event.originalTarget.getAttribute(\"anonid\") == \"close-button\") {\n          this.mOverCloseButton = true;\n        }\n\n        this._mouseenter();\n      ]]></handler>\n      <handler event=\"mouseout\"><![CDATA[\n        if (event.originalTarget.getAttribute(\"anonid\") == \"close-button\") {\n          this.mOverCloseButton = false;\n        }\n\n        this._mouseleave();\n      ]]></handler>\n\n      <handler event=\"dragstart\" phase=\"capturing\">\n        this.style.MozUserFocus = \"\";\n      </handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        if (this.mOverCloseButton) {\n          event.stopPropagation();\n        }\n      ]]></handler>\n\n      <handler event=\"mousedown\" phase=\"capturing\">\n      <![CDATA[\n        if (event.button == 0 && !this.selected && this.multiselected) {\n          gBrowser.lockClearMultiSelectionOnce();\n        }\n\n        let tabContainer = this.parentNode;\n        if (tabContainer._closeTabByDblclick &&\n            event.button == 0 &&\n            event.detail == 1) {\n          this._selectedOnFirstMouseDown = this.selected;\n        }\n\n        if (this.selected) {\n          this.style.MozUserFocus = \"ignore\";\n        } else {\n          // When browser.tabs.multiselect config is set to false,\n          // then we ignore the state of multi-selection keys (Ctrl/Cmd).\n          const tabSelectionToggled = tabContainer._multiselectEnabled &&\n            (event.getModifierState(\"Accel\") || event.shiftKey);\n\n          if (this.mOverCloseButton || this._overPlayingIcon || tabSelectionToggled) {\n            // Prevent tabbox.xml from selecting the tab.\n            event.stopPropagation();\n          }\n        }\n\n        if (event.button == 1) {\n          gBrowser.warmupTab(gBrowser._findTabToBlurTo(this));\n        }\n      ]]>\n      </handler>\n      <handler event=\"mouseup\">\n        // Make sure that clear-selection is released.\n        // Otherwise selection using Shift key may be broken.\n        gBrowser.unlockClearMultiSelection();\n\n        this.style.MozUserFocus = \"\";\n      </handler>\n\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        let tabContainer = this.parentNode;\n        if (tabContainer._multiselectEnabled) {\n          let shiftKey = event.shiftKey;\n          let accelKey = event.getModifierState(\"Accel\");\n          if (shiftKey) {\n            const lastSelectedTab = gBrowser.lastMultiSelectedTab;\n            if (!accelKey) {\n              gBrowser.selectedTab = lastSelectedTab;\n\n              // Make sure selection is cleared when tab-switch doesn't happen.\n              gBrowser.clearMultiSelectedTabs(false);\n            }\n            gBrowser.addRangeToMultiSelectedTabs(lastSelectedTab, this);\n            return;\n          }\n          if (accelKey) {\n            // Ctrl (Cmd for mac) key is pressed\n            if (this.multiselected) {\n              gBrowser.removeFromMultiSelectedTabs(this, true);\n            } else if (this != gBrowser.selectedTab) {\n              gBrowser.addToMultiSelectedTabs(this, false);\n              gBrowser.lastMultiSelectedTab = this;\n            }\n            return;\n          }\n\n          const overCloseButton = event.originalTarget.getAttribute(\"anonid\") == \"close-button\";\n          if (gBrowser.multiSelectedTabsCount > 0 && !overCloseButton && !this._overPlayingIcon) {\n            // Tabs were previously multi-selected and user clicks on a tab\n            // without holding Ctrl/Cmd Key\n\n            // Force positional attributes to update when the\n            // target (of the click) is the \"active\" tab.\n            let updatePositionalAttr = gBrowser.selectedTab == this;\n\n            gBrowser.clearMultiSelectedTabs(updatePositionalAttr);\n          }\n        }\n\n        if (this._overPlayingIcon) {\n          if (this.multiselected) {\n            gBrowser.toggleMuteAudioOnMultiSelectedTabs(this);\n          } else {\n            this.toggleMuteAudio();\n          }\n          return;\n        }\n\n        if (event.originalTarget.getAttribute(\"anonid\") == \"close-button\") {\n          if (this.multiselected) {\n            gBrowser.removeMultiSelectedTabs();\n          } else {\n            gBrowser.removeTab(this, {\n              animate: true,\n              byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE,\n            });\n          }\n          // This enables double-click protection for the tab container\n          // (see tabbrowser-tabs 'click' handler).\n          gBrowser.tabContainer._blockDblClick = true;\n        }\n      ]]></handler>\n\n      <handler event=\"dblclick\" button=\"0\" phase=\"capturing\"><![CDATA[\n        // for the one-close-button case\n        if (event.originalTarget.getAttribute(\"anonid\") == \"close-button\") {\n          event.stopPropagation();\n        }\n\n        let tabContainer = this.parentNode;\n        if (tabContainer._closeTabByDblclick &&\n            this._selectedOnFirstMouseDown &&\n            this.selected &&\n            !this._overPlayingIcon) {\n          gBrowser.removeTab(this, {\n            animate: true,\n            byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE,\n          });\n        }\n      ]]></handler>\n\n      <handler event=\"animationend\">\n      <![CDATA[\n        if (event.originalTarget.getAttribute(\"anonid\") == \"tab-loading-burst\") {\n          this.removeAttribute(\"bursting\");\n        }\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"urlbarBindings.xml","body":"<?xml version=\"1.0\"?>\n\n<!--\n-*- Mode: HTML -*-\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n-->\n\n<!DOCTYPE bindings [\n<!ENTITY % notificationDTD SYSTEM \"chrome://global/locale/notification.dtd\">\n%notificationDTD;\n<!ENTITY % browserDTD SYSTEM \"chrome://browser/locale/browser.dtd\">\n%browserDTD;\n<!ENTITY % brandDTD SYSTEM \"chrome://branding/locale/brand.dtd\">\n%brandDTD;\n]>\n\n<bindings id=\"urlbarBindings\" xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"urlbar\" extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content sizetopopup=\"pref\">\n      <xul:hbox flex=\"1\" class=\"urlbar-textbox-container\" tooltip=\"aHTMLTooltip\">\n        <children includes=\"image|deck|stack|box\"/>\n        <xul:moz-input-box anonid=\"moz-input-box\"\n                  class=\"urlbar-input-box\"\n                  flex=\"1\">\n          <children/>\n          <html:input anonid=\"scheme\"\n                      class=\"urlbar-scheme textbox-input\"\n                      required=\"required\"\n                      xbl:inherits=\"textoverflow,focused\"/>\n          <html:input anonid=\"input\"\n                      class=\"urlbar-input textbox-input\"\n                      allowevents=\"true\"\n                      inputmode=\"mozAwesomebar\"\n                      xbl:inherits=\"value,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,focused,textoverflow\"/>\n        </xul:moz-input-box>\n        <xul:image anonid=\"urlbar-go-button\"\n                   class=\"urlbar-go-button urlbar-icon\"\n                   onclick=\"gURLBar.handleCommand(event);\"\n                   tooltiptext=\"FROM-DTD.goEndCap.tooltip;\"\n                   xbl:inherits=\"pageproxystate,parentfocused=focused,usertyping\"/>\n        <xul:dropmarker anonid=\"historydropmarker\"\n                        class=\"urlbar-history-dropmarker urlbar-icon chromeclass-toolbar-additional\"\n                        tooltiptext=\"FROM-DTD.urlbar.openHistoryPopup.tooltip;\"\n                        allowevents=\"true\"\n                        xbl:inherits=\"open,parentfocused=focused,usertyping\"/>\n        <children includes=\"hbox\"/>\n      </xul:hbox>\n      <xul:popupset anonid=\"popupset\"\n                    class=\"autocomplete-result-popupset\"/>\n      <children includes=\"toolbarbutton\"/>\n    </content>\n  </binding>\n\n  <binding id=\"legacy-urlbar\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete\">\n\n    <content sizetopopup=\"pref\">\n      <xul:hbox flex=\"1\" class=\"urlbar-textbox-container\" tooltip=\"aHTMLTooltip\">\n        <children includes=\"image|deck|stack|box\"/>\n        <xul:moz-input-box anonid=\"moz-input-box\"\n                  class=\"urlbar-input-box\"\n                  flex=\"1\">\n          <children/>\n          <html:input anonid=\"scheme\"\n                      class=\"urlbar-scheme textbox-input\"\n                      required=\"required\"\n                      xbl:inherits=\"textoverflow,focused\"/>\n          <html:input anonid=\"input\"\n                      class=\"urlbar-input textbox-input\"\n                      allowevents=\"true\"\n                      inputmode=\"mozAwesomebar\"\n                      xbl:inherits=\"value,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,focused,textoverflow\"/>\n        </xul:moz-input-box>\n        <xul:image anonid=\"urlbar-go-button\"\n                   class=\"urlbar-go-button urlbar-icon\"\n                   onclick=\"gURLBar.handleCommand(event);\"\n                   tooltiptext=\"FROM-DTD.goEndCap.tooltip;\"\n                   xbl:inherits=\"pageproxystate,parentfocused=focused,usertyping\"/>\n        <xul:dropmarker anonid=\"historydropmarker\"\n                        class=\"urlbar-history-dropmarker urlbar-icon chromeclass-toolbar-additional\"\n                        tooltiptext=\"FROM-DTD.urlbar.openHistoryPopup.tooltip;\"\n                        allowevents=\"true\"\n                        xbl:inherits=\"open,parentfocused=focused,usertyping\"/>\n        <children includes=\"hbox\"/>\n      </xul:hbox>\n      <xul:popupset anonid=\"popupset\"\n                    class=\"autocomplete-result-popupset\"/>\n      <children includes=\"toolbarbutton\"/>\n    </content>\n\n    <implementation implements=\"nsIObserver\">\n      <field name=\"ExtensionSearchHandler\" readonly=\"true\">\n        (ChromeUtils.import(\"resource://gre/modules/ExtensionSearchHandler.jsm\", {})).ExtensionSearchHandler;\n      </field>\n\n      <constructor><![CDATA[\n        // UrlbarInput compatibility shims\n        this.document = document;\n        this.window = window;\n        this.textbox = this;\n\n        this._prefs = Cc[\"@mozilla.org/preferences-service;1\"]\n                        .getService(Ci.nsIPrefService)\n                        .getBranch(\"browser.urlbar.\");\n        this._prefs.addObserver(\"\", this);\n\n        this._defaultPrefs = Cc[\"@mozilla.org/preferences-service;1\"]\n                               .getService(Ci.nsIPrefService)\n                               .getDefaultBranch(\"browser.urlbar.\");\n\n        Services.prefs.addObserver(\"browser.search.suggest.enabled\", this);\n        this.browserSearchSuggestEnabled = Services.prefs.getBoolPref(\"browser.search.suggest.enabled\");\n\n        this.openInTab = this._prefs.getBoolPref(\"openintab\");\n        this.clickSelectsAll = this._prefs.getBoolPref(\"clickSelectsAll\");\n        this.doubleClickSelectsAll = this._prefs.getBoolPref(\"doubleClickSelectsAll\");\n        this.completeDefaultIndex = this._prefs.getBoolPref(\"autoFill\");\n        this.speculativeConnectEnabled = this._prefs.getBoolPref(\"speculativeConnect.enabled\");\n        this.urlbarSearchSuggestEnabled = this._prefs.getBoolPref(\"suggest.searches\");\n        this.timeout = this._prefs.getIntPref(\"delay\");\n        this._mayTrimURLs = this._prefs.getBoolPref(\"trimURLs\");\n        this._adoptIntoActiveWindow = this._prefs.getBoolPref(\"switchTabs.adoptIntoActiveWindow\");\n        this._ctrlCanonizesURLs = this._prefs.getBoolPref(\"ctrlCanonizesURLs\");\n        this.inputField.controllers.insertControllerAt(0, this._copyCutController);\n        this.inputField.addEventListener(\"paste\", this);\n        this.inputField.addEventListener(\"mousedown\", this);\n        this.inputField.addEventListener(\"mousemove\", this);\n        this.inputField.addEventListener(\"mouseout\", this);\n        this.inputField.addEventListener(\"overflow\", this);\n        this.inputField.addEventListener(\"underflow\", this);\n        this.inputField.addEventListener(\"scrollend\", this);\n        window.addEventListener(\"resize\", this);\n\n        var textBox = document.getAnonymousElementByAttribute(this,\n                                                \"anonid\", \"moz-input-box\");\n        // Force the Custom Element to upgrade until Bug 1470242 handles this:\n        customElements.upgrade(textBox);\n        var cxmenu = textBox.menupopup;\n        var pasteAndGo;\n        cxmenu.addEventListener(\"popupshowing\", function() {\n          if (!pasteAndGo)\n            return;\n          var controller = document.commandDispatcher.getControllerForCommand(\"cmd_paste\");\n          var enabled = controller.isCommandEnabled(\"cmd_paste\");\n          if (enabled)\n            pasteAndGo.removeAttribute(\"disabled\");\n          else\n            pasteAndGo.setAttribute(\"disabled\", \"true\");\n        });\n\n        var insertLocation = cxmenu.firstElementChild;\n        while (insertLocation.nextElementSibling &&\n               insertLocation.getAttribute(\"cmd\") != \"cmd_paste\")\n          insertLocation = insertLocation.nextElementSibling;\n        if (insertLocation) {\n          pasteAndGo = document.createXULElement(\"menuitem\");\n          let label = Services.strings.createBundle(\"chrome://browser/locale/browser.properties\").\n                                   GetStringFromName(\"pasteAndGo.label\");\n          pasteAndGo.setAttribute(\"label\", label);\n          pasteAndGo.setAttribute(\"anonid\", \"paste-and-go\");\n          pasteAndGo.setAttribute(\"oncommand\",\n              \"gURLBar.select(); goDoCommand('cmd_paste'); gURLBar.handleCommand();\");\n          cxmenu.insertBefore(pasteAndGo, insertLocation.nextElementSibling);\n        }\n\n        this.popup.addEventListener(\"popupshowing\", () => {\n          this._enableOrDisableOneOffSearches();\n        }, {capture: true, once: true});\n\n        // history dropmarker open state\n        this.popup.addEventListener(\"popupshowing\", () => {\n          this.setAttribute(\"open\", \"true\");\n        });\n        this.popup.addEventListener(\"popuphidden\", () => {\n          requestAnimationFrame(() => {\n            this.removeAttribute(\"open\");\n          });\n        });\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // Somehow, it's possible for the XBL destructor to fire without the\n        // constructor ever having fired. Fix:\n        if (!this._prefs) {\n          return;\n        }\n        this._prefs.removeObserver(\"\", this);\n        this._prefs = null;\n        Services.prefs.removeObserver(\"browser.search.suggest.enabled\", this);\n        this.inputField.controllers.removeController(this._copyCutController);\n        this.inputField.removeEventListener(\"paste\", this);\n        this.inputField.removeEventListener(\"mousedown\", this);\n        this.inputField.removeEventListener(\"mousemove\", this);\n        this.inputField.removeEventListener(\"mouseout\", this);\n        this.inputField.removeEventListener(\"overflow\", this);\n        this.inputField.removeEventListener(\"underflow\", this);\n        this.inputField.removeEventListener(\"scrollend\", this);\n        window.removeEventListener(\"resize\", this);\n\n        if (this._deferredKeyEventTimeout) {\n          clearTimeout(this._deferredKeyEventTimeout);\n          this._deferredKeyEventTimeout = null;\n        }\n\n        // Null out the one-offs' popup and textbox so that it cleans up its\n        // internal state for both.  Most importantly, it removes the event\n        // listeners that it added to both.\n        this.popup.oneOffSearchButtons.popup = null;\n        this.popup.oneOffSearchButtons.textbox = null;\n      ]]></destructor>\n\n      <field name=\"valueFormatter\" readonly=\"true\">\n        new UrlbarValueFormatter(this);\n      </field>\n\n      <field name=\"goButton\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"urlbar-go-button\");\n      </field>\n\n      <field name=\"_value\">\"\"</field>\n      <field name=\"gotResultForCurrentQuery\">false</field>\n\n      <!--\n        This is set around HandleHenter so it can be used in handleCommand.\n        It is also used to track whether we must handle a delayed handleEnter,\n        by checking if it has been cleared.\n      -->\n      <field name=\"handleEnterInstance\">null</field>\n\n      <!--\n        Since we never want scrollbars, we always use the maxResults value.\n      -->\n      <property name=\"maxRows\"\n                onget=\"return this.popup.maxResults;\"/>\n\n      <!--\n        Set by focusAndSelectUrlBar to indicate whether the next focus event was\n        initiated by an explicit user action. See the \"focus\" handler below.\n      -->\n      <field name=\"userInitiatedFocus\">false</field>\n\n      <!--\n        onBeforeValueGet is called by the base-binding's .value getter.\n        It can return an object with a \"value\" property, to override the\n        return value of the getter.\n      -->\n      <method name=\"onBeforeValueGet\">\n        <body><![CDATA[\n          return { value: this._value };\n        ]]></body>\n      </method>\n\n      <!--\n        onBeforeValueSet is called by the base-binding's .value setter.\n        It should return the value that the setter should use.\n      -->\n      <method name=\"onBeforeValueSet\">\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          this._value = aValue;\n          var returnValue = aValue;\n          var action = this._parseActionUrl(aValue);\n\n          if (action) {\n            switch (action.type) {\n              case \"switchtab\": // Fall through.\n              case \"remotetab\": // Fall through.\n              case \"visiturl\": {\n                returnValue = action.params.displayUrl;\n                break;\n              }\n              case \"keyword\": // Fall through.\n              case \"searchengine\": {\n                returnValue = action.params.input;\n                break;\n              }\n              case \"extension\": {\n                returnValue = action.params.content;\n                break;\n              }\n            }\n          } else {\n            let originalUrl = ReaderMode.getOriginalUrlObjectForDisplay(aValue);\n            if (originalUrl) {\n              returnValue = originalUrl.displaySpec;\n            }\n          }\n\n          // Set the actiontype only if the user is not overriding actions.\n          if (action && this._pressedNoActionKeys.size == 0) {\n            this.setAttribute(\"actiontype\", action.type);\n          } else {\n            this.removeAttribute(\"actiontype\");\n          }\n          return returnValue;\n        ]]></body>\n      </method>\n\n      <method name=\"onKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aNoDefer\"/>\n        <body><![CDATA[\n          switch (aEvent.keyCode) {\n            case KeyEvent.DOM_VK_LEFT:\n            case KeyEvent.DOM_VK_RIGHT:\n            case KeyEvent.DOM_VK_HOME:\n              // Reset the selected index so that nsAutoCompleteController\n              // simply closes the popup without trying to fill anything.\n              this.popup.selectedIndex = -1;\n              break;\n            case KeyEvent.DOM_VK_TAB:\n              this.userSelectionBehavior = \"tab\";\n              // The user is explicitly making a selection, so the popup\n              // should get accessibility focus.\n              this.popup.richlistbox.suppressMenuItemEvent = false;\n              break;\n            case KeyEvent.DOM_VK_UP:\n            case KeyEvent.DOM_VK_DOWN:\n            case KeyEvent.DOM_VK_PAGE_UP:\n            case KeyEvent.DOM_VK_PAGE_DOWN:\n              if (this.userSelectionBehavior != \"tab\")\n                this.userSelectionBehavior = \"arrow\";\n              // The user is explicitly making a selection, so the popup\n              // should get accessibility focus.\n              this.popup.richlistbox.suppressMenuItemEvent = false;\n              break;\n          }\n          if (!this.popup.disableKeyNavigation) {\n            if (!aNoDefer && this._shouldDeferKeyEvent(aEvent)) {\n              this._deferKeyEvent(aEvent, \"onKeyPress\");\n              return false;\n            }\n            if (this.popup.popupOpen && this.popup.handleKeyPress(aEvent)) {\n              return true;\n            }\n          }\n          return this.handleKeyPress(aEvent);\n        ]]></body>\n      </method>\n\n      <!--\n        Search results arrive asynchronously, which means that keypresses may\n        arrive before results do and therefore not have the effect the user\n        intends.  That's especially likely to happen with the down arrow and\n        enter keys due to the one-off search buttons: if the user very quickly\n        pastes something in the input, presses the down arrow key, and then hits\n        enter, they are probably expecting to visit the first result.  But if\n        there are no results, then pressing down and enter will trigger the\n        first one-off button.  To prevent that undesirable behavior, certain\n        keys are buffered and deferred until more results arrive, at which time\n        they're replayed.\n\n        @param  event\n                The key event that should maybe be deferred.\n        @return True if the event should be deferred, false if not.\n       -->\n      <method name=\"_shouldDeferKeyEvent\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          // If any event has been deferred for this search, then defer all\n          // subsequent events so that the user does not experience any\n          // keypresses out of order.  All events will be replayed when\n          // _deferredKeyEventTimeout fires.\n          if (this._deferredKeyEventQueue.length) {\n            return true;\n          }\n\n          // At this point, no events have been deferred for this search, and we\n          // need to decide whether `event` is the first one that should be.\n          if (!this._keyCodesToDefer.has(event.keyCode) &&\n              !(/Mac/.test(navigator.platform) &&\n                event.ctrlKey &&\n                (event.key === \"n\" || event.key === \"p\") &&\n                this.popupOpen)) {\n\n            // Not a key that should trigger deferring.\n            return false;\n          }\n\n          let waitedLongEnough =\n            this._searchStartDate + this._deferredKeyEventTimeoutMs <= Cu.now();\n          if (waitedLongEnough) {\n            // This is a key that we would defer, but enough time has passed\n            // since the start of the search that we don't want to block the\n            // user's keypresses anymore.\n            return false;\n          }\n\n          if (event.keyCode == KeyEvent.DOM_VK_TAB && !this.popupOpen) {\n            // The popup is closed and the user pressed the Tab key.  The\n            // focus should move out of the urlbar immediately.\n            return false;\n          }\n\n          return !this._safeToPlayDeferredKeyEvent(event);\n        ]]></body>\n      </method>\n\n      <!--\n        Returns true if the given deferred key event can be played now without\n        possibly surprising the user.  This depends on the state of the popup,\n        its results, and the type of keypress.  Use this method only after\n        determining that the event should be deferred, or after it's already\n        been deferred and you want to know if it can be played now.\n\n        @param  event\n                The key event.\n        @return True if the event can be played, false if not.\n      -->\n      <method name=\"_safeToPlayDeferredKeyEvent\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (event.keyCode == KeyEvent.DOM_VK_RETURN) {\n            return this.popup.selectedIndex != 0 ||\n                   this.gotResultForCurrentQuery;\n          }\n\n          if (!this.gotResultForCurrentQuery || !this.popupOpen) {\n            // We're still waiting on the first result, or the popup hasn't\n            // opened yet, so not safe.\n            return false;\n          }\n\n          let maxResultsRemaining =\n            this.popup.maxResults - this.popup.matchCount;\n          if (maxResultsRemaining == 0) {\n            // The popup can't possibly have any more results, so there's no\n            // need to defer any event now.\n            return true;\n          }\n\n          if (event.keyCode == KeyEvent.DOM_VK_DOWN) {\n            // Don't play the event if the last result is selected so that the\n            // user doesn't accidentally arrow down into the one-off buttons\n            // when they didn't mean to.\n            let lastResultSelected =\n              this.popup.selectedIndex + 1 == this.popup.matchCount;\n            return !lastResultSelected;\n          }\n\n          return true;\n        ]]></body>\n      </method>\n\n      <!--\n        Adds a key event to the deferred event queue.\n\n        @param event\n               The key event to defer.\n        @param methodName\n               The name of the method on `this` to call.  It's expected to take\n               two arguments: the event, and a noDefer bool.  If the bool is\n               true, then the event is being replayed and it should not be\n               deferred.\n      -->\n      <method name=\"_deferKeyEvent\">\n        <parameter name=\"event\"/>\n        <parameter name=\"methodName\"/>\n        <body><![CDATA[\n          // Somehow event.defaultPrevented ends up true for deferred events.\n          // autocomplete ignores defaultPrevented events, which means it would\n          // ignore replayed deferred events if we didn't tell it to bypass\n          // defaultPrevented.  That's the purpose of this expando.  If we could\n          // figure out what's setting defaultPrevented and prevent it, then we\n          // could get rid of this.\n          if (event.urlbarDeferred) {\n            throw new Error(\"Key event already deferred!\");\n          }\n          event.urlbarDeferred = true;\n\n          this._deferredKeyEventQueue.push({\n            methodName,\n            event,\n            searchString: this.mController.searchString,\n          });\n\n          if (!this._deferredKeyEventTimeout) {\n            // Start the timeout that will unconditionally replay all deferred\n            // events when it fires so that, after a certain point, we don't\n            // keep blocking the user's keypresses when nothing else has caused\n            // the events to be replayed.  Do not check whether it's safe to\n            // replay the events because otherwise it may look like we ignored\n            // the user's input.\n            let elapsed = Cu.now() - this._searchStartDate;\n            let remaining = this._deferredKeyEventTimeoutMs - elapsed;\n            this._deferredKeyEventTimeout = setTimeout(() => {\n              this.replayAllDeferredKeyEvents();\n              this._deferredKeyEventTimeout = null;\n            }, Math.max(0, remaining));\n          }\n        ]]></body>\n      </method>\n\n      <!-- The enter key is always deferred, so it's not included here. -->\n      <field name=\"_keyCodesToDefer\">new Set([\n        KeyboardEvent.DOM_VK_RETURN,\n        KeyboardEvent.DOM_VK_DOWN,\n        KeyboardEvent.DOM_VK_TAB,\n      ])</field>\n      <field name=\"_deferredKeyEventQueue\">[]</field>\n      <field name=\"_deferredKeyEventTimeout\">null</field>\n      <field name=\"_deferredKeyEventTimeoutMs\">200</field>\n      <field name=\"_searchStartDate\">0</field>\n\n      <method name=\"replaySafeDeferredKeyEvents\">\n        <body><![CDATA[\n          if (!this._deferredKeyEventQueue.length) {\n            return;\n          }\n          let instance = this._deferredKeyEventQueue[0];\n          if (!this._safeToPlayDeferredKeyEvent(instance.event)) {\n            return;\n          }\n          this._deferredKeyEventQueue.shift();\n          this._replayKeyEventInstance(instance);\n          Services.tm.dispatchToMainThread(() => {\n            this.replaySafeDeferredKeyEvents();\n          });\n        ]]></body>\n      </method>\n\n      <!--\n        Unconditionally replays all deferred key events.  This does not check\n        whether it's safe to replay the events; use replaySafeDeferredKeyEvents\n        for that.  Use this method when you must replay all events so that it\n        does not appear that we ignored the user's input.\n      -->\n      <method name=\"replayAllDeferredKeyEvents\">\n        <body><![CDATA[\n          let instance = this._deferredKeyEventQueue.shift();\n          if (!instance) {\n            return;\n          }\n          this._replayKeyEventInstance(instance);\n          Services.tm.dispatchToMainThread(() => {\n            this.replayAllDeferredKeyEvents();\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"_replayKeyEventInstance\">\n        <parameter name=\"instance\"/>\n        <body><![CDATA[\n          // Safety check: handle only if the search string didn't change.\n          if (this.mController.searchString == instance.searchString) {\n            this[instance.methodName](instance.event, true);\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_mayTrimURLs\">true</field>\n      <method name=\"trimValue\">\n        <parameter name=\"aURL\"/>\n        <body><![CDATA[\n          // This method must not modify the given URL such that calling\n          // nsIURIFixup::createFixupURI with the result will produce a different URI.\n          return this._mayTrimURLs ? trimURL(aURL) : aURL;\n        ]]></body>\n      </method>\n\n      <!--\n        This method tries to apply styling to the text in the input, depending\n        on the text.  See the _format* methods.\n      -->\n      <method name=\"formatValue\">\n        <body><![CDATA[\n          this.valueFormatter.update();\n        ]]></body>\n      </method>\n\n      <method name=\"handleRevert\">\n        <body><![CDATA[\n          var isScrolling = this.popupOpen;\n\n          gBrowser.userTypedValue = null;\n\n          // don't revert to last valid url unless page is NOT loading\n          // and user is NOT key-scrolling through autocomplete list\n          if (!XULBrowserWindow.isBusy && !isScrolling) {\n            URLBarSetURI(null, true);\n\n            // If the value isn't empty and the urlbar has focus, select the value.\n            if (this.value && this.hasAttribute(\"focused\"))\n              this.select();\n          }\n\n          // tell widget to revert to last typed text only if the user\n          // was scrolling when they hit escape\n          return !isScrolling;\n        ]]></body>\n      </method>\n\n      <method name=\"_whereToOpen\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let isMouseEvent = event instanceof MouseEvent;\n          let reuseEmpty = !isMouseEvent;\n          let where = undefined;\n          if (!isMouseEvent && event && event.altKey) {\n            // We support using 'alt' to open in a tab, because ctrl/shift\n            // might be used for canonizing URLs:\n            where = event.shiftKey ? \"tabshifted\" : \"tab\";\n          } else if (!isMouseEvent && this._ctrlCanonizesURLs && event && event.ctrlKey) {\n            // If we're allowing canonization, and this is a key event with ctrl\n            // pressed, open in current tab to allow ctrl-enter to canonize URL.\n            where = \"current\";\n          } else {\n            where = whereToOpenLink(event, false, false);\n          }\n          if (this.openInTab) {\n            if (where == \"current\") {\n              where = \"tab\";\n            } else if (where == \"tab\") {\n              where = \"current\";\n            }\n            reuseEmpty = true;\n          }\n          if (where == \"tab\" && reuseEmpty && isTabEmpty(gBrowser.selectedTab)) {\n            where = \"current\";\n          }\n          return where;\n        ]]></body>\n      </method>\n\n      <!--\n        This is ultimately called by the autocomplete controller as the result\n        of handleEnter when the Return key is pressed in the textbox.  Since\n        onPopupClick also calls handleEnter, this is also called as a result in\n        that case.\n\n        @param event\n               The event that triggered the command.\n        @param openUILinkWhere\n               Optional.  The \"where\" to pass to openTrustedLinkIn.  This method\n               computes the appropriate \"where\" given the event, but you can\n               use this to override it.\n        @param openUILinkParams\n               Optional.  The parameters to pass to openTrustedLinkIn.  As with\n               \"where\", this method computes the appropriate parameters, but\n               any parameters you supply here will override those.\n      -->\n      <method name=\"handleCommand\">\n        <parameter name=\"event\"/>\n        <parameter name=\"openUILinkWhere\"/>\n        <parameter name=\"openUILinkParams\"/>\n        <parameter name=\"triggeringPrincipal\"/>\n        <body><![CDATA[\n          let isMouseEvent = event instanceof MouseEvent;\n          if (isMouseEvent && event.button == 2) {\n            // Do nothing for right clicks.\n            return;\n          }\n\n          // Determine whether to use the selected one-off search button.  In\n          // one-off search buttons parlance, \"selected\" means that the button\n          // has been navigated to via the keyboard.  So we want to use it if\n          // the triggering event is not a mouse click -- i.e., it's a Return\n          // key -- or if the one-off was mouse-clicked.\n          let selectedOneOff = this.popup.oneOffSearchButtons.selectedButton;\n          if (selectedOneOff &&\n              isMouseEvent &&\n              event.originalTarget != selectedOneOff) {\n            selectedOneOff = null;\n          }\n\n          // Do the command of the selected one-off if it's not an engine.\n          if (selectedOneOff && !selectedOneOff.engine) {\n            selectedOneOff.doCommand();\n            return;\n          }\n\n          let where = openUILinkWhere || this._whereToOpen(event);\n\n          let url = this.value;\n          if (!url) {\n            return;\n          }\n\n          BrowserUsageTelemetry.recordUrlbarSelectedResultMethod(\n            event, this.userSelectionBehavior);\n\n          let mayInheritPrincipal = false;\n          let postData = null;\n          let browser = gBrowser.selectedBrowser;\n          let action = this._parseActionUrl(url);\n\n          if (selectedOneOff && selectedOneOff.engine) {\n            // If there's a selected one-off button then load a search using\n            // the one-off's engine.\n            [url, postData] =\n              this._parseAndRecordSearchEngineLoad(selectedOneOff.engine,\n                                                   this.oneOffSearchQuery,\n                                                   event, where,\n                                                   openUILinkParams);\n          } else if (action) {\n            switch (action.type) {\n              case \"visiturl\":\n                // Unifiedcomplete uses fixupURI to tell if something is a visit\n                // or a search, and passes out the fixedURI as the url param.\n                // By using that uri we would end up passing a different string\n                // to the docshell that may run a different not-found heuristic.\n                // For example, \"mozilla/run\" would be fixed by unifiedcomplete\n                // to \"http://mozilla/run\". The docshell, once it can't resolve\n                // mozilla, would note the string has a scheme, and try to load\n                // http://mozilla.com/run instead of searching \"mozilla/run\".\n                // So, if we have the original input at hand, we pass it through\n                // and let the docshell handle it.\n                if (action.params.input) {\n                  url = action.params.input;\n                  break;\n                }\n                url = action.params.url;\n                break;\n              case \"remotetab\":\n                url = action.params.url;\n                break;\n              case \"keyword\":\n                if (action.params.postData) {\n                  postData = getPostDataStream(action.params.postData);\n                }\n                mayInheritPrincipal = true;\n                url = action.params.url;\n                break;\n              case \"switchtab\":\n                url = action.params.url;\n                if (this.hasAttribute(\"actiontype\")) {\n                  this.handleRevert();\n                  let prevTab = gBrowser.selectedTab;\n                  let loadOpts = {\n                    adoptIntoActiveWindow: this._adoptIntoActiveWindow,\n                  };\n\n                  if (switchToTabHavingURI(url, false, loadOpts) &&\n                      isTabEmpty(prevTab)) {\n                    gBrowser.removeTab(prevTab);\n                  }\n                  return;\n                }\n\n                // Once we get here, we got a switchtab action but the user\n                // bypassed it by pressing shift/meta/ctrl. Those modifiers\n                // might otherwise affect where we open - we always want to\n                // open in the current tab.\n                where = \"current\";\n                break;\n              case \"searchengine\":\n                if (selectedOneOff && selectedOneOff.engine) {\n                  // Replace the engine with the selected one-off engine.\n                  action.params.engineName = selectedOneOff.engine.name;\n                }\n                const actionDetails = {\n                  isSuggestion: !!action.params.searchSuggestion,\n                  isAlias: !!action.params.alias,\n                };\n                [url, postData] = this._parseAndRecordSearchEngineLoad(\n                  action.params.engineName,\n                  action.params.searchSuggestion || action.params.searchQuery,\n                  event,\n                  where,\n                  openUILinkParams,\n                  actionDetails\n                );\n                break;\n              case \"extension\":\n                this.handleRevert();\n                // Give the extension control of handling the command.\n                let searchString = action.params.content;\n                let keyword = action.params.keyword;\n                this.ExtensionSearchHandler.handleInputEntered(keyword, searchString, where);\n                return;\n            }\n          } else {\n            // This is a fallback for add-ons and old testing code that directly\n            // set value and try to confirm it. UnifiedComplete should always\n            // resolve to a valid url.\n            try {\n              url = url.trim();\n              new URL(url);\n            } catch (ex) {\n              let lastLocationChange = browser.lastLocationChange;\n              getShortcutOrURIAndPostData(url).then(data => {\n                if (where != \"current\" ||\n                    browser.lastLocationChange == lastLocationChange) {\n                  this._loadURL(data.url, browser, data.postData, where,\n                                openUILinkParams, data.mayInheritPrincipal,\n                                triggeringPrincipal);\n                }\n              });\n              return;\n            }\n          }\n\n          this._loadURL(url, browser, postData, where, openUILinkParams,\n                        mayInheritPrincipal, triggeringPrincipal);\n        ]]></body>\n      </method>\n\n      <property name=\"oneOffSearchQuery\">\n        <getter><![CDATA[\n          // If the user has selected a search suggestion, chances are they\n          // want to use the one off search engine to search for that suggestion,\n          // not the string that they manually entered into the location bar.\n          let action = this._parseActionUrl(this.value);\n          if (action && action.type == \"searchengine\") {\n            return action.params.input;\n          }\n          // this.textValue may be an autofilled string.  Search only with the\n          // portion that the user typed, if any, by preferring the autocomplete\n          // controller's searchString (including handleEnterInstance.searchString).\n          return this.handleEnterSearchString ||\n                 this.mController.searchString ||\n                 this.textValue;\n        ]]></getter>\n      </property>\n\n      <method name=\"_loadURL\">\n        <parameter name=\"url\"/>\n        <parameter name=\"browser\"/>\n        <parameter name=\"postData\"/>\n        <parameter name=\"openUILinkWhere\"/>\n        <parameter name=\"openUILinkParams\"/>\n        <parameter name=\"mayInheritPrincipal\"/>\n        <parameter name=\"triggeringPrincipal\"/>\n        <body><![CDATA[\n          this.value = url;\n          browser.userTypedValue = url;\n          if (gInitialPages.includes(url)) {\n            browser.initialPageLoadedFromURLBar = url;\n          }\n          try {\n            addToUrlbarHistory(url);\n          } catch (ex) {\n            // Things may go wrong when adding url to session history,\n            // but don't let that interfere with the loading of the url.\n            Cu.reportError(ex);\n          }\n\n          let params = {\n            postData,\n            allowThirdPartyFixup: true,\n            triggeringPrincipal,\n          };\n          if (openUILinkWhere == \"current\") {\n            params.targetBrowser = browser;\n            params.indicateErrorPageLoad = true;\n            params.allowPinnedTabHostChange = true;\n            params.allowPopups = url.startsWith(\"javascript:\");\n          } else {\n            params.initiatingDoc = document;\n          }\n          params.allowInheritPrincipal = mayInheritPrincipal;\n\n          if (openUILinkParams) {\n            for (let key in openUILinkParams) {\n              params[key] = openUILinkParams[key];\n            }\n          }\n\n          // Focus the content area before triggering loads, since if the load\n          // occurs in a new tab, we want focus to be restored to the content\n          // area when the current tab is re-selected.\n          browser.focus();\n\n          if (openUILinkWhere != \"current\") {\n            this.handleRevert();\n          }\n\n          try {\n            openTrustedLinkIn(url, openUILinkWhere, params);\n          } catch (ex) {\n            // This load can throw an exception in certain cases, which means\n            // we'll want to replace the URL with the loaded URL:\n            if (ex.result != Cr.NS_ERROR_LOAD_SHOWED_ERRORPAGE) {\n              this.handleRevert();\n            }\n          }\n\n          // Ensure the start of the URL is visible for usability reasons.\n          this.selectionStart = this.selectionEnd = 0;\n        ]]></body>\n      </method>\n\n      <method name=\"_parseAndRecordSearchEngineLoad\">\n        <parameter name=\"engineOrEngineName\"/>\n        <parameter name=\"query\"/>\n        <parameter name=\"event\"/>\n        <parameter name=\"openUILinkWhere\"/>\n        <parameter name=\"openUILinkParams\"/>\n        <parameter name=\"searchActionDetails\"/>\n        <body><![CDATA[\n          let engine =\n            typeof(engineOrEngineName) == \"string\" ?\n              Services.search.getEngineByName(engineOrEngineName) :\n              engineOrEngineName;\n          let isOneOff = this.popup.oneOffSearchButtons\n              .maybeRecordTelemetry(event, openUILinkWhere, openUILinkParams);\n          // Infer the type of the event which triggered the search.\n          let eventType = \"unknown\";\n          if (event instanceof KeyboardEvent) {\n            eventType = \"key\";\n          } else if (event instanceof MouseEvent) {\n            eventType = \"mouse\";\n          }\n          // Augment the search action details object.\n          let details = searchActionDetails || {};\n          details.isOneOff = isOneOff;\n          details.type = eventType;\n\n          BrowserSearch.recordSearchInTelemetry(engine, \"urlbar\", details);\n          let submission = engine.getSubmission(query, null, \"keyword\");\n          return [submission.uri.spec, submission.postData];\n        ]]></body>\n      </method>\n\n      <method name=\"maybeCanonizeURL\">\n        <parameter name=\"aTriggeringEvent\"/>\n        <parameter name=\"aUrl\"/>\n        <body><![CDATA[\n          // Only add the suffix when the URL bar value isn't already \"URL-like\",\n          // and only if we get a keyboard event, to match user expectations.\n          if (!/^\\s*[^.:\\/\\s]+(?:\\/.*|\\s*)$/i.test(aUrl) ||\n              !this._ctrlCanonizesURLs ||\n              !(aTriggeringEvent instanceof KeyboardEvent) ||\n              !aTriggeringEvent.ctrlKey) {\n            return;\n          }\n\n          let suffix = Services.prefs.getCharPref(\"browser.fixup.alternate.suffix\", \".com/\");\n          if (!suffix.endsWith(\"/\")) {\n            suffix += \"/\";\n          }\n\n          // trim leading/trailing spaces (bug 233205)\n          let url = aUrl.trim();\n\n          // Tack www. and suffix on.  If user has appended directories, insert\n          // suffix before them (bug 279035).  Be careful not to get two slashes.\n          let firstSlash = url.indexOf(\"/\");\n          if (firstSlash >= 0) {\n            url = url.substring(0, firstSlash) + suffix +\n                  url.substring(firstSlash + 1);\n          } else {\n            url = url + suffix;\n          }\n\n          this.popup.overrideValue = \"http://www.\" + url;\n        ]]></body>\n      </method>\n\n      <method name=\"_initURLTooltip\">\n        <body><![CDATA[\n          if (this.focused || !this._inOverflow)\n            return;\n          this.inputField.setAttribute(\"title\", this.value);\n        ]]></body>\n      </method>\n\n      <method name=\"_hideURLTooltip\">\n        <body><![CDATA[\n          this.inputField.removeAttribute(\"title\");\n        ]]></body>\n      </method>\n\n      <!-- Returns:\n           null if there's a security issue and we should do nothing.\n           a URL object if there is one that we're OK with loading,\n           a text value otherwise.\n           -->\n      <method name=\"_getDroppableItem\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let links;\n          try {\n            links = browserDragAndDrop.dropLinks(aEvent);\n          } catch (ex) {\n            // this is possibly a security exception, in which case we should return\n            // null. Always return null because we can't *know* what exception is\n            // being returned.\n            return null;\n          }\n          // The URL bar automatically handles inputs with newline characters,\n          // so we can get away with treating text/x-moz-url flavours as text/plain.\n          if (links.length > 0 && links[0].url) {\n            let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(aEvent);\n            aEvent.preventDefault();\n            let url = links[0].url;\n            let strippedURL = stripUnsafeProtocolOnPaste(url);\n            if (strippedURL != url) {\n              aEvent.stopImmediatePropagation();\n              return null;\n            }\n            let urlObj;\n            try {\n              // If this throws, urlSecurityCheck would also throw, as that's what it\n              // does with things that don't pass the IO service's newURI constructor\n              // without fixup. It's conceivable we may want to relax this check in\n              // the future (so e.g. www.foo.com gets fixed up), but not right now.\n              urlObj = new URL(url);\n              // If we succeed, try to pass security checks. If this works, return the\n              // URL object. If the *security checks* fail, return null.\n              try {\n                urlSecurityCheck(url,\n                                 triggeringPrincipal,\n                                 Ci.nsIScriptSecurityManager.DISALLOW_INHERIT_PRINCIPAL);\n                return urlObj;\n              } catch (ex) {\n                return null;\n              }\n            } catch (ex) {\n              // We couldn't make a URL out of this. Continue on, and return text below.\n            }\n          }\n          return aEvent.dataTransfer.getData(\"text/unicode\");\n        ]]></body>\n      </method>\n\n      <method name=\"onDragOver\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this._getDroppableItem(aEvent)) {\n            aEvent.dataTransfer.dropEffect = \"none\";\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onDrop\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let droppedItem = this._getDroppableItem(aEvent);\n          if (droppedItem) {\n            let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(aEvent);\n            this.value = droppedItem instanceof URL ? droppedItem.href : droppedItem;\n            SetPageProxyState(\"invalid\");\n            this.focus();\n            this.handleCommand(null, undefined, undefined, triggeringPrincipal);\n            // Force not showing the dropped URI immediately.\n            gBrowser.userTypedValue = null;\n            URLBarSetURI(null, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"makeURIReadable\">\n        <parameter name=\"aURI\"/>\n        <body>\n          <![CDATA[\n            // Avoid copying 'about:reader?url=', and always provide the original URI:\n            // Reader mode ensures we call createExposableURI itself.\n            let readerStrippedURI = ReaderMode.getOriginalUrlObjectForDisplay(aURI.displaySpec);\n            if (readerStrippedURI) {\n              aURI = readerStrippedURI;\n            } else {\n              // Only copy exposable URIs\n              try {\n                aURI = Services.uriFixup.createExposableURI(aURI);\n              } catch (ex) {}\n            }\n            return aURI;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_getSelectedValueForClipboard\">\n        <body><![CDATA[\n          // Grab the actual input field's value, not our value, which could\n          // include \"moz-action:\".\n          var inputVal = this.inputField.value;\n          let selection = this.editor.selection;\n          const flags = Ci.nsIDocumentEncoder.OutputPreformatted |\n                        Ci.nsIDocumentEncoder.OutputRaw;\n          let selectedVal = selection.toStringWithFormat(\"text/plain\", flags, 0);\n\n          // Handle multiple-range selection as a string for simplicity.\n          if (selection.rangeCount > 1) {\n             return selectedVal;\n          }\n\n          // If the selection doesn't start at the beginning or doesn't span the\n          // full domain or the URL bar is modified or there is no text at all,\n          // nothing else to do here.\n          if (this.selectionStart > 0 || this.valueIsTyped || selectedVal == \"\")\n            return selectedVal;\n          // The selection doesn't span the full domain if it doesn't contain a slash and is\n          // followed by some character other than a slash.\n          if (!selectedVal.includes(\"/\")) {\n            let remainder = inputVal.replace(selectedVal, \"\");\n            if (remainder != \"\" && remainder[0] != \"/\")\n              return selectedVal;\n          }\n\n          // If the value was filled by a search suggestion, just return it.\n          let action = this._parseActionUrl(this.value);\n          if (action && action.type == \"searchengine\")\n            return selectedVal;\n\n          let uriFixup = Cc[\"@mozilla.org/docshell/urifixup;1\"].getService(Ci.nsIURIFixup);\n\n          let uri;\n          if (this.getAttribute(\"pageproxystate\") == \"valid\") {\n            uri = gBrowser.currentURI;\n          } else {\n            // We're dealing with an autocompleted value, create a new URI from that.\n            try {\n              uri = uriFixup.createFixupURI(inputVal, Ci.nsIURIFixup.FIXUP_FLAG_NONE);\n            } catch (e) {}\n            if (!uri)\n              return selectedVal;\n          }\n\n          uri = this.makeURIReadable(uri);\n\n          // If the entire URL is selected, just use the actual loaded URI,\n          // unless we want a decoded URI, or it's a data: or javascript: URI,\n          // since those are hard to read when encoded.\n          if (inputVal == selectedVal &&\n              !uri.schemeIs(\"javascript\") && !uri.schemeIs(\"data\") &&\n              !Services.prefs.getBoolPref(\"browser.urlbar.decodeURLsOnCopy\")) {\n            return uri.displaySpec;\n          }\n\n          // Just the beginning of the URL is selected, or we want a decoded\n          // url. First check for a trimmed value.\n          let spec = uri.displaySpec;\n          let trimmedSpec = this.trimValue(spec);\n          if (spec != trimmedSpec) {\n            // Prepend the portion that trimValue removed from the beginning.\n            // This assumes trimValue will only truncate the URL at\n            // the beginning or end (or both).\n            let trimmedSegments = spec.split(trimmedSpec);\n            selectedVal = trimmedSegments[0] + selectedVal;\n          }\n\n          return selectedVal;\n        ]]></body>\n      </method>\n\n      <field name=\"_copyCutController\"><![CDATA[\n        ({\n          urlbar: this,\n          doCommand(aCommand) {\n            var urlbar = this.urlbar;\n            var val = urlbar._getSelectedValueForClipboard();\n            if (!val)\n              return;\n\n            if (aCommand == \"cmd_cut\" && this.isCommandEnabled(aCommand)) {\n              let start = urlbar.selectionStart;\n              let end = urlbar.selectionEnd;\n              urlbar.inputField.value = urlbar.inputField.value.substring(0, start) +\n                                        urlbar.inputField.value.substring(end);\n              urlbar.selectionStart = urlbar.selectionEnd = start;\n\n              let event = document.createEvent(\"UIEvents\");\n              event.initUIEvent(\"input\", true, false, window, 0);\n              urlbar.dispatchEvent(event);\n\n              SetPageProxyState(\"invalid\");\n            }\n\n            Cc[\"@mozilla.org/widget/clipboardhelper;1\"]\n              .getService(Ci.nsIClipboardHelper)\n              .copyString(val);\n          },\n          supportsCommand(aCommand) {\n            switch (aCommand) {\n              case \"cmd_copy\":\n              case \"cmd_cut\":\n                return true;\n            }\n            return false;\n          },\n          isCommandEnabled(aCommand) {\n            return this.supportsCommand(aCommand) &&\n                   (aCommand != \"cmd_cut\" || !this.urlbar.readOnly) &&\n                   this.urlbar.selectionStart < this.urlbar.selectionEnd;\n          },\n          onEvent(aEventName) {},\n        })\n      ]]></field>\n\n      <method name=\"observe\">\n        <parameter name=\"aSubject\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aData\"/>\n        <body><![CDATA[\n          if (aTopic == \"nsPref:changed\") {\n            switch (aData) {\n              case \"clickSelectsAll\":\n              case \"doubleClickSelectsAll\":\n                this[aData] = this._prefs.getBoolPref(aData);\n                break;\n              case \"autoFill\":\n                this.completeDefaultIndex = this._prefs.getBoolPref(aData);\n                break;\n              case \"delay\":\n                this.timeout = this._prefs.getIntPref(aData);\n                break;\n              case \"ctrlCanonizesURLs\":\n                this._ctrlCanonizesURLs = this._prefs.getBoolPref(aData);\n                break;\n              case \"speculativeConnect.enabled\":\n                this.speculativeConnectEnabled = this._prefs.getBoolPref(aData);\n                break;\n              case \"openintab\":\n                this.openInTab = this._prefs.getBoolPref(aData);\n                break;\n              case \"browser.search.suggest.enabled\":\n                this.browserSearchSuggestEnabled = Services.prefs.getBoolPref(aData);\n                break;\n              case \"suggest.searches\":\n                this.urlbarSearchSuggestEnabled = this._prefs.getBoolPref(aData);\n              case \"userMadeSearchSuggestionsChoice\":\n                // Mirror the value for future use, see the comment in the\n                // binding's constructor.\n                this._prefs.setBoolPref(\"searchSuggestionsChoice\",\n                  this.urlbarSearchSuggestEnabled);\n                // Clear the cached value to allow changing conditions in tests.\n                delete this._whichSearchSuggestionsNotification;\n                break;\n              case \"trimURLs\":\n                this._mayTrimURLs = this._prefs.getBoolPref(aData);\n                break;\n              case \"oneOffSearches\":\n                this._enableOrDisableOneOffSearches();\n                break;\n              case \"maxRichResults\":\n                this.popup.maxResults = this._prefs.getIntPref(aData);\n                break;\n              case \"switchTabs.adoptIntoActiveWindow\":\n                this._adoptIntoActiveWindow =\n                  this._prefs.getBoolPref(\"switchTabs.adoptIntoActiveWindow\");\n                break;\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_enableOrDisableOneOffSearches\">\n        <body><![CDATA[\n          this.popup.oneOffSearchesEnabled =\n            this._prefs.getBoolPref(\"oneOffSearches\");\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.type) {\n            case \"paste\":\n              let originalPasteData = aEvent.clipboardData.getData(\"text/plain\");\n              if (!originalPasteData) {\n                return;\n              }\n\n              let oldValue = this.inputField.value;\n              let oldStart = oldValue.substring(0, this.inputField.selectionStart);\n              // If there is already non-whitespace content in the URL bar\n              // preceding the pasted content, it's not necessary to check\n              // protocols used by the pasted content:\n              if (oldStart.trim()) {\n                return;\n              }\n              let oldEnd = oldValue.substring(this.inputField.selectionEnd);\n\n              let pasteData = stripUnsafeProtocolOnPaste(originalPasteData);\n              if (originalPasteData != pasteData) {\n                // Unfortunately we're not allowed to set the bits being pasted\n                // so cancel this event:\n                aEvent.preventDefault();\n                aEvent.stopImmediatePropagation();\n\n                this.inputField.value = oldStart + pasteData + oldEnd;\n                // Fix up cursor/selection:\n                let newCursorPos = oldStart.length + pasteData.length;\n                this.inputField.selectionStart = newCursorPos;\n                this.inputField.selectionEnd = newCursorPos;\n              }\n              break;\n            case \"mousedown\":\n              if (this.doubleClickSelectsAll &&\n                  aEvent.button == 0 && aEvent.detail == 2) {\n                this.editor.selectAll();\n                aEvent.preventDefault();\n              }\n              break;\n            case \"mousemove\":\n              this._initURLTooltip();\n              break;\n            case \"mouseout\":\n              this._hideURLTooltip();\n              break;\n            case \"overflow\": {\n              const targetIsPlaceholder =\n                !aEvent.originalTarget.classList.contains(\"anonymous-div\");\n              // We only care about the non-placeholder text.\n              // This shouldn't be needed, see bug 1487036.\n              if (targetIsPlaceholder) {\n                break;\n              }\n              this._inOverflow = true;\n              this.updateTextOverflow();\n              break;\n            }\n            case \"underflow\": {\n              const targetIsPlaceholder =\n                !aEvent.originalTarget.classList.contains(\"anonymous-div\");\n              // We only care about the non-placeholder text.\n              // This shouldn't be needed, see bug 1487036.\n              if (targetIsPlaceholder) {\n                break;\n              }\n              this._inOverflow = false;\n              this.updateTextOverflow();\n              this._hideURLTooltip();\n              break;\n            }\n            case \"scrollend\":\n              this.updateTextOverflow();\n              break;\n            case \"TabSelect\":\n              // The autocomplete controller uses heuristic on some internal caches\n              // to handle cases like backspace, autofill or repeated searches.\n              // Ensure to clear those internal caches when switching tabs.\n              this.controller.resetInternalState();\n              break;\n            case \"resize\":\n              if (aEvent.target == window) {\n                // Close the popup since it would be wrongly sized, we'll\n                // recalculate a proper size on reopening. For example, this may\n                // happen when using special OS resize functions like Win+Arrow.\n                this.closePopup();\n\n                // Make sure the host remains visible in the input field\n                // when the window is resized.  We don't want to\n                // hurt resize performance though, so do this only after resize\n                // events have stopped and a small timeout has elapsed.\n                if (this._resizeThrottleTimeout) {\n                  clearTimeout(this._resizeThrottleTimeout);\n                }\n                this._resizeThrottleTimeout = setTimeout(() => {\n                  this._resizeThrottleTimeout = null;\n                  this.valueFormatter.ensureFormattedHostVisible();\n                }, 100);\n              }\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"updateTextOverflow\">\n        <body><![CDATA[\n          if (this._inOverflow) {\n            window.promiseDocumentFlushed(() => {\n              // Check overflow again to ensure it didn't change in the meanwhile.\n              let input = this.inputField;\n              if (input && this._inOverflow) {\n                let side = input.scrollLeft &&\n                           input.scrollLeft == input.scrollLeftMax ? \"start\" : \"end\";\n                this.setAttribute(\"textoverflow\", side);\n              }\n            });\n          } else {\n            this.removeAttribute(\"textoverflow\");\n          }\n        ]]></body>\n      </method>\n\n      <!--\n        onBeforeTextValueGet is called by the base-binding's .textValue getter.\n        It should return the value that the getter should use.\n      -->\n      <method name=\"onBeforeTextValueGet\">\n        <body><![CDATA[\n          return { value: this.inputField.value };\n        ]]></body>\n      </method>\n\n      <!--\n        onBeforeTextValueSet is called by the base-binding's .textValue setter.\n        It should return the value that the setter should use.\n      -->\n      <method name=\"onBeforeTextValueSet\">\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          let val = aValue;\n          let uri;\n          try {\n            uri = makeURI(val);\n          } catch (ex) {}\n\n          if (uri) {\n            // Do not touch moz-action URIs at all.  They depend on being\n            // properly encoded and decoded and will break if decoded\n            // unexpectedly.\n            if (!this._parseActionUrl(val)) {\n              val = losslessDecodeURI(uri);\n            }\n          }\n\n          return val;\n        ]]></body>\n      </method>\n\n      <method name=\"_parseActionUrl\">\n        <parameter name=\"aUrl\"/>\n        <body><![CDATA[\n          const MOZ_ACTION_REGEX = /^moz-action:([^,]+),(.*)$/;\n          if (!MOZ_ACTION_REGEX.test(aUrl))\n            return null;\n\n          // URL is in the format moz-action:ACTION,PARAMS\n          // Where PARAMS is a JSON encoded object.\n          let [, type, params] = aUrl.match(MOZ_ACTION_REGEX);\n\n          let action = {\n            type,\n          };\n\n          action.params = JSON.parse(params);\n          for (let key in action.params) {\n            action.params[key] = decodeURIComponent(action.params[key]);\n          }\n\n          if (\"url\" in action.params) {\n            let uri;\n            try {\n              uri = makeURI(action.params.url);\n              action.params.displayUrl = losslessDecodeURI(uri);\n            } catch (e) {\n              action.params.displayUrl = action.params.url;\n            }\n          }\n\n          return action;\n        ]]></body>\n      </method>\n\n      <property name=\"_noActionKeys\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.__noActionKeys) {\n            this.__noActionKeys = new Set([\n              KeyEvent.DOM_VK_ALT,\n              KeyEvent.DOM_VK_SHIFT,\n            ]);\n            let modifier = AppConstants.platform == \"macosx\" ?\n                           KeyEvent.DOM_VK_META :\n                           KeyEvent.DOM_VK_CONTROL;\n            this.__noActionKeys.add(modifier);\n          }\n          return this.__noActionKeys;\n        ]]></getter>\n      </property>\n\n      <field name=\"_pressedNoActionKeys\"><![CDATA[\n        new Set()\n      ]]></field>\n\n      <method name=\"_clearNoActions\">\n        <parameter name=\"aURL\"/>\n        <body><![CDATA[\n          this._pressedNoActionKeys.clear();\n          this.popup.removeAttribute(\"noactions\");\n          let action = this._parseActionUrl(this._value);\n          if (action)\n            this.setAttribute(\"actiontype\", action.type);\n        ]]></body>\n      </method>\n\n      <method name=\"onInput\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this.mIgnoreInput && this.mController.input == this) {\n            this._value = this.inputField.value;\n            gBrowser.userTypedValue = this.value;\n            this.valueIsTyped = true;\n            if (this.inputField.value) {\n              this.setAttribute(\"usertyping\", \"true\");\n            } else {\n              this.removeAttribute(\"usertyping\");\n            }\n            // If the popup already had accessibility focus, bring it back to\n            // the input, since the user is editing.\n            if (!this.popup.richlistbox.suppressMenuItemEvent &&\n                this.popup.richlistbox.currentItem) {\n              this.popup.richlistbox.currentItem._fireEvent(\"DOMMenuItemInactive\");\n            }\n            // The user is typing, so don't give accessibility focus to the\n            // popup, even if an item gets automatically selected.\n            this.popup.richlistbox.suppressMenuItemEvent = true;\n            // Only wait for a result when we are sure to get one.  In some\n            // cases, like when pasting the same exact text, we may not fire\n            // a new search and we won't get a result.\n            this._onInputHandledText = this.mController.handleText();\n            if (this._onInputHandledText) {\n              this.gotResultForCurrentQuery = false;\n              this._searchStartDate = Cu.now();\n              this._deferredKeyEventQueue = [];\n              if (this._deferredKeyEventTimeout) {\n                clearTimeout(this._deferredKeyEventTimeout);\n                this._deferredKeyEventTimeout = null;\n              }\n            }\n          }\n          this.resetActionType();\n        ]]></body>\n      </method>\n\n      <method name=\"handleEnter\">\n        <parameter name=\"event\"/>\n        <parameter name=\"noDefer\"/>\n        <body><![CDATA[\n          // We need to ensure we're using a selected autocomplete result.\n          // A result should automatically be selected by default,\n          // however autocomplete is async and therefore we may not\n          // have a result set relating to the current input yet. If that\n          // happens, we need to mark that when the first result does get added,\n          // it needs to be handled as if enter was pressed with that first\n          // result selected.\n          // If anything other than the default (first) result is selected, then\n          // it must have been manually selected by the human. We let this\n          // explicit choice be used, even if it may be related to a previous\n          // input.\n          // However, if the default result is automatically selected, we\n          // ensure that it corresponds to the current input.\n\n          // Store the current search string so it can be used in handleCommand,\n          // which will be called as a result of mController.handleEnter().\n          this.handleEnterSearchString = this.mController.searchString;\n\n          if (!noDefer && this._shouldDeferKeyEvent(event)) {\n            // Defer the event until the first non-heuristic result comes in.\n            this._deferKeyEvent(event, \"handleEnter\");\n            return false;\n          }\n\n          let canonizeValue = this.value;\n          if (event.ctrlKey) {\n            let action = this._parseActionUrl(canonizeValue);\n            if (action && \"searchSuggestion\" in action.params) {\n              canonizeValue = action.params.searchSuggestion;\n            } else if (this.popup.selectedIndex === 0 &&\n                       this.mController.getStyleAt(0).includes(\"autofill\")) {\n              canonizeValue = this.handleEnterSearchString;\n            }\n          }\n          this.maybeCanonizeURL(event, canonizeValue);\n          let handled = this.mController.handleEnter(false, event);\n          this.handleEnterSearchString = null;\n          this.popup.overrideValue = null;\n          return handled;\n        ]]></body>\n      </method>\n\n      <method name=\"handleDelete\">\n        <body><![CDATA[\n          // If the heuristic result is selected, then the autocomplete\n          // controller's handleDelete implementation will remove it, which is\n          // not what we want.  So in that case, call handleText so it acts as\n          // a backspace on the text value instead of removing the result.\n          if (this.popup.selectedIndex == 0 &&\n              this.popup._isFirstResultHeuristic) {\n            this.mController.handleText();\n            return false;\n          }\n          return this.mController.handleDelete();\n        ]]></body>\n      </method>\n\n      <property name=\"_userMadeSearchSuggestionsChoice\" readonly=\"true\">\n        <getter><![CDATA[\n          return this._prefs.getBoolPref(\"userMadeSearchSuggestionsChoice\") ||\n                 this._defaultPrefs.getBoolPref(\"suggest.searches\") != this._prefs.getBoolPref(\"suggest.searches\");\n        ]]></getter>\n      </property>\n\n      <property name=\"whichSearchSuggestionsNotification\" readonly=\"true\">\n        <getter><![CDATA[\n          // Once we return \"none\" once, we'll always return \"none\".\n          // If available, use the cached value, rather than running all of the\n          // checks again at every locationbar focus.\n          if (this._whichSearchSuggestionsNotification) {\n            return this._whichSearchSuggestionsNotification;\n          }\n\n          if (this.browserSearchSuggestEnabled && !this.inPrivateContext &&\n              // In any case, if the user made a choice we should not nag him.\n              !this._userMadeSearchSuggestionsChoice) {\n            if (this._defaultPrefs.getBoolPref(\"suggest.searches\") &&\n                this.urlbarSearchSuggestEnabled && // Has not been switched off.\n                this._prefs.getIntPref(\"timesBeforeHidingSuggestionsHint\")) {\n              return \"opt-out\";\n            }\n          }\n          return this._whichSearchSuggestionsNotification = \"none\";\n        ]]></getter>\n      </property>\n\n      <method name=\"updateSearchSuggestionsNotificationImpressions\">\n        <parameter name=\"whichNotification\"/>\n        <body><![CDATA[\n          if (whichNotification == \"none\") {\n            throw new Error(\"Unexpected notification type\");\n          }\n\n          let remaining = this._prefs.getIntPref(\"timesBeforeHidingSuggestionsHint\");\n          if (remaining > 0) {\n            this._prefs.setIntPref(\"timesBeforeHidingSuggestionsHint\", remaining - 1);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"maybeShowSearchSuggestionsNotificationOnFocus\">\n        <parameter name=\"mouseFocused\"/>\n        <body><![CDATA[\n          let whichNotification = this.whichSearchSuggestionsNotification;\n          if (this._showSearchSuggestionNotificationOnMouseFocus &&\n              mouseFocused) {\n            // Force showing the opt-out notification.\n            this._whichSearchSuggestionsNotification = whichNotification = \"opt-out\";\n          }\n          if (whichNotification == \"opt-out\") {\n            try {\n              this.popup.openAutocompletePopup(this, this);\n            } finally {\n              if (mouseFocused) {\n                delete this._whichSearchSuggestionsNotification;\n                this._showSearchSuggestionNotificationOnMouseFocus = false;\n              }\n            }\n          }\n        ]]></body>\n      </method>\n\n      <!--\n        Sets the input's value, starts a search, and opens the popup.\n\n        @param  value\n                The input's value will be set to this value, and the search will\n                use it as its query.\n        @param  options\n                An optional object with the following optional properties:\n                * disableOneOffButtons: Set to true to hide the one-off search\n                  buttons.\n                * disableSearchSuggestionsNotification: Set to true to hide the\n                  onboarding opt-out search suggestions notification.\n      -->\n      <method name=\"search\">\n        <parameter name=\"value\"/>\n        <parameter name=\"options\"/>\n        <body><![CDATA[\n          options = options || {};\n\n          if (options.disableOneOffButtons) {\n            this.popup.addEventListener(\"popupshowing\", () => {\n              if (this.popup.oneOffSearchesEnabled) {\n                this.popup.oneOffSearchesEnabled = false;\n                this.popup.addEventListener(\"popuphidden\", () => {\n                  this.popup.oneOffSearchesEnabled = true;\n                }, {once: true});\n              }\n            }, {once: true});\n          }\n\n          if (options.disableSearchSuggestionsNotification &&\n              this.whichSearchSuggestionsNotification != \"none\") {\n            let which = this.whichSearchSuggestionsNotification;\n            this._whichSearchSuggestionsNotification = \"none\";\n            this.popup.addEventListener(\"popuphidden\", () => {\n              this._whichSearchSuggestionsNotification = which;\n            }, {once: true});\n          }\n\n          // We want the value to be treated as text that the user typed.  It\n          // should go through the controller.handleText() path in onInput() so\n          // that gBrowser.userTypedValue, this.valueIsTyped, etc. are set and\n          // nsAutoCompleteController::HandleText() is called.  Set this.value\n          // and fire an input event to do that.  (If we set this.textValue we'd\n          // get an input event for free, but it would also set mIgnoreInput,\n          // skipping all of the above requirements.)\n          this.focus();\n          this.value = value;\n\n          // Avoid selecting the text if this method is called twice in a row.\n          this.selectionStart = -1;\n\n          let event = document.createEvent(\"Events\");\n          event.initEvent(\"input\", true, true);\n          this.dispatchEvent(event);\n\n          // handleText() ignores the value if it's the same as the previous\n          // value, but we want consecutive searches with the same value to be\n          // possible.  If handleText() returned false, then manually start a\n          // new search here.\n          if (!this._onInputHandledText) {\n            this.gotResultForCurrentQuery = false;\n            this.controller.startSearch(value);\n          }\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"keydown\"><![CDATA[\n        if (this._noActionKeys.has(event.keyCode) &&\n            this.popup.selectedIndex >= 0 &&\n            !this._pressedNoActionKeys.has(event.keyCode)) {\n          if (this._pressedNoActionKeys.size == 0) {\n            this.popup.setAttribute(\"noactions\", \"true\");\n            this.removeAttribute(\"actiontype\");\n          }\n          this._pressedNoActionKeys.add(event.keyCode);\n        }\n      ]]></handler>\n\n      <handler event=\"keyup\"><![CDATA[\n        if (this._noActionKeys.has(event.keyCode) &&\n            this._pressedNoActionKeys.has(event.keyCode)) {\n          this._pressedNoActionKeys.delete(event.keyCode);\n          if (this._pressedNoActionKeys.size == 0)\n            this._clearNoActions();\n        }\n      ]]></handler>\n\n      <handler event=\"mousedown\"><![CDATA[\n        if (event.button == 0) {\n          if (event.originalTarget.getAttribute(\"anonid\") == \"historydropmarker\") {\n            this.toggleHistoryPopup();\n          }\n\n          // Eventually show the opt-out notification even if the location bar is\n          // empty, focused, and the user clicks on it.\n          if (this.focused && this.textValue == \"\") {\n            this.maybeShowSearchSuggestionsNotificationOnFocus(true);\n          }\n        }\n      ]]></handler>\n\n      <handler event=\"focus\"><![CDATA[\n        if (event.originalTarget == this.inputField) {\n          this._hideURLTooltip();\n          this.formatValue();\n          if (this.getAttribute(\"pageproxystate\") != \"valid\") {\n            UpdatePopupNotificationsVisibility();\n          }\n\n          // We show the opt-out notification when the mouse/keyboard focus the\n          // urlbar, but in any case we want to enforce at least one\n          // notification when the user focuses it with the mouse.\n          let whichNotification = this.whichSearchSuggestionsNotification;\n          if (whichNotification == \"opt-out\" &&\n              this._showSearchSuggestionNotificationOnMouseFocus === undefined) {\n            this._showSearchSuggestionNotificationOnMouseFocus = true;\n          }\n\n          // Check whether the focus change came from a keyboard/mouse action.\n          let focusMethod = Services.focus.getLastFocusMethod(window);\n          // If it's a focus started by code and the primary user intention was\n          // not to go to the location bar, don't show a notification.\n          if (!focusMethod && !this.userInitiatedFocus) {\n            return;\n          }\n\n          let mouseFocused = !!(focusMethod & Services.focus.FLAG_BYMOUSE);\n          this.maybeShowSearchSuggestionsNotificationOnFocus(mouseFocused);\n        }\n      ]]></handler>\n\n      <handler event=\"blur\"><![CDATA[\n        if (event.originalTarget == this.inputField) {\n          this._clearNoActions();\n          this.formatValue();\n          if (this.getAttribute(\"pageproxystate\") != \"valid\") {\n            UpdatePopupNotificationsVisibility();\n          }\n        }\n        if (this.ExtensionSearchHandler.hasActiveInputSession()) {\n          this.ExtensionSearchHandler.handleInputCancelled();\n        }\n        if (this._deferredKeyEventTimeout) {\n          clearTimeout(this._deferredKeyEventTimeout);\n          this._deferredKeyEventTimeout = null;\n        }\n        this._deferredKeyEventQueue = [];\n      ]]></handler>\n\n      <handler event=\"dragstart\" phase=\"capturing\"><![CDATA[\n        // Drag only if the gesture starts from the input field.\n        if (this.inputField != event.originalTarget &&\n            !(this.inputField.compareDocumentPosition(event.originalTarget) &\n              Node.DOCUMENT_POSITION_CONTAINED_BY))\n          return;\n\n        // Drag only if the entire value is selected and it's a valid URI.\n        var isFullSelection = this.selectionStart == 0 &&\n                              this.selectionEnd == this.textLength;\n        if (!isFullSelection ||\n            this.getAttribute(\"pageproxystate\") != \"valid\")\n          return;\n\n        var urlString = gBrowser.selectedBrowser.currentURI.displaySpec;\n        var title = gBrowser.selectedBrowser.contentTitle || urlString;\n        var htmlString = \"<a href=\\\"\" + urlString + \"\\\">\" + urlString + \"</a>\";\n\n        var dt = event.dataTransfer;\n        dt.setData(\"text/x-moz-url\", urlString + \"\\n\" + title);\n        dt.setData(\"text/unicode\", urlString);\n        dt.setData(\"text/html\", htmlString);\n\n        dt.effectAllowed = \"copyLink\";\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\" phase=\"capturing\" action=\"this.onDragOver(event, this);\"/>\n      <handler event=\"drop\" phase=\"capturing\" action=\"this.onDrop(event, this);\"/>\n      <handler event=\"select\"><![CDATA[\n        if (!Cc[\"@mozilla.org/widget/clipboard;1\"]\n               .getService(Ci.nsIClipboard)\n               .supportsSelectionClipboard())\n          return;\n\n        if (!window.windowUtils.isHandlingUserInput)\n          return;\n\n        var val = this._getSelectedValueForClipboard();\n        if (!val)\n          return;\n\n        Cc[\"@mozilla.org/widget/clipboardhelper;1\"]\n          .getService(Ci.nsIClipboardHelper)\n          .copyStringToClipboard(val, Ci.nsIClipboard.kSelectionClipboard);\n      ]]></handler>\n    </handlers>\n\n  </binding>\n\n  <binding id=\"urlbar-rich-result-popup\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup\">\n\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\"\n             aria-owns=\"richlistbox\">\n      <xul:deck anonid=\"search-suggestions-notification\"\n                align=\"center\"\n                role=\"alert\"\n                selectedIndex=\"0\">\n        <!-- OPT-OUT -->\n        <xul:hbox flex=\"1\" align=\"center\" anonid=\"search-suggestions-opt-out\">\n          <xul:image class=\"ac-site-icon\" type=\"searchengine\"/>\n          <xul:hbox anonid=\"search-suggestions-hint-typing\">\n            <xul:description class=\"ac-title-text\">FROM-DTD.brandShortName;</xul:description>\n          </xul:hbox>\n          <xul:hbox anonid=\"search-suggestions-hint-box\" flex=\"1\">\n            <xul:description id=\"search-suggestions-hint\">\n              <html:span class=\"prefix\">&#x1f4a1; FROM-DTD.urlbar.searchSuggestionsNotification.hintPrefix;</html:span>\n              <html:span>FROM-DTD.urlbar.searchSuggestionsNotification.hint;</html:span>\n            </xul:description>\n          </xul:hbox>\n          <xul:label id=\"search-suggestions-change-settings\"\n                     class=\"text-link\"\n                     role=\"link\"\n\n                     value=\"FROM-DTD.urlbar.searchSuggestionsNotification.changeSettingsWin;\"\n                     accesskey=\"FROM-DTD.urlbar.searchSuggestionsNotification.changeSettingsWin.accesskey;\"\n\n                     onclick=\"openPreferences('paneSearch', {origin: 'searchChangeSettings'});\"\n                     control=\"search-suggestions-change-settings\"/>\n        </xul:hbox>\n      </xul:deck>\n      <xul:richlistbox anonid=\"richlistbox\" class=\"autocomplete-richlistbox\"\n                       flex=\"1\"/>\n      <xul:hbox anonid=\"footer\">\n        <children/>\n        <xul:vbox anonid=\"one-off-search-buttons\"\n                  class=\"search-one-offs\"\n                  compact=\"true\"\n                  includecurrentengine=\"true\"\n                  disabletab=\"true\"\n                  flex=\"1\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <!--\n        For performance reasons we want to limit the size of the text runs we\n        build and show to the user.\n      -->\n      <field name=\"textRunsMaxLen\">255</field>\n\n      <field name=\"_maxResults\">0</field>\n\n      <field name=\"_bundle\" readonly=\"true\">\n        Cc[\"@mozilla.org/intl/stringbundle;1\"].\n          getService(Ci.nsIStringBundleService).\n          createBundle(\"chrome://browser/locale/places/places.properties\");\n      </field>\n\n      <field name=\"searchSuggestionsNotification\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(\n          this, \"anonid\", \"search-suggestions-notification\"\n        );\n      </field>\n\n      <field name=\"footer\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"footer\");\n      </field>\n\n      <field name=\"shrinkDelay\" readonly=\"true\">\n        250\n      </field>\n\n      <field name=\"oneOffSearchButtons\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"one-off-search-buttons\");\n      </field>\n\n      <field name=\"_oneOffSearchesEnabled\">false</field>\n\n      <field name=\"_overrideValue\">null</field>\n      <property name=\"overrideValue\"\n                onget=\"return this._overrideValue;\"\n                onset=\"this._overrideValue = val; return val;\"/>\n\n      <method name=\"onPopupClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.button == 2) {\n            // Ignore right-clicks.\n            return;\n          }\n          // Otherwise \"call super\" -- do what autocomplete-base-popup does.\n          this.input.controller.handleEnter(true, aEvent);\n        ]]></body>\n      </method>\n\n      <property name=\"oneOffSearchesEnabled\">\n        <getter><![CDATA[\n          return this._oneOffSearchesEnabled;\n        ]]></getter>\n        <setter><![CDATA[\n          this._oneOffSearchesEnabled = !!val;\n          if (val) {\n            this.oneOffSearchButtons.telemetryOrigin = \"urlbar\";\n            this.oneOffSearchButtons.style.display = \"-moz-box\";\n            // Set .textbox first, since the popup setter will cause\n            // a _rebuild call that uses it.\n            this.oneOffSearchButtons.textbox = this.input;\n            this.oneOffSearchButtons.popup = this;\n          } else {\n            this.oneOffSearchButtons.telemetryOrigin = null;\n            this.oneOffSearchButtons.style.display = \"none\";\n            this.oneOffSearchButtons.textbox = null;\n            this.oneOffSearchButtons.popup = null;\n          }\n          return this._oneOffSearchesEnabled;\n        ]]></setter>\n      </property>\n\n      <!-- Override this so that navigating between items results in an item\n           always being selected. -->\n      <method name=\"getNextIndex\">\n        <parameter name=\"reverse\"/>\n        <parameter name=\"amount\"/>\n        <parameter name=\"index\"/>\n        <parameter name=\"maxRow\"/>\n        <body><![CDATA[\n          if (maxRow < 0)\n            return -1;\n\n          let newIndex = index + (reverse ? -1 : 1) * amount;\n\n          // We only want to wrap if navigation is in any direction by one item,\n          // otherwise we clamp to one end of the list.\n          // ie, hitting page-down will only cause is to wrap if we're already\n          // at one end of the list.\n\n          // Allow the selection to be removed if the first result is not a\n          // heuristic result.\n          if (!this._isFirstResultHeuristic) {\n            if (reverse && index == -1 || newIndex > maxRow && index != maxRow)\n              newIndex = maxRow;\n            else if (!reverse && index == -1 || newIndex < 0 && index != 0)\n              newIndex = 0;\n\n            if (newIndex < 0 && index == 0 || newIndex > maxRow && index == maxRow)\n              newIndex = -1;\n\n            return newIndex;\n          }\n\n          // Otherwise do not allow the selection to be removed.\n          if (newIndex < 0) {\n            newIndex = index > 0 ? 0 : maxRow;\n          } else if (newIndex > maxRow) {\n            newIndex = index < maxRow ? maxRow : 0;\n          }\n          return newIndex;\n        ]]></body>\n      </method>\n\n      <property name=\"_isFirstResultHeuristic\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            // The popup usually has a special \"heuristic\" first result (added\n            // by UnifiedComplete.js) that is automatically selected when the\n            // popup opens.\n            return this.input.mController.matchCount > 0 &&\n                   this.input.mController\n                             .getStyleAt(0)\n                             .split(/\\s+/).indexOf(\"heuristic\") > 0;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"maxResults\">\n        <getter>\n          <![CDATA[\n            if (!this._maxResults) {\n              this._maxResults = Services.prefs.getIntPref(\"browser.urlbar.maxRichResults\");\n            }\n            return this._maxResults;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            return this._maxResults = parseInt(val);\n          ]]>\n        </setter>\n      </property>\n\n      <!-- This is set either to undefined or to a new object containing\n           { start, end } margin values in pixels. These are used to align the\n           results to the input field. -->\n      <property name=\"margins\"\n                onget=\"return this._margins;\">\n        <setter>\n          <![CDATA[\n          this._margins = val;\n\n          if (val) {\n            /* eslint-disable no-multi-spaces */\n            let paddingInCSS =\n                3   // .autocomplete-richlistbox padding-left/right\n              + 6   // .ac-site-icon margin-inline-start\n              + 16  // .ac-site-icon width\n              + 6;  // .ac-site-icon margin-inline-end\n            /* eslint-enable no-multi-spaces */\n            let actualVal = Math.round(val.start) - paddingInCSS;\n            let actualValEnd = Math.round(val.end);\n            this.style.setProperty(\"--item-padding-start\", actualVal + \"px\");\n            this.style.setProperty(\"--item-padding-end\", actualValEnd + \"px\");\n          } else {\n            this.style.removeProperty(\"--item-padding-start\");\n            this.style.removeProperty(\"--item-padding-end\");\n          }\n\n          return val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          // initially the panel is hidden\n          // to avoid impacting startup / new window performance\n          aInput.popup.hidden = false;\n\n          this._openAutocompletePopup(aInput, aElement);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body><![CDATA[\n          if (this.mPopupOpen) {\n            return;\n          }\n\n          // Set the direction of the popup based on the textbox (bug 649840).\n          // getComputedStyle causes a layout flush, so avoid calling it if a\n          // direction has already been set.\n          if (!this.style.direction) {\n            this.style.direction =\n              aElement.ownerGlobal.getComputedStyle(aElement).direction;\n          }\n          let popupDirection = this.style.direction;\n\n          // Make the popup span the width of the window.  First, set its width.\n          let documentRect =\n            window.windowUtils\n                .getBoundsWithoutFlushing(window.document.documentElement);\n          let width = documentRect.right - documentRect.left;\n          this.setAttribute(\"width\", width);\n\n          // Now make its starting margin negative so that its leading edge\n          // aligns with the window border.\n          let elementRect =\n            window.windowUtils.getBoundsWithoutFlushing(aElement);\n          if (popupDirection == \"rtl\") {\n            let offset = elementRect.right - documentRect.right;\n            this.style.marginRight = offset + \"px\";\n          } else {\n            let offset = documentRect.left - elementRect.left;\n            this.style.marginLeft = offset + \"px\";\n          }\n\n          // Keep the popup items' site icons aligned with the urlbar's identity\n          // icon if it's not too far from the edge of the window.  We define\n          // \"too far\" as \"more than 30% of the window's width AND more than\n          // 250px\".  Do this *before* adding any items because when the new\n          // value of the margins are different from the previous value, over-\n          // and underflow must be handled for each item already in the popup.\n          let needsHandleOverUnderflow = false;\n          let boundToCheck = popupDirection == \"rtl\" ? \"right\" : \"left\";\n          let inputRect = window.windowUtils.getBoundsWithoutFlushing(aInput);\n          let startOffset = Math.abs(inputRect[boundToCheck] - documentRect[boundToCheck]);\n          let alignSiteIcons = startOffset / width <= 0.3 || startOffset <= 250;\n          if (alignSiteIcons) {\n            // Calculate the end margin if we have a start margin.\n            let boundToCheckEnd = popupDirection == \"rtl\" ? \"left\" : \"right\";\n            let endOffset = Math.abs(inputRect[boundToCheckEnd] -\n                                     documentRect[boundToCheckEnd]);\n            if (endOffset > startOffset * 2) {\n              // Provide more space when aligning would result in an unbalanced\n              // margin. This allows the location bar to be moved to the start\n              // of the navigation toolbar to reclaim space for results.\n              endOffset = startOffset;\n            }\n            let identityIcon = document.getElementById(\"identity-icon\");\n            let identityRect =\n              window.windowUtils.getBoundsWithoutFlushing(identityIcon);\n            let start = popupDirection == \"rtl\" ?\n                        documentRect.right - identityRect.right :\n                        identityRect.left;\n            if (!this.margins || start != this.margins.start ||\n                                 endOffset != this.margins.end ||\n                                 width != this.margins.width) {\n              this.margins = { start, end: endOffset, width };\n              needsHandleOverUnderflow = true;\n            }\n          } else if (this.margins) {\n            // Reset the alignment so that the site icons are positioned\n            // according to whatever's in the CSS.\n            this.margins = undefined;\n            needsHandleOverUnderflow = true;\n          }\n\n          // Now that the margins have been set, start adding items (via\n          // _invalidate).\n          this.mInput = aInput;\n          this.input.controller.setInitiallySelectedIndex(this._isFirstResultHeuristic ? 0 : -1);\n          this.input.userSelectionBehavior = \"none\";\n          this._invalidate();\n\n          try {\n            let whichNotification = aInput.whichSearchSuggestionsNotification;\n            if (whichNotification != \"none\") {\n              // Update the impressions count on real popupshown, since there's\n              // no guarantee openPopup will be respected by the platform.\n              // Though, we must ensure the handled event is the expected one.\n              let impressionId = this._searchSuggestionsImpressionId = {};\n              this.addEventListener(\"popupshown\", () => {\n                if (this._searchSuggestionsImpressionId == impressionId)\n                  aInput.updateSearchSuggestionsNotificationImpressions(whichNotification);\n              }, {once: true});\n              this._showSearchSuggestionsNotification(whichNotification, popupDirection);\n            } else if (this.classList.contains(\"showSearchSuggestionsNotification\")) {\n              this._hideSearchSuggestionsNotification();\n            }\n          } catch (ex) {\n            // Not critical for the urlbar functionality, just report the error.\n            Cu.reportError(ex);\n          }\n\n          // Position the popup below the navbar.  To get the y-coordinate,\n          // which is an offset from the bottom of the input, subtract the\n          // bottom of the navbar from the buttom of the input.\n          let yOffset = Math.round(\n            window.windowUtils.getBoundsWithoutFlushing(document.getElementById(\"nav-bar\")).bottom -\n            window.windowUtils.getBoundsWithoutFlushing(aInput).bottom);\n\n          if (!this.richlistbox.suppressMenuItemEvent && this.richlistbox.currentItem) {\n            // The richlistbox fired a DOMMenuItemActive for accessibility,\n            // but because the popup isn't open yet, accessibility will ignore\n            // it. Therefore, fire it again once the popup opens.\n            this.addEventListener(\"popupshown\", () => {\n              this.richlistbox.currentItem._fireEvent(\"DOMMenuItemActive\");\n            }, {once: true});\n          }\n\n          this.openPopup(aElement, \"after_start\", 0, yOffset, false, false);\n\n          // Do this immediately after we've requested the popup to open. This\n          // will cause sync reflows but prevents flickering.\n          if (needsHandleOverUnderflow) {\n            for (let item of this.richlistbox.children) {\n              item.handleOverUnderflow();\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"adjustHeight\">\n        <body>\n          <![CDATA[\n          // If we were going to shrink later, cancel that for now:\n          if (this._shrinkTimeout) {\n            clearTimeout(this._shrinkTimeout);\n            this._shrinkTimeout = null;\n          }\n          let lastRowCount = this._lastRowCount;\n          // Figure out how many rows to show\n          let rows = this.richlistbox.children;\n          this._lastRowCount = rows.length;\n          let numRows = Math.min(this.matchCount, this.maxRows, rows.length);\n\n          // If we're going from 0 to non-0 rows, we might need to remove\n          // the height attribute to allow the popup to size. The attribute\n          // is set from XUL popup management code.\n          if (!lastRowCount && rows.length) {\n            this.removeAttribute(\"height\");\n          }\n\n          // Default the height to 0 if we have no rows to show\n          let height = 0;\n          if (numRows) {\n            if (!this._rowHeight) {\n              window.promiseDocumentFlushed(() => {\n                if (window.closed) {\n                  return;\n                }\n                this._rowHeight = rows[0].getBoundingClientRect().height;\n                let style = window.getComputedStyle(this.richlistbox);\n\n                let paddingTop = parseInt(style.paddingTop) || 0;\n                let paddingBottom = parseInt(style.paddingBottom) || 0;\n                this._rlbPadding = paddingTop + paddingBottom;\n                // Then re-run - but don't dirty layout from inside this callback.\n                window.requestAnimationFrame(() => this.adjustHeight());\n              });\n              return;\n            }\n\n            // Calculate the height to have the first row to last row shown\n            height = (this._rowHeight * numRows) + this._rlbPadding;\n          }\n\n          let animate = this.getAttribute(\"dontanimate\") != \"true\";\n          let currentHeight =\n            parseFloat(this.richlistbox.getAttribute(\"height\"), 10) ||\n            parseFloat(this.richlistbox.style.height, 10) ||\n            0; // It's possible we get here when we haven't set height on the richlistbox\n               // yet, which means parseFloat will return NaN. It should return 0 instead.\n          if (height > currentHeight) {\n            // Grow immediately.\n            if (animate) {\n              this.richlistbox.removeAttribute(\"height\");\n              this.richlistbox.style.height = height + \"px\";\n            } else {\n              this.richlistbox.style.removeProperty(\"height\");\n              this.richlistbox.height = height;\n            }\n          } else if (height < currentHeight) { // Don't shrink if height matches exactly\n            // Delay shrinking to avoid flicker.\n            this._shrinkTimeout = setTimeout(() => {\n              this._collapseUnusedItems();\n              if (animate) {\n                this.richlistbox.removeAttribute(\"height\");\n                this.richlistbox.style.height = height + \"px\";\n              } else {\n                this.richlistbox.style.removeProperty(\"height\");\n                this.richlistbox.height = height;\n              }\n            }, this.shrinkDelay);\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_showSearchSuggestionsNotification\">\n        <parameter name=\"whichNotification\"/>\n        <parameter name=\"popupDirection\"/>\n        <body>\n          <![CDATA[\n          if (whichNotification == \"opt-out\") {\n            if (this.margins) {\n              this.searchSuggestionsNotification.style.paddingInlineStart =\n                this.margins.start + \"px\";\n            } else {\n              this.searchSuggestionsNotification.style.removeProperty(\"padding-inline-start\");\n            }\n\n            // We want to animate the opt-out hint only once.\n            if (!this._firstSearchSuggestionsNotification) {\n              this._firstSearchSuggestionsNotification = true;\n              this.searchSuggestionsNotification.setAttribute(\"animate\", \"true\");\n            }\n          }\n\n          this.searchSuggestionsNotification.setAttribute(\"aria-describedby\",\n                                                          \"search-suggestions-hint\");\n\n          // With the notification shown, the listbox's height can sometimes be\n          // too small when it's flexed, as it normally is.  Also, it can start\n          // out slightly scrolled down.  Both problems appear together, most\n          // often when the popup is very narrow and the notification's text\n          // must wrap.  Work around them by removing the flex.\n          //\n          // But without flexing the listbox, the listbox's height animation\n          // sometimes fails to complete, leaving the popup too tall.  Work\n          // around that problem by disabling the listbox animation.\n          this.richlistbox.flex = 0;\n          this.setAttribute(\"dontanimate\", \"true\");\n\n          this.classList.add(\"showSearchSuggestionsNotification\");\n          // Don't show the one-off buttons if we are showing onboarding and\n          // there's no result, since it would be ugly and pointless.\n          this.footer.collapsed = this.matchCount == 0;\n          this.input.tabScrolling = this.matchCount != 0;\n\n          // This event allows accessibility APIs to see the notification.\n          if (!this.popupOpen) {\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"AlertActive\", true, true);\n            this.searchSuggestionsNotification.dispatchEvent(event);\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_hideSearchSuggestionsNotification\">\n        <body>\n          <![CDATA[\n          this.classList.remove(\"showSearchSuggestionsNotification\");\n          this.richlistbox.flex = 1;\n          this.removeAttribute(\"dontanimate\");\n          this.searchSuggestionsNotification.removeAttribute(\"animate\");\n          if (this.matchCount) {\n            // Update popup height.\n            this._invalidate();\n          } else {\n            this.closePopup();\n          }\n          ]]>\n        </body>\n      </method>\n\n      <!-- This handles keypress changes to the selection among the one-off\n           search buttons and between the one-offs and the listbox.  It returns\n           true if the keypress was consumed and false if not. -->\n      <method name=\"handleKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          this.oneOffSearchButtons.handleKeyPress(aEvent, this.matchCount,\n                                                  !this._isFirstResultHeuristic,\n                                                  gBrowser.userTypedValue);\n          return aEvent.defaultPrevented && !aEvent.urlbarDeferred;\n        ]]></body>\n      </method>\n\n      <!-- This is called when a one-off is clicked and when \"search in new tab\"\n           is selected from a one-off context menu. -->\n      <method name=\"handleOneOffSearch\">\n        <parameter name=\"event\"/>\n        <parameter name=\"engine\"/>\n        <parameter name=\"where\"/>\n        <parameter name=\"params\"/>\n        <body><![CDATA[\n          this.input.handleCommand(event, where, params);\n        ]]></body>\n      </method>\n\n      <!-- Result listitems call this to determine which search engine they\n           should show in their labels and include in their url attributes. -->\n      <property name=\"overrideSearchEngineName\" readonly=\"true\">\n        <getter><![CDATA[\n          let button = this.oneOffSearchButtons.selectedButton;\n          return button && button.engine && button.engine.name;\n        ]]></getter>\n      </property>\n\n      <method name=\"createResultLabel\">\n        <parameter name=\"item\"/>\n        <parameter name=\"proposedLabel\"/>\n        <body>\n          <![CDATA[\n            let parts = [proposedLabel];\n\n            let action = this.input._parseActionUrl(item.getAttribute(\"url\"));\n            if (action) {\n              switch (action.type) {\n              case \"searchengine\":\n                parts = [\n                  action.params.searchSuggestion || action.params.searchQuery,\n                  action.params.engineName,\n                ];\n                break;\n              case \"switchtab\":\n              case \"remotetab\":\n                parts = [\n                  item.getAttribute(\"title\"),\n                  item.getAttribute(\"displayurl\"),\n                ];\n                break;\n              }\n            }\n\n            let types = item.getAttribute(\"type\").split(/\\s+/);\n            let type = types.find(t => t != \"action\" && t != \"heuristic\");\n            try {\n              // Some types intentionally do not map to strings, which is not\n              // an error.\n              parts.push(this._bundle.GetStringFromName(type + \"ResultLabel\"));\n            } catch (e) {}\n\n            return parts.filter(str => str).join(\" \");\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"maybeSetupSpeculativeConnect\">\n        <parameter name=\"aUriString\"/>\n        <body><![CDATA[\n          try {\n            let uri = makeURI(aUriString);\n            Services.io.speculativeConnect2(uri, gBrowser.contentPrincipal, null);\n          } catch (ex) {\n            // Can't setup speculative connection for this uri string for some\n            // reason, just ignore it.\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onResultsAdded\">\n        <body>\n          <![CDATA[\n            // If nothing is selected yet, select the first result if it is a\n            // pre-selected \"heuristic\" result.  (See UnifiedComplete.js.)\n            let selectHeuristic =\n              this.selectedIndex == -1 && this._isFirstResultHeuristic;\n            if (selectHeuristic) {\n              this.input.controller.setInitiallySelectedIndex(0);\n            }\n\n            // If this is the heuristic result of a new search, format its\n            // search alias in the input or remove the formatting of the\n            // previous alias, as necessary.  We need to check selectHeuristic\n            // because the result may have already been added but only now is\n            // being selected, and we need to check gotResultForCurrentQuery\n            // because the result may be from the previous search and already\n            // selected and is now being reused.\n            if (selectHeuristic || !this.input.gotResultForCurrentQuery) {\n              this.input.formatValue();\n            }\n\n            // If this is the first time we get the result from the current\n            // search and we are not in the private context, we can speculatively\n            // connect to the intended site as a performance optimization.\n            if (!this.input.gotResultForCurrentQuery &&\n                this.input.speculativeConnectEnabled &&\n                !this.input.inPrivateContext &&\n                this.input.mController.matchCount > 0) {\n              let firstStyle = this.input.mController.getStyleAt(0);\n              if (firstStyle.includes(\"autofill\")) {\n                let uri = this.input.mController.getFinalCompleteValueAt(0);\n                this.maybeSetupSpeculativeConnect(uri);\n              } else if (firstStyle.includes(\"searchengine\") &&\n                         this.input.browserSearchSuggestEnabled &&\n                         this.input.urlbarSearchSuggestEnabled) {\n                // Preconnect to the current search engine only if the search\n                // suggestions are enabled.\n                let engine = Services.search.currentEngine;\n                engine.speculativeConnect({window,\n                                           originAttributes: gBrowser.contentPrincipal.originAttributes});\n              }\n            }\n\n            // When a result is present the footer should always be visible.\n            this.footer.collapsed = false;\n            this.input.tabScrolling = true;\n\n            this.input.gotResultForCurrentQuery = true;\n            this.input.replaySafeDeferredKeyEvents();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_onSearchBegin\">\n        <body><![CDATA[\n          // Set the selected index to 0 (heuristic) until a result comes back\n          // and we can evaluate it better.\n          //\n          // This is required to properly manage delayed handleEnter:\n          // 1. if a search starts we set selectedIndex to 0 here, and it will\n          //    be updated by onResultsAdded. Since selectedIndex is 0,\n          //    handleEnter will delay the action if a result didn't arrive yet.\n          // 2. if a search doesn't start (for example if autocomplete is\n          //    disabled), this won't be called, and the selectedIndex will be\n          //    the default -1 value. Then handleEnter will know it should not\n          //    delay the action, cause a result wont't ever arrive.\n          this.input.controller.setInitiallySelectedIndex(0);\n\n          // Since we are starting a new search, reset the currently selected\n          // one-off button, to cover those cases where the oneoff buttons\n          // binding won't receive an actual DOM event. For example, a search\n          // could be started without an actual input event, and the popup may\n          // not have been closed from the previous search.\n          this.oneOffSearchButtons.selectedButton = null;\n        ]]></body>\n      </method>\n\n      <field name=\"_addonIframe\">null</field>\n      <field name=\"_addonIframeOwner\">null</field>\n      <field name=\"_addonIframeOverriddenFunctionsByName\">{}</field>\n\n      <!-- These methods must be overridden and properly handled by the API\n           runtime so that it doesn't break the popup.  If any of these methods\n           is not overridden, then initAddonIframe should throw. -->\n      <field name=\"_addonIframeOverrideFunctionNames\">[\n        \"_invalidate\",\n      ]</field>\n\n      <field name=\"_addonIframeHiddenAnonids\">[\n        \"search-suggestions-notification\",\n        \"richlistbox\",\n        \"one-off-search-buttons\",\n      ]</field>\n      <field name=\"_addonIframeHiddenDisplaysByAnonid\">{}</field>\n\n      <method name=\"initAddonIframe\">\n        <parameter name=\"owner\"/>\n        <parameter name=\"overrides\"/>\n        <body><![CDATA[\n          if (this._addonIframeOwner) {\n            // Another add-on has already requested the iframe.  Return null to\n            // signal to the calling add-on that it should not take over the\n            // popup.  First add-on wins for now.\n            return null;\n          }\n          // Make sure all overrides are provided before doing anything.\n          for (let name of this._addonIframeOverrideFunctionNames) {\n            if (typeof(overrides[name]) != \"function\") {\n              throw new Error(\n                \"Override for method '\" + name + \"' must be given\"\n              );\n            }\n          }\n          // OK, insert the iframe.\n          this._addonIframeOwner = owner;\n          this._addonIframe = this._makeAddonIframe();\n          this._addonIframeOverriddenFunctionsByName = {};\n          for (let name of this._addonIframeOverrideFunctionNames) {\n            this._addonIframeOverriddenFunctionsByName[name] = this[name];\n            this[name] = overrides[name];\n          }\n          return this._addonIframe;\n        ]]></body>\n      </method>\n\n      <method name=\"destroyAddonIframe\">\n        <parameter name=\"owner\"/>\n        <body><![CDATA[\n          if (this._addonIframeOwner != owner) {\n            throw new Error(\"You're not the iframe owner\");\n          }\n          this._addonIframeOwner = null;\n          this._addonIframe.remove();\n          this._addonIframe = null;\n          for (let anonid of this._addonIframeHiddenAnonids) {\n            let child = document.getAnonymousElementByAttribute(\n              this, \"anonid\", anonid\n            );\n            child.style.display =\n              this._addonIframeHiddenDisplaysByAnonid[anonid];\n          }\n          for (let name in this._addonIframeOverriddenFunctionsByName) {\n            this[name] = this._addonIframeOverriddenFunctionsByName[name];\n          }\n          this._addonIframeOverriddenFunctionsByName = {};\n        ]]></body>\n      </method>\n\n      <method name=\"_makeAddonIframe\">\n        <body><![CDATA[\n          this._addonIframeHiddenDisplaysByAnonid = {};\n          for (let anonid of this._addonIframeHiddenAnonids) {\n            let child = document.getAnonymousElementByAttribute(\n              this, \"anonid\", anonid\n            );\n            this._addonIframeHiddenDisplaysByAnonid[anonid] =\n              child.style.display;\n            child.style.display = \"none\";\n          }\n          let iframe = document.createXULElement(\"iframe\");\n          iframe.setAttribute(\"type\", \"content\");\n          iframe.setAttribute(\"flex\", \"1\");\n          iframe.style.transition = \"height 100ms\";\n          this.appendChild(iframe);\n          return iframe;\n        ]]></body>\n      </method>\n\n    </implementation>\n    <handlers>\n\n      <handler event=\"SelectedOneOffButtonChanged\"><![CDATA[\n        // Update all searchengine result items to use the newly selected\n        // engine.\n        for (let item of this.richlistbox.children) {\n          if (item.collapsed) {\n            break;\n          }\n          let url = item.getAttribute(\"url\");\n          if (url) {\n            let action = item._parseActionUrl(url);\n            if (action && action.type == \"searchengine\") {\n              item._adjustAcItem();\n            }\n          }\n        }\n\n        // If the selection moved from the results to the one-off settings\n        // button, then call formatValue to remove the formatting of the search\n        // alias in the input, if any.  In all other cases the alias formatting\n        // is removed when the input's value setter calls formatValue, but in\n        // this specific case, at the time that formatValue is called,\n        // oneOffSearchButtons.selectedButton is still null, so the formatting\n        // is not removed.  The settings button is selected right after that.\n        if (this.oneOffSearchButtons.selectedButton ==\n              this.oneOffSearchButtons.settingsButtonCompact &&\n            (!event.detail || !event.detail.previousSelectedButton)) {\n          this.input.formatValue();\n        }\n      ]]></handler>\n\n      <handler event=\"mousedown\"><![CDATA[\n        // Required to make the xul:label.text-link elements in the search\n        // suggestions notification work correctly when clicked on Linux.\n        // This is copied from the mousedown handler in\n        // browser-search-autocomplete-result-popup, which apparently had a\n        // similar problem.\n        event.preventDefault();\n\n        if (event.button == 2) {\n          // Right mouse button currently allows to select.\n          this.input.userSelectionBehavior = \"rightClick\";\n          // Ignore right-clicks.\n          return;\n        }\n\n        if (!this.input.speculativeConnectEnabled) {\n          return;\n        }\n\n        // Ensure the user is clicking on an url instead of other buttons\n        // on the popup.\n        let elt = event.originalTarget;\n        while (elt && elt.localName != \"richlistitem\" && elt != this) {\n          elt = elt.parentNode;\n        }\n        if (!elt || elt.localName != \"richlistitem\") {\n          return;\n        }\n        // The user might click on a ghost entry which was removed because of\n        // the coming new results.\n        if (this.input.controller.matchCount <= this.selectedIndex) {\n          return;\n        }\n\n        let url = this.input.controller.getFinalCompleteValueAt(this.selectedIndex);\n\n        // Whitelist the cases that we want to speculative connect, and ignore\n        // other moz-action uris or fancy protocols.\n        // Note that it's likely we've speculatively connected to the first\n        // url because it is a heuristic \"autofill\" result (see bug 1348275).\n        // \"moz-action:searchengine\" is also the same case. (see bug 1355443)\n        // So we won't duplicate the effort here.\n        if (url.startsWith(\"http\") && this.selectedIndex > 0) {\n          this.maybeSetupSpeculativeConnect(url);\n        } else if (url.startsWith(\"moz-action:remotetab\")) {\n          // URL is in the format moz-action:ACTION,PARAMS\n          // Where PARAMS is a JSON encoded object.\n          const MOZ_ACTION_REGEX = /^moz-action:([^,]+),(.*)$/;\n          if (!MOZ_ACTION_REGEX.test(url))\n            return;\n\n          let params = JSON.parse(url.match(MOZ_ACTION_REGEX)[2]);\n          if (params.url) {\n            this.maybeSetupSpeculativeConnect(decodeURIComponent(params.url));\n          }\n        }\n\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n  <binding id=\"addon-progress-notification\" extends=\"chrome://global/content/bindings/notification.xml#popup-notification\">\n    <implementation>\n      <constructor><![CDATA[\n        if (!this.notification)\n          return;\n\n        this.notification.options.installs.forEach(function(aInstall) {\n          aInstall.addListener(this);\n        }, this);\n\n        // Calling updateProgress can sometimes cause this notification to be\n        // removed in the middle of refreshing the notification panel which\n        // makes the panel get refreshed again. Just initialise to the\n        // undetermined state and then schedule a proper check at the next\n        // opportunity\n        this.setProgress(0, -1);\n        this._updateProgressTimeout = setTimeout(this.updateProgress.bind(this), 0);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        this.destroy();\n      ]]></destructor>\n\n      <field name=\"progressmeter\" readonly=\"true\">\n        document.getElementById(\"addon-progress-notification-progressmeter\");\n      </field>\n      <field name=\"progresstext\" readonly=\"true\">\n        document.getElementById(\"addon-progress-notification-progresstext\");\n      </field>\n      <property name=\"DownloadUtils\" readonly=\"true\">\n        <getter><![CDATA[\n          let module = {};\n          ChromeUtils.import(\"resource://gre/modules/DownloadUtils.jsm\", module);\n          Object.defineProperty(this, \"DownloadUtils\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: module.DownloadUtils,\n          });\n          return module.DownloadUtils;\n        ]]></getter>\n      </property>\n\n      <method name=\"destroy\">\n        <body><![CDATA[\n          if (!this.notification)\n            return;\n\n          this.notification.options.installs.forEach(function(aInstall) {\n            aInstall.removeListener(this);\n          }, this);\n          clearTimeout(this._updateProgressTimeout);\n        ]]></body>\n      </method>\n\n      <method name=\"setProgress\">\n        <parameter name=\"aProgress\"/>\n        <parameter name=\"aMaxProgress\"/>\n        <body><![CDATA[\n          if (aMaxProgress == -1) {\n            this.progressmeter.removeAttribute(\"value\");\n          } else {\n            this.progressmeter.setAttribute(\"value\", (aProgress * 100) / aMaxProgress);\n          }\n\n          let now = Date.now();\n\n          if (!this.notification.lastUpdate) {\n            this.notification.lastUpdate = now;\n            this.notification.lastProgress = aProgress;\n            return;\n          }\n\n          let delta = now - this.notification.lastUpdate;\n          if ((delta < 400) && (aProgress < aMaxProgress))\n            return;\n\n          delta /= 1000;\n\n          // This algorithm is the same used by the downloads code.\n          let speed = (aProgress - this.notification.lastProgress) / delta;\n          if (this.notification.speed)\n            speed = speed * 0.9 + this.notification.speed * 0.1;\n\n          this.notification.lastUpdate = now;\n          this.notification.lastProgress = aProgress;\n          this.notification.speed = speed;\n\n          let status = null;\n          [status, this.notification.last] = this.DownloadUtils.getDownloadStatus(aProgress, aMaxProgress, speed, this.notification.last);\n          this.progresstext.setAttribute(\"value\", status);\n          this.progresstext.setAttribute(\"tooltiptext\", status);\n        ]]></body>\n      </method>\n\n      <method name=\"cancel\">\n        <body><![CDATA[\n          let installs = this.notification.options.installs;\n          installs.forEach(function(aInstall) {\n            try {\n              aInstall.cancel();\n            } catch (e) {\n              // Cancel will throw if the download has already failed\n            }\n          }, this);\n\n          PopupNotifications.remove(this.notification);\n        ]]></body>\n      </method>\n\n      <method name=\"updateProgress\">\n        <body><![CDATA[\n          if (!this.notification)\n            return;\n\n          let downloadingCount = 0;\n          let progress = 0;\n          let maxProgress = 0;\n\n          this.notification.options.installs.forEach(function(aInstall) {\n            if (aInstall.maxProgress == -1)\n              maxProgress = -1;\n            progress += aInstall.progress;\n            if (maxProgress >= 0)\n              maxProgress += aInstall.maxProgress;\n            if (aInstall.state < AddonManager.STATE_DOWNLOADED)\n              downloadingCount++;\n          });\n\n          if (downloadingCount == 0) {\n            this.destroy();\n            this.progressmeter.removeAttribute(\"value\");\n            let status = gNavigatorBundle.getString(\"addonDownloadVerifying\");\n            this.progresstext.setAttribute(\"value\", status);\n            this.progresstext.setAttribute(\"tooltiptext\", status);\n          } else {\n            this.setProgress(progress, maxProgress);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadProgress\">\n        <body><![CDATA[\n          this.updateProgress();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadFailed\">\n        <body><![CDATA[\n          this.updateProgress();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadCancelled\">\n        <body><![CDATA[\n          this.updateProgress();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadEnded\">\n        <body><![CDATA[\n          this.updateProgress();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"toolbar.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"browserToolbarBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"customizableui-toolbar\">\n    <implementation>\n      <constructor><![CDATA[\n          let scope = {};\n          ChromeUtils.import(\"resource:///modules/CustomizableUI.jsm\", scope);\n          let CustomizableUI = scope.CustomizableUI;\n\n          // Searching for the toolbox palette in the toolbar binding because\n          // toolbars are constructed first.\n          let toolbox = this.closest(\"toolbox\");\n          if (toolbox && !toolbox.palette) {\n            for (let node of toolbox.children) {\n              if (node.localName == \"toolbarpalette\") {\n                // Hold on to the palette but remove it from the document.\n                toolbox.palette = node;\n                toolbox.removeChild(node);\n                break;\n              }\n            }\n          }\n\n          // pass the current set of children for comparison with placements:\n          let children = Array.from(this.children)\n                              .filter(node => node.getAttribute(\"skipintoolbarset\") != \"true\" && node.id)\n                              .map(node => node.id);\n          CustomizableUI.registerToolbarNode(this, children);\n      ]]></constructor>\n\n      <property name=\"customizationTarget\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._customizationTarget)\n            return this._customizationTarget;\n\n          let id = this.getAttribute(\"customizationtarget\");\n          if (id)\n            this._customizationTarget = document.getElementById(id);\n\n          if (!this._customizationTarget)\n            this._customizationTarget = this;\n\n          return this._customizationTarget;\n        ]]></getter>\n      </property>\n    </implementation>\n  </binding>\n\n  <!-- The toolbar-drag binding is almost a verbatim copy of its toolkit counterpart,\n       but it inherits from the customizableui's toolbar binding instead of toolkit's.\n       This functionality will move into CustomizableUI proper as part of our move\n       away from XBL. -->\n  <binding id=\"customizableui-toolbar-drag\"\n           extends=\"chrome://browser/content/customizableui/toolbar.xml#customizableui-toolbar\">\n    <implementation>\n      <field name=\"_dragBindingAlive\">true</field>\n      <constructor><![CDATA[\n        if (!this._draggableStarted) {\n          this._draggableStarted = true;\n          try {\n            let tmp = {};\n            ChromeUtils.import(\"resource://gre/modules/WindowDraggingUtils.jsm\", tmp);\n            let draggableThis = new tmp.WindowDraggingElement(this);\n            draggableThis.mouseDownCheck = function(e) {\n              return this._dragBindingAlive;\n            };\n          } catch (e) {}\n        }\n      ]]></constructor>\n    </implementation>\n  </binding>\n\n  <binding id=\"customizableui-toolbarpaletteitem\">\n    <content>\n      <xul:hbox class=\"toolbarpaletteitem-box\">\n        <children/>\n      </xul:hbox>\n      <xul:label class=\"toolbarpaletteitem-label\" xbl:inherits=\"xbl:text=title\"/>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"download.xml","body":"<?xml version=\"1.0\"?>\n<!-- -*- Mode: HTML; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- -->\n<!-- vim: set ts=2 et sw=2 tw=80: -->\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this file,\n   - You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings SYSTEM \"chrome://browser/locale/downloads/downloads.dtd\">\n\n<bindings id=\"downloadBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n  <binding id=\"download-subview-toolbarbutton\"\n           extends=\"chrome://global/content/bindings/button.xml#button-base\">\n    <content>\n      <xul:image class=\"toolbarbutton-icon\" validate=\"always\" xbl:inherits=\"src=image\"/>\n      <xul:vbox class=\"toolbarbutton-text\" flex=\"1\">\n        <xul:label crop=\"end\" xbl:inherits=\"value=label\"/>\n        <xul:label class=\"status-text status-full\" crop=\"end\" xbl:inherits=\"value=status\"/>\n        <xul:label class=\"status-text status-open\" crop=\"end\" xbl:inherits=\"value=openLabel\"/>\n        <xul:label class=\"status-text status-retry\" crop=\"end\" xbl:inherits=\"value=retryLabel\"/>\n        <xul:label class=\"status-text status-show\" crop=\"end\" xbl:inherits=\"value=showLabel\"/>\n      </xul:vbox>\n      <xul:toolbarbutton anonid=\"button\" class=\"action-button\"/>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"menu.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- import-globals-from controller.js -->\n\n<bindings id=\"placesMenuBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"places-popup-base\"\n           extends=\"chrome://global/content/bindings/popup.xml#popup\">\n    <content>\n      <xul:hbox flex=\"1\">\n        <xul:vbox class=\"menupopup-drop-indicator-bar\" hidden=\"true\">\n          <xul:image class=\"menupopup-drop-indicator\" mousethrough=\"always\"/>\n        </xul:vbox>\n        <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                            smoothscroll=\"false\">\n          <children/>\n        </xul:arrowscrollbox>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n\n      <field name=\"AppConstants\" readonly=\"true\">\n        (ChromeUtils.import(\"resource://gre/modules/AppConstants.jsm\", {})).AppConstants;\n      </field>\n\n      <field name=\"_indicatorBar\">\n        document.getAnonymousElementByAttribute(this, \"class\",\n                                                \"menupopup-drop-indicator-bar\");\n      </field>\n\n      <field name=\"_scrollBox\">\n        document.getAnonymousElementByAttribute(this, \"class\",\n                                                \"popup-internal-box\");\n      </field>\n\n      <!-- This is the view that manage the popup -->\n      <field name=\"_rootView\">PlacesUIUtils.getViewForNode(this);</field>\n\n      <!-- Check if we should hide the drop indicator for the target -->\n      <method name=\"_hideDropIndicator\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let target = aEvent.target;\n\n          // Don't draw the drop indicator outside of markers or if current\n          // node is not a Places node.\n          let betweenMarkers =\n            (this._startMarker.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_FOLLOWING) &&\n            (this._endMarker.compareDocumentPosition(target) & Node.DOCUMENT_POSITION_PRECEDING);\n\n          // Hide the dropmarker if current node is not a Places node.\n          return !(target && target._placesNode && betweenMarkers);\n        ]]></body>\n      </method>\n\n      <!-- This function returns information about where to drop when\n           dragging over this popup insertion point -->\n      <method name=\"_getDropPoint\">\n        <parameter name=\"aEvent\"/>\n          <body><![CDATA[\n            // Can't drop if the menu isn't a folder\n            let resultNode = this._placesNode;\n\n            if (!PlacesUtils.nodeIsFolder(resultNode) ||\n                this._rootView.controller.disallowInsertion(resultNode)) {\n              return null;\n            }\n\n            var dropPoint = { ip: null, folderElt: null };\n\n            // The element we are dragging over\n            let elt = aEvent.target;\n            if (elt.localName == \"menupopup\")\n              elt = elt.parentNode;\n\n            // Calculate positions taking care of arrowscrollbox\n            let scrollbox = this._scrollBox;\n            let eventY = aEvent.layerY + (scrollbox.boxObject.y - this.boxObject.y);\n            let scrollboxOffset = scrollbox.scrollBoxObject.y -\n                                  (scrollbox.boxObject.y - this.boxObject.y);\n            let eltY = elt.boxObject.y - scrollboxOffset;\n            let eltHeight = elt.boxObject.height;\n\n            if (!elt._placesNode) {\n              // If we are dragging over a non places node drop at the end.\n              dropPoint.ip = new PlacesInsertionPoint({\n                parentId: PlacesUtils.getConcreteItemId(resultNode),\n                parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n              });\n              // We can set folderElt if we are dropping over a static menu that\n              // has an internal placespopup.\n              let isMenu = elt.localName == \"menu\" ||\n                 (elt.localName == \"toolbarbutton\" &&\n                  elt.getAttribute(\"type\") == \"menu\");\n              if (isMenu && elt.lastElementChild &&\n                  elt.lastElementChild.hasAttribute(\"placespopup\"))\n                dropPoint.folderElt = elt;\n              return dropPoint;\n            }\n\n            let tagName = PlacesUtils.nodeIsTagQuery(elt._placesNode) ?\n                            elt._placesNode.title : null;\n            if ((PlacesUtils.nodeIsFolder(elt._placesNode) &&\n                 !PlacesUIUtils.isFolderReadOnly(elt._placesNode, this._rootView)) ||\n                PlacesUtils.nodeIsTagQuery(elt._placesNode)) {\n              // This is a folder or a tag container.\n              if (eventY - eltY < eltHeight * 0.20) {\n                // If mouse is in the top part of the element, drop above folder.\n                dropPoint.ip = new PlacesInsertionPoint({\n                  parentId: PlacesUtils.getConcreteItemId(resultNode),\n                  parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n                  orientation: Ci.nsITreeView.DROP_BEFORE,\n                  tagName,\n                  dropNearNode: elt._placesNode,\n                });\n                return dropPoint;\n              } else if (eventY - eltY < eltHeight * 0.80) {\n                // If mouse is in the middle of the element, drop inside folder.\n                dropPoint.ip = new PlacesInsertionPoint({\n                  parentId: PlacesUtils.getConcreteItemId(elt._placesNode),\n                  parentGuid: PlacesUtils.getConcreteItemGuid(elt._placesNode),\n                  tagName,\n                });\n                dropPoint.folderElt = elt;\n                return dropPoint;\n              }\n            } else if (eventY - eltY <= eltHeight / 2) {\n              // This is a non-folder node or a readonly folder.\n              // If the mouse is above the middle, drop above this item.\n              dropPoint.ip = new PlacesInsertionPoint({\n                parentId: PlacesUtils.getConcreteItemId(resultNode),\n                parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n                orientation: Ci.nsITreeView.DROP_BEFORE,\n                tagName,\n                dropNearNode: elt._placesNode,\n              });\n              return dropPoint;\n            }\n\n            // Drop below the item.\n            dropPoint.ip = new PlacesInsertionPoint({\n              parentId: PlacesUtils.getConcreteItemId(resultNode),\n              parentGuid: PlacesUtils.getConcreteItemGuid(resultNode),\n              orientation: Ci.nsITreeView.DROP_AFTER,\n              tagName,\n              dropNearNode: elt._placesNode,\n            });\n            return dropPoint;\n        ]]></body>\n      </method>\n\n      <!-- Sub-menus should be opened when the mouse drags over them, and closed\n           when the mouse drags off.  The overFolder object manages opening and\n           closing of folders when the mouse hovers. -->\n      <field name=\"_overFolder\"><![CDATA[({\n        _self: this,\n        _folder: {elt: null,\n                  openTimer: null,\n                  hoverTime: 350,\n                  closeTimer: null},\n        _closeMenuTimer: null,\n\n        get elt() {\n          return this._folder.elt;\n        },\n        set elt(val) {\n          return this._folder.elt = val;\n        },\n\n        get openTimer() {\n          return this._folder.openTimer;\n        },\n        set openTimer(val) {\n          return this._folder.openTimer = val;\n        },\n\n        get hoverTime() {\n          return this._folder.hoverTime;\n        },\n        set hoverTime(val) {\n          return this._folder.hoverTime = val;\n        },\n\n        get closeTimer() {\n          return this._folder.closeTimer;\n        },\n        set closeTimer(val) {\n          return this._folder.closeTimer = val;\n        },\n\n        get closeMenuTimer() {\n          return this._closeMenuTimer;\n        },\n        set closeMenuTimer(val) {\n          return this._closeMenuTimer = val;\n        },\n\n        setTimer: function OF__setTimer(aTime) {\n          var timer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n          timer.initWithCallback(this, aTime, timer.TYPE_ONE_SHOT);\n          return timer;\n        },\n\n        notify: function OF__notify(aTimer) {\n          // Function to process all timer notifications.\n\n          if (aTimer == this._folder.openTimer) {\n            // Timer to open a submenu that's being dragged over.\n            this._folder.elt.lastElementChild.setAttribute(\"autoopened\", \"true\");\n            this._folder.elt.lastElementChild.openPopup();\n            this._folder.openTimer = null;\n          } else if (aTimer == this._folder.closeTimer) {\n            // Timer to close a submenu that's been dragged off of.\n            // Only close the submenu if the mouse isn't being dragged over any\n            // of its child menus.\n            var draggingOverChild = PlacesControllerDragHelper\n                                    .draggingOverChildNode(this._folder.elt);\n            if (draggingOverChild)\n              this._folder.elt = null;\n            this.clear();\n\n            // Close any parent folders which aren't being dragged over.\n            // (This is necessary because of the above code that keeps a folder\n            // open while its children are being dragged over.)\n            if (!draggingOverChild)\n              this.closeParentMenus();\n          } else if (aTimer == this.closeMenuTimer) {\n            // Timer to close this menu after the drag exit.\n            var popup = this._self;\n            // if we are no more dragging we can leave the menu open to allow\n            // for better D&D bookmark organization\n            if (PlacesControllerDragHelper.getSession() &&\n                !PlacesControllerDragHelper.draggingOverChildNode(popup.parentNode)) {\n              popup.hidePopup();\n              // Close any parent menus that aren't being dragged over;\n              // otherwise they'll stay open because they couldn't close\n              // while this menu was being dragged over.\n              this.closeParentMenus();\n            }\n            this._closeMenuTimer = null;\n          }\n        },\n\n        //  Helper function to close all parent menus of this menu,\n        //  as long as none of the parent's children are currently being\n        //  dragged over.\n        closeParentMenus: function OF__closeParentMenus() {\n          var popup = this._self;\n          var parent = popup.parentNode;\n          while (parent) {\n            if (parent.localName == \"menupopup\" && parent._placesNode) {\n              if (PlacesControllerDragHelper.draggingOverChildNode(parent.parentNode))\n                break;\n              parent.hidePopup();\n            }\n            parent = parent.parentNode;\n          }\n        },\n\n        //  The mouse is no longer dragging over the stored menubutton.\n        //  Close the menubutton, clear out drag styles, and clear all\n        //  timers for opening/closing it.\n        clear: function OF__clear() {\n          if (this._folder.elt && this._folder.elt.lastElementChild) {\n            if (!this._folder.elt.lastElementChild.hasAttribute(\"dragover\"))\n              this._folder.elt.lastElementChild.hidePopup();\n            // remove menuactive style\n            this._folder.elt.removeAttribute(\"_moz-menuactive\");\n            this._folder.elt = null;\n          }\n          if (this._folder.openTimer) {\n            this._folder.openTimer.cancel();\n            this._folder.openTimer = null;\n          }\n          if (this._folder.closeTimer) {\n            this._folder.closeTimer.cancel();\n            this._folder.closeTimer = null;\n          }\n        },\n      })]]></field>\n\n      <method name=\"_cleanupDragDetails\">\n        <body><![CDATA[\n          // Called on dragend and drop.\n          PlacesControllerDragHelper.currentDropTarget = null;\n          this._rootView._draggedElt = null;\n          this.removeAttribute(\"dragover\");\n          this.removeAttribute(\"dragstart\");\n          this._indicatorBar.hidden = true;\n        ]]></body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"DOMMenuItemActive\"><![CDATA[\n        let elt = event.target;\n        if (elt.parentNode != this)\n          return;\n\n        if (this.AppConstants.platform === \"macosx\") {\n          // XXX: The following check is a temporary hack until bug 420033 is\n          // resolved.\n          let parentElt = elt.parent;\n          while (parentElt) {\n            if (parentElt.id == \"bookmarksMenuPopup\" ||\n                parentElt.id == \"goPopup\")\n              return;\n\n            parentElt = parentElt.parentNode;\n          }\n        }\n\n        if (window.XULBrowserWindow) {\n          let placesNode = elt._placesNode;\n\n          var linkURI;\n          if (placesNode && PlacesUtils.nodeIsURI(placesNode))\n            linkURI = placesNode.uri;\n          else if (elt.hasAttribute(\"targetURI\"))\n            linkURI = elt.getAttribute(\"targetURI\");\n\n          if (linkURI)\n            window.XULBrowserWindow.setOverLink(linkURI, null);\n        }\n      ]]></handler>\n\n      <handler event=\"DOMMenuItemInactive\"><![CDATA[\n        let elt = event.target;\n        if (elt.parentNode != this)\n          return;\n\n        if (window.XULBrowserWindow)\n          window.XULBrowserWindow.setOverLink(\"\", null);\n      ]]></handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        let elt = event.target;\n        if (!elt._placesNode)\n          return;\n\n        let draggedElt = elt._placesNode;\n\n        // Force a copy action if parent node is a query or we are dragging a\n        // not-removable node.\n        if (!this._rootView.controller.canMoveNode(draggedElt))\n          event.dataTransfer.effectAllowed = \"copyLink\";\n\n        // Activate the view and cache the dragged element.\n        this._rootView._draggedElt = draggedElt;\n        this._rootView.controller.setDataTransfer(event);\n        this.setAttribute(\"dragstart\", \"true\");\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"drop\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = event.target;\n\n        let dropPoint = this._getDropPoint(event);\n        if (dropPoint && dropPoint.ip) {\n          PlacesControllerDragHelper.onDrop(dropPoint.ip, event.dataTransfer)\n                                    .catch(Cu.reportError);\n          event.preventDefault();\n        }\n\n        this._cleanupDragDetails();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = event.target;\n        let dt = event.dataTransfer;\n\n        let dropPoint = this._getDropPoint(event);\n        if (!dropPoint || !dropPoint.ip ||\n            !PlacesControllerDragHelper.canDrop(dropPoint.ip, dt)) {\n          this._indicatorBar.hidden = true;\n          event.stopPropagation();\n          return;\n        }\n\n        // Mark this popup as being dragged over.\n        this.setAttribute(\"dragover\", \"true\");\n\n        if (dropPoint.folderElt) {\n          // We are dragging over a folder.\n          // _overFolder should take the care of opening it on a timer.\n          if (this._overFolder.elt &&\n              this._overFolder.elt != dropPoint.folderElt) {\n            // We are dragging over a new folder, let's clear old values\n            this._overFolder.clear();\n          }\n          if (!this._overFolder.elt) {\n            this._overFolder.elt = dropPoint.folderElt;\n            // Create the timer to open this folder.\n            this._overFolder.openTimer = this._overFolder\n                                             .setTimer(this._overFolder.hoverTime);\n          }\n          // Since we are dropping into a folder set the corresponding style.\n          dropPoint.folderElt.setAttribute(\"_moz-menuactive\", true);\n        } else {\n          // We are not dragging over a folder.\n          // Clear out old _overFolder information.\n          this._overFolder.clear();\n        }\n\n        // Autoscroll the popup strip if we drag over the scroll buttons.\n        let anonid = event.originalTarget.getAttribute(\"anonid\");\n        let scrollDir = 0;\n        if (anonid == \"scrollbutton-up\") {\n          scrollDir = -1;\n        } else if (anonid == \"scrollbutton-down\") {\n          scrollDir = 1;\n        }\n        if (scrollDir != 0) {\n          this._scrollBox.scrollByIndex(scrollDir, true);\n        }\n\n        // Check if we should hide the drop indicator for this target.\n        if (dropPoint.folderElt || this._hideDropIndicator(event)) {\n          this._indicatorBar.hidden = true;\n          event.preventDefault();\n          event.stopPropagation();\n          return;\n        }\n\n        // We should display the drop indicator relative to the arrowscrollbox.\n        let scrollbox = this._scrollBox.scrollBoxObject;\n        let newMarginTop = 0;\n        if (scrollDir == 0) {\n          let elt = this.firstElementChild;\n          while (elt && event.screenY > elt.boxObject.screenY +\n                                        elt.boxObject.height / 2)\n            elt = elt.nextElementSibling;\n          newMarginTop = elt ? elt.boxObject.screenY - scrollbox.screenY :\n                               scrollbox.height;\n        } else if (scrollDir == 1)\n          newMarginTop = scrollbox.height;\n\n        // Set the new marginTop based on arrowscrollbox.\n        newMarginTop += scrollbox.y - this._scrollBox.boxObject.y;\n        this._indicatorBar.firstElementChild.style.marginTop = newMarginTop + \"px\";\n        this._indicatorBar.hidden = false;\n\n        event.preventDefault();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragexit\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = null;\n        this.removeAttribute(\"dragover\");\n\n        // If we have not moved to a valid new target clear the drop indicator\n        // this happens when moving out of the popup.\n        let target = event.relatedTarget;\n        if (!target || !this.contains(target))\n          this._indicatorBar.hidden = true;\n\n        // Close any folder being hovered over\n        if (this._overFolder.elt) {\n          this._overFolder.closeTimer = this._overFolder\n                                            .setTimer(this._overFolder.hoverTime);\n        }\n\n        // The autoopened attribute is set when this folder was automatically\n        // opened after the user dragged over it.  If this attribute is set,\n        // auto-close the folder on drag exit.\n        // We should also try to close this popup if the drag has started\n        // from here, the timer will check if we are dragging over a child.\n        if (this.hasAttribute(\"autoopened\") ||\n            this.hasAttribute(\"dragstart\")) {\n          this._overFolder.closeMenuTimer = this._overFolder\n                                                .setTimer(this._overFolder.hoverTime);\n        }\n\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragend\"><![CDATA[\n        this._cleanupDragDetails();\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n  <!-- Most of this is copied from the arrowpanel binding in popup.xml -->\n  <binding id=\"places-popup-arrow\"\n           extends=\"chrome://browser/content/places/menu.xml#places-popup-base\">\n    <content flip=\"both\" side=\"top\" position=\"bottomcenter topright\">\n      <xul:vbox anonid=\"container\" class=\"panel-arrowcontainer\" flex=\"1\"\n               xbl:inherits=\"side,panelopen\">\n        <xul:box anonid=\"arrowbox\" class=\"panel-arrowbox\">\n          <xul:image anonid=\"arrow\" class=\"panel-arrow\" xbl:inherits=\"side\"/>\n        </xul:box>\n        <xul:box class=\"panel-arrowcontent\" xbl:inherits=\"side,align,dir,orient,pack\" flex=\"1\">\n          <xul:vbox class=\"menupopup-drop-indicator-bar\" hidden=\"true\">\n            <xul:image class=\"menupopup-drop-indicator\" mousethrough=\"always\"/>\n          </xul:vbox>\n          <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                              smoothscroll=\"false\">\n            <children/>\n          </xul:arrowscrollbox>\n        </xul:box>\n      </xul:vbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this.style.pointerEvents = \"none\";\n      ]]></constructor>\n      <method name=\"adjustArrowPosition\">\n        <body><![CDATA[\n          var arrow = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrow\");\n\n          var anchor = this.anchorNode;\n          if (!anchor) {\n            arrow.hidden = true;\n            return;\n          }\n\n          var container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n          var arrowbox = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\");\n\n          var position = this.alignmentPosition;\n          var offset = this.alignmentOffset;\n\n          this.setAttribute(\"arrowposition\", position);\n\n          // if this panel has a \"sliding\" arrow, we may have previously set margins...\n          arrowbox.style.removeProperty(\"transform\");\n          if (position.indexOf(\"start_\") == 0 || position.indexOf(\"end_\") == 0) {\n            container.orient = \"horizontal\";\n            arrowbox.orient = \"vertical\";\n            if (position.indexOf(\"_after\") > 0) {\n              arrowbox.pack = \"end\";\n            } else {\n              arrowbox.pack = \"start\";\n            }\n            arrowbox.style.transform = \"translate(0, \" + -offset + \"px)\";\n\n            // The assigned side stays the same regardless of direction.\n            var isRTL = (window.getComputedStyle(this).direction == \"rtl\");\n\n            if (position.indexOf(\"start_\") == 0) {\n              container.dir = \"reverse\";\n              this.setAttribute(\"side\", isRTL ? \"left\" : \"right\");\n            } else {\n              container.dir = \"\";\n              this.setAttribute(\"side\", isRTL ? \"right\" : \"left\");\n            }\n          } else if (position.indexOf(\"before_\") == 0 || position.indexOf(\"after_\") == 0) {\n            container.orient = \"\";\n            arrowbox.orient = \"\";\n            if (position.indexOf(\"_end\") > 0) {\n              arrowbox.pack = \"end\";\n            } else {\n              arrowbox.pack = \"start\";\n            }\n            arrowbox.style.transform = \"translate(\" + -offset + \"px, 0)\";\n\n            if (position.indexOf(\"before_\") == 0) {\n              container.dir = \"reverse\";\n              this.setAttribute(\"side\", \"bottom\");\n            } else {\n              container.dir = \"\";\n              this.setAttribute(\"side\", \"top\");\n            }\n          }\n\n          arrow.hidden = false;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\"><![CDATA[\n        this.adjustArrowPosition();\n        this.setAttribute(\"animate\", \"open\");\n      ]]></handler>\n      <handler event=\"popupshown\" phase=\"target\"><![CDATA[\n        this.setAttribute(\"panelopen\", \"true\");\n        let disablePointerEvents;\n        if (!this.hasAttribute(\"disablepointereventsfortransition\")) {\n          let container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n          let cs = getComputedStyle(container);\n          let transitionProp = cs.transitionProperty;\n          let transitionTime = parseFloat(cs.transitionDuration);\n          disablePointerEvents = (transitionProp.includes(\"transform\") ||\n                                  transitionProp == \"all\") &&\n                                 transitionTime > 0;\n          this.setAttribute(\"disablepointereventsfortransition\", disablePointerEvents);\n        } else {\n          disablePointerEvents = this.getAttribute(\"disablepointereventsfortransition\") == \"true\";\n        }\n        if (!disablePointerEvents) {\n          this.style.removeProperty(\"pointer-events\");\n        }\n      ]]></handler>\n      <handler event=\"transitionend\"><![CDATA[\n        if (event.originalTarget.getAttribute(\"anonid\") == \"container\" &&\n            (event.propertyName == \"transform\" || event.propertyName == \"-moz-window-transform\")) {\n          this.style.removeProperty(\"pointer-events\");\n        }\n      ]]></handler>\n      <handler event=\"popuphiding\" phase=\"target\"><![CDATA[\n        this.setAttribute(\"animate\", \"cancel\");\n      ]]></handler>\n      <handler event=\"popuphidden\" phase=\"target\"><![CDATA[\n        this.removeAttribute(\"panelopen\");\n        if (this.getAttribute(\"disablepointereventsfortransition\") == \"true\") {\n          this.style.pointerEvents = \"none\";\n        }\n        this.removeAttribute(\"animate\");\n      ]]></handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"tree.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- import-globals-from controller.js -->\n<!-- import-globals-from treeView.js -->\n\n<bindings id=\"placesTreeBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"places-tree\" extends=\"chrome://global/content/bindings/tree.xml#tree\">\n    <implementation>\n      <constructor><![CDATA[\n        // Force an initial build.\n        if (this.place)\n          this.place = this.place;\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // Break the treeviewer->result->treeviewer cycle.\n        // Note: unsetting the result's viewer also unsets\n        // the viewer's reference to our treeBoxObject.\n        var result = this.result;\n        if (result) {\n          result.root.containerOpen = false;\n        }\n\n        // Unregister the controllber before unlinking the view, otherwise it\n        // may still try to update commands on a view with a null result.\n        if (this._controller) {\n          this._controller.terminate();\n          this.controllers.removeController(this._controller);\n        }\n\n        if (this.view) {\n          this.view.uninit();\n        }\n        this.view = null;\n      ]]></destructor>\n\n      <property name=\"controller\"\n                readonly=\"true\"\n                onget=\"return this._controller\"/>\n\n      <property name=\"disableUserActions\"\n                onget=\"return this.getAttribute('disableUserActions') == 'true';\"\n                onset=\"if (val) this.setAttribute('disableUserActions', 'true');\n                       else this.removeAttribute('disableUserActions'); return val;\"/>\n\n      <!-- overriding -->\n      <property name=\"view\">\n        <getter><![CDATA[\n          try {\n            return this.treeBoxObject.view.wrappedJSObject || null;\n          } catch (e) {\n            return null;\n          }\n        ]]></getter>\n        <setter><![CDATA[\n          return this.treeBoxObject.view = val;\n        ]]></setter>\n      </property>\n\n      <property name=\"associatedElement\"\n                readonly=\"true\"\n                onget=\"return this\"/>\n\n      <method name=\"applyFilter\">\n        <parameter name=\"filterString\"/>\n        <parameter name=\"folderRestrict\"/>\n        <parameter name=\"includeHidden\"/>\n        <body><![CDATA[\n          // preserve grouping\n          var queryNode = PlacesUtils.asQuery(this.result.root);\n          var options = queryNode.queryOptions.clone();\n\n          // Make sure we're getting uri results.\n          // We do not yet support searching into grouped queries or into\n          // tag containers, so we must fall to the default case.\n          if (PlacesUtils.nodeIsHistoryContainer(queryNode) ||\n              PlacesUtils.nodeIsTagQuery(queryNode) ||\n              options.resultType == options.RESULTS_AS_TAGS_ROOT ||\n              options.resultType == options.RESULTS_AS_ROOTS_QUERY)\n            options.resultType = options.RESULTS_AS_URI;\n\n          var query = PlacesUtils.history.getNewQuery();\n          query.searchTerms = filterString;\n\n          if (folderRestrict) {\n            query.setParents(folderRestrict, folderRestrict.length);\n            options.queryType = options.QUERY_TYPE_BOOKMARKS;\n          }\n\n          options.includeHidden = !!includeHidden;\n\n          this.load(query, options);\n        ]]></body>\n      </method>\n\n      <method name=\"load\">\n        <parameter name=\"query\"/>\n        <parameter name=\"options\"/>\n        <body><![CDATA[\n          let result = PlacesUtils.history\n                                  .executeQuery(query, options);\n          let callback;\n          if (this.flatList) {\n            let onOpenFlatContainer = this.onOpenFlatContainer;\n            if (onOpenFlatContainer)\n              callback = new Function(\"aContainer\", onOpenFlatContainer);\n          }\n\n          if (!this._controller) {\n            this._controller = new PlacesController(this);\n            this._controller.disableUserActions = this.disableUserActions;\n            this.controllers.appendController(this._controller);\n          }\n\n          let treeView = new PlacesTreeView(this.flatList, callback, this._controller);\n\n          // Observer removal is done within the view itself.  When the tree\n          // goes away, treeboxobject calls view.setTree(null), which then\n          // calls removeObserver.\n          result.addObserver(treeView);\n          this.view = treeView;\n\n          if (this.getAttribute(\"selectfirstnode\") == \"true\" && treeView.rowCount > 0) {\n            treeView.selection.select(0);\n          }\n\n          this._cachedInsertionPoint = undefined;\n        ]]></body>\n      </method>\n\n      <property name=\"flatList\">\n        <getter><![CDATA[\n          return this.getAttribute(\"flatList\") == \"true\";\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.flatList != val) {\n            this.setAttribute(\"flatList\", val);\n            // reload with the last place set\n            if (this.place)\n              this.place = this.place;\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"onOpenFlatContainer\">\n        <getter><![CDATA[\n          return this.getAttribute(\"onopenflatcontainer\");\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.onOpenFlatContainer != val) {\n            this.setAttribute(\"onopenflatcontainer\", val);\n            // reload with the last place set\n            if (this.place)\n              this.place = this.place;\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <!--\n        Causes a particular node represented by the specified placeURI to be\n        selected in the tree. All containers above the node in the hierarchy\n        will be opened, so that the node is visible.\n        -->\n      <method name=\"selectPlaceURI\">\n        <parameter name=\"placeURI\"/>\n        <body><![CDATA[\n          // Do nothing if a node matching the given uri is already selected\n          if (this.hasSelection && this.selectedNode.uri == placeURI)\n            return;\n\n          function findNode(container, nodesURIChecked) {\n            var containerURI = container.uri;\n            if (containerURI == placeURI)\n              return container;\n            if (nodesURIChecked.includes(containerURI))\n              return null;\n\n            // never check the contents of the same query\n            nodesURIChecked.push(containerURI);\n\n            var wasOpen = container.containerOpen;\n            if (!wasOpen)\n              container.containerOpen = true;\n            for (var i = 0; i < container.childCount; ++i) {\n              var child = container.getChild(i);\n              var childURI = child.uri;\n              if (childURI == placeURI)\n                return child;\n              else if (PlacesUtils.nodeIsContainer(child)) {\n                var nested = findNode(PlacesUtils.asContainer(child), nodesURIChecked);\n                if (nested)\n                  return nested;\n              }\n            }\n\n            if (!wasOpen)\n              container.containerOpen = false;\n\n            return null;\n          }\n\n          var container = this.result.root;\n          console.assert(container, \"No result, cannot select place URI!\");\n          if (!container)\n            return;\n\n          var child = findNode(container, []);\n          if (child)\n            this.selectNode(child);\n          else {\n            // If the specified child could not be located, clear the selection\n            var selection = this.view.selection;\n            selection.clearSelection();\n          }\n        ]]></body>\n      </method>\n\n      <!--\n        Causes a particular node to be selected in the tree, resulting in all\n        containers above the node in the hierarchy to be opened, so that the\n        node is visible.\n        -->\n      <method name=\"selectNode\">\n        <parameter name=\"node\"/>\n        <body><![CDATA[\n          var view = this.view;\n\n          var parent = node.parent;\n          if (parent && !parent.containerOpen) {\n            // Build a list of all of the nodes that are the parent of this one\n            // in the result.\n            var parents = [];\n            var root = this.result.root;\n            while (parent && parent != root) {\n              parents.push(parent);\n              parent = parent.parent;\n            }\n\n            // Walk the list backwards (opening from the root of the hierarchy)\n            // opening each folder as we go.\n            for (var i = parents.length - 1; i >= 0; --i) {\n              let index = view.treeIndexForNode(parents[i]);\n              if (index != -1 &&\n                  view.isContainer(index) && !view.isContainerOpen(index))\n                view.toggleOpenState(index);\n            }\n            // Select the specified node...\n          }\n\n          let index = view.treeIndexForNode(node);\n          if (index == -1)\n            return;\n\n          view.selection.select(index);\n          // ... and ensure it's visible, not scrolled off somewhere.\n          this.treeBoxObject.ensureRowIsVisible(index);\n        ]]></body>\n      </method>\n\n      <!-- nsIPlacesView -->\n      <property name=\"result\">\n        <getter><![CDATA[\n          try {\n            return this.view.QueryInterface(Ci.nsINavHistoryResultObserver).result;\n          } catch (e) {\n            return null;\n          }\n        ]]></getter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"place\">\n        <getter><![CDATA[\n          return this.getAttribute(\"place\");\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"place\", val);\n\n          let query = {}, options = {};\n          PlacesUtils.history.queryStringToQuery(val, query, options);\n          this.load(query.value, options.value);\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"hasSelection\">\n        <getter><![CDATA[\n          return this.view && this.view.selection.count >= 1;\n        ]]></getter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"selectedNodes\">\n        <getter><![CDATA[\n          let nodes = [];\n          if (!this.hasSelection)\n            return nodes;\n\n          let selection = this.view.selection;\n          let rc = selection.getRangeCount();\n          let resultview = this.view;\n          for (let i = 0; i < rc; ++i) {\n            let min = { }, max = { };\n            selection.getRangeAt(i, min, max);\n            for (let j = min.value; j <= max.value; ++j) {\n              nodes.push(resultview.nodeForTreeIndex(j));\n            }\n          }\n          return nodes;\n        ]]></getter>\n      </property>\n\n      <method name=\"toggleCutNode\">\n        <parameter name=\"aNode\"/>\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          this.view.toggleCutNode(aNode, aValue);\n        ]]></body>\n      </method>\n\n      <!-- nsIPlacesView -->\n      <property name=\"removableSelectionRanges\">\n        <getter><![CDATA[\n          // This property exists in addition to selectedNodes because it\n          // encodes selection ranges (which only occur in list views) into\n          // the return value. For each removed range, the index at which items\n          // will be re-inserted upon the remove transaction being performed is\n          // the first index of the range, so that the view updates correctly.\n          //\n          // For example, if we remove rows 2,3,4 and 7,8 from a list, when we\n          // undo that operation, if we insert what was at row 3 at row 3 again,\n          // it will show up _after_ the item that was at row 5. So we need to\n          // insert all items at row 2, and the tree view will update correctly.\n          //\n          // Also, this function collapses the selection to remove redundant\n          // data, e.g. when deleting this selection:\n          //\n          //      http://www.foo.com/\n          //  (-) Some Folder\n          //        http://www.bar.com/\n          //\n          // ... returning http://www.bar.com/ as part of the selection is\n          // redundant because it is implied by removing \"Some Folder\". We\n          // filter out all such redundancies since some partial amount of\n          // the folder's children may be selected.\n          //\n          let nodes = [];\n          if (!this.hasSelection)\n            return nodes;\n\n          var selection = this.view.selection;\n          var rc = selection.getRangeCount();\n          var resultview = this.view;\n          // This list is kept independently of the range selected (i.e. OUTSIDE\n          // the for loop) since the row index of a container is unique for the\n          // entire view, and we could have some really wacky selection and we\n          // don't want to blow up.\n          var containers = { };\n          for (var i = 0; i < rc; ++i) {\n            var range = [];\n            var min = { }, max = { };\n            selection.getRangeAt(i, min, max);\n\n            for (var j = min.value; j <= max.value; ++j) {\n              if (this.view.isContainer(j))\n                containers[j] = true;\n              if (!(this.view.getParentIndex(j) in containers))\n                range.push(resultview.nodeForTreeIndex(j));\n            }\n            nodes.push(range);\n          }\n          return nodes;\n        ]]></getter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"draggableSelection\"\n                onget=\"return this.selectedNodes\"/>\n\n      <!-- nsIPlacesView -->\n      <property name=\"selectedNode\">\n        <getter><![CDATA[\n          var view = this.view;\n          if (!view || view.selection.count != 1)\n            return null;\n\n          var selection = view.selection;\n          var min = { }, max = { };\n          selection.getRangeAt(0, min, max);\n\n          return this.view.nodeForTreeIndex(min.value);\n        ]]></getter>\n      </property>\n\n      <!-- nsIPlacesView -->\n      <property name=\"insertionPoint\">\n        <getter><![CDATA[\n          // invalidated on selection and focus changes\n          if (this._cachedInsertionPoint !== undefined)\n            return this._cachedInsertionPoint;\n\n          // there is no insertion point for history queries\n          // so bail out now and save a lot of work when updating commands\n          var resultNode = this.result.root;\n          if (PlacesUtils.nodeIsQuery(resultNode) &&\n              PlacesUtils.asQuery(resultNode).queryOptions.queryType ==\n                Ci.nsINavHistoryQueryOptions.QUERY_TYPE_HISTORY)\n              return this._cachedInsertionPoint = null;\n\n          var orientation = Ci.nsITreeView.DROP_BEFORE;\n          // If there is no selection, insert at the end of the container.\n          if (!this.hasSelection) {\n            var index = this.view.rowCount - 1;\n            this._cachedInsertionPoint =\n              this._getInsertionPoint(index, orientation);\n            return this._cachedInsertionPoint;\n          }\n\n          // This is a two-part process. The first part is determining the drop\n          // orientation.\n          // * The default orientation is to drop _before_ the selected item.\n          // * If the selected item is a container, the default orientation\n          //   is to drop _into_ that container.\n          //\n          // Warning: It may be tempting to use tree indexes in this code, but\n          //          you must not, since the tree is nested and as your tree\n          //          index may change when folders before you are opened and\n          //          closed. You must convert your tree index to a node, and\n          //          then use getChildIndex to find your absolute index in\n          //          the parent container instead.\n          //\n          var resultView = this.view;\n          var selection = resultView.selection;\n          var rc = selection.getRangeCount();\n          var min = { }, max = { };\n          selection.getRangeAt(rc - 1, min, max);\n\n          // If the sole selection is a container, and we are not in\n          // a flatlist, insert into it.\n          // Note that this only applies to _single_ selections,\n          // if the last element within a multi-selection is a\n          // container, insert _adjacent_ to the selection.\n          //\n          // If the sole selection is the bookmarks toolbar folder, we insert\n          // into it even if it is not opened\n          if (selection.count == 1 && resultView.isContainer(max.value) &&\n              !this.flatList)\n            orientation = Ci.nsITreeView.DROP_ON;\n\n          this._cachedInsertionPoint =\n            this._getInsertionPoint(max.value, orientation);\n          return this._cachedInsertionPoint;\n        ]]></getter>\n      </property>\n\n      <method name=\"_getInsertionPoint\">\n        <parameter name=\"index\"/>\n        <parameter name=\"orientation\"/>\n        <body><![CDATA[\n          var result = this.result;\n          var resultview = this.view;\n          var container = result.root;\n          var dropNearNode = null;\n          console.assert(container, \"null container\");\n          // When there's no selection, assume the container is the container\n          // the view is populated from (i.e. the result's itemId).\n          if (index != -1) {\n            var lastSelected = resultview.nodeForTreeIndex(index);\n            if (resultview.isContainer(index) && orientation == Ci.nsITreeView.DROP_ON) {\n              // If the last selected item is an open container, append _into_\n              // it, rather than insert adjacent to it.\n              container = lastSelected;\n              index = -1;\n            } else if (lastSelected.containerOpen &&\n                       orientation == Ci.nsITreeView.DROP_AFTER &&\n                       lastSelected.hasChildren) {\n             // If the last selected item is an open container and the user is\n             // trying to drag into it as a first item, really insert into it.\n             container = lastSelected;\n             orientation = Ci.nsITreeView.DROP_ON;\n             index = 0;\n            } else {\n              // Use the last-selected node's container.\n              container = lastSelected.parent;\n\n              // See comment in the treeView.js's copy of this method\n              if (!container || !container.containerOpen)\n                return null;\n\n              // Avoid the potentially expensive call to getChildIndex\n              // if we know this container doesn't allow insertion\n              if (this.controller.disallowInsertion(container))\n                return null;\n\n              var queryOptions = PlacesUtils.asQuery(result.root).queryOptions;\n              if (queryOptions.sortingMode !=\n                    Ci.nsINavHistoryQueryOptions.SORT_BY_NONE) {\n                // If we are within a sorted view, insert at the end\n                index = -1;\n              } else if (queryOptions.excludeItems ||\n                         queryOptions.excludeQueries ||\n                         queryOptions.excludeReadOnlyFolders) {\n                // Some item may be invisible, insert near last selected one.\n                // We don't replace index here to avoid requests to the db,\n                // instead it will be calculated later by the controller.\n                index = -1;\n                dropNearNode = lastSelected;\n              } else {\n                var lsi = container.getChildIndex(lastSelected);\n                index = orientation == Ci.nsITreeView.DROP_BEFORE ? lsi : lsi + 1;\n              }\n            }\n          }\n\n          if (this.controller.disallowInsertion(container))\n            return null;\n\n          let tagName = PlacesUtils.nodeIsTagQuery(container) ?\n                          PlacesUtils.asQuery(container).query.tags[0] : null;\n\n          return new PlacesInsertionPoint({\n            parentId: PlacesUtils.getConcreteItemId(container),\n            parentGuid: PlacesUtils.getConcreteItemGuid(container),\n            index, orientation, tagName, dropNearNode,\n          });\n        ]]></body>\n      </method>\n\n      <!-- nsIPlacesView -->\n      <method name=\"selectAll\">\n        <body><![CDATA[\n          this.view.selection.selectAll();\n        ]]></body>\n      </method>\n\n      <!-- This method will select the first node in the tree that matches\n           each given item guid. It will open any folder nodes that it needs\n           to in order to show the selected items.\n      -->\n      <method name=\"selectItems\">\n        <parameter name=\"aGuids\"/>\n        <parameter name=\"aOpenContainers\"/>\n        <body><![CDATA[\n          // Never open containers in flat lists.\n          if (this.flatList)\n            aOpenContainers = false;\n          // By default, we do search and select within containers which were\n          // closed (note that containers in which nodes were not found are\n          // closed).\n          if (aOpenContainers === undefined)\n            aOpenContainers = true;\n\n          var guids = aGuids; // don't manipulate the caller's array\n\n          // Array of nodes found by findNodes which are to be selected\n          var nodes = [];\n\n          // Array of nodes found by findNodes which should be opened\n          var nodesToOpen = [];\n\n          // A set of GUIDs of container-nodes that were previously searched,\n          // and thus shouldn't be searched again. This is empty at the initial\n          // start of the recursion and gets filled in as the recursion\n          // progresses.\n          var checkedGuidsSet = new Set();\n\n          /**\n           * Recursively search through a node's children for items\n           * with the given GUIDs. When a matching item is found, remove its GUID\n           * from the GUIDs array, and add the found node to the nodes dictionary.\n           *\n           * NOTE: This method will leave open any node that had matching items\n           * in its subtree.\n           */\n          function findNodes(node) {\n            var foundOne = false;\n            // See if node matches an ID we wanted; add to results.\n            // For simple folder queries, check both itemId and the concrete\n            // item id.\n            var index = guids.indexOf(node.bookmarkGuid);\n            if (index == -1) {\n              let concreteGuid = PlacesUtils.getConcreteItemGuid(node);\n              if (concreteGuid != node.bookmarkGuid) {\n                index = guids.indexOf(concreteGuid);\n              }\n            }\n\n            if (index != -1) {\n              nodes.push(node);\n              foundOne = true;\n              guids.splice(index, 1);\n            }\n\n            var concreteGuid = PlacesUtils.getConcreteItemGuid(node);\n            if (guids.length == 0 || !PlacesUtils.nodeIsContainer(node) ||\n                checkedGuidsSet.has(concreteGuid))\n              return foundOne;\n\n            // Only follow a query if it has been been explicitly opened by the\n            // caller. We support the \"AllBookmarks\" case to allow callers to\n            // specify just the top-level bookmark folders.\n            let shouldOpen = aOpenContainers && (PlacesUtils.nodeIsFolder(node) ||\n              (PlacesUtils.nodeIsQuery(node) && node.bookmarkGuid == PlacesUIUtils.virtualAllBookmarksGuid));\n\n            PlacesUtils.asContainer(node);\n            if (!node.containerOpen && !shouldOpen)\n              return foundOne;\n\n            checkedGuidsSet.add(concreteGuid);\n\n            // Remember the beginning state so that we can re-close\n            // this node if we don't find any additional results here.\n            var previousOpenness = node.containerOpen;\n            node.containerOpen = true;\n            for (var child = 0; child < node.childCount && guids.length > 0; child++) {\n              var childNode = node.getChild(child);\n              var found = findNodes(childNode);\n              if (!foundOne)\n                foundOne = found;\n            }\n\n            // If we didn't find any additional matches in this node's\n            // subtree, revert the node to its previous openness.\n            if (foundOne)\n              nodesToOpen.unshift(node);\n            node.containerOpen = previousOpenness;\n            return foundOne;\n          }\n\n          // Disable notifications while looking for nodes.\n          let result = this.result;\n          let didSuppressNotifications = result.suppressNotifications;\n          if (!didSuppressNotifications)\n            result.suppressNotifications = true;\n          try {\n            findNodes(this.result.root);\n          } finally {\n            if (!didSuppressNotifications)\n              result.suppressNotifications = false;\n          }\n\n          // For all the nodes we've found, highlight the corresponding\n          // index in the tree.\n          var resultview = this.view;\n          var selection = this.view.selection;\n          selection.selectEventsSuppressed = true;\n          selection.clearSelection();\n          // Open nodes containing found items\n          for (let i = 0; i < nodesToOpen.length; i++) {\n            nodesToOpen[i].containerOpen = true;\n          }\n          for (let i = 0; i < nodes.length; i++) {\n            var index = resultview.treeIndexForNode(nodes[i]);\n            if (index == -1)\n              continue;\n            selection.rangedSelect(index, index, true);\n          }\n          selection.selectEventsSuppressed = false;\n        ]]></body>\n      </method>\n\n      <field name=\"_contextMenuShown\">false</field>\n\n      <method name=\"buildContextMenu\">\n        <parameter name=\"aPopup\"/>\n        <body><![CDATA[\n          this._contextMenuShown = true;\n          return this.controller.buildContextMenu(aPopup);\n        ]]></body>\n      </method>\n\n      <method name=\"destroyContextMenu\">\n        <parameter name=\"aPopup\"/>\n          this._contextMenuShown = false;\n        <body/>\n      </method>\n\n      <property name=\"ownerWindow\"\n                readonly=\"true\"\n                onget=\"return window;\"/>\n\n      <field name=\"_active\">true</field>\n      <property name=\"active\"\n                onget=\"return this._active\"\n                onset=\"return this._active = val\"/>\n\n    </implementation>\n    <handlers>\n      <handler event=\"focus\"><![CDATA[\n        this._cachedInsertionPoint = undefined;\n\n        // See select handler. We need the sidebar's places commandset to be\n        // updated as well\n        document.commandDispatcher.updateCommands(\"focus\");\n      ]]></handler>\n      <handler event=\"select\"><![CDATA[\n        this._cachedInsertionPoint = undefined;\n\n        // This additional complexity is here for the sidebars\n        var win = window;\n        while (true) {\n          win.document.commandDispatcher.updateCommands(\"focus\");\n          if (win == window.top)\n            break;\n\n          win = win.parent;\n        }\n      ]]></handler>\n\n      <handler event=\"dragstart\"><![CDATA[\n        if (event.target.localName != \"treechildren\")\n          return;\n\n        if (this.disableUserActions) {\n          event.preventDefault();\n          event.stopPropagation();\n          return;\n        }\n\n        let nodes = this.selectedNodes;\n        for (let i = 0; i < nodes.length; i++) {\n          let node = nodes[i];\n\n          // Disallow dragging the root node of a tree.\n          if (!node.parent) {\n            event.preventDefault();\n            event.stopPropagation();\n            return;\n          }\n\n          // If this node is child of a readonly container (e.g. a livemark)\n          // or cannot be moved, we must force a copy.\n          if (!this.controller.canMoveNode(node)) {\n            event.dataTransfer.effectAllowed = \"copyLink\";\n            break;\n          }\n        }\n\n        this._controller.setDataTransfer(event);\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragover\"><![CDATA[\n        if (event.target.localName != \"treechildren\")\n          return;\n\n        let cell = this.treeBoxObject.getCellAt(event.clientX, event.clientY);\n        let node = cell.row != -1 ?\n                   this.view.nodeForTreeIndex(cell.row) :\n                   this.result.root;\n        // cache the dropTarget for the view\n        PlacesControllerDragHelper.currentDropTarget = node;\n\n        // We have to calculate the orientation since view.canDrop will use\n        // it and we want to be consistent with the dropfeedback.\n        let tbo = this.treeBoxObject;\n        let rowHeight = tbo.rowHeight;\n        let eventY = event.clientY - tbo.treeBody.boxObject.y -\n                     rowHeight * (cell.row - tbo.getFirstVisibleRow());\n\n        let orientation = Ci.nsITreeView.DROP_BEFORE;\n\n        if (cell.row == -1) {\n          // If the row is not valid we try to insert inside the resultNode.\n          orientation = Ci.nsITreeView.DROP_ON;\n        } else if (PlacesUtils.nodeIsContainer(node) &&\n                 eventY > rowHeight * 0.75) {\n          // If we are below the 75% of a container the treeview we try\n          // to drop after the node.\n          orientation = Ci.nsITreeView.DROP_AFTER;\n        } else if (PlacesUtils.nodeIsContainer(node) &&\n                 eventY > rowHeight * 0.25) {\n          // If we are below the 25% of a container the treeview we try\n          // to drop inside the node.\n          orientation = Ci.nsITreeView.DROP_ON;\n        }\n\n        if (!this.view.canDrop(cell.row, orientation, event.dataTransfer))\n          return;\n\n        event.preventDefault();\n        event.stopPropagation();\n      ]]></handler>\n\n      <handler event=\"dragend\"><![CDATA[\n        PlacesControllerDragHelper.currentDropTarget = null;\n      ]]></handler>\n\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"search.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- XULCommandEvent is a specialised global. -->\n<!-- global XULCommandEvent -->\n\n<!DOCTYPE bindings [\n<!ENTITY % browserDTD SYSTEM \"chrome://browser/locale/browser.dtd\">\n%browserDTD;\n]>\n\n<bindings id=\"SearchBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"searchbar-textbox\"\n      extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete\">\n    <implementation>\n      <constructor><![CDATA[\n        if (this.closest(\"searchbar\").parentNode.parentNode.localName ==\n            \"toolbarpaletteitem\")\n          return;\n\n        if (Services.prefs.getBoolPref(\"browser.urlbar.clickSelectsAll\"))\n          this.setAttribute(\"clickSelectsAll\", true);\n\n        var textBox = document.getAnonymousElementByAttribute(this,\n                                              \"anonid\", \"moz-input-box\");\n\n        // Force the Custom Element to upgrade until Bug 1470242 handles this:\n        customElements.upgrade(textBox);\n        var cxmenu = textBox.menupopup;\n        cxmenu.addEventListener(\"popupshowing\",\n                                () => { this.initContextMenu(cxmenu); },\n                                {capture: true, once: true});\n\n        this.setAttribute(\"aria-owns\", this.popup.id);\n        this.closest(\"searchbar\")._textboxInitialized = true;\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // If the context menu has never been opened, there won't be anything\n        // to remove here.\n        // Also, XBL and the customize toolbar code sometimes interact poorly.\n        try {\n          this.controllers.removeController(this.searchbarController);\n        } catch (ex) { }\n      ]]></destructor>\n\n      // Add items to context menu and attach controller to handle them the\n      // first time the context menu is opened.\n      <method name=\"initContextMenu\">\n        <parameter name=\"aMenu\"/>\n        <body><![CDATA[\n          let stringBundle = this.closest(\"searchbar\")._stringBundle;\n\n          let pasteAndSearch, suggestMenuItem;\n          let element, label, akey;\n\n          element = document.createXULElement(\"menuseparator\");\n          aMenu.appendChild(element);\n\n          let insertLocation = aMenu.firstElementChild;\n          while (insertLocation.nextElementSibling &&\n                 insertLocation.getAttribute(\"cmd\") != \"cmd_paste\")\n            insertLocation = insertLocation.nextElementSibling;\n          if (insertLocation) {\n            element = document.createXULElement(\"menuitem\");\n            label = stringBundle.getString(\"cmd_pasteAndSearch\");\n            element.setAttribute(\"label\", label);\n            element.setAttribute(\"anonid\", \"paste-and-search\");\n            element.setAttribute(\"oncommand\", \"BrowserSearch.pasteAndSearch(event)\");\n            aMenu.insertBefore(element, insertLocation.nextElementSibling);\n            pasteAndSearch = element;\n          }\n\n          element = document.createXULElement(\"menuitem\");\n          label = stringBundle.getString(\"cmd_clearHistory\");\n          akey = stringBundle.getString(\"cmd_clearHistory_accesskey\");\n          element.setAttribute(\"label\", label);\n          element.setAttribute(\"accesskey\", akey);\n          element.setAttribute(\"cmd\", \"cmd_clearhistory\");\n          aMenu.appendChild(element);\n\n          element = document.createXULElement(\"menuitem\");\n          label = stringBundle.getString(\"cmd_showSuggestions\");\n          akey = stringBundle.getString(\"cmd_showSuggestions_accesskey\");\n          element.setAttribute(\"anonid\", \"toggle-suggest-item\");\n          element.setAttribute(\"label\", label);\n          element.setAttribute(\"accesskey\", akey);\n          element.setAttribute(\"cmd\", \"cmd_togglesuggest\");\n          element.setAttribute(\"type\", \"checkbox\");\n          element.setAttribute(\"autocheck\", \"false\");\n          suggestMenuItem = element;\n          aMenu.appendChild(element);\n\n          if (AppConstants.platform == \"macosx\") {\n            this.addEventListener(\"keypress\", aEvent => {\n              if (aEvent.keyCode == KeyEvent.DOM_VK_F4)\n                this.openSearch();\n            }, true);\n          }\n\n          this.controllers.appendController(this.searchbarController);\n\n          let onpopupshowing = function() {\n            BrowserSearch.searchBar._textbox.closePopup();\n            if (suggestMenuItem) {\n              let enabled =\n                Services.prefs.getBoolPref(\"browser.search.suggest.enabled\");\n              suggestMenuItem.setAttribute(\"checked\", enabled);\n            }\n\n            if (!pasteAndSearch)\n              return;\n            let controller = document.commandDispatcher.getControllerForCommand(\"cmd_paste\");\n            let enabled = controller.isCommandEnabled(\"cmd_paste\");\n            if (enabled)\n              pasteAndSearch.removeAttribute(\"disabled\");\n            else\n              pasteAndSearch.setAttribute(\"disabled\", \"true\");\n          };\n          aMenu.addEventListener(\"popupshowing\", onpopupshowing);\n          onpopupshowing();\n        ]]></body>\n      </method>\n\n      <!--\n        This overrides the searchParam property in autocomplete.xml.  We're\n        hijacking this property as a vehicle for delivering the privacy\n        information about the window into the guts of nsSearchSuggestions.\n\n        Note that the setter is the same as the parent.  We were not sure whether\n        we can override just the getter.  If that proves to be the case, the setter\n        can be removed.\n      -->\n      <property name=\"searchParam\"\n                onget=\"return this.getAttribute('autocompletesearchparam') +\n                       (PrivateBrowsingUtils.isWindowPrivate(window) ? '|private' : '');\"\n                onset=\"this.setAttribute('autocompletesearchparam', val); return val;\"/>\n\n      <!-- This is implemented so that when textbox.value is set directly (e.g.,\n           by tests), the one-off query is updated. -->\n      <method name=\"onBeforeValueSet\">\n        <parameter name=\"aValue\"/>\n        <body><![CDATA[\n          this.popup.oneOffButtons.query = aValue;\n          return aValue;\n        ]]></body>\n      </method>\n\n      <!--\n        This method overrides the autocomplete binding's openPopup (essentially\n        duplicating the logic from the autocomplete popup binding's\n        openAutocompletePopup method), modifying it so that the popup is aligned with\n        the inner textbox, but sized to not extend beyond the search bar border.\n      -->\n      <method name=\"openPopup\">\n        <body><![CDATA[\n          // Entering customization mode after the search bar had focus causes\n          // the popup to appear again, due to focus returning after the\n          // hamburger panel closes. Don't open in that spurious event.\n          if (document.documentElement.getAttribute(\"customizing\") == \"true\") {\n            return;\n          }\n\n          var popup = this.popup;\n          if (!popup.mPopupOpen) {\n            // Initially the panel used for the searchbar (PopupSearchAutoComplete\n            // in browser.xul) is hidden to avoid impacting startup / new\n            // window performance. The base binding's openPopup would normally\n            // call the overriden openAutocompletePopup in\n            // browser-search-autocomplete-result-popup binding to unhide the popup,\n            // but since we're overriding openPopup we need to unhide the panel\n            // ourselves.\n            popup.hidden = false;\n\n            // Don't roll up on mouse click in the anchor for the search UI.\n            if (popup.id == \"PopupSearchAutoComplete\") {\n              popup.setAttribute(\"norolluponanchor\", \"true\");\n            }\n\n            popup.mInput = this;\n            // clear any previous selection, see bugs 400671 and 488357\n            popup.selectedIndex = -1;\n\n            document.popupNode = null;\n\n            const isRTL = getComputedStyle(this, \"\").direction == \"rtl\";\n\n            var outerRect = this.getBoundingClientRect();\n            var innerRect = this.inputField.getBoundingClientRect();\n            let width = isRTL ?\n                        innerRect.right - outerRect.left :\n                        outerRect.right - innerRect.left;\n            popup.setAttribute(\"width\", width > 100 ? width : 100);\n\n            // invalidate() depends on the width attribute\n            popup._invalidate();\n\n            var yOffset = outerRect.bottom - innerRect.bottom;\n            popup.openPopup(this.inputField, \"after_start\", 0, yOffset, false, false);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"openSearch\">\n        <body>\n          <![CDATA[\n            if (!this.popupOpen) {\n              this.closest(\"searchbar\").openSuggestionsPanel();\n              return false;\n            }\n            return true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"handleEnter\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          // Toggle the open state of the add-engine menu button if it's\n          // selected.  We're using handleEnter for this instead of listening\n          // for the command event because a command event isn't fired.\n          if (this.selectedButton &&\n              this.selectedButton.getAttribute(\"anonid\") ==\n                \"addengine-menu-button\") {\n            this.selectedButton.open = !this.selectedButton.open;\n            return true;\n          }\n          // Otherwise, \"call super\": do what the autocomplete binding's\n          // handleEnter implementation does.\n          return this.mController.handleEnter(false, event || null);\n        ]]></body>\n      </method>\n\n      <!-- override |onTextEntered| in autocomplete.xml -->\n      <method name=\"onTextEntered\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let engine;\n          let oneOff = this.selectedButton;\n          if (oneOff) {\n            if (!oneOff.engine) {\n              oneOff.doCommand();\n              return;\n            }\n            engine = oneOff.engine;\n          }\n          if (this._selectionDetails) {\n            BrowserSearch.searchBar.telemetrySearchDetails = this._selectionDetails;\n            this._selectionDetails = null;\n          }\n          this.closest(\"searchbar\").handleSearchCommand(aEvent, engine);\n        ]]></body>\n      </method>\n\n      <property name=\"selectedButton\">\n        <getter><![CDATA[\n          return this.popup.oneOffButtons.selectedButton;\n        ]]></getter>\n        <setter><![CDATA[\n          return this.popup.oneOffButtons.selectedButton = val;\n        ]]></setter>\n      </property>\n\n      <method name=\"handleKeyboardNavigation\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          let popup = this.popup;\n          if (!popup.popupOpen)\n            return;\n\n          // accel + up/down changes the default engine and shouldn't affect\n          // the selection on the one-off buttons.\n          if (aEvent.getModifierState(\"Accel\"))\n            return;\n\n          let suggestionsHidden =\n            popup.richlistbox.getAttribute(\"collapsed\") == \"true\";\n          let numItems = suggestionsHidden ? 0 : this.popup.matchCount;\n          this.popup.oneOffButtons.handleKeyPress(aEvent, numItems, true);\n        ]]></body>\n      </method>\n\n      <!-- nsIController -->\n      <field name=\"searchbarController\" readonly=\"true\"><![CDATA[({\n        _self: this,\n        supportsCommand(aCommand) {\n          return aCommand == \"cmd_clearhistory\" ||\n                 aCommand == \"cmd_togglesuggest\";\n        },\n\n        isCommandEnabled(aCommand) {\n          return true;\n        },\n\n        doCommand(aCommand) {\n          switch (aCommand) {\n            case \"cmd_clearhistory\":\n              var param = this._self.getAttribute(\"autocompletesearchparam\");\n\n              BrowserSearch.searchBar.FormHistory.update({ op: \"remove\", fieldname: param }, null);\n              this._self.value = \"\";\n              break;\n            case \"cmd_togglesuggest\":\n              let enabled =\n                Services.prefs.getBoolPref(\"browser.search.suggest.enabled\");\n              Services.prefs.setBoolPref(\"browser.search.suggest.enabled\",\n                                         !enabled);\n              break;\n            default:\n              // do nothing with unrecognized command\n          }\n        },\n      })]]></field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"input\"><![CDATA[\n        this.popup.removeAttribute(\"showonlysettings\");\n      ]]></handler>\n\n      <handler event=\"keypress\" phase=\"capturing\"\n               action=\"return this.handleKeyboardNavigation(event);\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"accel\"\n               phase=\"capturing\"\n               action='this.closest(\"searchbar\").selectEngine(event, false);'/>\n\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"accel\"\n               phase=\"capturing\"\n               action='this.closest(\"searchbar\").selectEngine(event, true);'/>\n\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"alt\"\n               phase=\"capturing\"\n               action=\"return this.openSearch();\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"alt\"\n               phase=\"capturing\"\n               action=\"return this.openSearch();\"/>\n\n      <handler event=\"dragover\">\n      <![CDATA[\n        var types = event.dataTransfer.types;\n        if (types.includes(\"text/plain\") || types.includes(\"text/x-moz-text-internal\"))\n          event.preventDefault();\n      ]]>\n      </handler>\n\n      <handler event=\"drop\">\n      <![CDATA[\n        var dataTransfer = event.dataTransfer;\n        var data = dataTransfer.getData(\"text/plain\");\n        if (!data)\n          data = dataTransfer.getData(\"text/x-moz-text-internal\");\n        if (data) {\n          event.preventDefault();\n          this.value = data;\n          this.closest(\"searchbar\").openSuggestionsPanel();\n        }\n      ]]>\n      </handler>\n\n    </handlers>\n  </binding>\n\n  <binding id=\"browser-search-autocomplete-result-popup\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup\">\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\">\n      <xul:hbox anonid=\"searchbar-engine\" xbl:inherits=\"showonlysettings\"\n                class=\"search-panel-header search-panel-current-engine\">\n        <xul:image class=\"searchbar-engine-image\" xbl:inherits=\"src\"/>\n        <xul:label anonid=\"searchbar-engine-name\" flex=\"1\" crop=\"end\"\n                   role=\"presentation\"/>\n      </xul:hbox>\n      <xul:richlistbox anonid=\"richlistbox\" class=\"autocomplete-richlistbox search-panel-tree\" flex=\"1\"/>\n      <xul:vbox anonid=\"search-one-off-buttons\" class=\"search-one-offs\"/>\n    </content>\n    <implementation>\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body><![CDATA[\n          // initially the panel is hidden\n          // to avoid impacting startup / new window performance\n          aInput.popup.hidden = false;\n\n          // this method is defined on the base binding\n          this._openAutocompletePopup(aInput, aElement);\n        ]]></body>\n      </method>\n\n      <method name=\"onPopupClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          // Ignore all right-clicks\n          if (aEvent.button == 2)\n            return;\n\n          var searchBar = BrowserSearch.searchBar;\n          var popupForSearchBar = searchBar && searchBar.textbox == this.mInput;\n          if (popupForSearchBar) {\n            searchBar.telemetrySearchDetails = {\n              index: this.selectedIndex,\n              kind: \"mouse\",\n            };\n          }\n\n          // Check for unmodified left-click, and use default behavior\n          if (aEvent.button == 0 && !aEvent.shiftKey && !aEvent.ctrlKey &&\n              !aEvent.altKey && !aEvent.metaKey) {\n            this.input.controller.handleEnter(true, aEvent);\n            return;\n          }\n\n          // Check for middle-click or modified clicks on the search bar\n          if (popupForSearchBar) {\n            BrowserUsageTelemetry.recordSearchbarSelectedResultMethod(\n              aEvent,\n              this.selectedIndex\n            );\n\n            // Handle search bar popup clicks\n            var search = this.input.controller.getValueAt(this.selectedIndex);\n\n            // open the search results according to the clicking subtlety\n            var where = whereToOpenLink(aEvent, false, true);\n            let params = {};\n\n            // But open ctrl/cmd clicks on autocomplete items in a new background tab.\n            let modifier = AppConstants.platform == \"macosx\" ?\n                           aEvent.metaKey :\n                           aEvent.ctrlKey;\n            if (where == \"tab\" && (aEvent instanceof MouseEvent) &&\n                (aEvent.button == 1 || modifier))\n              params.inBackground = true;\n\n            // leave the popup open for background tab loads\n            if (!(where == \"tab\" && params.inBackground)) {\n              // close the autocomplete popup and revert the entered search term\n              this.closePopup();\n              this.input.controller.handleEscape();\n            }\n\n            searchBar.doSearch(search, where, null, params);\n            if (where == \"tab\" && params.inBackground)\n              searchBar.focus();\n            else\n              searchBar.value = search;\n          }\n        ]]></body>\n      </method>\n\n      <!-- Popup rollup is triggered by native events before the mousedown event\n           reaches the DOM. The will be set to true by the popuphiding event and\n           false after the mousedown event has been triggered to detect what\n           caused rollup. -->\n      <field name=\"_isHiding\">false</field>\n      <field name=\"_bundle\">null</field>\n      <property name=\"bundle\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (!this._bundle) {\n              const kBundleURI = \"chrome://browser/locale/search.properties\";\n              this._bundle = Services.strings.createBundle(kBundleURI);\n            }\n            return this._bundle;\n          ]]>\n        </getter>\n      </property>\n\n      <field name=\"oneOffButtons\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"search-one-off-buttons\");\n      </field>\n\n      <method name=\"updateHeader\">\n        <body><![CDATA[\n          let currentEngine = Services.search.currentEngine;\n          let uri = currentEngine.iconURI;\n          if (uri) {\n            this.setAttribute(\"src\", uri.spec);\n          } else {\n            // If the default has just been changed to a provider without icon,\n            // avoid showing the icon of the previous default provider.\n            this.removeAttribute(\"src\");\n          }\n\n          let headerText = this.bundle.formatStringFromName(\"searchHeader\",\n                                                            [currentEngine.name], 1);\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"searchbar-engine-name\")\n                  .setAttribute(\"value\", headerText);\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"searchbar-engine\")\n                  .engine = currentEngine;\n        ]]></body>\n      </method>\n\n      <!-- This is called when a one-off is clicked and when \"search in new tab\"\n           is selected from a one-off context menu. -->\n      <method name=\"handleOneOffSearch\">\n        <parameter name=\"event\"/>\n        <parameter name=\"engine\"/>\n        <parameter name=\"where\"/>\n        <parameter name=\"params\"/>\n        <body><![CDATA[\n          let searchbar = document.getElementById(\"searchbar\");\n          searchbar.handleSearchCommandWhere(event, engine, where, params);\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // Force the panel to have the width of the searchbar rather than\n        // the width of the textfield.\n        let DOMUtils = window.windowUtils;\n        let textboxRect = DOMUtils.getBoundsWithoutFlushing(this.mInput);\n        let inputRect = DOMUtils.getBoundsWithoutFlushing(this.mInput.inputField);\n\n        // Ensure the panel is wide enough to fit at least 3 engines.\n        let minWidth = Math.max(textboxRect.width,\n                                this.oneOffButtons.buttonWidth * 3);\n        this.style.minWidth = Math.round(minWidth) + \"px\";\n        // Alignment of the panel with the searchbar is obtained with negative\n        // margins.\n        this.style.marginLeft = (textboxRect.left - inputRect.left) + \"px\";\n        // This second margin is needed when the direction is reversed,\n        // eg. when using command+shift+X.\n        this.style.marginRight = (inputRect.right - textboxRect.right) + \"px\";\n\n        // First handle deciding if we are showing the reduced version of the\n        // popup containing only the preferences button. We do this if the\n        // glass icon has been clicked if the text field is empty.\n        let searchbar = document.getElementById(\"searchbar\");\n        if (searchbar.hasAttribute(\"showonlysettings\")) {\n          searchbar.removeAttribute(\"showonlysettings\");\n          this.setAttribute(\"showonlysettings\", \"true\");\n\n          // Setting this with an xbl-inherited attribute gets overridden the\n          // second time the user clicks the glass icon for some reason...\n          this.richlistbox.collapsed = true;\n        } else {\n          this.removeAttribute(\"showonlysettings\");\n          // Uncollapse as long as we have a view which has >= 1 row.\n          // The autocomplete binding itself will take care of uncollapsing later,\n          // if we currently have no rows but end up having some in the future\n          // when the search string changes\n          this.richlistbox.collapsed = (this.matchCount == 0);\n        }\n\n        // Show the current default engine in the top header of the panel.\n        this.updateHeader();\n      ]]></handler>\n\n      <handler event=\"popuphiding\"><![CDATA[\n        this._isHiding = true;\n        Services.tm.dispatchToMainThread(() => {\n          this._isHiding = false;\n        });\n      ]]></handler>\n\n      <!-- This handles clicks on the topmost \"Foo Search\" header in the\n           popup (hbox[anonid=\"searchbar-engine\"]). -->\n      <handler event=\"click\"><![CDATA[\n        if (event.button == 2) {\n          // Ignore right clicks.\n          return;\n        }\n        let button = event.originalTarget;\n        let engine = button.parentNode.engine;\n        if (!engine) {\n          return;\n        }\n        this.oneOffButtons.handleSearchCommand(event, engine);\n      ]]></handler>\n    </handlers>\n\n  </binding>\n\n  <binding id=\"search-one-offs\">\n    <content context=\"_child\">\n      <xul:deck anonid=\"search-panel-one-offs-header\"\n                selectedIndex=\"0\"\n                class=\"search-panel-header search-panel-current-input\">\n        <xul:label anonid=\"searchbar-oneoffheader-search\"\n                   value=\"FROM-DTD.searchWithHeader.label;\"/>\n        <xul:hbox anonid=\"search-panel-searchforwith\"\n                  class=\"search-panel-current-input\">\n          <xul:label anonid=\"searchbar-oneoffheader-before\"\n                     value=\"FROM-DTD.searchFor.label;\"/>\n          <xul:label anonid=\"searchbar-oneoffheader-searchtext\"\n                     class=\"search-panel-input-value\"\n                     flex=\"1\"\n                     crop=\"end\"/>\n          <xul:label anonid=\"searchbar-oneoffheader-after\"\n                     flex=\"10000\"\n                     value=\"FROM-DTD.searchWith.label;\"/>\n        </xul:hbox>\n        <xul:hbox anonid=\"search-panel-searchonengine\"\n                  class=\"search-panel-current-input\">\n          <xul:label anonid=\"searchbar-oneoffheader-beforeengine\"\n                     value=\"FROM-DTD.search.label;\"/>\n          <xul:label anonid=\"searchbar-oneoffheader-engine\"\n                     class=\"search-panel-input-value\"\n                     flex=\"1\"\n                     crop=\"end\"/>\n          <xul:label anonid=\"searchbar-oneoffheader-afterengine\"\n                     flex=\"10000\"\n                     value=\"FROM-DTD.searchAfter.label;\"/>\n        </xul:hbox>\n      </xul:deck>\n      <xul:description anonid=\"search-panel-one-offs\"\n                       role=\"group\"\n                       class=\"search-panel-one-offs\"\n                       xbl:inherits=\"compact\">\n        <xul:button anonid=\"search-settings-compact\"\n                    oncommand=\"showSettings();\"\n                    class=\"searchbar-engine-one-off-item search-setting-button-compact\"\n                    tooltiptext=\"FROM-DTD.changeSearchSettings.tooltip;\"\n                    xbl:inherits=\"compact\"/>\n      </xul:description>\n      <xul:vbox anonid=\"add-engines\" class=\"search-add-engines\"/>\n      <xul:button anonid=\"search-settings\"\n                  oncommand=\"showSettings();\"\n                  class=\"search-setting-button search-panel-header\"\n                  label=\"FROM-DTD.changeSearchSettings.button;\"\n                  xbl:inherits=\"compact\"/>\n      <xul:menupopup anonid=\"search-one-offs-context-menu\">\n        <xul:menuitem anonid=\"search-one-offs-context-open-in-new-tab\"\n                      label=\"FROM-DTD.searchInNewTab.label;\"\n                      accesskey=\"FROM-DTD.searchInNewTab.accesskey;\"/>\n        <xul:menuitem anonid=\"search-one-offs-context-set-default\"\n                      label=\"FROM-DTD.searchSetAsDefault.label;\"\n                      accesskey=\"FROM-DTD.searchSetAsDefault.accesskey;\"/>\n      </xul:menupopup>\n    </content>\n\n    <implementation implements=\"nsIObserver,nsIWeakReference\">\n\n      <!-- Width in pixels of the one-off buttons.  49px is the min-width of\n           each search engine button, adapt this const when changing the css.\n           It's actually 48px + 1px of right border. -->\n      <property name=\"buttonWidth\" readonly=\"true\" onget=\"return 49;\"/>\n\n      <field name=\"_popup\">null</field>\n\n      <!-- The popup that contains the one-offs.  This is required, so it should\n           never be null or undefined, except possibly before the one-offs are\n           used. -->\n      <property name=\"popup\">\n        <getter><![CDATA[\n          return this._popup;\n        ]]></getter>\n        <setter><![CDATA[\n          let events = [\n            \"popupshowing\",\n            \"popuphidden\",\n          ];\n          if (this._popup) {\n            for (let event of events) {\n              this._popup.removeEventListener(event, this);\n            }\n          }\n          if (val) {\n            for (let event of events) {\n              val.addEventListener(event, this);\n            }\n          }\n          this._popup = val;\n\n          // If the popup is already open, rebuild the one-offs now.  The\n          // popup may be opening, so check that the state is not closed\n          // instead of checking popupOpen.\n          if (val && val.state != \"closed\") {\n            this._rebuild();\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <field name=\"_textbox\">null</field>\n      <field name=\"_textboxWidth\">0</field>\n\n      <!-- The textbox associated with the one-offs.  Set this to a textbox to\n           automatically keep the related one-offs UI up to date.  Otherwise you\n           can leave it null/undefined, and in that case you should update the\n           query property manually. -->\n      <property name=\"textbox\">\n        <getter><![CDATA[\n          return this._textbox;\n        ]]></getter>\n        <setter><![CDATA[\n          if (this._textbox) {\n            this._textbox.removeEventListener(\"input\", this);\n          }\n          if (val) {\n            val.addEventListener(\"input\", this);\n          }\n          return this._textbox = val;\n        ]]></setter>\n      </property>\n\n      <!-- Set this to a string that identifies your one-offs consumer.  It'll\n           be appended to telemetry recorded with maybeRecordTelemetry(). -->\n      <field name=\"telemetryOrigin\">\"\"</field>\n\n      <field name=\"_query\">\"\"</field>\n\n      <!-- The query string currently shown in the one-offs.  If the textbox\n           property is non-null, then this is automatically updated on\n           input. -->\n      <property name=\"query\">\n        <getter><![CDATA[\n          return this._query;\n        ]]></getter>\n        <setter><![CDATA[\n          this._query = val;\n          if (this.popup && this.popup.popupOpen) {\n            this._updateAfterQueryChanged();\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <field name=\"_selectedButton\">null</field>\n\n      <!-- The selected one-off, a xul:button, including the add-engine button\n           and the search-settings button.  Null if no one-off is selected. -->\n      <property name=\"selectedButton\">\n        <getter><![CDATA[\n          return this._selectedButton;\n        ]]></getter>\n        <setter><![CDATA[\n          if (val && val.classList.contains(\"dummy\")) {\n            // Never select dummy buttons.\n            val = null;\n          }\n          let previousButton = this._selectedButton;\n          if (previousButton) {\n            previousButton.removeAttribute(\"selected\");\n          }\n          if (val) {\n            val.setAttribute(\"selected\", \"true\");\n          }\n          this._selectedButton = val;\n          this._updateStateForButton(null);\n          if (val && !val.engine) {\n            // If the button doesn't have an engine, then clear the popup's\n            // selection to indicate that pressing Return while the button is\n            // selected will do the button's command, not search.\n            this.popup.selectedIndex = -1;\n          }\n          let event = new CustomEvent(\"SelectedOneOffButtonChanged\", {\n            previousSelectedButton: previousButton,\n          });\n          this.dispatchEvent(event);\n          return val;\n        ]]></setter>\n      </property>\n\n      <!-- The index of the selected one-off, including the add-engine button\n           and the search-settings button.  -1 if no one-off is selected. -->\n      <property name=\"selectedButtonIndex\">\n        <getter><![CDATA[\n          let buttons = this.getSelectableButtons(true);\n          for (let i = 0; i < buttons.length; i++) {\n            if (buttons[i] == this._selectedButton) {\n              return i;\n            }\n          }\n          return -1;\n        ]]></getter>\n        <setter><![CDATA[\n          let buttons = this.getSelectableButtons(true);\n          this.selectedButton = buttons[val];\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"compact\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.getAttribute(\"compact\") == \"true\";\n        ]]></getter>\n      </property>\n\n      <field name=\"buttons\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"search-panel-one-offs\");\n      </field>\n      <field name=\"header\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"search-panel-one-offs-header\");\n      </field>\n      <field name=\"addEngines\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"add-engines\");\n      </field>\n      <field name=\"settingsButton\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"search-settings\");\n      </field>\n      <field name=\"settingsButtonCompact\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"search-settings-compact\");\n      </field>\n\n      <field name=\"_bundle\">null</field>\n\n      <property name=\"bundle\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._bundle) {\n            const kBundleURI = \"chrome://browser/locale/search.properties\";\n            this._bundle = Services.strings.createBundle(kBundleURI);\n          }\n          return this._bundle;\n        ]]></getter>\n      </property>\n\n      <!-- When a context menu is opened on a one-off button, this is set to the\n           engine of that button for use with the context menu actions. -->\n      <field name=\"_contextEngine\">null</field>\n\n      <constructor><![CDATA[\n        // Force the <deck> Custom Element to be constructed. This can be removed\n        // once Bug 1470242 makes this happen behind the scenes.\n        customElements.upgrade(this.header);\n\n        // Prevent popup events from the context menu from reaching the autocomplete\n        // binding (or other listeners).\n        let menu = document.getAnonymousElementByAttribute(this, \"anonid\", \"search-one-offs-context-menu\");\n        let listener = aEvent => aEvent.stopPropagation();\n        menu.addEventListener(\"popupshowing\", listener);\n        menu.addEventListener(\"popuphiding\", listener);\n        menu.addEventListener(\"popupshown\", aEvent => {\n          this._ignoreMouseEvents = true;\n          aEvent.stopPropagation();\n        });\n        menu.addEventListener(\"popuphidden\", aEvent => {\n          this._ignoreMouseEvents = false;\n          aEvent.stopPropagation();\n        });\n\n        // Add weak referenced observers to invalidate our cached list of engines.\n        Services.prefs.addObserver(\"browser.search.hiddenOneOffs\", this, true);\n        Services.obs.addObserver(this, \"browser-search-engine-modified\", true);\n        Services.obs.addObserver(this, \"browser-search-service\", true);\n\n        // Rebuild the buttons when the theme changes.  See bug 1357800 for\n        // details.  Summary: On Linux, switching between themes can cause a row\n        // of buttons to disappear.\n        Services.obs.addObserver(this, \"lightweight-theme-changed\", true);\n      ]]></constructor>\n\n      <!-- This handles events outside the one-off buttons, like on the popup\n           and textbox. -->\n      <method name=\"handleEvent\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          switch (event.type) {\n            case \"input\":\n              // Allow the consumer's input to override its value property with\n              // a oneOffSearchQuery property.  That way if the value is not\n              // actually what the user typed (e.g., it's autofilled, or it's a\n              // mozaction URI), the consumer has some way of providing it.\n              this.query = event.target.oneOffSearchQuery || event.target.value;\n              break;\n            case \"popupshowing\":\n              this._rebuild();\n              break;\n            case \"popuphidden\":\n              Services.tm.dispatchToMainThread(() => {\n                this.selectedButton = null;\n                this._contextEngine = null;\n              });\n              break;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"observe\">\n        <parameter name=\"aEngine\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aData\"/>\n        <body><![CDATA[\n          // Make sure the engine list is refetched next time it's needed.\n          this._engines = null;\n        ]]></body>\n      </method>\n\n      <method name=\"showSettings\">\n        <body><![CDATA[\n          openPreferences(\"paneSearch\", {origin: \"contentSearch\"});\n\n          // If the preference tab was already selected, the panel doesn't\n          // close itself automatically.\n          this.popup.hidePopup();\n        ]]></body>\n      </method>\n\n      <!-- Updates the parts of the UI that show the query string. -->\n      <method name=\"_updateAfterQueryChanged\">\n        <body><![CDATA[\n          let headerSearchText =\n            document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                    \"searchbar-oneoffheader-searchtext\");\n          headerSearchText.setAttribute(\"value\", this.query);\n          let groupText;\n          let isOneOffSelected =\n            this.selectedButton &&\n            this.selectedButton.classList.contains(\"searchbar-engine-one-off-item\");\n          // Typing de-selects the settings or opensearch buttons at the bottom\n          // of the search panel, as typing shows the user intends to search.\n          if (this.selectedButton && !isOneOffSelected)\n            this.selectedButton = null;\n          if (this.query) {\n            groupText = headerSearchText.previousElementSibling.value +\n                        '\"' + headerSearchText.value + '\"' +\n                        headerSearchText.nextElementSibling.value;\n            if (!isOneOffSelected)\n              this.header.selectedIndex = 1;\n          } else {\n            let noSearchHeader =\n              document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                      \"searchbar-oneoffheader-search\");\n            groupText = noSearchHeader.value;\n            if (!isOneOffSelected)\n              this.header.selectedIndex = 0;\n          }\n          this.buttons.setAttribute(\"aria-label\", groupText);\n        ]]></body>\n      </method>\n\n      <field name=\"_engines\">null</field>\n      <property name=\"engines\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._engines)\n            return this._engines;\n          let currentEngineNameToIgnore;\n          if (!this.getAttribute(\"includecurrentengine\"))\n            currentEngineNameToIgnore = Services.search.currentEngine.name;\n\n          let pref = Services.prefs.getStringPref(\"browser.search.hiddenOneOffs\");\n          let hiddenList = pref ? pref.split(\",\") : [];\n\n          this._engines = Services.search.getVisibleEngines().filter(e => {\n            let name = e.name;\n            return (!currentEngineNameToIgnore ||\n                    name != currentEngineNameToIgnore) &&\n                   !hiddenList.includes(name);\n          });\n\n          return this._engines;\n        ]]></getter>\n      </property>\n\n      <!-- Builds all the UI. -->\n      <method name=\"_rebuild\">\n        <body><![CDATA[\n          // Update the 'Search for <keywords> with:\" header.\n          this._updateAfterQueryChanged();\n\n          // Handle opensearch items. This needs to be done before building the\n          // list of one off providers, as that code will return early if all the\n          // alternative engines are hidden.\n          // Skip this in compact mode, ie. for the urlbar.\n          if (!this.compact)\n            this._rebuildAddEngineList();\n\n          // Check if the one-off buttons really need to be rebuilt.\n          if (this._textbox) {\n            // We can't get a reliable value for the popup width without flushing,\n            // but the popup width won't change if the textbox width doesn't.\n            let DOMUtils = window.windowUtils;\n            let textboxWidth =\n              DOMUtils.getBoundsWithoutFlushing(this._textbox).width;\n            // We can return early if neither the list of engines nor the panel\n            // width has changed.\n            if (this._engines && this._textboxWidth == textboxWidth) {\n              return;\n            }\n            this._textboxWidth = textboxWidth;\n          }\n\n          // Finally, build the list of one-off buttons.\n          while (this.buttons.firstElementChild != this.settingsButtonCompact)\n            this.buttons.firstElementChild.remove();\n          // Remove the trailing empty text node introduced by the binding's\n          // content markup above.\n          if (this.settingsButtonCompact.nextElementSibling)\n            this.settingsButtonCompact.nextElementSibling.remove();\n\n          let engines = this.engines;\n          let oneOffCount = engines.length;\n          let collapsed = !oneOffCount ||\n                          (oneOffCount == 1 && engines[0].name == Services.search.currentEngine.name);\n\n          // header is a xul:deck so collapsed doesn't work on it, see bug 589569.\n          this.header.hidden = this.buttons.collapsed = collapsed;\n\n          if (collapsed)\n            return;\n\n          let panelWidth = parseInt(this.popup.clientWidth);\n\n          // There's one weird thing to guard against: when layout pixels\n          // aren't an integral multiple of device pixels, the last button\n          // of each row sometimes gets pushed to the next row, depending on the\n          // panel and button widths.\n          // This is likely because the clientWidth getter rounds the value, but\n          // the panel's border width is not an integer.\n          // As a workaround, decrement the width if the scale is not an integer.\n          let scale = window.windowUtils.screenPixelsPerCSSPixel;\n          if (Math.floor(scale) != scale) {\n            --panelWidth;\n          }\n\n          // The + 1 is because the last button doesn't have a right border.\n          let enginesPerRow = Math.floor((panelWidth + 1) / this.buttonWidth);\n          let buttonWidth = Math.floor(panelWidth / enginesPerRow);\n          // There will be an emtpy area of:\n          //   panelWidth - enginesPerRow * buttonWidth  px\n          // at the end of each row.\n\n          // If the <description> tag with the list of search engines doesn't have\n          // a fixed height, the panel will be sized incorrectly, causing the bottom\n          // of the suggestion <tree> to be hidden.\n          if (this.compact)\n            ++oneOffCount;\n          let rowCount = Math.ceil(oneOffCount / enginesPerRow);\n          let height = rowCount * 33; // 32px per row, 1px border.\n          this.buttons.setAttribute(\"height\", height + \"px\");\n\n          // Ensure we can refer to the settings buttons by ID:\n          let origin = this.telemetryOrigin;\n          this.settingsButton.id = origin + \"-anon-search-settings\";\n          this.settingsButtonCompact.id = origin + \"-anon-search-settings-compact\";\n\n          let dummyItems = enginesPerRow - (oneOffCount % enginesPerRow || enginesPerRow);\n          for (let i = 0; i < engines.length; ++i) {\n            let engine = engines[i];\n            let button = document.createXULElement(\"button\");\n            button.id = this._buttonIDForEngine(engine);\n            let uri = \"chrome://browser/skin/search-engine-placeholder.png\";\n            if (engine.iconURI) {\n              uri = engine.iconURI.spec;\n            }\n            button.setAttribute(\"image\", uri);\n            button.setAttribute(\"class\", \"searchbar-engine-one-off-item\");\n            button.setAttribute(\"tooltiptext\", engine.name);\n            button.setAttribute(\"width\", buttonWidth);\n            button.engine = engine;\n\n            if ((i + 1) % enginesPerRow == 0)\n              button.classList.add(\"last-of-row\");\n\n            if (i + 1 == engines.length)\n              button.classList.add(\"last-engine\");\n\n            if (i >= oneOffCount + dummyItems - enginesPerRow)\n              button.classList.add(\"last-row\");\n\n            this.buttons.insertBefore(button, this.settingsButtonCompact);\n          }\n\n          let hasDummyItems = !!dummyItems;\n          while (dummyItems) {\n            let button = document.createXULElement(\"button\");\n            button.setAttribute(\"class\", \"searchbar-engine-one-off-item dummy last-row\");\n            button.setAttribute(\"width\", buttonWidth);\n\n            if (!--dummyItems)\n              button.classList.add(\"last-of-row\");\n\n            this.buttons.insertBefore(button, this.settingsButtonCompact);\n          }\n\n          if (this.compact) {\n            this.settingsButtonCompact.setAttribute(\"width\", buttonWidth);\n            if (rowCount == 1 && hasDummyItems) {\n              // When there's only one row, make the compact settings button\n              // hug the right edge of the panel.  It may not due to the panel's\n              // width not being an integral multiple of the button width.  (See\n              // the \"There will be an emtpy area\" comment above.)  Increase the\n              // width of the last dummy item by the remainder.\n              let remainder = panelWidth - (enginesPerRow * buttonWidth);\n              let width = remainder + buttonWidth;\n              let lastDummyItem = this.settingsButtonCompact.previousElementSibling;\n              lastDummyItem.setAttribute(\"width\", width);\n            }\n          }\n        ]]></body>\n      </method>\n\n      <!-- If a page offers more than this number of engines, the add-engines\n           menu button is shown, instead of showing the engines directly in the\n           popup. -->\n      <field name=\"_addEngineMenuThreshold\">5</field>\n\n      <method name=\"_rebuildAddEngineList\">\n        <body><![CDATA[\n        let list = this.addEngines;\n        while (list.firstChild) {\n          list.firstChild.remove();\n        }\n\n        // Add a button for each engine that the page in the selected browser\n        // offers, except when there are too many offered engines.\n        // The popup isn't designed to handle too many (by scrolling for\n        // example), so a page could break the popup by offering too many.\n        // Instead, add a single menu button with a submenu of all the engines.\n\n        if (!gBrowser.selectedBrowser.engines) {\n          return;\n        }\n\n        let engines = gBrowser.selectedBrowser.engines;\n        let tooManyEngines = engines.length > this._addEngineMenuThreshold;\n\n        if (tooManyEngines) {\n          // Make the top-level menu button.\n          let button = document.createXULElement(\"toolbarbutton\");\n          list.appendChild(button);\n          button.classList.add(\"addengine-item\", \"badged-button\");\n          button.setAttribute(\"anonid\", \"addengine-menu-button\");\n          button.setAttribute(\"type\", \"menu\");\n          button.setAttribute(\"label\",\n            this.bundle.GetStringFromName(\"cmd_addFoundEngineMenu\"));\n          button.setAttribute(\"crop\", \"end\");\n          button.setAttribute(\"pack\", \"start\");\n\n          // Set the menu button's image to the image of the first engine.  The\n          // offered engines may have differing images, so there's no perfect\n          // choice here.\n          let engine = engines[0];\n          if (engine.icon) {\n            button.setAttribute(\"image\", engine.icon);\n          }\n\n          // Now make the button's child menupopup.\n          list = document.createXULElement(\"menupopup\");\n          button.appendChild(list);\n          list.setAttribute(\"anonid\", \"addengine-menu\");\n          list.setAttribute(\"position\", \"topright topleft\");\n\n          // Events from child menupopups bubble up to the autocomplete binding,\n          // which breaks it, so prevent these events from propagating.\n          let suppressEventTypes = [\n            \"popupshowing\",\n            \"popuphiding\",\n            \"popupshown\",\n            \"popuphidden\",\n          ];\n          for (let type of suppressEventTypes) {\n            list.addEventListener(type, event => {\n              event.stopPropagation();\n            });\n          }\n        }\n\n        // Finally, add the engines to the list.  If there aren't too many\n        // engines, the list is the add-engines vbox.  Otherwise it's the\n        // menupopup created earlier.  In the latter case, create menuitem\n        // elements instead of buttons, because buttons don't get keyboard\n        // handling for free inside menupopups.\n        let eltType = tooManyEngines ? \"menuitem\" : \"toolbarbutton\";\n        for (let engine of engines) {\n          let button = document.createXULElement(eltType);\n          button.classList.add(\"addengine-item\");\n          if (!tooManyEngines) {\n            button.classList.add(\"badged-button\");\n          }\n          button.id = this.telemetryOrigin + \"-add-engine-\" +\n                      this._fixUpEngineNameForID(engine.title);\n          let label = this.bundle.formatStringFromName(\"cmd_addFoundEngine\",\n                                                       [engine.title], 1);\n          button.setAttribute(\"label\", label);\n          button.setAttribute(\"crop\", \"end\");\n          button.setAttribute(\"tooltiptext\", engine.title + \"\\n\" + engine.uri);\n          button.setAttribute(\"uri\", engine.uri);\n          button.setAttribute(\"title\", engine.title);\n          if (engine.icon) {\n            button.setAttribute(\"image\", engine.icon);\n          }\n          if (tooManyEngines) {\n            button.classList.add(\"menuitem-iconic\");\n          } else {\n            button.setAttribute(\"pack\", \"start\");\n          }\n          list.appendChild(button);\n        }\n        ]]></body>\n      </method>\n\n      <method name=\"_buttonIDForEngine\">\n        <parameter name=\"engine\"/>\n        <body><![CDATA[\n          return this.telemetryOrigin + \"-engine-one-off-item-\" +\n                 this._fixUpEngineNameForID(engine.name);\n        ]]></body>\n      </method>\n\n      <method name=\"_fixUpEngineNameForID\">\n        <parameter name=\"name\"/>\n        <body><![CDATA[\n          return name.replace(/ /g, \"-\");\n        ]]></body>\n      </method>\n\n      <method name=\"_buttonForEngine\">\n        <parameter name=\"engine\"/>\n        <body><![CDATA[\n          return document.getElementById(this._buttonIDForEngine(engine));\n        ]]></body>\n      </method>\n\n      <!--\n        Updates the popup and textbox for the currently selected or moused-over\n        button.\n\n        @param mousedOverButton\n               The currently moused-over button, or null if there isn't one.\n      -->\n      <method name=\"_updateStateForButton\">\n        <parameter name=\"mousedOverButton\"/>\n        <body><![CDATA[\n          let button = mousedOverButton;\n\n          // Ignore dummy buttons.\n          if (button && button.classList.contains(\"dummy\")) {\n            button = null;\n          }\n\n          // If there's no moused-over button, then the one-offs should reflect\n          // the selected button, if any.\n          button = button || this.selectedButton;\n\n          if (!button) {\n            this.header.selectedIndex = this.query ? 1 : 0;\n            if (this.textbox) {\n              this.textbox.removeAttribute(\"aria-activedescendant\");\n            }\n            return;\n          }\n\n          if (button.classList.contains(\"searchbar-engine-one-off-item\") &&\n              button.engine) {\n            let headerEngineText =\n              document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                      \"searchbar-oneoffheader-engine\");\n            this.header.selectedIndex = 2;\n            headerEngineText.value = button.engine.name;\n          } else {\n            this.header.selectedIndex = this.query ? 1 : 0;\n          }\n          if (this.textbox) {\n            this.textbox.setAttribute(\"aria-activedescendant\", button.id);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"getSelectableButtons\">\n        <parameter name=\"aIncludeNonEngineButtons\"/>\n        <body><![CDATA[\n          let buttons = [];\n          for (let oneOff = this.buttons.firstElementChild; oneOff; oneOff = oneOff.nextElementSibling) {\n            // oneOff may be a text node since the list xul:description contains\n            // whitespace and the compact settings button.  See the markup\n            // above.  _rebuild removes text nodes, but it may not have been\n            // called yet (because e.g. the popup hasn't been opened yet).\n            if (oneOff.nodeType == Node.ELEMENT_NODE) {\n              if (oneOff.classList.contains(\"dummy\") ||\n                  oneOff.classList.contains(\"search-setting-button-compact\"))\n                break;\n              buttons.push(oneOff);\n            }\n          }\n\n          if (aIncludeNonEngineButtons) {\n            for (let addEngine = this.addEngines.firstElementChild; addEngine; addEngine = addEngine.nextElementSibling) {\n              buttons.push(addEngine);\n            }\n            buttons.push(this.compact ? this.settingsButtonCompact : this.settingsButton);\n          }\n\n          return buttons;\n        ]]></body>\n      </method>\n\n      <method name=\"handleSearchCommand\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aEngine\"/>\n        <parameter name=\"aForceNewTab\"/>\n        <body><![CDATA[\n          let where = \"current\";\n          let params;\n\n          // Open ctrl/cmd clicks on one-off buttons in a new background tab.\n          if (aForceNewTab) {\n            where = \"tab\";\n            if (Services.prefs.getBoolPref(\"browser.tabs.loadInBackground\")) {\n              params = {\n                inBackground: true,\n              };\n            }\n          } else {\n            var newTabPref = Services.prefs.getBoolPref(\"browser.search.openintab\");\n            if (((aEvent instanceof KeyboardEvent && aEvent.altKey) ^ newTabPref) &&\n                !isTabEmpty(gBrowser.selectedTab)) {\n              where = \"tab\";\n            }\n            if ((aEvent instanceof MouseEvent) &&\n                (aEvent.button == 1 || aEvent.getModifierState(\"Accel\"))) {\n              where = \"tab\";\n              params = {\n                inBackground: true,\n              };\n            }\n          }\n\n          this.popup.handleOneOffSearch(aEvent, aEngine, where, params);\n        ]]></body>\n      </method>\n\n      <!--\n        Increments or decrements the index of the currently selected one-off.\n\n        @param aForward\n               If true, the index is incremented, and if false, the index is\n               decremented.\n        @param aIncludeNonEngineButtons\n               If true, non-dummy buttons that do not have engines are included.\n               These buttons include the OpenSearch and settings buttons.  For\n               example, if the currently selected button is an engine button,\n               the next button is the settings button, and you pass true for\n               aForward, then passing true for this value would cause the\n               settings to be selected.  Passing false for this value would\n               cause the selection to clear or wrap around, depending on what\n               value you passed for the aWrapAround parameter.\n        @param aWrapAround\n               If true, the selection wraps around between the first and last\n               buttons.\n        @return True if the selection can continue to advance after this method\n                returns and false if not.\n      -->\n      <method name=\"advanceSelection\">\n        <parameter name=\"aForward\"/>\n        <parameter name=\"aIncludeNonEngineButtons\"/>\n        <parameter name=\"aWrapAround\"/>\n        <body><![CDATA[\n          let buttons = this.getSelectableButtons(aIncludeNonEngineButtons);\n          let index;\n          if (this.selectedButton) {\n            let inc = aForward ? 1 : -1;\n            let oldIndex = buttons.indexOf(this.selectedButton);\n            index = ((oldIndex + inc) + buttons.length) % buttons.length;\n            if (!aWrapAround &&\n                ((aForward && index <= oldIndex) ||\n                 (!aForward && oldIndex <= index))) {\n              // The index has wrapped around, but wrapping around isn't\n              // allowed.\n              index = -1;\n            }\n          } else {\n            index = aForward ? 0 : buttons.length - 1;\n          }\n          this.selectedButton = index < 0 ? null : buttons[index];\n        ]]></body>\n      </method>\n\n      <!--\n        This handles key presses specific to the one-off buttons like Tab and\n        Alt+Up/Down, and Up/Down keys within the buttons.  Since one-off buttons\n        are always used in conjunction with a list of some sort (in this.popup),\n        it also handles Up/Down keys that cross the boundaries between list\n        items and the one-off buttons.\n\n        If this method handles the key press, then event.defaultPrevented will\n        be true when it returns.\n\n        @param event\n               The key event.\n        @param numListItems\n               The number of items in the list.  The reason that this is a\n               parameter at all is that the list may contain items at the end\n               that should be ignored, depending on the consumer.  That's true\n               for the urlbar for example.\n        @param allowEmptySelection\n               Pass true if it's OK that neither the list nor the one-off\n               buttons contains a selection.  Pass false if either the list or\n               the one-off buttons (or both) should always contain a selection.\n        @param textboxUserValue\n               When the last list item is selected and the user presses Down,\n               the first one-off becomes selected and the textbox value is\n               restored to the value that the user typed.  Pass that value here.\n               However, if you pass true for allowEmptySelection, you don't need\n               to pass anything for this parameter.  (Pass undefined or null.)\n      -->\n      <method name=\"handleKeyPress\">\n        <parameter name=\"event\"/>\n        <parameter name=\"numListItems\"/>\n        <parameter name=\"allowEmptySelection\"/>\n        <parameter name=\"textboxUserValue\"/>\n        <body><![CDATA[\n          if (!this.popup) {\n            return;\n          }\n          let handled = this._handleKeyPress(event, numListItems,\n                                             allowEmptySelection,\n                                             textboxUserValue);\n          if (handled) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_handleKeyPress\">\n        <parameter name=\"event\"/>\n        <parameter name=\"numListItems\"/>\n        <parameter name=\"allowEmptySelection\"/>\n        <parameter name=\"textboxUserValue\"/>\n        <body><![CDATA[\n          if (this.compact && this.buttons.collapsed)\n            return false;\n          if (event.keyCode == KeyEvent.DOM_VK_RIGHT &&\n              this.selectedButton &&\n              this.selectedButton.getAttribute(\"anonid\") ==\n                \"addengine-menu-button\") {\n            // If the add-engine overflow menu item is selected and the user\n            // presses the right arrow key, open the submenu.  Unfortunately\n            // handling the left arrow key -- to close the popup -- isn't\n            // straightforward.  Once the popup is open, it consumes all key\n            // events.  Setting ignorekeys=handled on it doesn't help, since the\n            // popup handles all arrow keys.  Setting ignorekeys=true on it does\n            // mean that the popup no longer consumes the left arrow key, but\n            // then it no longer handles up/down keys to select items in the\n            // popup.\n            this.selectedButton.open = true;\n            return true;\n          }\n\n          // Handle the Tab key, but only if non-Shift modifiers aren't also\n          // pressed to avoid clobbering other shortcuts (like the Alt+Tab\n          // browser tab switcher).  The reason this uses getModifierState() and\n          // checks for \"AltGraph\" is that when you press Shift-Alt-Tab,\n          // event.altKey is actually false for some reason, at least on macOS.\n          // getModifierState(\"Alt\") is also false, but \"AltGraph\" is true.\n          if (event.keyCode == KeyEvent.DOM_VK_TAB &&\n              !event.getModifierState(\"Alt\") &&\n              !event.getModifierState(\"AltGraph\") &&\n              !event.getModifierState(\"Control\") &&\n              !event.getModifierState(\"Meta\")) {\n            if (this.getAttribute(\"disabletab\") == \"true\" ||\n                (event.shiftKey &&\n                  this.selectedButtonIndex <= 0) ||\n                (!event.shiftKey &&\n                 this.selectedButtonIndex ==\n                   this.getSelectableButtons(true).length - 1)) {\n              this.selectedButton = null;\n              return false;\n            }\n            this.popup.selectedIndex = -1;\n            this.advanceSelection(!event.shiftKey, true, false);\n            return !!this.selectedButton;\n          }\n\n          if (event.keyCode == KeyboardEvent.DOM_VK_UP) {\n            if (event.altKey) {\n              // Keep the currently selected result in the list (if any) as a\n              // secondary \"alt\" selection and move the selection up within the\n              // buttons.\n              this.advanceSelection(false, false, false);\n              return true;\n            }\n            if (numListItems == 0) {\n              this.advanceSelection(false, true, false);\n              return true;\n            }\n            if (this.popup.selectedIndex > 0) {\n              // Moving up within the list.  The autocomplete controller should\n              // handle this case.  A button may be selected, so null it.\n              this.selectedButton = null;\n              return false;\n            }\n            if (this.popup.selectedIndex == 0) {\n              // Moving up from the top of the list.\n              if (allowEmptySelection) {\n                // Let the autocomplete controller remove selection in the list\n                // and revert the typed text in the textbox.\n                return false;\n              }\n              // Wrap selection around to the last button.\n              if (this.textbox && typeof(textboxUserValue) == \"string\") {\n                this.textbox.value = textboxUserValue;\n              }\n              this.advanceSelection(false, true, true);\n              return true;\n            }\n            if (!this.selectedButton) {\n              // Moving up from no selection in the list or the buttons, back\n              // down to the last button.\n              this.advanceSelection(false, true, true);\n              return true;\n            }\n            if (this.selectedButtonIndex == 0) {\n              // Moving up from the buttons to the bottom of the list.\n              this.selectedButton = null;\n              return false;\n            }\n            // Moving up/left within the buttons.\n            this.advanceSelection(false, true, false);\n            return true;\n          }\n\n          if (event.keyCode == KeyboardEvent.DOM_VK_DOWN) {\n            if (event.altKey) {\n              // Keep the currently selected result in the list (if any) as a\n              // secondary \"alt\" selection and move the selection down within\n              // the buttons.\n              this.advanceSelection(true, false, false);\n              return true;\n            }\n            if (numListItems == 0) {\n              this.advanceSelection(true, true, false);\n              return true;\n            }\n            if (this.popup.selectedIndex >= 0 &&\n                this.popup.selectedIndex < numListItems - 1) {\n              // Moving down within the list.  The autocomplete controller\n              // should handle this case.  A button may be selected, so null it.\n              this.selectedButton = null;\n              return false;\n            }\n            if (this.popup.selectedIndex == numListItems - 1) {\n              // Moving down from the last item in the list to the buttons.\n              this.selectedButtonIndex = 0;\n              if (allowEmptySelection) {\n                // Let the autocomplete controller remove selection in the list\n                // and revert the typed text in the textbox.\n                return false;\n              }\n              if (this.textbox && typeof(textboxUserValue) == \"string\") {\n                this.textbox.value = textboxUserValue;\n              }\n              this.popup.selectedIndex = -1;\n              return true;\n            }\n            if (this.selectedButton) {\n              let buttons = this.getSelectableButtons(true);\n              if (this.selectedButtonIndex == buttons.length - 1) {\n                // Moving down from the buttons back up to the top of the list.\n                this.selectedButton = null;\n                if (allowEmptySelection) {\n                  // Prevent the selection from wrapping around to the top of\n                  // the list by returning true, since the list currently has no\n                  // selection.  Nothing should be selected after handling this\n                  // Down key.\n                  return true;\n                }\n                return false;\n              }\n              // Moving down/right within the buttons.\n              this.advanceSelection(true, true, false);\n              return true;\n            }\n            return false;\n          }\n\n          if (event.keyCode == KeyboardEvent.DOM_VK_LEFT) {\n            if (this.selectedButton &&\n                (this.compact || this.selectedButton.engine)) {\n              // Moving left within the buttons.\n              this.advanceSelection(false, this.compact, true);\n              return true;\n            }\n            return false;\n          }\n\n          if (event.keyCode == KeyboardEvent.DOM_VK_RIGHT) {\n            if (this.selectedButton &&\n                (this.compact || this.selectedButton.engine)) {\n              // Moving right within the buttons.\n              this.advanceSelection(true, this.compact, true);\n              return true;\n            }\n            return false;\n          }\n\n          return false;\n        ]]></body>\n      </method>\n\n      <!--\n        If the given event is related to the one-offs, this method records\n        one-off telemetry for it.  this.telemetryOrigin will be appended to the\n        computed source, so make sure you set that first.\n\n        @param aEvent\n               An event, like a click on a one-off button.\n        @param aOpenUILinkWhere\n               The \"where\" passed to openUILink.\n        @param aOpenUILinkParams\n               The \"params\" passed to openUILink.\n        @return True if telemetry was recorded and false if not.\n      -->\n      <method name=\"maybeRecordTelemetry\">\n        <parameter name=\"aEvent\"/>\n        <parameter name=\"aOpenUILinkWhere\"/>\n        <parameter name=\"aOpenUILinkParams\"/>\n        <body><![CDATA[\n          if (!aEvent) {\n            return false;\n          }\n\n          let source = null;\n          let type = \"unknown\";\n          let engine = null;\n          let target = aEvent.originalTarget;\n\n          if (aEvent instanceof KeyboardEvent) {\n            type = \"key\";\n            if (this.selectedButton) {\n              source = \"oneoff\";\n              engine = this.selectedButton.engine;\n            }\n          } else if (aEvent instanceof MouseEvent) {\n            type = \"mouse\";\n            if (target.classList.contains(\"searchbar-engine-one-off-item\")) {\n              source = \"oneoff\";\n              engine = target.engine;\n            }\n          } else if ((aEvent instanceof XULCommandEvent) &&\n                     target.getAttribute(\"anonid\") ==\n                       \"search-one-offs-context-open-in-new-tab\") {\n            source = \"oneoff-context\";\n            engine = this._contextEngine;\n          }\n\n          if (!source) {\n            return false;\n          }\n\n          if (this.telemetryOrigin) {\n            source += \"-\" + this.telemetryOrigin;\n          }\n\n          let tabBackground = aOpenUILinkWhere == \"tab\" &&\n                              aOpenUILinkParams &&\n                              aOpenUILinkParams.inBackground;\n          let where = tabBackground ? \"tab-background\" : aOpenUILinkWhere;\n          BrowserSearch.recordOneoffSearchInTelemetry(engine, source, type,\n                                                      where);\n          return true;\n        ]]></body>\n      </method>\n\n      <!-- All this stuff is to make the add-engines menu button behave like an\n           actual menu.  The add-engines menu button is shown when there are\n           many engines offered by the current site. -->\n      <field name=\"_addEngineMenuTimeoutMs\">200</field>\n      <field name=\"_addEngineMenuTimeout\">null</field>\n      <field name=\"_addEngineMenuShouldBeOpen\">false</field>\n\n      <method name=\"_resetAddEngineMenuTimeout\">\n        <body><![CDATA[\n        if (this._addEngineMenuTimeout) {\n          clearTimeout(this._addEngineMenuTimeout);\n        }\n        this._addEngineMenuTimeout = setTimeout(() => {\n          delete this._addEngineMenuTimeout;\n          let button = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"addengine-menu-button\"\n          );\n          button.open = this._addEngineMenuShouldBeOpen;\n        }, this._addEngineMenuTimeoutMs);\n        ]]></body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n\n      <handler event=\"mousedown\"><![CDATA[\n        let target = event.originalTarget;\n        if (target.getAttribute(\"anonid\") == \"addengine-menu-button\") {\n          return;\n        }\n        // Required to receive click events from the buttons on Linux.\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"mousemove\"><![CDATA[\n        let target = event.originalTarget;\n\n        // Handle mouseover on the add-engine menu button and its popup items.\n        if (target.getAttribute(\"anonid\") == \"addengine-menu-button\" ||\n            (target.localName == \"menuitem\" &&\n             target.classList.contains(\"addengine-item\"))) {\n          let menuButton = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"addengine-menu-button\"\n          );\n          this._updateStateForButton(menuButton);\n          this._addEngineMenuShouldBeOpen = true;\n          this._resetAddEngineMenuTimeout();\n          return;\n        }\n\n        if (target.localName != \"button\")\n          return;\n\n        // Ignore mouse events when the context menu is open.\n         if (this._ignoreMouseEvents)\n           return;\n\n        let isOneOff =\n          target.classList.contains(\"searchbar-engine-one-off-item\") &&\n          !target.classList.contains(\"dummy\");\n        if (isOneOff ||\n            target.classList.contains(\"addengine-item\") ||\n            target.classList.contains(\"search-setting-button\")) {\n          this._updateStateForButton(target);\n        }\n      ]]></handler>\n\n      <handler event=\"mouseout\"><![CDATA[\n\n        let target = event.originalTarget;\n\n        // Handle mouseout on the add-engine menu button and its popup items.\n        if (target.getAttribute(\"anonid\") == \"addengine-menu-button\" ||\n            (target.localName == \"menuitem\" &&\n             target.classList.contains(\"addengine-item\"))) {\n          this._updateStateForButton(null);\n          this._addEngineMenuShouldBeOpen = false;\n          this._resetAddEngineMenuTimeout();\n          return;\n        }\n\n        if (target.localName != \"button\") {\n          return;\n        }\n\n        // Don't update the mouseover state if the context menu is open.\n        if (this._ignoreMouseEvents)\n          return;\n\n        this._updateStateForButton(null);\n      ]]></handler>\n\n      <handler event=\"click\"><![CDATA[\n        if (event.button == 2)\n          return; // ignore right clicks.\n\n        let button = event.originalTarget;\n        let engine = button.engine;\n\n        if (!engine)\n          return;\n\n        // Select the clicked button so that consumers can easily tell which\n        // button was acted on.\n        this.selectedButton = button;\n        this.handleSearchCommand(event, engine);\n      ]]></handler>\n\n      <handler event=\"command\"><![CDATA[\n        let target = event.originalTarget;\n        if (target.classList.contains(\"addengine-item\")) {\n          // On success, hide the panel and tell event listeners to reshow it to\n          // show the new engine.\n          let installCallback = {\n            onSuccess: engine => {\n              this._rebuild();\n            },\n            onError(errorCode) {\n              if (errorCode != Ci.nsISearchInstallCallback.ERROR_DUPLICATE_ENGINE) {\n                // Download error is shown by the search service\n                return;\n              }\n              const kSearchBundleURI = \"chrome://global/locale/search/search.properties\";\n              let searchBundle = Services.strings.createBundle(kSearchBundleURI);\n              let brandBundle = document.getElementById(\"bundle_brand\");\n              let brandName = brandBundle.getString(\"brandShortName\");\n              let title = searchBundle.GetStringFromName(\"error_invalid_engine_title\");\n              let text = searchBundle.formatStringFromName(\"error_duplicate_engine_msg\",\n                                                           [brandName, target.getAttribute(\"uri\")], 2);\n              Services.prompt.QueryInterface(Ci.nsIPromptFactory);\n              let prompt = Services.prompt.getPrompt(gBrowser.contentWindow, Ci.nsIPrompt);\n              prompt.QueryInterface(Ci.nsIWritablePropertyBag2);\n              prompt.setPropertyAsBool(\"allowTabModal\", true);\n              prompt.alert(title, text);\n            },\n          };\n          Services.search.addEngine(target.getAttribute(\"uri\"),\n                                    target.getAttribute(\"image\"), false,\n                                    installCallback);\n        }\n        let anonid = target.getAttribute(\"anonid\");\n        if (anonid == \"search-one-offs-context-open-in-new-tab\") {\n          // Select the context-clicked button so that consumers can easily\n          // tell which button was acted on.\n          this.selectedButton = this._buttonForEngine(this._contextEngine);\n          this.handleSearchCommand(event, this._contextEngine, true);\n        }\n        if (anonid == \"search-one-offs-context-set-default\") {\n          let currentEngine = Services.search.currentEngine;\n\n          if (!this.getAttribute(\"includecurrentengine\")) {\n            // Make the target button of the context menu reflect the current\n            // search engine first. Doing this as opposed to rebuilding all the\n            // one-off buttons avoids flicker.\n            let button = this._buttonForEngine(this._contextEngine);\n            button.id = this._buttonIDForEngine(currentEngine);\n            let uri = \"chrome://browser/skin/search-engine-placeholder.png\";\n            if (currentEngine.iconURI)\n              uri = currentEngine.iconURI.spec;\n            button.setAttribute(\"image\", uri);\n            button.setAttribute(\"tooltiptext\", currentEngine.name);\n            button.engine = currentEngine;\n          }\n\n          Services.search.currentEngine = this._contextEngine;\n        }\n      ]]></handler>\n\n      <handler event=\"contextmenu\"><![CDATA[\n        let target = event.originalTarget;\n        // Prevent the context menu from appearing except on the one off buttons.\n        if (!target.classList.contains(\"searchbar-engine-one-off-item\") ||\n            target.classList.contains(\"dummy\")) {\n          event.preventDefault();\n          return;\n        }\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"search-one-offs-context-set-default\")\n                .setAttribute(\"disabled\", target.engine == Services.search.currentEngine);\n\n        this._contextEngine = target.engine;\n      ]]></handler>\n    </handlers>\n\n  </binding>\n\n</bindings>\n"},{"file":"translation-infobar.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings [\n<!ENTITY % notificationDTD SYSTEM \"chrome://global/locale/notification.dtd\">\n%notificationDTD;\n<!ENTITY % translationDTD SYSTEM \"chrome://browser/locale/translation.dtd\" >\n%translationDTD;\n]>\n\n<bindings id=\"translationBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n  <binding id=\"translationbar\" extends=\"chrome://global/content/bindings/notification.xml#notification\">\n    <content>\n      <xul:hbox anonid=\"details\" align=\"center\" flex=\"1\">\n        <xul:image class=\"translate-infobar-element messageImage\"\n                   anonid=\"messageImage\"/>\n        <xul:panel anonid=\"welcomePanel\" class=\"translation-welcome-panel\"\n                   type=\"arrow\" align=\"start\">\n          <xul:image class=\"translation-welcome-logo\"/>\n          <xul:vbox flex=\"1\" class=\"translation-welcome-content\">\n            <xul:description class=\"translation-welcome-headline\"\n                             anonid=\"welcomeHeadline\"/>\n            <xul:description class=\"translation-welcome-body\" anonid=\"welcomeBody\"/>\n            <xul:hbox align=\"center\">\n              <xul:label anonid=\"learnMore\" class=\"plain text-link\"\n                         onclick=\"openTrustedLinkIn('https://support.mozilla.org/kb/automatic-translation', 'tab'); this.parentNode.parentNode.parentNode.hidePopup();\"/>\n              <xul:spacer flex=\"1\"/>\n              <xul:button class=\"translate-infobar-element\" anonid=\"thanksButton\"\n                          onclick=\"this.parentNode.parentNode.parentNode.hidePopup();\"/>\n            </xul:hbox>\n          </xul:vbox>\n        </xul:panel>\n        <xul:deck anonid=\"translationStates\" selectedIndex=\"0\">\n\n          <!-- offer to translate -->\n          <xul:hbox class=\"translate-offer-box\" align=\"center\">\n            <xul:label class=\"translate-infobar-element\" value=\"FROM-DTD.translation.thisPageIsIn.label;\"/>\n            <xul:menulist class=\"translate-infobar-element\" anonid=\"detectedLanguage\">\n              <xul:menupopup/>\n            </xul:menulist>\n            <xul:label class=\"translate-infobar-element\" value=\"FROM-DTD.translation.translateThisPage.label;\"/>\n            <xul:button class=\"translate-infobar-element\"\n                        label=\"FROM-DTD.translation.translate.button;\"\n                        anonid=\"translate\"\n                        oncommand=\"document.getBindingParent(this).translate();\"/>\n            <xul:button class=\"translate-infobar-element\"\n                        label=\"FROM-DTD.translation.notNow.button;\" anonid=\"notNow\"\n                        oncommand=\"document.getBindingParent(this).closeCommand();\"/>\n          </xul:hbox>\n\n          <!-- translating -->\n          <xul:vbox class=\"translating-box\" pack=\"center\">\n            <xul:label class=\"translate-infobar-element\"\n                       value=\"FROM-DTD.translation.translatingContent.label;\"/>\n          </xul:vbox>\n\n          <!-- translated -->\n          <xul:hbox class=\"translated-box\" align=\"center\">\n            <xul:label class=\"translate-infobar-element\"\n                       value=\"FROM-DTD.translation.translatedFrom.label;\"/>\n            <xul:menulist class=\"translate-infobar-element\"\n                          anonid=\"fromLanguage\"\n                          oncommand=\"document.getBindingParent(this).translate()\">\n              <xul:menupopup/>\n            </xul:menulist>\n            <xul:label class=\"translate-infobar-element\"\n                       value=\"FROM-DTD.translation.translatedTo.label;\"/>\n            <xul:menulist class=\"translate-infobar-element\"\n                          anonid=\"toLanguage\"\n                          oncommand=\"document.getBindingParent(this).translate()\">\n              <xul:menupopup/>\n            </xul:menulist>\n            <xul:label class=\"translate-infobar-element\"\n                       value=\"FROM-DTD.translation.translatedToSuffix.label;\"/>\n            <xul:button anonid=\"showOriginal\"\n                        class=\"translate-infobar-element\"\n                        label=\"FROM-DTD.translation.showOriginal.button;\"\n                        oncommand=\"document.getBindingParent(this).showOriginal();\"/>\n            <xul:button anonid=\"showTranslation\"\n                        class=\"translate-infobar-element\"\n                        label=\"FROM-DTD.translation.showTranslation.button;\"\n                        oncommand=\"document.getBindingParent(this).showTranslation();\"/>\n          </xul:hbox>\n\n          <!-- error -->\n          <xul:hbox class=\"translation-error\" align=\"center\">\n            <xul:label class=\"translate-infobar-element\"\n                       value=\"FROM-DTD.translation.errorTranslating.label;\"/>\n            <xul:button class=\"translate-infobar-element\"\n                        label=\"FROM-DTD.translation.tryAgain.button;\"\n                        anonid=\"tryAgain\"\n                        oncommand=\"document.getBindingParent(this).translate();\"/>\n          </xul:hbox>\n\n          <!-- unavailable -->\n          <xul:vbox class=\"translation-unavailable\" pack=\"center\">\n            <xul:label class=\"translate-infobar-element\"\n                       value=\"FROM-DTD.translation.serviceUnavailable.label;\"/>\n          </xul:vbox>\n\n        </xul:deck>\n        <xul:spacer flex=\"1\"/>\n\n        <xul:button type=\"menu\"\n                    class=\"translate-infobar-element options-menu-button\"\n                    anonid=\"options\"\n                    label=\"FROM-DTD.translation.options.menu;\">\n          <xul:menupopup class=\"translation-menupopup cui-widget-panel cui-widget-panelview\n                                cui-widget-panelWithFooter PanelUI-subView\"\n                         onpopupshowing=\"document.getBindingParent(this).optionsShowing();\">\n            <xul:menuitem anonid=\"neverForLanguage\"\n                          oncommand=\"document.getBindingParent(this).neverForLanguage();\"/>\n            <xul:menuitem anonid=\"neverForSite\"\n                          oncommand=\"document.getBindingParent(this).neverForSite();\"\n                          label=\"FROM-DTD.translation.options.neverForSite.label;\"\n                          accesskey=\"FROM-DTD.translation.options.neverForSite.accesskey;\"/>\n            <xul:menuseparator/>\n            <xul:menuitem oncommand=\"openPreferences('paneGeneral', {origin:'translationInfobar'});\"\n                          label=\"FROM-DTD.translation.options.preferences.label;\"\n                          accesskey=\"FROM-DTD.translation.options.preferences.accesskey;\"/>\n            <xul:menuitem class=\"subviewbutton panel-subview-footer\"\n                          oncommand=\"document.getBindingParent(this).openProviderAttribution();\">\n              <xul:deck anonid=\"translationEngine\" selectedIndex=\"0\">\n                <xul:hbox class=\"translation-attribution\">\n                  <xul:label>FROM-DTD.translation.options.attribution.beforeLogo;</xul:label>\n                  <xul:image src=\"chrome://browser/content/microsoft-translator-attribution.png\"\n                             aria-label=\"Microsoft Translator\"/>\n                  <xul:label>FROM-DTD.translation.options.attribution.afterLogo;</xul:label>\n                </xul:hbox>\n                <xul:label class=\"translation-attribution\">FROM-DTD.translation.options.attribution.yandexTranslate;</xul:label>\n              </xul:deck>\n            </xul:menuitem>\n          </xul:menupopup>\n        </xul:button>\n\n      </xul:hbox>\n      <xul:toolbarbutton ondblclick=\"event.stopPropagation();\"\n                         anonid=\"closeButton\"\n                         class=\"messageCloseButton close-icon tabbable\"\n                         xbl:inherits=\"hidden=hideclose\"\n                         tooltiptext=\"FROM-DTD.closeNotification.tooltip;\"\n                         oncommand=\"document.getBindingParent(this).closeCommand();\"/>\n    </content>\n    <implementation>\n      <property name=\"state\"\n                onget=\"return this._getAnonElt('translationStates').selectedIndex;\">\n        <setter>\n          <![CDATA[\n          let deck = this._getAnonElt(\"translationStates\");\n\n          let activeElt = document.activeElement;\n          if (activeElt && deck.contains(activeElt))\n            activeElt.blur();\n\n          let stateName;\n          for (let name of [\"OFFER\", \"TRANSLATING\", \"TRANSLATED\", \"ERROR\"]) {\n            if (Translation[\"STATE_\" + name] == val) {\n              stateName = name.toLowerCase();\n              break;\n            }\n          }\n          this.setAttribute(\"state\", stateName);\n\n          if (val == Translation.STATE_TRANSLATED)\n            this._handleButtonHiding();\n\n          deck.selectedIndex = val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"init\">\n        <parameter name=\"aTranslation\"/>\n        <body>\n          <![CDATA[\n            this.translation = aTranslation;\n\n            let sortByLocalizedName = function(aList) {\n              let names = Services.intl.getLanguageDisplayNames(undefined, aList);\n              return aList.map((code, i) => [code, names[i]])\n                          .sort((a, b) => a[1].localeCompare(b[1]));\n            };\n\n            // Fill the lists of supported source languages.\n            let detectedLanguage = this._getAnonElt(\"detectedLanguage\");\n            let fromLanguage = this._getAnonElt(\"fromLanguage\");\n            let sourceLanguages =\n              sortByLocalizedName(Translation.supportedSourceLanguages);\n            for (let [code, name] of sourceLanguages) {\n              detectedLanguage.appendItem(name, code);\n              fromLanguage.appendItem(name, code);\n            }\n            detectedLanguage.value = this.translation.detectedLanguage;\n\n            // translatedFrom is only set if we have already translated this page.\n            if (aTranslation.translatedFrom)\n              fromLanguage.value = aTranslation.translatedFrom;\n\n            // Fill the list of supported target languages.\n            let toLanguage = this._getAnonElt(\"toLanguage\");\n            let targetLanguages =\n              sortByLocalizedName(Translation.supportedTargetLanguages);\n            for (let [code, name] of targetLanguages)\n              toLanguage.appendItem(name, code);\n\n            if (aTranslation.translatedTo)\n              toLanguage.value = aTranslation.translatedTo;\n\n            if (aTranslation.state)\n              this.state = aTranslation.state;\n\n            // Show attribution for the preferred translator.\n            let engineIndex = Object.keys(Translation.supportedEngines)\n              .indexOf(Translation.translationEngine);\n            // We currently only have attribution for the Bing and Yandex engines.\n            if (engineIndex >= 0) {\n              --engineIndex;\n            }\n            let attributionNode = this._getAnonElt(\"translationEngine\");\n            if (engineIndex != -1) {\n              attributionNode.selectedIndex = engineIndex;\n            } else {\n              // Hide the attribution menuitem\n              let footer = attributionNode.parentNode;\n              footer.hidden = true;\n              // Make the 'Translation preferences' item the new footer.\n              footer = footer.previousSibling;\n              footer.setAttribute(\"class\", \"subviewbutton panel-subview-footer\");\n              // And hide the menuseparator.\n              footer.previousSibling.hidden = true;\n            }\n\n            const kWelcomePref = \"browser.translation.ui.welcomeMessageShown\";\n            if (Services.prefs.prefHasUserValue(kWelcomePref) ||\n                this.translation.browser != gBrowser.selectedBrowser)\n              return;\n\n            this.addEventListener(\"transitionend\", function() {\n              // These strings are hardcoded because they need to reach beta\n              // without riding the trains.\n              let localizedStrings = {\n                en: [\"Hey look! It's something new!\",\n                     \"Now the Web is even more accessible with our new in-page translation feature. Click the translate button to try it!\",\n                     \"Learn more.\",\n                     \"Thanks\"],\n                \"es-AR\": [\"\\xA1Mir\\xE1! \\xA1Hay algo nuevo!\",\n                          \"Ahora la web es a\\xFAn m\\xE1s accesible con nuestra nueva funcionalidad de traducci\\xF3n integrada. \\xA1Hac\\xE9 clic en el bot\\xF3n traducir para probarla!\",\n                          \"Conoc\\xE9 m\\xE1s.\",\n                          \"Gracias\"],\n                \"es-ES\": [\"\\xA1Mira! \\xA1Hay algo nuevo!\",\n                          \"Con la nueva funcionalidad de traducci\\xF3n integrada, ahora la Web es a\\xFAn m\\xE1s accesible. \\xA1Pulsa el bot\\xF3n Traducir y pru\\xE9bala!\",\n                          \"M\\xE1s informaci\\xF3n.\",\n                          \"Gracias\"],\n                pl: [\"Sp\\xF3jrz tutaj! To co\\u015B nowego!\",\n                     \"Sie\\u0107 sta\\u0142a si\\u0119 w\\u0142a\\u015Bnie jeszcze bardziej dost\\u0119pna dzi\\u0119ki opcji bezpo\\u015Bredniego t\\u0142umaczenia stron. Kliknij przycisk t\\u0142umaczenia, aby spr\\xF3bowa\\u0107!\",\n                     \"Dowiedz si\\u0119 wi\\u0119cej\",\n                     \"Dzi\\u0119kuj\\u0119\"],\n                tr: [\"Bak\\u0131n, burada yeni bir \\u015Fey var!\",\n                     \"Yeni sayfa i\\xE7i \\xE7eviri \\xF6zelli\\u011Fimiz sayesinde Web art\\u0131k \\xE7ok daha anla\\u015F\\u0131l\\u0131r olacak. Denemek i\\xE7in \\xC7evir d\\xFC\\u011Fmesine t\\u0131klay\\u0131n!\",\n                     \"Daha fazla bilgi al\\u0131n.\",\n                     \"Te\\u015Fekk\\xFCrler\"],\n                vi: [\"Nh\\xECn n\\xE0y! \\u0110\\u1ED3 m\\u1EDBi!\",\n                     \"Gi\\u1EDD \\u0111\\xE2y ch\\xFAng ta c\\xF3 th\\u1EC3 ti\\u1EBFp c\\u1EADn web d\\u1EC5 d\\xE0ng h\\u01A1n n\\u1EEFa v\\u1EDBi t\\xEDnh n\\u0103ng d\\u1ECBch ngay trong trang.  Hay nh\\u1EA5n n\\xFAt d\\u1ECBch \\u0111\\u1EC3 th\\u1EED!\",\n                     \"T\\xECm hi\\u1EC3u th\\xEAm.\",\n                     \"C\\u1EA3m \\u01A1n\"],\n              };\n\n              let locale = Services.locale.appLocaleAsLangTag;\n              if (!(locale in localizedStrings))\n                locale = \"en\";\n              let strings = localizedStrings[locale];\n\n              this._getAnonElt(\"welcomeHeadline\").setAttribute(\"value\", strings[0]);\n              this._getAnonElt(\"welcomeBody\").textContent = strings[1];\n              this._getAnonElt(\"learnMore\").setAttribute(\"value\", strings[2]);\n              this._getAnonElt(\"thanksButton\").setAttribute(\"label\", strings[3]);\n\n              let panel = this._getAnonElt(\"welcomePanel\");\n              panel.openPopup(this._getAnonElt(\"messageImage\"),\n                              \"bottomcenter topleft\");\n\n              Services.prefs.setBoolPref(kWelcomePref, true);\n            }, {once: true});\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_getAnonElt\">\n        <parameter name=\"aAnonId\"/>\n        <body>\n          return document.getAnonymousElementByAttribute(this, \"anonid\", aAnonId);\n        </body>\n      </method>\n\n      <method name=\"translate\">\n        <body>\n          <![CDATA[\n            if (this.state == Translation.STATE_OFFER) {\n              this._getAnonElt(\"fromLanguage\").value =\n                this._getAnonElt(\"detectedLanguage\").value;\n              this._getAnonElt(\"toLanguage\").value =\n                Translation.defaultTargetLanguage;\n            }\n\n            this.translation.translate(this._getAnonElt(\"fromLanguage\").value,\n                                       this._getAnonElt(\"toLanguage\").value);\n          ]]>\n        </body>\n      </method>\n\n      <!-- To be called when the infobar should be closed per user's wish (e.g.\n           by clicking the notification's close button -->\n      <method name=\"closeCommand\">\n        <body>\n          <![CDATA[\n            this.close();\n            this.translation.infobarClosed();\n          ]]>\n        </body>\n      </method>\n      <method name=\"_handleButtonHiding\">\n        <body>\n          <![CDATA[\n            let originalShown = this.translation.originalShown;\n            this._getAnonElt(\"showOriginal\").hidden = originalShown;\n            this._getAnonElt(\"showTranslation\").hidden = !originalShown;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"showOriginal\">\n        <body>\n          <![CDATA[\n            this.translation.showOriginalContent();\n            this._handleButtonHiding();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"showTranslation\">\n        <body>\n          <![CDATA[\n            this.translation.showTranslatedContent();\n            this._handleButtonHiding();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"optionsShowing\">\n        <body>\n          <![CDATA[\n            // Get the source language name.\n            let lang;\n            if (this.state == Translation.STATE_OFFER)\n              lang = this._getAnonElt(\"detectedLanguage\").value;\n            else {\n              lang = this._getAnonElt(\"fromLanguage\").value;\n\n              // If we have never attempted to translate the page before the\n              // service became unavailable, \"fromLanguage\" isn't set.\n              if (!lang && this.state == Translation.STATE_UNAVAILABLE)\n                lang = this.translation.detectedLanguage;\n            }\n\n            let langName = Services.intl.getLanguageDisplayNames(undefined, [lang])[0];\n\n            // Set the label and accesskey on the menuitem.\n            let bundle =\n              Services.strings.createBundle(\"chrome://browser/locale/translation.properties\");\n            let item = this._getAnonElt(\"neverForLanguage\");\n            const kStrId = \"translation.options.neverForLanguage\";\n            item.setAttribute(\"label\",\n                              bundle.formatStringFromName(kStrId + \".label\",\n                                                          [langName], 1));\n            item.setAttribute(\"accesskey\",\n                              bundle.GetStringFromName(kStrId + \".accesskey\"));\n            item.langCode = lang;\n\n            // We may need to disable the menuitems if they have already been used.\n            // Check if translation is already disabled for this language:\n            let neverForLangs =\n              Services.prefs.getCharPref(\"browser.translation.neverForLanguages\");\n            item.disabled = neverForLangs.split(\",\").includes(lang);\n\n            // Check if translation is disabled for the domain:\n            let uri = this.translation.browser.currentURI;\n            let perms = Services.perms;\n            item = this._getAnonElt(\"neverForSite\");\n            item.disabled =\n              perms.testExactPermission(uri, \"translate\") == perms.DENY_ACTION;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"neverForLanguage\">\n        <body>\n          <![CDATA[\n            const kPrefName = \"browser.translation.neverForLanguages\";\n\n            let val = Services.prefs.getCharPref(kPrefName);\n            if (val)\n              val += \",\";\n            val += this._getAnonElt(\"neverForLanguage\").langCode;\n\n            Services.prefs.setCharPref(kPrefName, val);\n\n            this.closeCommand();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"neverForSite\">\n        <body>\n          <![CDATA[\n            let uri = this.translation.browser.currentURI;\n            let perms = Services.perms;\n            perms.add(uri, \"translate\", perms.DENY_ACTION);\n\n            this.closeCommand();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"openProviderAttribution\">\n        <body>\n          <![CDATA[\n            Translation.openProviderAttribution();\n          ]]>\n        </body>\n      </method>\n\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"formautofill.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"formautofillBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"autocomplete-profile-listitem-base\" extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n      </constructor>\n      <!-- For form autofill, we want to unify the selection no matter by\n      keyboard navigation or mouseover in order not to confuse user which\n      profile preview is being shown. This field is set to true to indicate\n      that selectedIndex of popup should be changed while mouseover item -->\n      <field name=\"selectedByMouseOver\">true</field>\n\n      <property name=\"_stringBundle\">\n        <getter><![CDATA[\n          /* global Services */\n          if (!this.__stringBundle) {\n            this.__stringBundle = Services.strings.createBundle(\"chrome://formautofill/locale/formautofill.properties\");\n          }\n          return this.__stringBundle;\n        ]]></getter>\n      </property>\n\n      <method name=\"_cleanup\">\n        <body>\n        <![CDATA[\n          this.removeAttribute(\"formautofillattached\");\n          if (this._itemBox) {\n            this._itemBox.removeAttribute(\"size\");\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_onOverflow\">\n        <body></body>\n      </method>\n\n      <method name=\"_onUnderflow\">\n        <body></body>\n      </method>\n\n      <method name=\"handleOverUnderflow\">\n        <body></body>\n      </method>\n\n      <method name=\"_adjustAutofillItemLayout\">\n        <body>\n        <![CDATA[\n          let outerBoxRect = this.parentNode.getBoundingClientRect();\n\n          // Make item fit in popup as XUL box could not constrain\n          // item's width\n          this._itemBox.style.width = outerBoxRect.width + \"px\";\n          // Use two-lines layout when width is smaller than 150px or\n          // 185px if an image precedes the label.\n          let oneLineMinRequiredWidth = this.getAttribute(\"ac-image\") ? 185 : 150;\n\n          if (outerBoxRect.width <= oneLineMinRequiredWidth) {\n            this._itemBox.setAttribute(\"size\", \"small\");\n          } else {\n            this._itemBox.removeAttribute(\"size\");\n          }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-profile-listitem\" extends=\"chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base\">\n    <xbl:content xmlns=\"http://www.w3.org/1999/xhtml\">\n      <div anonid=\"autofill-item-box\" class=\"autofill-item-box\" xbl:inherits=\"ac-image\">\n        <div class=\"profile-label-col profile-item-col\">\n          <span anonid=\"profile-label-affix\" class=\"profile-label-affix\"></span>\n          <span anonid=\"profile-label\" class=\"profile-label\"></span>\n        </div>\n        <div class=\"profile-comment-col profile-item-col\">\n          <span anonid=\"profile-comment\" class=\"profile-comment\"></span>\n        </div>\n      </div>\n    </xbl:content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n        <![CDATA[\n          this._itemBox = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"autofill-item-box\"\n          );\n          this._labelAffix = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"profile-label-affix\"\n          );\n          this._label = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"profile-label\"\n          );\n          this._comment = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"profile-comment\"\n          );\n\n          this._adjustAcItem();\n        ]]>\n      </constructor>\n\n      <property name=\"selected\" onget=\"return this.getAttribute('selected') == 'true';\">\n        <setter><![CDATA[\n          /* global Cu */\n          if (val) {\n            this.setAttribute(\"selected\", \"true\");\n          } else {\n            this.removeAttribute(\"selected\");\n          }\n\n          let {AutoCompletePopup} = ChromeUtils.import(\"resource://gre/modules/AutoCompletePopup.jsm\", {});\n\n          AutoCompletePopup.sendMessageToBrowser(\"FormAutofill:PreviewProfile\");\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <method name=\"_adjustAcItem\">\n        <body>\n        <![CDATA[\n          this._adjustAutofillItemLayout();\n          this.setAttribute(\"formautofillattached\", \"true\");\n          this._itemBox.style.setProperty(\"--primary-icon\", `url(${this.getAttribute(\"ac-image\")})`);\n\n          let {primaryAffix, primary, secondary} = JSON.parse(this.getAttribute(\"ac-value\"));\n\n          this._labelAffix.textContent = primaryAffix;\n          this._label.textContent = primary;\n          this._comment.textContent = secondary;\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-profile-listitem-footer\" extends=\"chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base\">\n    <xbl:content xmlns=\"http://www.w3.org/1999/xhtml\">\n      <div anonid=\"autofill-footer\" class=\"autofill-item-box autofill-footer\">\n        <div anonid=\"autofill-warning\" class=\"autofill-footer-row autofill-warning\">\n        </div>\n        <div anonid=\"autofill-option-button\" class=\"autofill-footer-row autofill-button\">\n        </div>\n      </div>\n    </xbl:content>\n\n    <handlers>\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        if (this._warningTextBox.contains(event.originalTarget)) {\n          return;\n        }\n\n        window.openPreferences(\"privacy-form-autofill\", {origin: \"autofillFooter\"});\n      ]]></handler>\n    </handlers>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n        <![CDATA[\n          this._itemBox = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"autofill-footer\"\n          );\n          this._optionButton = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"autofill-option-button\"\n          );\n          this._warningTextBox = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"autofill-warning\"\n          );\n\n          /**\n           * A handler for updating warning message once selectedIndex has been changed.\n           *\n           * There're three different states of warning message:\n           * 1. None of addresses were selected: We show all the categories intersection of fields in the\n           *    form and fields in the results.\n           * 2. An address was selested: Show the additional categories that will also be filled.\n           * 3. An address was selected, but the focused category is the same as the only one category: Only show\n           * the exact category that we're going to fill in.\n           *\n           * @private\n           * @param {string[]} data.categories\n           *        The categories of all the fields contained in the selected address.\n           */\n          this._updateWarningNote = ({data} = {}) => {\n            let categories = (data && data.categories) ? data.categories : this._allFieldCategories;\n            // If the length of categories is 1, that means all the fillable fields are in the same\n            // category. We will change the way to inform user according to this flag. When the value\n            // is true, we show \"Also autofills ...\", otherwise, show \"Autofills ...\" only.\n            let hasExtraCategories = categories.length > 1;\n            // Show the categories in certain order to conform with the spec.\n            let orderedCategoryList = [{id: \"address\", l10nId: \"category.address\"},\n                                       {id: \"name\", l10nId: \"category.name\"},\n                                       {id: \"organization\", l10nId: \"category.organization2\"},\n                                       {id: \"tel\", l10nId: \"category.tel\"},\n                                       {id: \"email\", l10nId: \"category.email\"}];\n            let showCategories = hasExtraCategories ?\n              orderedCategoryList.filter(category => categories.includes(category.id) && category.id != this._focusedCategory) :\n              [orderedCategoryList.find(category => category.id == this._focusedCategory)];\n\n            let separator = this._stringBundle.GetStringFromName(\"fieldNameSeparator\");\n            let warningTextTmplKey = hasExtraCategories ? \"phishingWarningMessage\" : \"phishingWarningMessage2\";\n            let categoriesText = showCategories.map(category => this._stringBundle.GetStringFromName(category.l10nId)).join(separator);\n\n            this._warningTextBox.textContent = this._stringBundle.formatStringFromName(warningTextTmplKey,\n              [categoriesText], 1);\n            this.parentNode.parentNode.adjustHeight();\n          };\n\n          this._adjustAcItem();\n        ]]>\n      </constructor>\n\n      <method name=\"_onCollapse\">\n        <body>\n        <![CDATA[\n          /* global messageManager */\n\n          if (this.showWarningText) {\n            messageManager.removeMessageListener(\"FormAutofill:UpdateWarningMessage\", this._updateWarningNote);\n          }\n\n          this._itemBox.removeAttribute(\"no-warning\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_adjustAcItem\">\n        <body>\n        <![CDATA[\n          /* global Cu */\n          this._adjustAutofillItemLayout();\n          this.setAttribute(\"formautofillattached\", \"true\");\n\n          let {AppConstants} = ChromeUtils.import(\"resource://gre/modules/AppConstants.jsm\", {});\n          // TODO: The \"Short\" suffix is pointless now as normal version string is no longer needed,\n          // we should consider removing the suffix if possible when the next time locale change.\n          let buttonTextBundleKey = AppConstants.platform == \"macosx\" ?\n            \"autocompleteFooterOptionOSXShort\" : \"autocompleteFooterOptionShort\";\n          let buttonText = this._stringBundle.GetStringFromName(buttonTextBundleKey);\n          this._optionButton.textContent = buttonText;\n\n          let value = JSON.parse(this.getAttribute(\"ac-value\"));\n\n          this._allFieldCategories = value.categories;\n          this._focusedCategory = value.focusedCategory;\n          this.showWarningText = this._allFieldCategories && this._focusedCategory;\n\n          if (this.showWarningText) {\n            messageManager.addMessageListener(\"FormAutofill:UpdateWarningMessage\", this._updateWarningNote);\n\n            this._updateWarningNote();\n          } else {\n            this._itemBox.setAttribute(\"no-warning\", \"true\");\n          }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-creditcard-insecure-field\" extends=\"chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base\">\n    <xbl:content xmlns=\"http://www.w3.org/1999/xhtml\">\n      <div anonid=\"autofill-item-box\" class=\"autofill-insecure-item\">\n      </div>\n    </xbl:content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n      <![CDATA[\n        this._itemBox = document.getAnonymousElementByAttribute(\n          this, \"anonid\", \"autofill-item-box\"\n        );\n\n        this._adjustAcItem();\n      ]]>\n      </constructor>\n\n      <property name=\"selected\" onget=\"return this.getAttribute('selected') == 'true';\">\n        <setter><![CDATA[\n          // Make this item unselectable since we see this item as a pure message.\n          return false;\n        ]]></setter>\n      </property>\n\n      <method name=\"_adjustAcItem\">\n        <body>\n        <![CDATA[\n          this._adjustAutofillItemLayout();\n          this.setAttribute(\"formautofillattached\", \"true\");\n\n          let value = this.getAttribute(\"ac-value\");\n          this._itemBox.textContent = value;\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-profile-listitem-clear-button\" extends=\"chrome://formautofill/content/formautofill.xml#autocomplete-profile-listitem-base\">\n    <xbl:content xmlns=\"http://www.w3.org/1999/xhtml\">\n      <div anonid=\"autofill-item-box\" class=\"autofill-item-box autofill-footer\">\n        <div anonid=\"autofill-clear-button\" class=\"autofill-footer-row autofill-button\"></div>\n      </div>\n    </xbl:content>\n\n    <handlers>\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        /* global Cu */\n        let {AutoCompletePopup} = ChromeUtils.import(\"resource://gre/modules/AutoCompletePopup.jsm\", {});\n\n        AutoCompletePopup.sendMessageToBrowser(\"FormAutofill:ClearForm\");\n      ]]></handler>\n    </handlers>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n      <![CDATA[\n        this._itemBox = document.getAnonymousElementByAttribute(\n          this, \"anonid\", \"autofill-item-box\"\n        );\n        this._clearBtn = document.getAnonymousElementByAttribute(\n          this, \"anonid\", \"autofill-clear-button\"\n        );\n\n        this._adjustAcItem();\n      ]]>\n      </constructor>\n\n      <method name=\"_adjustAcItem\">\n        <body>\n        <![CDATA[\n          this._adjustAutofillItemLayout();\n          this.setAttribute(\"formautofillattached\", \"true\");\n\n          let clearFormBtnLabel = this._stringBundle.GetStringFromName(\"clearFormBtnLabel2\");\n          this._clearBtn.textContent = clearFormBtnLabel;\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"organizer.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"organizerBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"toolbarbutton-dropdown\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:image class=\"menubar-left\" xbl:inherits=\"src=image\"/>\n      <xul:label class=\"menubar-text\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\"/>\n      <xul:hbox class=\"menubar-right\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"platformHTMLBindings.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"htmlBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"builtin-android-inputFields\" bindToUntrustedContent=\"true\">\n    <handlers>\n\n      <handler event=\"keypress\" key=\"a\" modifiers=\"accel\" command=\"cmd_selectAll\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control\" command=\"cmd_wordPrevious\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control\" command=\"cmd_wordNext\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift,control\" command=\"cmd_selectWordPrevious\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift,control\" command=\"cmd_selectWordNext\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"alt\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"alt\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift,alt\" command=\"cmd_selectBeginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift,alt\" command=\"cmd_selectEndLine\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_HOME\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift\" command=\"cmd_selectBeginLine\" />\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift\" command=\"cmd_selectEndLine\" />\n\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"alt\" command=\"cmd_deleteToBeginningOfLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"alt\" command=\"cmd_deleteToEndOfLine\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-android-textAreas\" bindToUntrustedContent=\"true\">\n    <handlers>\n\n      <handler event=\"keypress\" key=\"a\" modifiers=\"accel\" command=\"cmd_selectAll\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control\" command=\"cmd_wordPrevious\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control\" command=\"cmd_wordNext\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift,control\" command=\"cmd_selectWordPrevious\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift,control\" command=\"cmd_selectWordNext\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"alt\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"alt\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift,alt\" command=\"cmd_selectBeginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift,alt\" command=\"cmd_selectEndLine\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"alt\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"alt\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"shift,alt\" command=\"cmd_selectTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"shift,alt\" command=\"cmd_selectBottom\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" command=\"cmd_movePageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" command=\"cmd_movePageDown\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"shift\" command=\"cmd_selectPageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"shift\" command=\"cmd_selectPageDown\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"alt\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"alt\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"shift,alt\" command=\"cmd_selectTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"shift,alt\" command=\"cmd_selectBottom\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_HOME\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift\" command=\"cmd_selectBeginLine\" />\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift\" command=\"cmd_selectEndLine\" />\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift,control\" command=\"cmd_selectTop\" />\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift,control\" command=\"cmd_selectBottom\" />\n\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"alt\" command=\"cmd_deleteToBeginningOfLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"alt\" command=\"cmd_deleteToEndOfLine\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-android-browser\">\n    <handlers>\n\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift\" command=\"cmd_selectCharPrevious\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift\" command=\"cmd_selectCharNext\" />\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control\" command=\"cmd_wordPrevious\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control\" command=\"cmd_wordNext\" />\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control,shift\" command=\"cmd_selectWordPrevious\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control,shift\" command=\"cmd_selectWordNext\" />\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"alt\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"alt\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift,alt\" command=\"cmd_selectBeginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift,alt\" command=\"cmd_selectEndLine\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"shift\" command=\"cmd_selectLinePrevious\" />\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"shift\" command=\"cmd_selectLineNext\" />\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"alt\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"alt\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"shift,alt\" command=\"cmd_selectTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"shift,alt\" command=\"cmd_selectBottom\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" command=\"cmd_movePageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" command=\"cmd_movePageDown\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"shift\" command=\"cmd_selectPageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"shift\" command=\"cmd_selectPageDown\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"alt\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"alt\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"shift,alt\" command=\"cmd_selectTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"shift,alt\" command=\"cmd_selectBottom\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_HOME\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift\" command=\"cmd_selectBeginLine\" />\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift\" command=\"cmd_selectEndLine\" />\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift,control\" command=\"cmd_selectTop\" />\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift,control\" command=\"cmd_selectBottom\" />\n\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"alt\" command=\"cmd_deleteToBeginningOfLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"alt\" command=\"cmd_deleteToEndOfLine\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-android-editor\">\n    <handlers>\n\n      <handler event=\"keypress\" key=\"a\" modifiers=\"accel\" command=\"cmd_selectAll\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control\" command=\"cmd_wordPrevious\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control\" command=\"cmd_wordNext\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift,control\" command=\"cmd_selectWordPrevious\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift,control\" command=\"cmd_selectWordNext\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"alt\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"alt\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift,alt\" command=\"cmd_selectBeginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift,alt\" command=\"cmd_selectEndLine\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"alt\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"alt\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"shift,alt\" command=\"cmd_selectTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"shift,alt\" command=\"cmd_selectBottom\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" command=\"cmd_movePageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" command=\"cmd_movePageDown\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"shift\" command=\"cmd_selectPageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"shift\" command=\"cmd_selectPageDown\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"alt\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"alt\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"shift,alt\" command=\"cmd_selectTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"shift,alt\" command=\"cmd_selectBottom\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_HOME\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift\" command=\"cmd_selectBeginLine\" />\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift\" command=\"cmd_selectEndLine\" />\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift,control\" command=\"cmd_selectTop\" />\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift,control\" command=\"cmd_selectBottom\" />\n\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"alt\" command=\"cmd_deleteToBeginningOfLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"alt\" command=\"cmd_deleteToEndOfLine\"/>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"platformHTMLBindings.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"htmlBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n \n  <binding id=\"builtin-emacs-inputFields\" bindToUntrustedContent=\"true\">\n    <handlers>\n\n    <!-- Emacsish single-line motion and delete keys -->\n    <handler event=\"keypress\" key=\"a\" modifiers=\"control\"\n        command=\"cmd_beginLine\"/>\n    <handler event=\"keypress\" key=\"e\" modifiers=\"control\"\n        command=\"cmd_endLine\"/>\n    <handler event=\"keypress\" key=\"b\" modifiers=\"control\"\n        command=\"cmd_charPrevious\"/>\n    <handler event=\"keypress\" key=\"f\" modifiers=\"control\"\n        command=\"cmd_charNext\"/>\n    <handler event=\"keypress\" key=\"h\" modifiers=\"control\"\n        command=\"cmd_deleteCharBackward\"/>\n    <handler event=\"keypress\" key=\"d\" modifiers=\"control\"\n        command=\"cmd_deleteCharForward\"/>\n    <handler event=\"keypress\" key=\"w\" modifiers=\"control\"\n        command=\"cmd_deleteWordBackward\"/>\n    <handler event=\"keypress\" key=\"u\" modifiers=\"control\"\n        command=\"cmd_deleteToBeginningOfLine\"/>\n    <handler event=\"keypress\" key=\"k\" modifiers=\"control\"\n        command=\"cmd_deleteToEndOfLine\"/>\n\n    <!-- Alternate Windows copy/paste/undo/redo keys -->\n    <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"shift\"\n        command=\"cmd_cutOrDelete\"/>\n    <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"control\"\n        command=\"cmd_copyOrDelete\"/>\n    <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"control\" \n        command=\"cmd_copy\"/>\n    <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"shift\"\n        command=\"cmd_paste\"/>\n\n    <!-- navigating by word keys -->\n    <handler event=\"keypress\" keycode=\"VK_HOME\" \n        command=\"cmd_beginLine\"/>\n    <handler event=\"keypress\" keycode=\"VK_END\" \n        command=\"cmd_endLine\"/>\n    <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift\"\n        command=\"cmd_selectBeginLine\"/>\n    <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift\"\n        command=\"cmd_selectEndLine\"/>\n    <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control\"\n        command=\"cmd_beginLine\"/>\n    <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control\" \n        command=\"cmd_endLine\"/>\n    <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control,shift\"\n        command=\"cmd_selectBeginLine\"/>\n    <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control,shift\"\n        command=\"cmd_selectEndLine\"/>\n    <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"control\"\n        command=\"cmd_deleteWordBackward\"/>\n\n    <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control\" \n        command=\"cmd_wordPrevious\"/>\n    <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control\"\n        command=\"cmd_wordNext\"/>\n    <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift,control\" \n        command=\"cmd_selectWordPrevious\"/>\n    <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift,control\" \n        command=\"cmd_selectWordNext\"/>\n    <handler event=\"keypress\" key=\"y\" modifiers=\"accel\"\n        command=\"cmd_redo\"/>\n    <handler event=\"keypress\" key=\"a\" modifiers=\"alt\"\n        command=\"cmd_selectAll\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-emacs-textAreas\" bindToUntrustedContent=\"true\">\n    <handlers>\n\n    <!-- Emacsish single-line motion and delete keys -->\n    <handler event=\"keypress\" key=\"a\" modifiers=\"control\"\n        command=\"cmd_beginLine\"/>\n    <handler event=\"keypress\" key=\"e\" modifiers=\"control\"\n        command=\"cmd_endLine\"/>\n    <handler event=\"keypress\" id=\"key_left\" key=\"b\" modifiers=\"control\"\n        command=\"cmd_charPrevious\"/>\n    <handler event=\"keypress\" id=\"key_right\" key=\"f\" modifiers=\"control\"\n        command=\"cmd_charNext\"/>\n    <handler event=\"keypress\" id=\"key_delback\" key=\"h\" modifiers=\"control\"\n        command=\"cmd_deleteCharBackward\"/>\n    <handler event=\"keypress\" id=\"key_delforw\" key=\"d\" modifiers=\"control\"\n        command=\"cmd_deleteCharForward\"/>\n    <handler event=\"keypress\" id=\"key_delwback\" key=\"w\" modifiers=\"control\"\n        command=\"cmd_deleteWordBackward\"/>\n    <handler event=\"keypress\" id=\"key_del_bol\" key=\"u\" modifiers=\"control\"\n        command=\"cmd_deleteToBeginningOfLine\"/>\n    <handler event=\"keypress\" id=\"key_del_eol\" key=\"k\" modifiers=\"control\"\n        command=\"cmd_deleteToEndOfLine\"/>\n\n    <!-- Alternate Windows copy/paste/undo/redo keys -->\n    <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"shift\"\n        command=\"cmd_cutOrDelete\"/>\n    <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"control\"\n        command=\"cmd_copyOrDelete\"/>\n    <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"control\"\n        command=\"cmd_copy\"/>\n    <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"shift\"\n        command=\"cmd_paste\"/>\n\n    <!-- Emacsish multi-line motion and delete keys -->\n    <handler event=\"keypress\" id=\"key_linedown\" key=\"n\" modifiers=\"control\"\n        command=\"cmd_lineNext\"/>\n    <handler event=\"keypress\" id=\"key_lineup\" key=\"p\" modifiers=\"control\"\n        command=\"cmd_linePrevious\"/>\n\n    <!-- handle home/end/arrow keys and redo -->\n    <handler event=\"keypress\" keycode=\"VK_HOME\" \n        command=\"cmd_beginLine\"/>\n    <handler event=\"keypress\" keycode=\"VK_END\" \n        command=\"cmd_endLine\"/>\n    <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift\"\n        command=\"cmd_selectBeginLine\"/>\n    <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift\"\n        command=\"cmd_selectEndLine\"/>\n\n    <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control\" \n        command=\"cmd_moveTop\"/>\n    <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control\" \n        command=\"cmd_moveBottom\"/>\n    <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift,control\"\n        command=\"cmd_selectTop\"/>\n    <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift,control\"\n        command=\"cmd_selectBottom\"/>\n\n    <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" \n        command=\"cmd_movePageUp\"/>\n    <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" \n        command=\"cmd_movePageDown\"/>\n    <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"shift\"\n        command=\"cmd_selectPageUp\"/>\n    <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"shift\"\n        command=\"cmd_selectPageDown\"/>\n\n    <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control\" \n        command=\"cmd_wordPrevious\"/>\n    <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control\" \n        command=\"cmd_wordNext\"/>\n    <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift,control\" \n        command=\"cmd_selectWordPrevious\"/>\n    <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift,control\" \n        command=\"cmd_selectWordNext\"/>\n    <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"control\"\n        command=\"cmd_deleteWordBackward\"/>\n    <handler event=\"keypress\" key=\"y\" modifiers=\"accel\"\n        command=\"cmd_redo\"/>\n    <handler event=\"keypress\" key=\"a\" modifiers=\"alt\"\n        command=\"cmd_selectAll\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-emacs-browser\">\n    <handlers>\n\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" command=\"cmd_movePageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" command=\"cmd_movePageDown\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"shift\" command=\"cmd_selectPageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"shift\" command=\"cmd_selectPageDown\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"shift\" command=\"cmd_cut\" /> \n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"control\" command=\"cmd_copy\" /> \n      <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"control\" command=\"cmd_copy\" /> \n      <handler event=\"keypress\" keycode=\"VK_HOME\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift,control\" command=\"cmd_selectTop\" /> \n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift,control\" command=\"cmd_selectBottom\" /> \n\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control\" command=\"cmd_wordPrevious\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control\" command=\"cmd_wordNext\" />\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control,shift\" command=\"cmd_selectWordPrevious\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control,shift\" command=\"cmd_selectWordNext\" />\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift\" command=\"cmd_selectCharPrevious\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift\" command=\"cmd_selectCharNext\" />\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift\" command=\"cmd_selectBeginLine\" />\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift\" command=\"cmd_selectEndLine\" />\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"shift\" command=\"cmd_selectLinePrevious\" />\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"shift\" command=\"cmd_selectLineNext\" />\n      <handler event=\"keypress\" key=\"a\" modifiers=\"alt\" command=\"cmd_selectAll\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-emacs-editor\">\n    <handlers>\n\n      <handler event=\"keypress\" key=\"h\" modifiers=\"control\" command=\"cmd_deleteCharBackward\"/>\n      <handler event=\"keypress\" key=\"d\" modifiers=\"control\" command=\"cmd_deleteCharForward\"/>\n      <handler event=\"keypress\" key=\"k\" modifiers=\"control\" command=\"cmd_deleteToEndOfLine\"/>\n      <handler event=\"keypress\" key=\"u\" modifiers=\"control\" command=\"cmd_deleteToBeginningOfLine\"/>\n      <handler event=\"keypress\" key=\"a\" modifiers=\"control\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" key=\"e\" modifiers=\"control\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" key=\"b\" modifiers=\"control\" command=\"cmd_charPrevious\"/>\n      <handler event=\"keypress\" key=\"f\" modifiers=\"control\" command=\"cmd_charNext\"/>\n      <handler event=\"keypress\" key=\"p\" modifiers=\"control\" command=\"cmd_linePrevious\"/>\n      <handler event=\"keypress\" key=\"n\" modifiers=\"control\" command=\"cmd_lineNext\"/>\n      <handler event=\"keypress\" key=\"x\" modifiers=\"control\" command=\"cmd_cut\"/>\n      <handler event=\"keypress\" key=\"c\" modifiers=\"control\" command=\"cmd_copy\"/>\n      <handler event=\"keypress\" key=\"v\" modifiers=\"control\" command=\"cmd_paste\"/>\n      <handler event=\"keypress\" key=\"z\" modifiers=\"control\" command=\"cmd_undo\"/>\n      <handler event=\"keypress\" key=\"y\" modifiers=\"accel\"   command=\"cmd_redo\"/>\n      <handler event=\"keypress\" key=\"a\" modifiers=\"alt\" command=\"cmd_selectAll\"/>\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"shift\" command=\"cmd_cutOrDelete\"/>\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"control\" command=\"cmd_copyOrDelete\"/>\n      <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"control\" command=\"cmd_copy\"/>\n      <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"shift\" command=\"cmd_paste\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control\" command=\"cmd_wordPrevious\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control\" command=\"cmd_wordNext\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift,control\" command=\"cmd_selectWordPrevious\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift,control\" command=\"cmd_selectWordNext\"/>\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"control\" command=\"cmd_deleteWordBackward\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift\" command=\"cmd_selectBeginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift\" command=\"cmd_selectEndLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift,control\" command=\"cmd_selectTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift,control\" command=\"cmd_selectBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" command=\"cmd_movePageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" command=\"cmd_movePageDown\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"shift\" command=\"cmd_selectPageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"shift\" command=\"cmd_selectPageDown\"/>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"platformHTMLBindings.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"htmlBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"builtin-mac-inputFields\" bindToUntrustedContent=\"true\">\n    <handlers>\n      <handler event=\"keypress\" key=\"c\" modifiers=\"accel\" command=\"cmd_copy\"/>\n      <handler event=\"keypress\" key=\"x\" modifiers=\"accel\" command=\"cmd_cut\"/>\n      <handler event=\"keypress\" key=\"v\" modifiers=\"accel\" command=\"cmd_paste\"/>\n      <handler event=\"keypress\" key=\"z\" modifiers=\"accel\" command=\"cmd_undo\"/>\n      <handler event=\"keypress\" key=\"z\" modifiers=\"accel,shift\" command=\"cmd_redo\"/>\n      <handler event=\"keypress\" key=\"a\" modifiers=\"accel\" command=\"cmd_selectAll\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-mac-textAreas\" bindToUntrustedContent=\"true\">\n    <handlers>\n      <handler event=\"keypress\" key=\"c\" modifiers=\"accel\" command=\"cmd_copy\"/>\n      <handler event=\"keypress\" key=\"x\" modifiers=\"accel\" command=\"cmd_cut\"/>\n      <handler event=\"keypress\" key=\"v\" modifiers=\"accel\" command=\"cmd_paste\"/>\n      <handler event=\"keypress\" key=\"z\" modifiers=\"accel\" command=\"cmd_undo\"/>\n      <handler event=\"keypress\" key=\"z\" modifiers=\"accel,shift\" command=\"cmd_redo\"/>\n      <handler event=\"keypress\" key=\"a\" modifiers=\"accel\" command=\"cmd_selectAll\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-mac-browser\">\n    <handlers>\n\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" command=\"cmd_scrollPageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" command=\"cmd_scrollPageDown\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" command=\"cmd_scrollTop\" /> \n      <handler event=\"keypress\" keycode=\"VK_END\"  command=\"cmd_scrollBottom\" /> \n\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"alt\" command=\"cmd_moveLeft2\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"alt\" command=\"cmd_moveRight2\" />\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"alt,shift\" command=\"cmd_selectLeft2\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"alt,shift\" command=\"cmd_selectRight2\" />\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift\" command=\"cmd_selectLeft\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift\" command=\"cmd_selectRight\" />\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"alt,shift\" command=\"cmd_selectUp2\" />\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"alt,shift\" command=\"cmd_selectDown2\" />\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"shift\" command=\"cmd_selectUp\" />\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"shift\" command=\"cmd_selectDown\" />\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"accel\" command=\"cmd_moveUp2\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"accel\" command=\"cmd_moveDown2\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-mac-editor\">\n    <handlers>\n      <handler event=\"keypress\" key=\" \" modifiers=\"shift\" command=\"cmd_scrollPageUp\" />\n      <handler event=\"keypress\" key=\" \" command=\"cmd_scrollPageDown\" />\n\n      <handler event=\"keypress\" key=\"z\" command=\"cmd_undo\" modifiers=\"accel\"/>\n      <handler event=\"keypress\" key=\"z\" command=\"cmd_redo\" modifiers=\"accel,shift\" />\n      <handler event=\"keypress\" key=\"x\" command=\"cmd_cut\" modifiers=\"accel\"/>\n      <handler event=\"keypress\" key=\"c\" command=\"cmd_copy\" modifiers=\"accel\"/>\n      <handler event=\"keypress\" key=\"v\" command=\"cmd_paste\" modifiers=\"accel\"/>\n      <handler event=\"keypress\" key=\"v\" command=\"cmd_pasteNoFormatting\" modifiers=\"accel,shift\"/>\n      <handler event=\"keypress\" key=\"a\" command=\"cmd_selectAll\" modifiers=\"accel\"/>\n      <handler event=\"keypress\" key=\"v\" command=\"cmd_pasteNoFormatting\" modifiers=\"accel,alt,shift\"/>\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"platformHTMLBindings.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"htmlBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n \n  <binding id=\"builtin-unix-inputFields\" bindToUntrustedContent=\"true\">\n    <handlers>\n\n    <handler event=\"keypress\" key=\"a\" modifiers=\"alt\"\n        command=\"cmd_selectAll\"/>\n    <handler event=\"keypress\" key=\"y\" modifiers=\"accel\"\n        command=\"cmd_redo\"/>\n    <handler event=\"keypress\" key=\"z\" modifiers=\"accel,shift\" command=\"cmd_redo\"/>\n    <handler event=\"keypress\" key=\"z\" modifiers=\"accel\" command=\"cmd_undo\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-unix-textAreas\" bindToUntrustedContent=\"true\">\n    <handlers>\n\n    <handler event=\"keypress\" key=\"a\" modifiers=\"alt\"\n        command=\"cmd_selectAll\"/>\n    <handler event=\"keypress\" key=\"y\" modifiers=\"accel\"\n        command=\"cmd_redo\"/>\n    <handler event=\"keypress\" key=\"z\" modifiers=\"accel\" command=\"cmd_undo\"/>\n    <handler event=\"keypress\" key=\"z\" modifiers=\"accel,shift\" command=\"cmd_redo\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-unix-browser\">\n    <handlers>\n\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" command=\"cmd_movePageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" command=\"cmd_movePageDown\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"shift\" command=\"cmd_selectPageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"shift\" command=\"cmd_selectPageDown\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"shift\" command=\"cmd_cut\" /> \n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"control\" command=\"cmd_copy\" /> \n      <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"control\" command=\"cmd_copy\" /> \n      <handler event=\"keypress\" keycode=\"VK_HOME\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift\" command=\"cmd_selectBeginLine\" />\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift\" command=\"cmd_selectEndLine\" />\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift,control\" command=\"cmd_selectTop\" /> \n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift,control\" command=\"cmd_selectBottom\" /> \n\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift\" command=\"cmd_selectLeft\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift\" command=\"cmd_selectRight\" />\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control\" command=\"cmd_moveLeft2\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control\" command=\"cmd_moveRight2\" />\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control,shift\" command=\"cmd_selectLeft2\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control,shift\" command=\"cmd_selectRight2\" />\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"shift\" command=\"cmd_selectUp\" />\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"shift\" command=\"cmd_selectDown\" />\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"control\" command=\"cmd_moveUp2\" />\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"control\" command=\"cmd_moveDown2\" />\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"control,shift\" command=\"cmd_selectUp2\" />\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"control,shift\" command=\"cmd_selectDown2\" />\n\n      <handler event=\"keypress\" key=\"a\" modifiers=\"alt\" command=\"cmd_selectAll\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-unix-editor\">\n    <handlers>\n\n      <handler event=\"keypress\" key=\"z\" modifiers=\"accel\" command=\"cmd_undo\"/>\n      <handler event=\"keypress\" key=\"z\" modifiers=\"accel,shift\" command=\"cmd_redo\"/>\n      <handler event=\"keypress\" key=\"y\" modifiers=\"accel\"   command=\"cmd_redo\"/>\n      <handler event=\"keypress\" key=\"a\" modifiers=\"alt\" command=\"cmd_selectAll\"/>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"platformHTMLBindings.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"htmlBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n \n  <binding id=\"builtin-win-inputFields\" bindToUntrustedContent=\"true\">\n    <handlers>\n\n      <handler event=\"keypress\" keycode=\"VK_HOME\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift\" command=\"cmd_selectBeginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift\" command=\"cmd_selectEndLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift,control\" command=\"cmd_selectTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift,control\" command=\"cmd_selectBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control\" command=\"cmd_moveBottom\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control\" command=\"cmd_moveLeft2\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control\" command=\"cmd_moveRight2\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift,control\" command=\"cmd_selectLeft2\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift,control\" command=\"cmd_selectRight2\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"control\" command=\"cmd_moveUp2\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"control\" command=\"cmd_moveDown2\"/>\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"shift,control\" command=\"cmd_selectUp2\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"shift,control\" command=\"cmd_selectDown2\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"shift\" command=\"cmd_cutOrDelete\"/>\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"control\" command=\"cmd_deleteWordForward\"/>\n      <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"control\" command=\"cmd_copy\"/>\n      <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"shift\" command=\"cmd_paste\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"alt\" command=\"cmd_undo\"/>\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"alt,shift\" command=\"cmd_redo\"/>\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"control\" command=\"cmd_deleteWordBackward\"/>\n\n      <handler event=\"keypress\" key=\"a\" modifiers=\"accel\" command=\"cmd_selectAll\"/>\n      <handler event=\"keypress\" key=\"y\" modifiers=\"accel\" command=\"cmd_redo\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-win-textAreas\" bindToUntrustedContent=\"true\">\n    <handlers>\n\n      <handler event=\"keypress\" keycode=\"VK_HOME\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift\" command=\"cmd_selectBeginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift\" command=\"cmd_selectEndLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift,control\" command=\"cmd_selectTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift,control\" command=\"cmd_selectBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control\" command=\"cmd_moveBottom\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control\" command=\"cmd_moveLeft2\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control\" command=\"cmd_moveRight2\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift,control\" command=\"cmd_selectLeft2\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift,control\" command=\"cmd_selectRight2\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"control\" command=\"cmd_moveUp2\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"control\" command=\"cmd_moveDown2\"/>\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"shift,control\" command=\"cmd_selectUp2\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"shift,control\" command=\"cmd_selectDown2\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" command=\"cmd_movePageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" command=\"cmd_movePageDown\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"shift\" command=\"cmd_selectPageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"shift\" command=\"cmd_selectPageDown\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"shift\" command=\"cmd_cutOrDelete\"/>\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"control\" command=\"cmd_deleteWordForward\"/>\n      <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"control\" command=\"cmd_copy\"/>\n      <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"shift\" command=\"cmd_paste\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"alt\" command=\"cmd_undo\"/>\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"alt,shift\" command=\"cmd_redo\"/>\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"control\" command=\"cmd_deleteWordBackward\"/>\n\n      <handler event=\"keypress\" key=\"a\" modifiers=\"accel\" command=\"cmd_selectAll\"/>\n      <handler event=\"keypress\" key=\"y\" modifiers=\"accel\" command=\"cmd_redo\"/>\n     </handlers>\n  </binding>\n\n  <binding id=\"builtin-win-browser\">\n    <handlers>\n\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" command=\"cmd_movePageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" command=\"cmd_movePageDown\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"shift\" command=\"cmd_selectPageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"shift\" command=\"cmd_selectPageDown\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"shift\" command=\"cmd_cut\"/>\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"control\" command=\"cmd_deleteWordForward\"/>\n      <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"control\" command=\"cmd_copy\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift,control\" command=\"cmd_selectTop\" />\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift,control\" command=\"cmd_selectBottom\" />\n\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control\" command=\"cmd_moveLeft2\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control\" command=\"cmd_moveRight2\" />\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"control,shift\" command=\"cmd_selectLeft2\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"control,shift\" command=\"cmd_selectRight2\" />\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift\" command=\"cmd_selectLeft\" />\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift\" command=\"cmd_selectRight\" />\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"control\" command=\"cmd_moveUp2\" />\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"control\" command=\"cmd_moveDown2\" />\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"control,shift\" command=\"cmd_selectUp2\" />\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"control,shift\" command=\"cmd_selectDown2\" />\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"shift\" command=\"cmd_selectUp\" />\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"shift\" command=\"cmd_selectDown\" />\n\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift\" command=\"cmd_selectBeginLine\" />\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift\" command=\"cmd_selectEndLine\" />\n      <handler event=\"keypress\" key=\"y\" modifiers=\"accel\" command=\"cmd_redo\"/>\n    </handlers>\n  </binding>\n\n  <binding id=\"builtin-win-editor\">\n    <handlers>\n\n      <handler event=\"keypress\" key=\"a\" command=\"cmd_selectAll\" modifiers=\"accel\"/>\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"shift\" command=\"cmd_cutOrDelete\"/>\n      <handler event=\"keypress\" keycode=\"VK_DELETE\" modifiers=\"control\" command=\"cmd_deleteWordForward\"/>\n      <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"control\" command=\"cmd_copy\"/>\n      <handler event=\"keypress\" keycode=\"VK_INSERT\" modifiers=\"shift\" command=\"cmd_paste\"/>\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"alt\" command=\"cmd_undo\"/>\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"alt,shift\" command=\"cmd_redo\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"accel\" command=\"cmd_moveLeft2\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"accel\" command=\"cmd_moveRight2\"/>\n      <handler event=\"keypress\" keycode=\"VK_LEFT\" modifiers=\"shift,accel\" command=\"cmd_selectLeft2\"/>\n      <handler event=\"keypress\" keycode=\"VK_RIGHT\" modifiers=\"shift,accel\" command=\"cmd_selectRight2\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"accel\" command=\"cmd_moveUp2\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"accel\" command=\"cmd_moveDown2\"/>\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"shift,accel\" command=\"cmd_selectUp2\"/>\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"shift,accel\" command=\"cmd_selectDown2\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"shift,control\" command=\"cmd_selectTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"shift,control\" command=\"cmd_selectBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control\" command=\"cmd_moveTop\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control\" command=\"cmd_moveBottom\"/>\n      <handler event=\"keypress\" keycode=\"VK_BACK\" modifiers=\"control\" command=\"cmd_deleteWordBackward\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_HOME\" command=\"cmd_beginLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" command=\"cmd_endLine\"/>\n      <handler event=\"keypress\" keycode=\"VK_HOME\" command=\"cmd_selectBeginLine\" modifiers=\"shift\"/>\n      <handler event=\"keypress\" keycode=\"VK_END\" command=\"cmd_selectEndLine\" modifiers=\"shift\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" command=\"cmd_movePageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" command=\"cmd_movePageDown\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"shift\" command=\"cmd_selectPageUp\"/>\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"shift\" command=\"cmd_selectPageDown\"/>\n      <handler event=\"keypress\" key=\"y\" modifiers=\"accel\" command=\"cmd_redo\"/>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"xbl-marquee.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"marqueeBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n\n  <binding id=\"marquee\" bindToUntrustedContent=\"true\">\n\n    <resources>\n      <stylesheet src=\"chrome://xbl-marquee/content/xbl-marquee.css\"/>\n    </resources>\n    <implementation>\n\n      <property name=\"scrollAmount\" exposeToUntrustedContent=\"true\">\n        <getter>\n          <![CDATA[\n          this._mutationActor(this._mutationObserver.takeRecords());\n          return this._scrollAmount;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n          var val = parseInt(val);\n          if (val < 0) {\n            return;\n          }\n          if (isNaN(val)) {\n            val = 0;\n          }\n          this.setAttribute(\"scrollamount\", val);\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"scrollDelay\" exposeToUntrustedContent=\"true\">\n        <getter>\n          <![CDATA[\n          this._mutationActor(this._mutationObserver.takeRecords());\n          var val = parseInt(this.getAttribute(\"scrolldelay\"));\n\n          if (val <= 0 || isNaN(val)) {\n            return this._scrollDelay;\n          }\n\n          return val;\n          ]]>\n        </getter>\n        <setter>\n          var val = parseInt(val);\n          if (val > 0 ) {\n            this.setAttribute(\"scrolldelay\", val);\n          }\n        </setter>\n      </property>\n\n      <property name=\"trueSpeed\" exposeToUntrustedContent=\"true\">\n        <getter>\n          <![CDATA[\n          if (!this.hasAttribute(\"truespeed\")) {\n            return false;\n          }\n\n          return true;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n          if (val) {\n            this.setAttribute(\"truespeed\", \"\");\n          } else {\n            this.removeAttribute('truespeed');\n          }\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"direction\" exposeToUntrustedContent=\"true\">\n        <getter>\n          this._mutationActor(this._mutationObserver.takeRecords());\n          return this._direction;\n        </getter>\n        <setter>\n          <![CDATA[\n          if (typeof val == 'string') {\n            val = val.toLowerCase();\n          } else {\n            return;\n          }\n          if (val != 'left' && val != 'right' && val != 'up' && val != 'down') {\n            val = 'left';\n          }\n\n          this.setAttribute(\"direction\", val);\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"behavior\" exposeToUntrustedContent=\"true\">\n        <getter>\n          this._mutationActor(this._mutationObserver.takeRecords());\n          return this._behavior;\n        </getter>\n        <setter>\n          if (typeof val == 'string') {\n            val = val.toLowerCase();\n          }\n          if (val == \"alternate\" || val == \"slide\" || val == 'scroll') {\n            this.setAttribute(\"behavior\", val);\n          }\n        </setter>\n      </property>\n\n\n      <property name=\"loop\" exposeToUntrustedContent=\"true\">\n        <getter>\n          <![CDATA[\n          this._mutationActor(this._mutationObserver.takeRecords());\n          return this._loop;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n          var val = parseInt(val);\n          if (val == -1 || val > 0) {\n            this.setAttribute(\"loop\", val);\n          }\n          ]]>\n        </setter>\n      </property>\n\n\n      <property name=\"onstart\" exposeToUntrustedContent=\"true\">\n        <getter>\n          return this.getAttribute(\"onstart\");\n        </getter>\n        <setter>\n          this._setEventListener(\"start\", val, true);\n          this.setAttribute(\"onstart\", val);\n        </setter>\n      </property>\n\n      <property name=\"onfinish\" exposeToUntrustedContent=\"true\">\n        <getter>\n          return this.getAttribute(\"onfinish\");\n        </getter>\n        <setter>\n          this._setEventListener(\"finish\", val, true);\n          this.setAttribute(\"onfinish\", val);\n        </setter>\n      </property>\n\n      <property name=\"onbounce\" exposeToUntrustedContent=\"true\">\n        <getter>\n          return this.getAttribute(\"onbounce\");\n        </getter>\n        <setter>\n          this._setEventListener(\"bounce\", val, true);\n          this.setAttribute(\"onbounce\", val);\n        </setter>\n      </property>\n\n      <property name=\"outerDiv\"\n        onget=\"return document.getAnonymousNodes(this)[0]\"\n      />\n\n      <property name=\"innerDiv\"\n        onget=\"return document.getAnonymousElementByAttribute(this, 'class', 'innerDiv');\"\n      />\n\n      <property name=\"height\" exposeToUntrustedContent=\"true\"\n        onget=\"return this.getAttribute('height');\"\n        onset=\"this.setAttribute('height', val);\"\n      />\n\n      <property name=\"width\" exposeToUntrustedContent=\"true\"\n        onget=\"return this.getAttribute('width');\"\n        onset=\"this.setAttribute('width', val);\"\n      />\n\n      <method name=\"_set_scrollDelay\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          aValue = parseInt(aValue);\n          if (aValue <= 0) {\n            return;\n          } else if (isNaN(aValue)) {\n            this._scrollDelay = 85;\n          } else if (aValue < 60) {\n            if (this.trueSpeed == true) {\n              this._scrollDelay = aValue;\n            } else {\n              this._scrollDelay = 60;\n            }\n          } else {\n            this._scrollDelay = aValue;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_set_scrollAmount\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          aValue = parseInt(aValue);\n          if (isNaN(aValue)) {\n            this._scrollAmount = 6;\n          } else if (aValue < 0) {\n            return;\n          } else {\n            this._scrollAmount = aValue;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_set_behavior\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          if (typeof aValue == 'string') {\n            aValue = aValue.toLowerCase();\n          }\n          if (aValue != 'alternate' && aValue != 'slide' && aValue != 'scroll') {\n            this._behavior = 'scroll';\n          } else {\n            this._behavior = aValue;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_set_direction\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          if (typeof aValue == 'string') {\n            aValue = aValue.toLowerCase();\n          }\n          if (aValue != 'left' && aValue != 'right' && aValue != 'up' && aValue != 'down') {\n            aValue = 'left';\n          }\n\n          if (aValue != this._direction) {\n            this.startNewDirection = true;\n          }\n          this._direction = aValue;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_set_loop\">\n        <parameter name=\"aValue\"/>\n        <body>\n          <![CDATA[\n          var aValue = parseInt(aValue);\n          if (aValue == 0) {\n            return;\n          }\n          if (isNaN(aValue) || aValue <= -1) {\n            aValue = -1;\n          }\n          this._loop = aValue;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_setEventListener\">\n        <parameter name=\"aName\"/>\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aIgnoreNextCall\"/>\n        <body>\n          <![CDATA[\n          // _setEventListener is only used for setting the attribute event\n          // handlers, which we want to ignore if our document is sandboxed\n          // without the allow-scripts keyword.\n          if (document.hasScriptsBlockedBySandbox) {\n            return true;\n          }\n\n          // attribute event handlers should only be added if the\n          // document's CSP allows it.\n          if (!document.inlineScriptAllowedByCSP) {\n            return true;\n          }\n\n          if (this._ignoreNextCall) {\n            return this._ignoreNextCall = false;\n          }\n\n          if (aIgnoreNextCall) {\n            this._ignoreNextCall = true;\n          }\n\n          if (typeof this[\"_on\" + aName] == 'function') {\n            this.removeEventListener(aName, this[\"_on\" + aName]);\n          }\n\n          switch (typeof aValue)\n          {\n            case \"function\":\n              this[\"_on\" + aName] = aValue;\n              this.addEventListener(aName, this[\"_on\" + aName]);\n            break;\n\n            case \"string\":\n              if (!aIgnoreNextCall) {\n                try {\n                  // Function Xrays make this simple and safe. \\o/\n                  this[\"_on\" + aName] = new window.Function(\"event\", aValue);\n                }\n                catch(e) {\n                  return false;\n                }\n                this.addEventListener(aName, this[\"_on\" + aName]);\n              }\n              else {\n                this[\"_on\" + aName] = aValue;\n              }\n            break;\n\n            case \"object\":\n              this[\"_on\" + aName] = aValue;\n            break;\n\n            default:\n              this._ignoreNextCall = false;\n              throw new Error(\"Invalid argument for Marquee::on\" + aName);\n          }\n          return true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_fireEvent\">\n        <parameter name=\"aName\"/>\n        <parameter name=\"aBubbles\"/>\n        <parameter name=\"aCancelable\"/>\n        <body>\n        <![CDATA[\n          var e = document.createEvent(\"Events\");\n          e.initEvent(aName, aBubbles, aCancelable);\n          this.dispatchEvent(e);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"start\" exposeToUntrustedContent=\"true\">\n        <body>\n        <![CDATA[\n          if (this.runId == 0) {\n            var myThis = this;\n            var lambda = function myTimeOutFunction(){myThis._doMove(false);}\n            this.runId = window.setTimeout(lambda, this._scrollDelay - this._deltaStartStop);\n            this._deltaStartStop = 0;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"stop\" exposeToUntrustedContent=\"true\">\n        <body>\n        <![CDATA[\n          if (this.runId != 0) {\n            this._deltaStartStop = Date.now()- this._lastMoveDate;\n            clearTimeout(this.runId);\n          }\n\n          this.runId = 0;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_doMove\">\n        <parameter name=\"aResetPosition\"/>\n        <body>\n        <![CDATA[\n          this._lastMoveDate = Date.now();\n\n          //startNewDirection is true at first load and whenever the direction is changed\n          if (this.startNewDirection) {\n            this.startNewDirection = false; //we only want this to run once every scroll direction change\n\n            var corrvalue = 0;\n\n            switch (this._direction)\n            {\n              case \"up\":\n                var height = document.defaultView.getComputedStyle(this).height;\n                this.outerDiv.style.height = height;\n                if (this.originalHeight > this.outerDiv.offsetHeight) {\n                    corrvalue = this.originalHeight - this.outerDiv.offsetHeight;\n                }\n                this.innerDiv.style.padding = height + \" 0\";\n                this.dirsign = 1;\n                this.startAt = (this._behavior == 'alternate') ? (this.originalHeight - corrvalue) : 0;\n                this.stopAt  = (this._behavior == 'alternate' || this._behavior == 'slide') ? \n                                (parseInt(height) + corrvalue) : (this.originalHeight + parseInt(height));\n              break;\n\n              case \"down\":\n                var height = document.defaultView.getComputedStyle(this).height;\n                this.outerDiv.style.height = height;\n                if (this.originalHeight > this.outerDiv.offsetHeight) {\n                    corrvalue = this.originalHeight - this.outerDiv.offsetHeight;\n                }\n                this.innerDiv.style.padding = height + \" 0\";\n                this.dirsign = -1;\n                this.startAt  = (this._behavior == 'alternate') ?\n                                (parseInt(height) + corrvalue) : (this.originalHeight + parseInt(height));\n                this.stopAt = (this._behavior == 'alternate' || this._behavior == 'slide') ? \n                              (this.originalHeight - corrvalue) : 0;\n              break;\n\n              case \"right\":\n                if (this.innerDiv.offsetWidth > this.outerDiv.offsetWidth) {\n                    corrvalue = this.innerDiv.offsetWidth - this.outerDiv.offsetWidth;\n                }\n                this.dirsign = -1;\n                this.stopAt  = (this._behavior == 'alternate' || this._behavior == 'slide') ? \n                               (this.innerDiv.offsetWidth - corrvalue) : 0;\n                this.startAt = this.outerDiv.offsetWidth + ((this._behavior == 'alternate') ? \n                               corrvalue : (this.innerDiv.offsetWidth + this.stopAt));   \n              break;\n\n              case \"left\":\n              default:\n                if (this.innerDiv.offsetWidth > this.outerDiv.offsetWidth) {\n                    corrvalue = this.innerDiv.offsetWidth - this.outerDiv.offsetWidth;\n                }\n                this.dirsign = 1;\n                this.startAt = (this._behavior == 'alternate') ? (this.innerDiv.offsetWidth - corrvalue) : 0;\n                this.stopAt  = this.outerDiv.offsetWidth + \n                               ((this._behavior == 'alternate' || this._behavior == 'slide') ? \n                               corrvalue : (this.innerDiv.offsetWidth + this.startAt));\n            }\n\n            if (aResetPosition) {\n              this.newPosition = this.startAt;\n              this._fireEvent(\"start\", false, false);\n            }\n          } //end if\n\n          this.newPosition = this.newPosition + (this.dirsign * this._scrollAmount);\n\n          if ((this.dirsign == 1 && this.newPosition > this.stopAt) ||\n              (this.dirsign == -1 && this.newPosition < this.stopAt))\n          {\n            switch (this._behavior) \n            {\n              case 'alternate':\n                // lets start afresh\n                this.startNewDirection = true;\n\n                // swap direction\n                const swap = {left: \"right\", down: \"up\", up: \"down\", right: \"left\"};\n                this._direction = swap[this._direction];\n                this.newPosition = this.stopAt;\n\n                if ((this._direction == \"up\") || (this._direction == \"down\")) {\n                  this.outerDiv.scrollTop = this.newPosition;\n                } else {\n                  this.outerDiv.scrollLeft = this.newPosition;\n                }\n\n                if (this._loop != 1) {\n                  this._fireEvent(\"bounce\", false, true);\n                }\n              break;\n\n              case 'slide':\n                if (this._loop > 1) {\n                  this.newPosition = this.startAt;\n                }\n              break;\n\n              default:\n                this.newPosition = this.startAt;\n\n                if ((this._direction == \"up\") || (this._direction == \"down\")) {\n                  this.outerDiv.scrollTop = this.newPosition;\n                } else {\n                  this.outerDiv.scrollLeft = this.newPosition;\n                }\n\n                //dispatch start event, even when this._loop == 1, comp. with IE6\n                this._fireEvent(\"start\", false, false);\n            }\n\n            if (this._loop > 1) {\n              this._loop--;\n            } else if (this._loop == 1) {\n              if ((this._direction == \"up\") || (this._direction == \"down\")) {\n                this.outerDiv.scrollTop = this.stopAt;\n              } else {\n                this.outerDiv.scrollLeft = this.stopAt;\n              }\n              this.stop();\n              this._fireEvent(\"finish\", false, true);\n              return;\n            }\n          }\n          else {\n            if ((this._direction == \"up\") || (this._direction == \"down\")) {\n              this.outerDiv.scrollTop = this.newPosition;\n            } else {\n              this.outerDiv.scrollLeft = this.newPosition;\n            }\n          }\n\n          var myThis = this;\n          var lambda = function myTimeOutFunction(){myThis._doMove(false);}\n          this.runId = window.setTimeout(lambda, this._scrollDelay);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"init\">\n        <body>\n        <![CDATA[\n          this.stop();\n\n          if ((this._direction != \"up\") && (this._direction != \"down\")) {\n            var width = window.getComputedStyle(this).width;\n            this.innerDiv.parentNode.style.margin = '0 ' + width;\n\n            //XXX Adding the margin sometimes causes the marquee to widen, \n            // see testcase from bug bug 364434: \n            // https://bugzilla.mozilla.org/attachment.cgi?id=249233\n            // Just add a fixed width with current marquee's width for now\n            if (width != window.getComputedStyle(this).width) {\n              var width = window.getComputedStyle(this).width;\n              this.outerDiv.style.width = width;\n              this.innerDiv.parentNode.style.margin = '0 ' + width;\n            }\n          }\n          else {\n            // store the original height before we add padding\n            this.innerDiv.style.padding = 0;\n            this.originalHeight = this.innerDiv.offsetHeight;\n          }\n\n          this._doMove(true);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_mutationActor\">\n        <parameter name=\"aMutations\"/>\n        <body>\n        <![CDATA[\n          while (aMutations.length > 0) {\n            var mutation = aMutations.shift();\n            var attrName = mutation.attributeName.toLowerCase();\n            var oldValue = mutation.oldValue;\n            var target = mutation.target;\n            var newValue = target.getAttribute(attrName);\n\n            if (oldValue != newValue) {\n              switch (attrName) {\n                case \"loop\":\n                  target._set_loop(newValue);\n                  if (target.rundId == 0) {\n                    target.start();\n                  }\n                  break;\n                case \"scrollamount\":\n                  target._set_scrollAmount(newValue);\n                  break;\n                case \"scrolldelay\":\n                  target._set_scrollDelay(newValue);\n                  target.stop();\n                  target.start();\n                  break;\n                case \"truespeed\":\n                  //needed to update target._scrollDelay\n                  var myThis = target;\n                  var lambda = function() {myThis._set_scrollDelay(myThis.getAttribute('scrolldelay'));}\n                  window.setTimeout(lambda, 0);\n                  break;\n                case \"behavior\":\n                  target._set_behavior(newValue);\n                  target.startNewDirection = true;\n                  if ((oldValue == \"slide\" && target.newPosition == target.stopAt) ||\n                      newValue == \"alternate\" || newValue == \"slide\") {\n                    target.stop();\n                    target._doMove(true);\n                  }\n                  break;\n                case \"direction\":\n                  if (!newValue) {\n                    newValue = \"left\";\n                  }\n                  target._set_direction(newValue);\n                  break;\n                case \"width\":\n                case \"height\":\n                  target.startNewDirection = true;\n                  break;\n                case \"onstart\":\n                  target._setEventListener(\"start\", newValue);\n                  break;\n                case \"onfinish\":\n                  target._setEventListener(\"finish\", newValue);\n                  break;\n                case \"onbounce\":\n                  target._setEventListener(\"bounce\", newValue);\n                  break;\n              }\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <constructor>\n        <![CDATA[\n          // Set up state.\n          this._scrollAmount = 6;\n          this._scrollDelay = 85;\n          this._direction = \"left\";\n          this._behavior = \"scroll\";\n          this._loop = -1;\n          this.dirsign = 1;\n          this.startAt = 0;\n          this.stopAt = 0;\n          this.newPosition = 0;\n          this.runId = 0;\n          this.originalHeight = 0;\n          this.startNewDirection = true;\n\n          // hack needed to fix js error, see bug 386470\n          var myThis = this;\n          var lambda = function myScopeFunction() { if (myThis.init) myThis.init(); }\n\n          this._set_direction(this.getAttribute('direction'));\n          this._set_behavior(this.getAttribute('behavior'));\n          this._set_scrollDelay(this.getAttribute('scrolldelay'));\n          this._set_scrollAmount(this.getAttribute('scrollamount'));\n          this._set_loop(this.getAttribute('loop'));\n          this._setEventListener(\"start\", this.getAttribute(\"onstart\"));\n          this._setEventListener(\"finish\", this.getAttribute(\"onfinish\"));\n          this._setEventListener(\"bounce\", this.getAttribute(\"onbounce\"));\n          this.startNewDirection = true;\n\n          this._mutationObserver = new MutationObserver(this._mutationActor);\n          this._mutationObserver.observe(this, { attributes: true,\n            attributeOldValue: true,\n            attributeFilter: ['loop', 'scrollamount', 'scrolldelay', '', 'truespeed', 'behavior',\n              'direction', 'width', 'height', 'onstart', 'onfinish', 'onbounce'] });\n\n          // init needs to be run after the page has loaded in order to calculate\n          // the correct height/width\n          if (document.readyState == \"complete\") {\n            lambda();\n          } else {\n            window.addEventListener(\"load\", lambda);\n          }\n        ]]>\n      </constructor>\n    </implementation>\n\n  </binding>\n\n  <binding id=\"marquee-horizontal\" bindToUntrustedContent=\"true\"\n           extends=\"chrome://xbl-marquee/content/xbl-marquee.xml#marquee\"\n           inheritstyle=\"false\">\n\n    <!-- White-space isn't allowed because a marquee could be \n         inside 'white-space: pre' -->\n    <content>\n      <html:div style=\"display: -moz-box; overflow: hidden; width: -moz-available;\"\n        ><html:div style=\"display: -moz-box;\"\n          ><html:div class=\"innerDiv\" style=\"display: table; border-spacing: 0;\"\n            ><html:div\n              ><children\n            /></html:div\n          ></html:div\n        ></html:div\n      ></html:div>\n    </content>\n\n  </binding>\n\n  <binding id=\"marquee-vertical\" bindToUntrustedContent=\"true\"\n           extends=\"chrome://xbl-marquee/content/xbl-marquee.xml#marquee\"\n           inheritstyle=\"false\">\n\n    <!-- White-space isn't allowed because a marquee could be \n         inside 'white-space: pre' -->\n    <content>\n      <html:div style=\"overflow: hidden; width: -moz-available;\"\n        ><html:div class=\"innerDiv\"\n          ><children\n        /></html:div\n      ></html:div>\n    </content>\n\n  </binding>\n\n  <binding id=\"marquee-horizontal-editable\" bindToUntrustedContent=\"true\"\n           inheritstyle=\"false\">\n\n    <!-- White-space isn't allowed because a marquee could be \n         inside 'white-space: pre' -->\n    <content>\n      <html:div style=\"display: inline-block; overflow: auto; width: -moz-available;\"\n        ><children\n      /></html:div>\n    </content>\n\n  </binding>\n\n  <binding id=\"marquee-vertical-editable\" bindToUntrustedContent=\"true\"\n           inheritstyle=\"false\">\n\n    <!-- White-space isn't allowed because a marquee could be \n         inside 'white-space: pre' -->\n    <content>\n      <html:div style=\"overflow: auto; height: inherit; width: -moz-available;\"\n        ><children/></html:div>\n    </content>\n\n  </binding>\n\n</bindings>\n"},{"file":"tabprompts.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This file is imported into the browser window, and expects various variables,\n     e.g. Ci, Services, to be available. -->\n\n<!DOCTYPE bindings [\n<!ENTITY % commonDialogDTD  SYSTEM \"chrome://global/locale/commonDialog.dtd\">\n<!ENTITY % dialogOverlayDTD SYSTEM \"chrome://global/locale/dialogOverlay.dtd\">\n%commonDialogDTD;\n%dialogOverlayDTD;\n]>\n\n<bindings id=\"tabPrompts\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"tabmodalprompt\">\n    <xbl:content xmlns=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n                 role=\"dialog\"\n                 aria-describedby=\"infoBody\">\n\n        <!-- This is based on the guts of commonDialog.xul -->\n        <spacer flex=\"1\"/>\n        <hbox pack=\"center\">\n            <vbox anonid=\"mainContainer\" class=\"tabmodalprompt-mainContainer\">\n                <grid class=\"tabmodalprompt-topContainer\" flex=\"1\">\n                    <columns>\n                        <column/>\n                        <column flex=\"1\"/>\n                    </columns>\n\n                    <rows>\n                        <vbox anonid=\"infoContainer\" align=\"center\" pack=\"center\" flex=\"1\">\n                            <description anonid=\"infoTitle\" class=\"infoTitle\" hidden=\"true\" />\n                            <description anonid=\"infoBody\" class=\"infoBody\"/>\n                        </vbox>\n\n                        <row anonid=\"loginContainer\" hidden=\"true\" align=\"center\">\n                            <label anonid=\"loginLabel\" value=\"FROM-DTD.editfield0.label;\" control=\"loginTextbox\"/>\n                            <textbox anonid=\"loginTextbox\"/>\n                        </row>\n\n                        <row anonid=\"password1Container\" hidden=\"true\" align=\"center\">\n                            <label anonid=\"password1Label\" value=\"FROM-DTD.editfield1.label;\" control=\"password1Textbox\"/>\n                            <textbox anonid=\"password1Textbox\" type=\"password\"/>\n                        </row>\n\n                        <row anonid=\"checkboxContainer\" hidden=\"true\">\n                            <spacer/>\n                            <checkbox anonid=\"checkbox\"/>\n                        </row>\n\n                        <xbl:children includes=\"row\"/>\n                    </rows>\n                </grid>\n                <xbl:children/>\n                <hbox class=\"tabmodalprompt-buttonContainer\">\n\n                    <button anonid=\"button3\" hidden=\"true\"/>\n                    <spacer anonid=\"buttonSpacer\" flex=\"1\"/>\n                    <button anonid=\"button0\" label=\"FROM-DTD.okButton.label;\"/>\n                    <button anonid=\"button2\" hidden=\"true\"/>\n                    <button anonid=\"button1\" label=\"FROM-DTD.cancelButton.label;\"/>\n\n                </hbox>\n            </vbox>\n        </hbox>\n        <spacer flex=\"2\"/>\n    </xbl:content>\n\n    <implementation>\n        <constructor>\n        <![CDATA[\n            let self = this;\n            function getElement(anonid) {\n                return document.getAnonymousElementByAttribute(self, \"anonid\", anonid);\n            }\n\n            this.ui = {\n                prompt: this,\n                loginContainer: getElement(\"loginContainer\"),\n                loginTextbox: getElement(\"loginTextbox\"),\n                loginLabel: getElement(\"loginLabel\"),\n                password1Container: getElement(\"password1Container\"),\n                password1Textbox: getElement(\"password1Textbox\"),\n                password1Label: getElement(\"password1Label\"),\n                infoBody: getElement(\"infoBody\"),\n                infoTitle: getElement(\"infoTitle\"),\n                infoIcon: null,\n                checkbox: getElement(\"checkbox\"),\n                checkboxContainer: getElement(\"checkboxContainer\"),\n                button3: getElement(\"button3\"),\n                button2: getElement(\"button2\"),\n                button1: getElement(\"button1\"),\n                button0: getElement(\"button0\"),\n                // focusTarget (for BUTTON_DELAY_ENABLE) not yet supported\n            };\n\n            this.ui.button0.addEventListener(\"command\", this.onButtonClick.bind(this, 0));\n            this.ui.button1.addEventListener(\"command\", this.onButtonClick.bind(this, 1));\n            this.ui.button2.addEventListener(\"command\", this.onButtonClick.bind(this, 2));\n            this.ui.button3.addEventListener(\"command\", this.onButtonClick.bind(this, 3));\n            // Anonymous wrapper used here because |Dialog| doesn't exist until init() is called!\n            this.ui.checkbox.addEventListener(\"command\", function() { self.Dialog.onCheckbox(); });\n            this.isLive = false;\n        ]]>\n        </constructor>\n        <destructor>\n        <![CDATA[\n            if (this.isLive) {\n                this.abortPrompt();\n            }\n        ]]>\n        </destructor>\n\n        <field name=\"ui\"/>\n        <field name=\"args\"/>\n        <field name=\"linkedTab\"/>\n        <field name=\"onCloseCallback\"/>\n        <field name=\"Dialog\"/>\n        <field name=\"isLive\"/>\n        <field name=\"availWidth\"/>\n        <field name=\"availHeight\"/>\n        <field name=\"minWidth\"/>\n        <field name=\"minHeight\"/>\n\n        <method name=\"init\">\n            <parameter name=\"args\"/>\n            <parameter name=\"linkedTab\"/>\n            <parameter name=\"onCloseCallback\"/>\n            <body>\n            <![CDATA[\n                this.args = args;\n                this.linkedTab = linkedTab;\n                this.onCloseCallback = onCloseCallback;\n\n                if (args.enableDelay)\n                    throw \"BUTTON_DELAY_ENABLE not yet supported for tab-modal prompts\";\n\n                // We need to remove the prompt when the tab or browser window is closed or\n                // the page navigates, else we never unwind the event loop and that's sad times.\n                // Remember to cleanup in shutdownPrompt()!\n                this.isLive = true;\n                window.addEventListener(\"resize\", this);\n                window.addEventListener(\"unload\", this);\n                if (linkedTab) {\n                  linkedTab.addEventListener(\"TabClose\", this);\n                }\n                // Note:\n                // nsPrompter.js or in e10s mode browser-parent.js call abortPrompt,\n                // when the domWindow, for which the prompt was created, generates\n                // a \"pagehide\" event.\n\n                let tmp = {};\n                ChromeUtils.import(\"resource://gre/modules/CommonDialog.jsm\", tmp);\n                this.Dialog = new tmp.CommonDialog(args, this.ui);\n                this.Dialog.onLoad(null);\n\n                // Display the tabprompt title that shows the prompt origin when\n                // the prompt origin is not the same as that of the top window.\n                if (!args.showAlertOrigin)\n                    this.ui.infoTitle.removeAttribute(\"hidden\");\n\n                // TODO: should unhide buttonSpacer on Windows when there are 4 buttons.\n                //       Better yet, just drop support for 4-button dialogs. (bug 609510)\n\n                this.onResize();\n            ]]>\n            </body>\n        </method>\n\n        <method name=\"shutdownPrompt\">\n            <body>\n            <![CDATA[\n                // remove our event listeners\n                try {\n                    window.removeEventListener(\"resize\", this);\n                    window.removeEventListener(\"unload\", this);\n                    if (this.linkedTab) {\n                      this.linkedTab.removeEventListener(\"TabClose\", this);\n                    }\n                } catch (e) { }\n                this.isLive = false;\n                // invoke callback\n                this.onCloseCallback();\n            ]]>\n            </body>\n        </method>\n\n        <method name=\"abortPrompt\">\n            <body>\n            <![CDATA[\n                // Called from other code when the page changes.\n                this.Dialog.abortPrompt();\n                this.shutdownPrompt();\n            ]]>\n            </body>\n        </method>\n\n        <method name=\"handleEvent\">\n            <parameter name=\"aEvent\"/>\n            <body>\n            <![CDATA[\n                switch (aEvent.type) {\n                  case \"resize\":\n                    this.onResize();\n                    break;\n                  case \"unload\":\n                  case \"TabClose\":\n                    this.abortPrompt();\n                    break;\n                }\n            ]]>\n            </body>\n        </method>\n\n        <method name=\"onResize\">\n            <body>\n            <![CDATA[\n                let availWidth = this.clientWidth;\n                let availHeight = this.clientHeight;\n                if (availWidth == this.availWidth && availHeight == this.availHeight)\n                    return;\n                this.availWidth = availWidth;\n                this.availHeight = availHeight;\n\n                let self = this;\n                function getElement(anonid) {\n                    return document.getAnonymousElementByAttribute(self, \"anonid\", anonid);\n                }\n                let main = getElement(\"mainContainer\");\n                let info = getElement(\"infoContainer\");\n                let body = this.ui.infoBody;\n\n                // cap prompt dimensions at 60% width and 60% height of content area\n                if (!this.minWidth)\n                  this.minWidth = parseInt(window.getComputedStyle(main).minWidth);\n                if (!this.minHeight)\n                  this.minHeight = parseInt(window.getComputedStyle(main).minHeight);\n                let maxWidth = Math.max(Math.floor(availWidth * 0.6), this.minWidth) +\n                               info.clientWidth - main.clientWidth;\n                let maxHeight = Math.max(Math.floor(availHeight * 0.6), this.minHeight) +\n                                info.clientHeight - main.clientHeight;\n                body.style.maxWidth = maxWidth + \"px\";\n                info.style.overflow = info.style.width = info.style.height = \"\";\n\n                // when prompt text is too long, use scrollbars\n                if (info.clientWidth > maxWidth) {\n                    info.style.overflow = \"auto\";\n                    info.style.width = maxWidth + \"px\";\n                }\n                if (info.clientHeight > maxHeight) {\n                    info.style.overflow = \"auto\";\n                    info.style.height = maxHeight + \"px\";\n                }\n            ]]>\n            </body>\n        </method>\n\n        <method name=\"onButtonClick\">\n            <parameter name=\"buttonNum\"/>\n            <body>\n            <![CDATA[\n                // We want to do all the work her asynchronously off a Gecko\n                // runnable, because of situations like the one described in\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=1167575#c35 : we\n                // get here off processing of an OS event and will also process\n                // one more Gecko runnable before we break out of the event loop\n                // spin whoever posted the prompt is doing.  If we do all our\n                // work sync, we will exit modal state _before_ processing that\n                // runnable, and if exiting moral state posts a runnable we will\n                // incorrectly process that runnable before leaving our event\n                // loop spin.\n                Services.tm.dispatchToMainThread(() => {\n                    this.Dialog[\"onButton\" + buttonNum]();\n                    this.shutdownPrompt();\n                  });\n            ]]>\n            </body>\n        </method>\n\n        <method name=\"onKeyAction\">\n            <parameter name=\"action\"/>\n            <parameter name=\"event\"/>\n            <body>\n            <![CDATA[\n                if (event.defaultPrevented)\n                    return;\n\n                event.stopPropagation();\n                if (action == \"default\") {\n                    let bnum = this.args.defaultButtonNum || 0;\n                    this.onButtonClick(bnum);\n                } else { // action == \"cancel\"\n                    this.onButtonClick(1); // Cancel button\n                }\n            ]]>\n            </body>\n        </method>\n    </implementation>\n\n    <handlers>\n        <!-- Based on dialog.xml handlers -->\n        <handler event=\"keypress\" keycode=\"VK_RETURN\"\n                 group=\"system\" action=\"this.onKeyAction('default', event);\"/>\n        <handler event=\"keypress\" keycode=\"VK_ESCAPE\"\n                 group=\"system\" action=\"this.onKeyAction('cancel', event);\"/>\n\n        <handler event=\"focus\" phase=\"capturing\">\n            let bnum = this.args.defaultButtonNum || 0;\n            let defaultButton = this.ui[\"button\" + bnum];\n\n            let { AppConstants } =\n                ChromeUtils.import(\"resource://gre/modules/AppConstants.jsm\", {});\n            if (AppConstants.platform == \"macosx\") {\n              // On OS X, the default button always stays marked as such (until\n              // the entire prompt blurs).\n              defaultButton.setAttribute(\"default\", true);\n            } else {\n              // On other platforms, the default button is only marked as such\n              // when no other button has focus. XUL buttons on not-OSX will\n              // react to pressing enter as a command, so you can't trigger the\n              // default without tabbing to it or something that isn't a button.\n              let focusedDefault = (event.originalTarget == defaultButton);\n              let someButtonFocused = event.originalTarget instanceof Ci.nsIDOMXULButtonElement;\n              defaultButton.setAttribute(\"default\", focusedDefault || !someButtonFocused);\n            }\n        </handler>\n        <handler event=\"blur\">\n            // If focus shifted to somewhere else in the browser, don't make\n            // the default button look active.\n            let bnum = this.args.defaultButtonNum || 0;\n            let button = this.ui[\"button\" + bnum];\n            button.setAttribute(\"default\", false);\n        </handler>\n    </handlers>\n\n  </binding>\n</bindings>\n"},{"file":"autocomplete.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"autocompleteBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:html=\"http://www.w3.org/1999/xhtml\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"autocomplete\"\n           extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content sizetopopup=\"pref\">\n      <children includes=\"image|deck|stack|box\"/>\n\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\">\n        <children/>\n        <html:input anonid=\"input\" class=\"textbox-input\"\n                    allowevents=\"true\"\n                    xbl:inherits=\"value,type=inputtype,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,mozactionhint\"/>\n      </xul:moz-input-box>\n      <children includes=\"hbox\"/>\n\n      <xul:popupset anonid=\"popupset\" class=\"autocomplete-result-popupset\"/>\n\n      <children includes=\"toolbarbutton\"/>\n    </content>\n\n    <implementation implements=\"nsIAutoCompleteInput, nsIDOMXULMenuListElement\">\n      <field name=\"mController\">null</field>\n      <field name=\"mSearchNames\">null</field>\n      <field name=\"mIgnoreInput\">false</field>\n\n      <field name=\"_searchBeginHandler\">null</field>\n      <field name=\"_searchCompleteHandler\">null</field>\n      <field name=\"_textEnteredHandler\">null</field>\n      <field name=\"_textRevertedHandler\">null</field>\n\n      <constructor><![CDATA[\n        this.mController = Cc[\"@mozilla.org/autocomplete/controller;1\"].\n          getService(Ci.nsIAutoCompleteController);\n\n        this._searchBeginHandler = this.initEventHandler(\"searchbegin\");\n        this._searchCompleteHandler = this.initEventHandler(\"searchcomplete\");\n        this._textEnteredHandler = this.initEventHandler(\"textentered\");\n        this._textRevertedHandler = this.initEventHandler(\"textreverted\");\n\n        // For security reasons delay searches on pasted values.\n        this.inputField.controllers.insertControllerAt(0, this._pasteController);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        this.inputField.controllers.removeController(this._pasteController);\n      ]]></destructor>\n\n      <!-- =================== nsIAutoCompleteInput =================== -->\n\n      <field name=\"_popup\">null</field>\n      <property name=\"popup\" readonly=\"true\">\n        <getter><![CDATA[\n          // Memoize the result in a field rather than replacing this property,\n          // so that it can be reset along with the binding.\n          if (this._popup) {\n            return this._popup;\n          }\n\n          let popup = null;\n          let popupId = this.getAttribute(\"autocompletepopup\");\n          if (popupId) {\n            popup = document.getElementById(popupId);\n          }\n          if (!popup) {\n            popup = document.createXULElement(\"panel\");\n            popup.setAttribute(\"type\", \"autocomplete-richlistbox\");\n            popup.setAttribute(\"noautofocus\", \"true\");\n\n            let popupset = document.getAnonymousElementByAttribute(this, \"anonid\", \"popupset\");\n            popupset.appendChild(popup);\n          }\n          popup.mInput = this;\n\n          return this._popup = popup;\n        ]]></getter>\n      </property>\n\n      <property name=\"controller\" onget=\"return this.mController;\" readonly=\"true\"/>\n\n      <property name=\"popupOpen\"\n                onget=\"return this.popup.popupOpen;\"\n                onset=\"if (val) this.openPopup(); else this.closePopup();\"/>\n\n      <property name=\"disableAutoComplete\"\n                onset=\"this.setAttribute('disableautocomplete', val); return val;\"\n                onget=\"return this.getAttribute('disableautocomplete') == 'true';\"/>\n\n      <property name=\"completeDefaultIndex\"\n                onset=\"this.setAttribute('completedefaultindex', val); return val;\"\n                onget=\"return this.getAttribute('completedefaultindex') == 'true';\"/>\n\n      <property name=\"completeSelectedIndex\"\n                onset=\"this.setAttribute('completeselectedindex', val); return val;\"\n                onget=\"return this.getAttribute('completeselectedindex') == 'true';\"/>\n\n      <property name=\"forceComplete\"\n                onset=\"this.setAttribute('forcecomplete', val); return val;\"\n                onget=\"return this.getAttribute('forcecomplete') == 'true';\"/>\n\n      <property name=\"minResultsForPopup\"\n                onset=\"this.setAttribute('minresultsforpopup', val); return val;\"\n                onget=\"var m = parseInt(this.getAttribute('minresultsforpopup')); return isNaN(m) ? 1 : m;\"/>\n\n      <property name=\"timeout\"\n                onset=\"this.setAttribute('timeout', val); return val;\">\n        <getter><![CDATA[\n          // For security reasons delay searches on pasted values.\n          if (this._valueIsPasted) {\n            let t = parseInt(this.getAttribute(\"pastetimeout\"));\n            return isNaN(t) ? 1000 : t;\n          }\n\n          let t = parseInt(this.getAttribute(\"timeout\"));\n          return isNaN(t) ? 50 : t;\n        ]]></getter>\n      </property>\n\n      <property name=\"searchParam\"\n                onget=\"return this.getAttribute('autocompletesearchparam') || '';\"\n                onset=\"this.setAttribute('autocompletesearchparam', val); return val;\"/>\n\n      <property name=\"searchCount\" readonly=\"true\"\n                onget=\"this.initSearchNames(); return this.mSearchNames.length;\"/>\n\n      <property name=\"PrivateBrowsingUtils\" readonly=\"true\">\n        <getter><![CDATA[\n          let module = {};\n          ChromeUtils.import(\"resource://gre/modules/PrivateBrowsingUtils.jsm\", module);\n          Object.defineProperty(this, \"PrivateBrowsingUtils\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: module.PrivateBrowsingUtils,\n          });\n          return module.PrivateBrowsingUtils;\n        ]]></getter>\n      </property>\n\n      <property name=\"inPrivateContext\" readonly=\"true\"\n                onget=\"return this.PrivateBrowsingUtils.isWindowPrivate(window);\"/>\n\n      <property name=\"noRollupOnCaretMove\" readonly=\"true\"\n                onget=\"return this.popup.getAttribute('norolluponanchor') == 'true'\"/>\n\n      <!-- This is the maximum number of drop-down rows we get when we\n            hit the drop marker beside fields that have it (like the URLbar).-->\n      <field name=\"maxDropMarkerRows\" readonly=\"true\">14</field>\n\n      <method name=\"getSearchAt\">\n        <parameter name=\"aIndex\"/>\n        <body><![CDATA[\n          this.initSearchNames();\n          return this.mSearchNames[aIndex];\n        ]]></body>\n      </method>\n\n      <method name=\"setTextValueWithReason\">\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aReason\"/>\n        <body><![CDATA[\n          if (aReason == Ci.nsIAutoCompleteInput\n                           .TEXTVALUE_REASON_COMPLETEDEFAULT) {\n            this._textValueSetByCompleteDefault = true;\n          }\n          this.textValue = aValue;\n          this._textValueSetByCompleteDefault = false;\n        ]]></body>\n      </method>\n\n      <property name=\"textValue\">\n        <getter><![CDATA[\n          if (typeof this.onBeforeTextValueGet == \"function\") {\n            let result = this.onBeforeTextValueGet();\n            if (result) {\n              return result.value;\n            }\n          }\n          return this.value;\n        ]]></getter>\n        <setter><![CDATA[\n          if (typeof this.onBeforeTextValueSet == \"function\" &&\n              !this._textValueSetByCompleteDefault) {\n            val = this.onBeforeTextValueSet(val);\n          }\n\n          this.value = val;\n\n          // Completing a result should simulate the user typing the result, so\n          // fire an input event.\n          let evt = document.createEvent(\"UIEvents\");\n          evt.initUIEvent(\"input\", true, false, window, 0);\n          this.mIgnoreInput = true;\n          this.dispatchEvent(evt);\n          this.mIgnoreInput = false;\n\n          return this.value;\n        ]]></setter>\n      </property>\n\n      <method name=\"selectTextRange\">\n        <parameter name=\"aStartIndex\"/>\n        <parameter name=\"aEndIndex\"/>\n        <body><![CDATA[\n          this.inputField.setSelectionRange(aStartIndex, aEndIndex);\n        ]]></body>\n      </method>\n\n      <method name=\"onSearchBegin\">\n        <body><![CDATA[\n          if (this.popup && typeof this.popup.onSearchBegin == \"function\")\n            this.popup.onSearchBegin();\n          if (this._searchBeginHandler)\n            this._searchBeginHandler();\n        ]]></body>\n      </method>\n\n      <method name=\"onSearchComplete\">\n        <body><![CDATA[\n          if (this.mController.matchCount == 0)\n            this.setAttribute(\"nomatch\", \"true\");\n          else\n            this.removeAttribute(\"nomatch\");\n\n          if (this.ignoreBlurWhileSearching && !this.focused) {\n            this.handleEnter();\n            this.detachController();\n          }\n\n          if (this._searchCompleteHandler)\n            this._searchCompleteHandler();\n        ]]></body>\n      </method>\n\n      <method name=\"onTextEntered\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          let rv = false;\n          if (this._textEnteredHandler) {\n            rv = this._textEnteredHandler(event);\n          }\n          return rv;\n        ]]></body>\n      </method>\n\n      <method name=\"onTextReverted\">\n        <body><![CDATA[\n          if (this._textRevertedHandler)\n            return this._textRevertedHandler();\n          return false;\n        ]]></body>\n      </method>\n\n      <!-- =================== nsIDOMXULMenuListElement =================== -->\n\n      <property name=\"editable\" readonly=\"true\"\n                onget=\"return true;\" />\n\n      <property name=\"crop\"\n                onset=\"this.setAttribute('crop',val); return val;\"\n                onget=\"return this.getAttribute('crop');\"/>\n\n      <property name=\"open\"\n                onget=\"return this.getAttribute('open') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.showHistoryPopup();\n          else\n            this.closePopup();\n        ]]></setter>\n      </property>\n\n      <!-- =================== PUBLIC MEMBERS =================== -->\n\n      <field name=\"valueIsTyped\">false</field>\n      <field name=\"_textValueSetByCompleteDefault\">false</field>\n      <property name=\"value\">\n        <getter><![CDATA[\n          if (typeof this.onBeforeValueGet == \"function\") {\n            var result = this.onBeforeValueGet();\n            if (result)\n              return result.value;\n          }\n          return this.inputField.value;\n        ]]></getter>\n        <setter><![CDATA[\n          this.mIgnoreInput = true;\n\n          if (typeof this.onBeforeValueSet == \"function\")\n            val = this.onBeforeValueSet(val);\n\n          if (typeof this.trimValue == \"function\" &&\n              !this._textValueSetByCompleteDefault)\n            val = this.trimValue(val);\n\n          this.valueIsTyped = false;\n          this.inputField.value = val;\n\n          if (typeof this.formatValue == \"function\")\n            this.formatValue();\n\n          this.mIgnoreInput = false;\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"ValueChange\", true, true);\n          this.inputField.dispatchEvent(event);\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"focused\" readonly=\"true\"\n                onget=\"return this.getAttribute('focused') == 'true';\"/>\n\n      <!-- maximum number of rows to display at a time -->\n      <property name=\"maxRows\"\n                onset=\"this.setAttribute('maxrows', val); return val;\"\n                onget=\"return parseInt(this.getAttribute('maxrows')) || 0;\"/>\n\n      <!-- option to allow scrolling through the list via the tab key, rather than\n           tab moving focus out of the textbox -->\n      <property name=\"tabScrolling\"\n                onset=\"this.setAttribute('tabscrolling', val); return val;\"\n                onget=\"return this.getAttribute('tabscrolling') == 'true';\"/>\n\n      <!-- option to completely ignore any blur events while searches are\n           still going on. -->\n      <property name=\"ignoreBlurWhileSearching\"\n                onset=\"this.setAttribute('ignoreblurwhilesearching', val); return val;\"\n                onget=\"return this.getAttribute('ignoreblurwhilesearching') == 'true';\"/>\n\n      <!-- disable key navigation handling in the popup results -->\n      <property name=\"disableKeyNavigation\"\n                onset=\"this.setAttribute('disablekeynavigation', val); return val;\"\n                onget=\"return this.getAttribute('disablekeynavigation') == 'true';\"/>\n\n      <!-- option to highlight entries that don't have any matches -->\n      <property name=\"highlightNonMatches\"\n                onset=\"this.setAttribute('highlightnonmatches', val); return val;\"\n                onget=\"return this.getAttribute('highlightnonmatches') == 'true';\"/>\n\n      <!-- =================== PRIVATE MEMBERS =================== -->\n\n      <!-- ::::::::::::: autocomplete controller ::::::::::::: -->\n\n      <method name=\"attachController\">\n        <body><![CDATA[\n          this.mController.input = this;\n        ]]></body>\n      </method>\n\n      <method name=\"detachController\">\n        <body><![CDATA[\n          if (this.mController.input == this)\n            this.mController.input = null;\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: popup opening ::::::::::::: -->\n\n      <method name=\"openPopup\">\n        <body><![CDATA[\n          if (this.focused)\n            this.popup.openAutocompletePopup(this, this);\n        ]]></body>\n      </method>\n\n      <method name=\"closePopup\">\n        <body><![CDATA[\n          this.popup.closePopup();\n        ]]></body>\n      </method>\n\n      <method name=\"showHistoryPopup\">\n        <body><![CDATA[\n          // Store our \"normal\" maxRows on the popup, so that it can reset the\n          // value when the popup is hidden.\n          this.popup._normalMaxRows = this.maxRows;\n\n          // Increase our maxRows temporarily, since we want the dropdown to\n          // be bigger in this case. The popup's popupshowing/popuphiding\n          // handlers will take care of resetting this.\n          this.maxRows = this.maxDropMarkerRows;\n\n          // Ensure that we have focus.\n          if (!this.focused)\n            this.focus();\n          this.attachController();\n          this.mController.startSearch(\"\");\n        ]]></body>\n      </method>\n\n      <method name=\"toggleHistoryPopup\">\n        <body><![CDATA[\n          if (!this.popup.popupOpen)\n            this.showHistoryPopup();\n          else\n            this.closePopup();\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: event dispatching ::::::::::::: -->\n\n      <method name=\"initEventHandler\">\n        <parameter name=\"aEventType\"/>\n        <body><![CDATA[\n          let handlerString = this.getAttribute(\"on\" + aEventType);\n          if (handlerString) {\n            return (new Function(\"eventType\", \"param\", handlerString)).bind(this, aEventType);\n          }\n          return null;\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: key handling ::::::::::::: -->\n\n      <field name=\"_selectionDetails\">null</field>\n      <method name=\"onKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          return this.handleKeyPress(aEvent);\n        ]]></body>\n      </method>\n\n      <method name=\"handleKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.target.localName != \"textbox\")\n            return true; // Let child buttons of autocomplete take input\n\n          // Re: urlbarDeferred, see the comment in urlbarBindings.xml.\n          if (aEvent.defaultPrevented && !aEvent.urlbarDeferred) {\n            return false;\n          }\n\n          const isMac = /Mac/.test(navigator.platform);\n          var cancel = false;\n\n          // Catch any keys that could potentially move the caret. Ctrl can be\n          // used in combination with these keys on Windows and Linux; and Alt\n          // can be used on OS X, so make sure the unused one isn't used.\n          let metaKey = isMac ? aEvent.ctrlKey : aEvent.altKey;\n          if (!this.disableKeyNavigation && !metaKey) {\n            switch (aEvent.keyCode) {\n              case KeyEvent.DOM_VK_LEFT:\n              case KeyEvent.DOM_VK_RIGHT:\n              case KeyEvent.DOM_VK_HOME:\n                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);\n                break;\n            }\n          }\n\n          // Handle keys that are not part of a keyboard shortcut (no Ctrl or Alt)\n          if (!this.disableKeyNavigation && !aEvent.ctrlKey && !aEvent.altKey) {\n            switch (aEvent.keyCode) {\n              case KeyEvent.DOM_VK_TAB:\n                if (this.tabScrolling && this.popup.popupOpen)\n                  cancel = this.mController.handleKeyNavigation(aEvent.shiftKey ?\n                                                                KeyEvent.DOM_VK_UP :\n                                                                KeyEvent.DOM_VK_DOWN);\n                else if (this.forceComplete && this.mController.matchCount >= 1)\n                  this.mController.handleTab();\n                break;\n              case KeyEvent.DOM_VK_UP:\n              case KeyEvent.DOM_VK_DOWN:\n              case KeyEvent.DOM_VK_PAGE_UP:\n              case KeyEvent.DOM_VK_PAGE_DOWN:\n                cancel = this.mController.handleKeyNavigation(aEvent.keyCode);\n                break;\n            }\n          }\n\n          // Handle readline/emacs-style navigation bindings on Mac.\n          if (isMac &&\n              !this.disableKeyNavigation &&\n              this.popup.popupOpen &&\n              aEvent.ctrlKey &&\n              (aEvent.key === \"n\" || aEvent.key === \"p\")) {\n\n            const effectiveKey = (aEvent.key === \"p\") ?\n                                 KeyEvent.DOM_VK_UP :\n                                 KeyEvent.DOM_VK_DOWN;\n            cancel = this.mController.handleKeyNavigation(effectiveKey);\n          }\n\n          // Handle keys we know aren't part of a shortcut, even with Alt or\n          // Ctrl.\n          switch (aEvent.keyCode) {\n            case KeyEvent.DOM_VK_ESCAPE:\n              cancel = this.mController.handleEscape();\n              break;\n            case KeyEvent.DOM_VK_RETURN:\n              if (isMac) {\n                // Prevent the default action, since it will beep on Mac\n                if (aEvent.metaKey)\n                  aEvent.preventDefault();\n              }\n              if (this.popup.selectedIndex >= 0) {\n                this._selectionDetails = {\n                  index: this.popup.selectedIndex,\n                  kind: \"key\",\n                };\n              }\n              cancel = this.handleEnter(aEvent);\n              break;\n            case KeyEvent.DOM_VK_DELETE:\n              if (isMac && !aEvent.shiftKey) {\n                break;\n              }\n              cancel = this.handleDelete();\n              break;\n            case KeyEvent.DOM_VK_BACK_SPACE:\n              if (isMac && aEvent.shiftKey) {\n                cancel = this.handleDelete();\n              }\n              break;\n            case KeyEvent.DOM_VK_DOWN:\n            case KeyEvent.DOM_VK_UP:\n              if (aEvent.altKey)\n                this.toggleHistoryPopup();\n              break;\n            case KeyEvent.DOM_VK_F4:\n              if (!isMac) {\n                this.toggleHistoryPopup();\n              }\n              break;\n          }\n\n          if (cancel) {\n            aEvent.stopPropagation();\n            aEvent.preventDefault();\n          }\n\n          return true;\n        ]]></body>\n      </method>\n\n      <method name=\"handleEnter\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          return this.mController.handleEnter(false, event || null);\n        ]]></body>\n      </method>\n\n      <method name=\"handleDelete\">\n        <body><![CDATA[\n          return this.mController.handleDelete();\n        ]]></body>\n      </method>\n\n      <!-- ::::::::::::: miscellaneous ::::::::::::: -->\n\n      <method name=\"initSearchNames\">\n        <body><![CDATA[\n          if (!this.mSearchNames) {\n            var names = this.getAttribute(\"autocompletesearch\");\n            if (!names)\n              this.mSearchNames = [];\n            else\n              this.mSearchNames = names.split(\" \");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_focus\">\n        <!-- doesn't reset this.mController -->\n        <body><![CDATA[\n          this._dontBlur = true;\n          this.focus();\n          this._dontBlur = false;\n        ]]></body>\n      </method>\n\n      <method name=\"resetActionType\">\n        <body><![CDATA[\n          if (this.mIgnoreInput)\n            return;\n          this.removeAttribute(\"actiontype\");\n        ]]></body>\n      </method>\n\n      <field name=\"_valueIsPasted\">false</field>\n      <field name=\"_pasteController\"><![CDATA[\n        ({\n          _autocomplete: this,\n          _kGlobalClipboard: Ci.nsIClipboard.kGlobalClipboard,\n          supportsCommand: aCommand => aCommand == \"cmd_paste\",\n          doCommand(aCommand) {\n            this._autocomplete._valueIsPasted = true;\n            this._autocomplete.editor.paste(this._kGlobalClipboard);\n            this._autocomplete._valueIsPasted = false;\n          },\n          isCommandEnabled(aCommand) {\n            return this._autocomplete.editor.isSelectionEditable &&\n                   this._autocomplete.editor.canPaste(this._kGlobalClipboard);\n          },\n          onEvent() {},\n        })\n      ]]></field>\n\n      <method name=\"onInput\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this.mIgnoreInput && this.mController.input == this) {\n            this.valueIsTyped = true;\n            this.mController.handleText();\n          }\n          this.resetActionType();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"input\"><![CDATA[\n        this.onInput(event);\n      ]]></handler>\n\n      <handler event=\"keypress\" phase=\"capturing\" group=\"system\"\n               action=\"return this.onKeyPress(event);\"/>\n\n      <handler event=\"compositionstart\" phase=\"capturing\"\n               action=\"if (this.mController.input == this) this.mController.handleStartComposition();\"/>\n\n      <handler event=\"compositionend\" phase=\"capturing\"\n               action=\"if (this.mController.input == this) this.mController.handleEndComposition();\"/>\n\n      <handler event=\"focus\" phase=\"capturing\"><![CDATA[\n        this.attachController();\n        if (window.gBrowser && window.gBrowser.selectedBrowser.hasAttribute(\"usercontextid\")) {\n          this.userContextId = parseInt(window.gBrowser.selectedBrowser.getAttribute(\"usercontextid\"));\n        } else {\n          this.userContextId = 0;\n        }\n      ]]></handler>\n\n      <handler event=\"blur\" phase=\"capturing\"><![CDATA[\n        if (!this._dontBlur) {\n          if (this.forceComplete && this.mController.matchCount >= 1) {\n            // If forceComplete is requested, we need to call the enter processing\n            // on blur so the input will be forced to the closest match.\n            // Thunderbird is the only consumer of forceComplete and this is used\n            // to force an recipient's email to the exact address book entry.\n            this.mController.handleEnter(true);\n          }\n          if (!this.ignoreBlurWhileSearching)\n            this.detachController();\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autocomplete-rich-result-popup\" extends=\"chrome://global/content/bindings/popup.xml#popup\">\n    <content ignorekeys=\"true\" level=\"top\" consumeoutsideclicks=\"never\">\n      <xul:richlistbox anonid=\"richlistbox\" class=\"autocomplete-richlistbox\" flex=\"1\"/>\n      <xul:hbox>\n        <children/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIAutoCompletePopup\">\n      <field name=\"mInput\">null</field>\n      <field name=\"mPopupOpen\">false</field>\n      <field name=\"_currentIndex\">0</field>\n\n      <!-- =================== nsIAutoCompletePopup =================== -->\n\n      <property name=\"input\" readonly=\"true\"\n                onget=\"return this.mInput\"/>\n\n      <property name=\"overrideValue\" readonly=\"true\"\n                onget=\"return null;\"/>\n\n      <property name=\"popupOpen\" readonly=\"true\"\n                onget=\"return this.mPopupOpen;\"/>\n\n      <method name=\"closePopup\">\n        <body>\n          <![CDATA[\n          if (this.mPopupOpen) {\n            this.hidePopup();\n            this.removeAttribute(\"width\");\n          }\n        ]]>\n        </body>\n      </method>\n\n      <!-- This is the default number of rows that we give the autocomplete\n           popup when the textbox doesn't have a \"maxrows\" attribute\n           for us to use. -->\n      <field name=\"defaultMaxRows\" readonly=\"true\">6</field>\n\n      <!-- In some cases (e.g. when the input's dropmarker button is clicked),\n           the input wants to display a popup with more rows. In that case, it\n           should increase its maxRows property and store the \"normal\" maxRows\n           in this field. When the popup is hidden, we restore the input's\n           maxRows to the value stored in this field.\n\n           This field is set to -1 between uses so that we can tell when it's\n           been set by the input and when we need to set it in the popupshowing\n           handler. -->\n      <field name=\"_normalMaxRows\">-1</field>\n\n      <property name=\"maxRows\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n          return (this.mInput && this.mInput.maxRows) || this.defaultMaxRows;\n        ]]>\n        </getter>\n      </property>\n\n      <method name=\"getNextIndex\">\n        <parameter name=\"aReverse\"/>\n        <parameter name=\"aAmount\"/>\n        <parameter name=\"aIndex\"/>\n        <parameter name=\"aMaxRow\"/>\n        <body><![CDATA[\n          if (aMaxRow < 0)\n            return -1;\n\n          var newIdx = aIndex + (aReverse ? -1 : 1) * aAmount;\n          if (aReverse && aIndex == -1 || newIdx > aMaxRow && aIndex != aMaxRow)\n            newIdx = aMaxRow;\n          else if (!aReverse && aIndex == -1 || newIdx < 0 && aIndex != 0)\n            newIdx = 0;\n\n          if (newIdx < 0 && aIndex == 0 || newIdx > aMaxRow && aIndex == aMaxRow)\n            aIndex = -1;\n          else\n            aIndex = newIdx;\n\n          return aIndex;\n        ]]></body>\n      </method>\n\n      <method name=\"onPopupClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          this.input.controller.handleEnter(true, aEvent);\n        ]]></body>\n      </method>\n\n      <property name=\"selectedIndex\"\n                onget=\"return this.richlistbox.selectedIndex;\">\n        <setter>\n          <![CDATA[\n          if (val != this.richlistbox.selectedIndex) {\n            this._previousSelectedIndex = this.richlistbox.selectedIndex;\n          }\n          this.richlistbox.selectedIndex = val;\n          // Since ensureElementIsVisible may cause an expensive Layout flush,\n          // invoke it only if there may be a scrollbar, so if we could fetch\n          // more results than we can show at once.\n          // maxResults is the maximum number of fetched results, maxRows is the\n          // maximum number of rows we show at once, without a scrollbar.\n          if (this.mPopupOpen && this.maxResults > this.maxRows) {\n            // when clearing the selection (val == -1, so selectedItem will be\n            // null), we want to scroll back to the top.  see bug #406194\n            this.richlistbox.ensureElementIsVisible(\n              this.richlistbox.selectedItem || this.richlistbox.firstElementChild);\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <field name=\"_previousSelectedIndex\">-1</field>\n\n      <method name=\"onSearchBegin\">\n        <body><![CDATA[\n          this.richlistbox.mousedOverIndex = -1;\n\n          if (typeof this._onSearchBegin == \"function\") {\n            this._onSearchBegin();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          // until we have \"baseBinding\", (see bug #373652) this allows\n          // us to override openAutocompletePopup(), but still call\n          // the method on the base class\n          this._openAutocompletePopup(aInput, aElement);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_openAutocompletePopup\">\n        <parameter name=\"aInput\"/>\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n          if (!this.mPopupOpen) {\n            // It's possible that the panel is hidden initially\n            // to avoid impacting startup / new window performance\n            aInput.popup.hidden = false;\n\n            this.mInput = aInput;\n            // clear any previous selection, see bugs 400671 and 488357\n            this.selectedIndex = -1;\n\n            var width = aElement.getBoundingClientRect().width;\n            this.setAttribute(\"width\", width > 100 ? width : 100);\n            // invalidate() depends on the width attribute\n            this._invalidate();\n\n            this.openPopup(aElement, \"after_start\", 0, 0, false, false);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"invalidate\">\n        <parameter name=\"reason\"/>\n        <body>\n          <![CDATA[\n          // Don't bother doing work if we're not even showing\n          if (!this.mPopupOpen)\n            return;\n\n          this._invalidate(reason);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_invalidate\">\n        <parameter name=\"reason\"/>\n        <body>\n          <![CDATA[\n          // collapsed if no matches\n          this.richlistbox.collapsed = (this.matchCount == 0);\n\n          // Update the richlistbox height.\n          if (this._adjustHeightRAFToken) {\n            cancelAnimationFrame(this._adjustHeightRAFToken);\n            this._adjustHeightRAFToken = null;\n          }\n\n          if (this.mPopupOpen) {\n            delete this._adjustHeightOnPopupShown;\n            this._adjustHeightRAFToken = requestAnimationFrame(() => this.adjustHeight());\n          } else {\n            this._adjustHeightOnPopupShown = true;\n          }\n\n          this._currentIndex = 0;\n          if (this._appendResultTimeout) {\n            clearTimeout(this._appendResultTimeout);\n          }\n          this._appendCurrentResult(reason);\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"maxResults\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            // This is how many richlistitems will be kept around.\n            // Note, this getter may be overridden, or instances\n            // can have the nomaxresults attribute set to have no\n            // limit.\n            if (this.getAttribute(\"nomaxresults\") == \"true\") {\n              return Infinity;\n            }\n\n            return 20;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"matchCount\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n          return Math.min(this.mInput.controller.matchCount, this.maxResults);\n          ]]>\n        </getter>\n      </property>\n\n      <method name=\"_collapseUnusedItems\">\n        <body>\n          <![CDATA[\n            let existingItemsCount = this.richlistbox.children.length;\n            for (let i = this.matchCount; i < existingItemsCount; ++i) {\n              let item = this.richlistbox.children[i];\n\n              item.collapsed = true;\n              if (typeof item._onCollapse == \"function\") {\n                item._onCollapse();\n              }\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"adjustHeight\">\n        <body>\n          <![CDATA[\n          // Figure out how many rows to show\n          let rows = this.richlistbox.children;\n          let numRows = Math.min(this.matchCount, this.maxRows, rows.length);\n\n          // Default the height to 0 if we have no rows to show\n          let height = 0;\n          if (numRows) {\n            let firstRowRect = rows[0].getBoundingClientRect();\n            if (this._rlbPadding == undefined) {\n              let style = window.getComputedStyle(this.richlistbox);\n              let paddingTop = parseInt(style.paddingTop) || 0;\n              let paddingBottom = parseInt(style.paddingBottom) || 0;\n              this._rlbPadding = paddingTop + paddingBottom;\n            }\n\n            // The class `forceHandleUnderflow` is for the item might need to\n            // handle OverUnderflow or Overflow when the height of an item will\n            // be changed dynamically.\n            for (let i = 0; i < numRows; i++) {\n              if (rows[i].classList.contains(\"forceHandleUnderflow\")) {\n                rows[i].handleOverUnderflow();\n              }\n            }\n\n            let lastRowRect = rows[numRows - 1].getBoundingClientRect();\n            // Calculate the height to have the first row to last row shown\n            height = lastRowRect.bottom - firstRowRect.top +\n                     this._rlbPadding;\n          }\n\n          let currentHeight = this.richlistbox.getBoundingClientRect().height;\n          if (height <= currentHeight) {\n            this._collapseUnusedItems();\n          }\n          this.richlistbox.style.removeProperty(\"height\");\n          this.richlistbox.height = height;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_appendCurrentResult\">\n        <parameter name=\"invalidateReason\"/>\n        <body>\n          <![CDATA[\n          var controller = this.mInput.controller;\n          var matchCount = this.matchCount;\n          var existingItemsCount = this.richlistbox.children.length;\n\n          // Process maxRows per chunk to improve performance and user experience\n          for (let i = 0; i < this.maxRows; i++) {\n            if (this._currentIndex >= matchCount) {\n              break;\n            }\n            let item;\n            let reusable = false;\n            let itemExists = this._currentIndex < existingItemsCount;\n\n            let originalValue, originalText, originalType;\n            let style = controller.getStyleAt(this._currentIndex);\n            let value =\n              style && style.includes(\"autofill\") ?\n              controller.getFinalCompleteValueAt(this._currentIndex) :\n              controller.getValueAt(this._currentIndex);\n            let label = controller.getLabelAt(this._currentIndex);\n            let comment = controller.getCommentAt(this._currentIndex);\n            let image = controller.getImageAt(this._currentIndex);\n            // trim the leading/trailing whitespace\n            let trimmedSearchString = controller.searchString.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n\n            if (itemExists) {\n              item = this.richlistbox.children[this._currentIndex];\n\n              // Url may be a modified version of value, see _adjustAcItem().\n              originalValue = item.getAttribute(\"url\") || item.getAttribute(\"ac-value\");\n              originalText = item.getAttribute(\"ac-text\");\n              originalType = item.getAttribute(\"originaltype\");\n\n              // The styles on the list which have different <content> structure and overrided\n              // _adjustAcItem() are unreusable.\n              const UNREUSEABLE_STYLES = [\n                \"autofill-profile\",\n                \"autofill-footer\",\n                \"autofill-clear-button\",\n                \"autofill-insecureWarning\",\n              ];\n              // Reuse the item when its style is exactly equal to the previous style or\n              // neither of their style are in the UNREUSEABLE_STYLES.\n              reusable = originalType === style ||\n                !(UNREUSEABLE_STYLES.includes(style) || UNREUSEABLE_STYLES.includes(originalType));\n\n            } else {\n              // need to create a new item\n              item = document.createXULElement(\"richlistitem\");\n            }\n\n            item.setAttribute(\"dir\", this.style.direction);\n            item.setAttribute(\"ac-image\", image);\n            item.setAttribute(\"ac-value\", value);\n            item.setAttribute(\"ac-label\", label);\n            item.setAttribute(\"ac-comment\", comment);\n            item.setAttribute(\"ac-text\", trimmedSearchString);\n\n            // Completely reuse the existing richlistitem for invalidation\n            // due to new results, but only when: the item is the same, *OR*\n            // we are about to replace the currently moused-over item, to\n            // avoid surprising the user.\n            let iface = Ci.nsIAutoCompletePopup;\n            if (reusable &&\n                originalText == trimmedSearchString &&\n                invalidateReason == iface.INVALIDATE_REASON_NEW_RESULT &&\n                (originalValue == value ||\n                 this.richlistbox.mousedOverIndex === this._currentIndex)) {\n\n              // try to re-use the existing item\n              let reused = item._reuseAcItem();\n              if (reused) {\n                this._currentIndex++;\n                continue;\n              }\n            } else {\n              if (typeof item._cleanup == \"function\") {\n                item._cleanup();\n              }\n              item.setAttribute(\"originaltype\", style);\n            }\n\n            if (itemExists) {\n              // Adjust only when the result's type is reusable for existing\n              // item's. Otherwise, we might insensibly call old _adjustAcItem()\n              // as new binding has not been attached yet.\n              // We don't need to worry about switching to new binding, since\n              // _adjustAcItem() will fired by its own constructor accordingly.\n              if (reusable) {\n                item._adjustAcItem();\n              }\n              item.collapsed = false;\n            } else {\n              // set the class at the end so we can use the attributes\n              // in the xbl constructor\n              item.className = \"autocomplete-richlistitem\";\n              this.richlistbox.appendChild(item);\n            }\n\n            this._currentIndex++;\n          }\n\n          if (typeof this.onResultsAdded == \"function\")\n            this.onResultsAdded();\n\n          if (this._currentIndex < matchCount) {\n            // yield after each batch of items so that typing the url bar is\n            // responsive\n            this._appendResultTimeout = setTimeout(() => this._appendCurrentResult(), 0);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"overflowPadding\"\n                onget=\"return Number(this.getAttribute('overflowpadding'))\"\n                readonly=\"true\" />\n\n      <method name=\"selectBy\">\n        <parameter name=\"aReverse\"/>\n        <parameter name=\"aPage\"/>\n        <body>\n          <![CDATA[\n          try {\n            var amount = aPage ? 5 : 1;\n\n            // because we collapsed unused items, we can't use this.richlistbox.getRowCount(), we need to use the matchCount\n            this.selectedIndex = this.getNextIndex(aReverse, amount, this.selectedIndex, this.matchCount - 1);\n            if (this.selectedIndex == -1) {\n              this.input._focus();\n            }\n          } catch (ex) {\n            // do nothing - occasionally timer-related js errors happen here\n            // e.g. \"this.selectedIndex has no properties\", when you type fast and hit a\n            // navigation key before this popup has opened\n          }\n            ]]>\n        </body>\n      </method>\n\n      <field name=\"richlistbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"richlistbox\");\n      </field>\n\n      <property name=\"view\"\n                onget=\"return this.mInput.controller;\"\n                onset=\"return val;\"/>\n\n    </implementation>\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // If normalMaxRows wasn't already set by the input, then set it here\n        // so that we restore the correct number when the popup is hidden.\n\n        // Null-check this.mInput; see bug 1017914\n        if (this._normalMaxRows < 0 && this.mInput) {\n          this._normalMaxRows = this.mInput.maxRows;\n        }\n\n        // Set an attribute for styling the popup based on the input.\n        let inputID = \"\";\n        if (this.mInput && this.mInput.ownerDocument &&\n            this.mInput.ownerDocument.documentURIObject.schemeIs(\"chrome\")) {\n          inputID = this.mInput.id;\n          // Take care of elements with no id that are inside xbl bindings\n          if (!inputID) {\n            let bindingParent = this.mInput.ownerDocument.getBindingParent(this.mInput);\n            if (bindingParent) {\n              inputID = bindingParent.id;\n            }\n          }\n        }\n        this.setAttribute(\"autocompleteinput\", inputID);\n\n        this.mPopupOpen = true;\n      ]]></handler>\n\n      <handler event=\"popupshown\">\n        <![CDATA[\n          if (this._adjustHeightOnPopupShown) {\n            delete this._adjustHeightOnPopupShown;\n            this.adjustHeight();\n          }\n      ]]>\n      </handler>\n\n      <handler event=\"popuphiding\"><![CDATA[\n        var isListActive = true;\n        if (this.selectedIndex == -1)\n          isListActive = false;\n        this.input.controller.stopSearch();\n\n        this.removeAttribute(\"autocompleteinput\");\n        this.mPopupOpen = false;\n\n        // Reset the maxRows property to the cached \"normal\" value (if there's\n        // any), and reset normalMaxRows so that we can detect whether it was set\n        // by the input when the popupshowing handler runs.\n\n        // Null-check this.mInput; see bug 1017914\n        if (this.mInput && this._normalMaxRows > 0) {\n          this.mInput.maxRows = this._normalMaxRows;\n        }\n        this._normalMaxRows = -1;\n        // If the list was being navigated and then closed, make sure\n        // we fire accessible focus event back to textbox\n\n        // Null-check this.mInput; see bug 1017914\n        if (isListActive && this.mInput) {\n          this.mInput.mIgnoreFocus = true;\n          this.mInput._focus();\n          this.mInput.mIgnoreFocus = false;\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autocomplete-richlistitem-insecure-field\" extends=\"chrome://global/content/bindings/autocomplete.xml#autocomplete-richlistitem\">\n    <content align=\"center\"\n             onoverflow=\"this._onOverflow();\"\n             onunderflow=\"this._onUnderflow();\">\n      <xul:image anonid=\"type-icon\"\n                 class=\"ac-type-icon\"\n                 xbl:inherits=\"selected,current,type\"/>\n      <xul:image anonid=\"site-icon\"\n                 class=\"ac-site-icon\"\n                 xbl:inherits=\"src=image,selected,type\"/>\n      <xul:vbox class=\"ac-title\"\n                align=\"left\"\n                xbl:inherits=\"\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"title-text\"\n                           class=\"ac-title-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:vbox>\n      <xul:hbox anonid=\"tags\"\n                class=\"ac-tags\"\n                align=\"center\"\n                xbl:inherits=\"selected\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"tags-text\"\n                           class=\"ac-tags-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox anonid=\"separator\"\n                class=\"ac-separator\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype,type\">\n        <xul:description class=\"ac-separator-text\">—</xul:description>\n      </xul:hbox>\n      <xul:hbox class=\"ac-url\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"url-text\"\n                           class=\"ac-url-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox class=\"ac-action\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"action-text\"\n                           class=\"ac-action-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n    </content>\n\n    <handlers>\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        let baseURL = Services.urlFormatter.formatURLPref(\"app.support.baseURL\");\n        window.openTrustedLinkIn(baseURL + \"insecure-password\", \"tab\", {\n          relatedToCurrent: true,\n        });\n      ]]></handler>\n    </handlers>\n\n    <implementation>\n      <constructor><![CDATA[\n        // Unlike other autocomplete items, the height of the insecure warning\n        // increases by wrapping. So \"forceHandleUnderflow\" is for container to\n        // recalculate an item's height and width.\n        this.classList.add(\"forceHandleUnderflow\");\n      ]]></constructor>\n\n      <property name=\"_learnMoreString\">\n        <getter><![CDATA[\n          if (!this.__learnMoreString) {\n            this.__learnMoreString =\n              Services.strings.createBundle(\"chrome://passwordmgr/locale/passwordmgr.properties\").\n              GetStringFromName(\"insecureFieldWarningLearnMore\");\n          }\n          return this.__learnMoreString;\n        ]]></getter>\n      </property>\n\n      <!-- Override _getSearchTokens to have the Learn More text emphasized -->\n      <method name=\"_getSearchTokens\">\n        <parameter name=\"aSearch\"/>\n        <body>\n          <![CDATA[\n            return [this._learnMoreString.toLowerCase()];\n          ]]>\n        </body>\n      </method>\n\n    </implementation>\n  </binding>\n\n  <binding id=\"autocomplete-richlistitem\" extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n\n    <content align=\"center\"\n             onoverflow=\"this._onOverflow();\"\n             onunderflow=\"this._onUnderflow();\">\n      <xul:image anonid=\"type-icon\"\n                 class=\"ac-type-icon\"\n                 xbl:inherits=\"selected,current,type\"/>\n      <xul:image anonid=\"site-icon\"\n                 class=\"ac-site-icon\"\n                 xbl:inherits=\"src=image,selected,type\"/>\n      <xul:hbox class=\"ac-title\"\n                align=\"center\"\n                xbl:inherits=\"selected\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"title-text\"\n                           class=\"ac-title-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox anonid=\"tags\"\n                class=\"ac-tags\"\n                align=\"center\"\n                xbl:inherits=\"selected\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"tags-text\"\n                           class=\"ac-tags-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox anonid=\"separator\"\n                class=\"ac-separator\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype,type\">\n        <xul:description class=\"ac-separator-text\">—</xul:description>\n      </xul:hbox>\n      <xul:hbox class=\"ac-url\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"url-text\"\n                           class=\"ac-url-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n      <xul:hbox class=\"ac-action\"\n                align=\"center\"\n                xbl:inherits=\"selected,actiontype\">\n        <xul:description class=\"ac-text-overflow-container\">\n          <xul:description anonid=\"action-text\"\n                           class=\"ac-action-text\"\n                           xbl:inherits=\"selected\"/>\n        </xul:description>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n        <![CDATA[\n          this._typeIcon = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"type-icon\"\n          );\n          this._siteIcon = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"site-icon\"\n          );\n          this._titleText = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"title-text\"\n          );\n          this._tags = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"tags\"\n          );\n          this._tagsText = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"tags-text\"\n          );\n          this._separator = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"separator\"\n          );\n          this._urlText = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"url-text\"\n          );\n          this._actionText = document.getAnonymousElementByAttribute(\n            this, \"anonid\", \"action-text\"\n          );\n          this._adjustAcItem();\n        ]]>\n      </constructor>\n\n      <method name=\"_cleanup\">\n        <body>\n        <![CDATA[\n          this.removeAttribute(\"url\");\n          this.removeAttribute(\"image\");\n          this.removeAttribute(\"title\");\n          this.removeAttribute(\"text\");\n          this.removeAttribute(\"displayurl\");\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"label\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            // This property is a string that is read aloud by screen readers,\n            // so it must not contain anything that should not be user-facing.\n\n            let parts = [\n              this.getAttribute(\"title\"),\n              this.getAttribute(\"displayurl\"),\n            ];\n            let label = parts.filter(str => str).join(\" \");\n\n            // allow consumers that have extended popups to override\n            // the label values for the richlistitems\n            let panel = this.parentNode.parentNode;\n            if (panel.createResultLabel) {\n              return panel.createResultLabel(this, label);\n            }\n\n            return label;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"_stringBundle\">\n        <getter><![CDATA[\n          if (!this.__stringBundle) {\n            this.__stringBundle = Services.strings.createBundle(\"chrome://global/locale/autocomplete.properties\");\n          }\n          return this.__stringBundle;\n        ]]></getter>\n      </property>\n\n      <field name=\"_boundaryCutoff\">null</field>\n\n      <property name=\"boundaryCutoff\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n          if (!this._boundaryCutoff) {\n            this._boundaryCutoff =\n              Cc[\"@mozilla.org/preferences-service;1\"].\n              getService(Ci.nsIPrefBranch).\n              getIntPref(\"toolkit.autocomplete.richBoundaryCutoff\");\n          }\n          return this._boundaryCutoff;\n          ]]>\n        </getter>\n      </property>\n\n      <field name=\"_inOverflow\">false</field>\n\n      <method name=\"_onOverflow\">\n        <body>\n          <![CDATA[\n          this._inOverflow = true;\n          this._handleOverflow();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_onUnderflow\">\n        <body>\n          <![CDATA[\n          this._inOverflow = false;\n          this._handleOverflow();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_getBoundaryIndices\">\n        <parameter name=\"aText\"/>\n        <parameter name=\"aSearchTokens\"/>\n        <body>\n          <![CDATA[\n          // Short circuit for empty search ([\"\"] == \"\")\n          if (aSearchTokens == \"\")\n            return [0, aText.length];\n\n          // Find which regions of text match the search terms\n          let regions = [];\n          for (let search of Array.prototype.slice.call(aSearchTokens)) {\n            let matchIndex = -1;\n            let searchLen = search.length;\n\n            // Find all matches of the search terms, but stop early for perf\n            let lowerText = aText.substr(0, this.boundaryCutoff).toLowerCase();\n            while ((matchIndex = lowerText.indexOf(search, matchIndex + 1)) >= 0) {\n              regions.push([matchIndex, matchIndex + searchLen]);\n            }\n          }\n\n          // Sort the regions by start position then end position\n          regions = regions.sort((a, b) => {\n            let start = a[0] - b[0];\n            return (start == 0) ? a[1] - b[1] : start;\n          });\n\n          // Generate the boundary indices from each region\n          let start = 0;\n          let end = 0;\n          let boundaries = [];\n          let len = regions.length;\n          for (let i = 0; i < len; i++) {\n            // We have a new boundary if the start of the next is past the end\n            let region = regions[i];\n            if (region[0] > end) {\n              // First index is the beginning of match\n              boundaries.push(start);\n              // Second index is the beginning of non-match\n              boundaries.push(end);\n\n              // Track the new region now that we've stored the previous one\n              start = region[0];\n            }\n\n            // Push back the end index for the current or new region\n            end = Math.max(end, region[1]);\n          }\n\n          // Add the last region\n          boundaries.push(start);\n          boundaries.push(end);\n\n          // Put on the end boundary if necessary\n          if (end < aText.length)\n            boundaries.push(aText.length);\n\n          // Skip the first item because it's always 0\n          return boundaries.slice(1);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_getSearchTokens\">\n        <parameter name=\"aSearch\"/>\n        <body>\n          <![CDATA[\n          let search = aSearch.toLowerCase();\n          return search.split(/\\s+/);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_setUpDescription\">\n        <parameter name=\"aDescriptionElement\"/>\n        <parameter name=\"aText\"/>\n        <parameter name=\"aNoEmphasis\"/>\n        <body>\n          <![CDATA[\n          // Get rid of all previous text\n          if (!aDescriptionElement) {\n            return;\n          }\n          while (aDescriptionElement.hasChildNodes())\n            aDescriptionElement.firstChild.remove();\n\n          // If aNoEmphasis is specified, don't add any emphasis\n          if (aNoEmphasis) {\n            aDescriptionElement.appendChild(document.createTextNode(aText));\n            return;\n          }\n\n          // Get the indices that separate match and non-match text\n          let search = this.getAttribute(\"text\");\n          let tokens = this._getSearchTokens(search);\n          let indices = this._getBoundaryIndices(aText, tokens);\n\n          this._appendDescriptionSpans(indices, aText, aDescriptionElement,\n                                       aDescriptionElement);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_appendDescriptionSpans\">\n        <parameter name=\"indices\"/>\n        <parameter name=\"text\"/>\n        <parameter name=\"spansParentElement\"/>\n        <parameter name=\"descriptionElement\"/>\n        <body>\n          <![CDATA[\n          let next;\n          let start = 0;\n          let len = indices.length;\n          // Even indexed boundaries are matches, so skip the 0th if it's empty\n          for (let i = indices[0] == 0 ? 1 : 0; i < len; i++) {\n            next = indices[i];\n            let spanText = text.substr(start, next - start);\n            start = next;\n\n            if (i % 2 == 0) {\n              // Emphasize the text for even indices\n              let span = spansParentElement.appendChild(\n                document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"span\"));\n              this._setUpEmphasisSpan(span, descriptionElement);\n              span.textContent = spanText;\n            } else {\n              // Otherwise, it's plain text\n              spansParentElement.appendChild(document.createTextNode(spanText));\n            }\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_setUpTags\">\n        <parameter name=\"tags\"/>\n        <body>\n          <![CDATA[\n          while (this._tagsText.hasChildNodes()) {\n            this._tagsText.firstChild.remove();\n          }\n\n          let anyTagsMatch = false;\n\n          // Include only tags that match the search string.\n          for (let tag of tags) {\n            // Check if the tag matches the search string.\n            let search = this.getAttribute(\"text\");\n            let tokens = this._getSearchTokens(search);\n            let indices = this._getBoundaryIndices(tag, tokens);\n\n            if (indices.length == 2 &&\n                indices[0] == 0 &&\n                indices[1] == tag.length) {\n              // The tag doesn't match the search string, so don't include it.\n              continue;\n            }\n\n            anyTagsMatch = true;\n\n            let tagSpan =\n              document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"span\");\n            tagSpan.classList.add(\"ac-tag\");\n            this._tagsText.appendChild(tagSpan);\n\n            this._appendDescriptionSpans(indices, tag, tagSpan, this._tagsText);\n          }\n\n          return anyTagsMatch;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_setUpEmphasisSpan\">\n        <parameter name=\"aSpan\"/>\n        <parameter name=\"aDescriptionElement\"/>\n        <body>\n          <![CDATA[\n          aSpan.classList.add(\"ac-emphasize-text\");\n          switch (aDescriptionElement) {\n            case this._titleText:\n              aSpan.classList.add(\"ac-emphasize-text-title\");\n              break;\n            case this._tagsText:\n              aSpan.classList.add(\"ac-emphasize-text-tag\");\n              break;\n            case this._urlText:\n              aSpan.classList.add(\"ac-emphasize-text-url\");\n              break;\n            case this._actionText:\n              aSpan.classList.add(\"ac-emphasize-text-action\");\n              break;\n          }\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        This will generate an array of emphasis pairs for use with\n        _setUpEmphasisedSections(). Each pair is a tuple (array) that\n        represents a block of text - containing the text of that block, and a\n        boolean for whether that block should have an emphasis styling applied\n        to it.\n\n        These pairs are generated by parsing a localised string (aSourceString)\n        with parameters, in the format that is used by\n        nsIStringBundle.formatStringFromName():\n\n          \"textA %1$S textB textC %2$S\"\n\n        Or:\n\n          \"textA %S\"\n\n        Where \"%1$S\", \"%2$S\", and \"%S\" are intended to be replaced by provided\n        replacement strings. These are specified an array of tuples\n        (aReplacements), each containing the replacement text and a boolean for\n        whether that text should have an emphasis styling applied. This is used\n        as a 1-based array - ie, \"%1$S\" is replaced by the item in the first\n        index of aReplacements, \"%2$S\" by the second, etc. \"%S\" will always\n        match the first index.\n      -->\n      <method name=\"_generateEmphasisPairs\">\n        <parameter name=\"aSourceString\"/>\n        <parameter name=\"aReplacements\"/>\n        <body>\n          <![CDATA[\n            let pairs = [];\n\n            // Split on %S, %1$S, %2$S, etc. ie:\n            //   \"textA %S\"\n            //     becomes [\"textA \", \"%S\"]\n            //   \"textA %1$S textB textC %2$S\"\n            //     becomes [\"textA \", \"%1$S\", \" textB textC \", \"%2$S\"]\n            let parts = aSourceString.split(/(%(?:[0-9]+\\$)?S)/);\n\n            for (let part of parts) {\n              // The above regex will actually give us an empty string at the\n              // end - we don't want that, as we don't want to later generate an\n              // empty text node for it.\n              if (part.length === 0)\n                continue;\n\n              // Determine if this token is a replacement token or a normal text\n              // token. If it is a replacement token, we want to extract the\n              // numerical number. However, we still want to match on \"$S\".\n              let match = part.match(/^%(?:([0-9]+)\\$)?S$/);\n\n              if (match) {\n                // \"%S\" doesn't have a numerical number in it, but will always\n                // be assumed to be 1. Furthermore, the input string specifies\n                // these with a 1-based index, but we want a 0-based index.\n                let index = (match[1] || 1) - 1;\n\n                if (index >= 0 && index < aReplacements.length) {\n                  pairs.push([...aReplacements[index]]);\n                }\n              } else {\n                pairs.push([part]);\n              }\n            }\n\n            return pairs;\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        _setUpEmphasisedSections() has the same use as _setUpDescription,\n        except instead of taking a string and highlighting given tokens, it takes\n        an array of pairs generated by _generateEmphasisPairs(). This allows\n        control over emphasising based on specific blocks of text, rather than\n        search for substrings.\n      -->\n      <method name=\"_setUpEmphasisedSections\">\n        <parameter name=\"aDescriptionElement\"/>\n        <parameter name=\"aTextPairs\"/>\n        <body>\n          <![CDATA[\n          // Get rid of all previous text\n          while (aDescriptionElement.hasChildNodes())\n            aDescriptionElement.firstChild.remove();\n\n          for (let [text, emphasise] of aTextPairs) {\n            if (emphasise) {\n              let span = aDescriptionElement.appendChild(\n                document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"span\"));\n              span.textContent = text;\n              switch (emphasise) {\n                case \"match\":\n                  this._setUpEmphasisSpan(span, aDescriptionElement);\n                  break;\n              }\n            } else {\n              aDescriptionElement.appendChild(document.createTextNode(text));\n            }\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_unescapeUrl\">\n        <parameter name=\"url\"/>\n        <body>\n          <![CDATA[\n          return Services.textToSubURI.unEscapeURIForUI(\"UTF-8\", url);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_reuseAcItem\">\n        <body>\n          <![CDATA[\n            let action = this._parseActionUrl(this.getAttribute(\"url\"));\n            let popup = this.parentNode.parentNode;\n\n            // If the item is a searchengine action, then it should\n            // only be reused if the engine name is the same as the\n            // popup's override engine name, if any.\n            if (!action ||\n                action.type != \"searchengine\" ||\n                !popup.overrideSearchEngineName ||\n                action.params.engineName == popup.overrideSearchEngineName) {\n\n              this.collapsed = false;\n\n              // The popup may have changed size between now and the last\n              // time the item was shown, so always handle over/underflow.\n              let dwu = window.windowUtils;\n              let popupWidth = dwu.getBoundsWithoutFlushing(this.parentNode).width;\n              if (!this._previousPopupWidth || this._previousPopupWidth != popupWidth) {\n                this._previousPopupWidth = popupWidth;\n                this.handleOverUnderflow();\n              }\n\n              return true;\n            }\n\n            return false;\n          ]]>\n        </body>\n      </method>\n\n\n      <method name=\"_adjustAcItem\">\n        <body>\n          <![CDATA[\n          let originalUrl = this.getAttribute(\"ac-value\");\n          let title = this.getAttribute(\"ac-comment\");\n          this.setAttribute(\"url\", originalUrl);\n          this.setAttribute(\"image\", this.getAttribute(\"ac-image\"));\n          this.setAttribute(\"title\", title);\n          this.setAttribute(\"text\", this.getAttribute(\"ac-text\"));\n\n          let popup = this.parentNode.parentNode;\n          let titleLooksLikeUrl = false;\n          let displayUrl = originalUrl;\n          let emphasiseUrl = true;\n          let trimDisplayUrl = true;\n\n          let type = this.getAttribute(\"originaltype\");\n          let types = new Set(type.split(/\\s+/));\n          let initialTypes = new Set(types);\n          // Remove types that should ultimately not be in the `type` string.\n          types.delete(\"action\");\n          types.delete(\"autofill\");\n          types.delete(\"heuristic\");\n          type = [...types][0] || \"\";\n\n          let action;\n\n          if (initialTypes.has(\"autofill\") && !initialTypes.has(\"action\")) {\n            // Treat autofills as visiturl actions, unless they are already also\n            // actions.\n            action = {\n              type: \"visiturl\",\n              params: { url: title },\n            };\n          }\n\n          this.removeAttribute(\"actiontype\");\n          this.classList.remove(\n            \"overridable-action\",\n            \"emptySearchQuery\",\n            \"aliasOffer\"\n          );\n\n          // If the type includes an action, set up the item appropriately.\n          if (initialTypes.has(\"action\") || action) {\n            action = action || this._parseActionUrl(originalUrl);\n            this.setAttribute(\"actiontype\", action.type);\n\n            switch (action.type) {\n            case \"switchtab\": {\n              this.classList.add(\"overridable-action\");\n              displayUrl = action.params.url;\n              let desc = this._stringBundle.GetStringFromName(\"switchToTab2\");\n              this._setUpDescription(this._actionText, desc, true);\n              break;\n            }\n            case \"remotetab\": {\n              displayUrl = action.params.url;\n              let desc = action.params.deviceName;\n              this._setUpDescription(this._actionText, desc, true);\n              break;\n            }\n            case \"searchengine\": {\n              emphasiseUrl = false;\n\n              // The order here is not localizable, we default to appending\n              // \"- Search with Engine\" to the search string, to be able to\n              // properly generate emphasis pairs. That said, no localization\n              // changed the order while it was possible, so doesn't look like\n              // there's a strong need for that.\n              let {\n                engineName,\n                searchSuggestion,\n                searchQuery,\n                alias,\n              } = action.params;\n\n              // Override the engine name if the popup defines an override.\n              let override = popup.overrideSearchEngineName;\n              if (override && override != engineName) {\n                engineName = override;\n                action.params.engineName = override;\n                let newURL =\n                  PlacesUtils.mozActionURI(action.type, action.params);\n                this.setAttribute(\"url\", newURL);\n              }\n\n              let engineStr =\n                this._stringBundle.formatStringFromName(\"searchWithEngine\",\n                                                        [engineName], 1);\n              this._setUpDescription(this._actionText, engineStr, true);\n\n              // Make the title by generating an array of pairs and its\n              // corresponding interpolation string (e.g., \"%1$S\") to pass to\n              // _generateEmphasisPairs.\n              let pairs;\n              if (searchSuggestion) {\n                // Check if the search query appears in the suggestion.  It may\n                // not.  If it does, then emphasize the query in the suggestion\n                // and otherwise just include the suggestion without emphasis.\n                let idx = searchSuggestion.indexOf(searchQuery);\n                if (idx >= 0) {\n                  pairs = [\n                    [searchSuggestion.substring(0, idx), \"\"],\n                    [searchQuery, \"match\"],\n                    [searchSuggestion.substring(idx + searchQuery.length), \"\"],\n                  ];\n                } else {\n                  pairs = [\n                    [searchSuggestion, \"\"],\n                  ];\n                }\n              } else if (alias &&\n                         !searchQuery.trim() &&\n                         !initialTypes.has(\"heuristic\")) {\n                // For non-heuristic alias results that have an empty query, we\n                // want to show \"@engine -- Search with Engine\" to make it clear\n                // that the user can search by selecting the result and using\n                // the alias.  Normally we hide the \"Search with Engine\" part\n                // until the result is selected or moused over, but not here.\n                // Add the aliasOffer class so we can detect this in the CSS.\n                this.classList.add(\"aliasOffer\");\n                pairs = [\n                  [alias, \"\"],\n                ];\n              } else {\n                // Add the emptySearchQuery class if the search query is the\n                // empty string.  We use it to hide .ac-separator in CSS.\n                if (!searchQuery.trim()) {\n                  this.classList.add(\"emptySearchQuery\");\n                }\n                pairs = [\n                  [searchQuery, \"\"],\n                ];\n              }\n              let interpStr = pairs.map((pair, i) => `%${i + 1}$S`).join(\"\");\n              title = this._generateEmphasisPairs(interpStr, pairs);\n\n              // If this is a default search match, we remove the image so we\n              // can style it ourselves with a generic search icon.\n              // We don't do this when matching an aliased search engine,\n              // because the icon helps with recognising which engine will be\n              // used (when using the default engine, we don't need that\n              // recognition).\n              if (!action.params.alias && !initialTypes.has(\"favicon\")) {\n                this.removeAttribute(\"image\");\n              }\n              break;\n            }\n            case \"visiturl\": {\n              emphasiseUrl = false;\n              displayUrl = action.params.url;\n              titleLooksLikeUrl = true;\n              let visitStr = this._stringBundle.GetStringFromName(\"visit\");\n              this._setUpDescription(this._actionText, visitStr, true);\n              break;\n            }\n            case \"extension\": {\n              let content = action.params.content;\n              displayUrl = content;\n              trimDisplayUrl = false;\n              this._setUpDescription(this._actionText, content, true);\n              break;\n            }\n            }\n          }\n\n          if (trimDisplayUrl) {\n            let input = popup.input;\n            if (typeof input.trimValue == \"function\")\n              displayUrl = input.trimValue(displayUrl);\n            displayUrl = this._unescapeUrl(displayUrl);\n          }\n          // For performance reasons we may want to limit the displayUrl size.\n          if (popup.textRunsMaxLen && displayUrl) {\n            displayUrl = displayUrl.substr(0, popup.textRunsMaxLen);\n          }\n          this.setAttribute(\"displayurl\", displayUrl);\n\n          // Show the domain as the title if we don't have a title.\n          if (!title) {\n            titleLooksLikeUrl = true;\n            try {\n              let uri = Services.io.newURI(originalUrl);\n              // Not all valid URLs have a domain.\n              if (uri.host)\n                title = uri.host;\n            } catch (e) {}\n            if (!title)\n              title = displayUrl;\n          }\n\n          this._tags.setAttribute(\"empty\", \"true\");\n\n          if (type == \"tag\" || type == \"bookmark-tag\") {\n            // The title is separated from the tags by an endash\n            let tags;\n            [, title, tags] = title.match(/^(.+) \\u2013 (.+)$/);\n\n            // Each tag is split by a comma in an undefined order, so sort it\n            let sortedTags = tags.split(/\\s*,\\s*/).sort((a, b) => {\n              return a.localeCompare(a);\n            });\n\n            let anyTagsMatch = this._setUpTags(sortedTags);\n            if (anyTagsMatch) {\n              this._tags.removeAttribute(\"empty\");\n            }\n            if (type == \"bookmark-tag\") {\n              type = \"bookmark\";\n            }\n          } else if (type == \"keyword\") {\n            // Note that this is a moz-action with action.type == keyword.\n            emphasiseUrl = false;\n            let keywordArg = this.getAttribute(\"text\").replace(/^[^\\s]+\\s*/, \"\");\n            if (!keywordArg) {\n              // Treat keyword searches without arguments as visiturl actions.\n              type = \"visiturl\";\n              this.setAttribute(\"actiontype\", \"visiturl\");\n              let visitStr = this._stringBundle.GetStringFromName(\"visit\");\n              this._setUpDescription(this._actionText, visitStr, true);\n            } else {\n              let pairs = [[title, \"\"], [keywordArg, \"match\"]];\n              let interpStr =\n                this._stringBundle.GetStringFromName(\"bookmarkKeywordSearch\");\n              title = this._generateEmphasisPairs(interpStr, pairs);\n              // The action box will be visible since this is a moz-action, but\n              // we want it to appear as if it were not visible, so set its text\n              // to the empty string.\n              this._setUpDescription(this._actionText, \"\", false);\n            }\n          }\n\n          this.setAttribute(\"type\", type);\n\n          if (titleLooksLikeUrl) {\n            this._titleText.setAttribute(\"lookslikeurl\", \"true\");\n          } else {\n            this._titleText.removeAttribute(\"lookslikeurl\");\n          }\n\n          if (Array.isArray(title)) {\n            // For performance reasons we may want to limit the title size.\n            if (popup.textRunsMaxLen) {\n              title.forEach(t => {\n                // Limit all the even items.\n                for (let i = 0; i < t.length; i += 2) {\n                  t[i] = t[i].substr(0, popup.textRunsMaxLen);\n                }\n              });\n            }\n            this._setUpEmphasisedSections(this._titleText, title);\n          } else {\n            // For performance reasons we may want to limit the title size.\n            if (popup.textRunsMaxLen && title) {\n              title = title.substr(0, popup.textRunsMaxLen);\n            }\n            this._setUpDescription(this._titleText, title, false);\n          }\n          this._setUpDescription(this._urlText, displayUrl, !emphasiseUrl);\n\n          // Removing the max-width may be jarring when the item is visible, but\n          // we have no other choice to properly crop the text.\n          // Removing max-widths may cause overflow or underflow events, that\n          // will set the _inOverflow property. In case both the old and the new\n          // text are overflowing, the overflow event won't happen, and we must\n          // enforce an _handleOverflow() call to update the max-widths.\n          let wasInOverflow = this._inOverflow;\n          this._removeMaxWidths();\n          if (wasInOverflow && this._inOverflow) {\n            this._handleOverflow();\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_removeMaxWidths\">\n        <body>\n          <![CDATA[\n          if (this._hasMaxWidths) {\n            this._titleText.style.removeProperty(\"max-width\");\n            this._tagsText.style.removeProperty(\"max-width\");\n            this._urlText.style.removeProperty(\"max-width\");\n            this._actionText.style.removeProperty(\"max-width\");\n            this._hasMaxWidths = false;\n          }\n          ]]>\n        </body>\n      </method>\n\n      <!-- This method truncates the displayed strings as necessary. -->\n      <method name=\"_handleOverflow\">\n        <body><![CDATA[\n          let itemRect = this.parentNode.getBoundingClientRect();\n          let titleRect = this._titleText.getBoundingClientRect();\n          let tagsRect = this._tagsText.getBoundingClientRect();\n          let separatorRect = this._separator.getBoundingClientRect();\n          let urlRect = this._urlText.getBoundingClientRect();\n          let actionRect = this._actionText.getBoundingClientRect();\n          let separatorURLActionWidth =\n            separatorRect.width + Math.max(urlRect.width, actionRect.width);\n\n          // Total width for the title and URL/action is the width of the item\n          // minus the start of the title text minus a little optional extra padding.\n          // This extra padding amount is basically arbitrary but keeps the text\n          // from getting too close to the popup's edge.\n          let dir = this.getAttribute(\"dir\");\n          let titleStart = dir == \"rtl\" ? itemRect.right - titleRect.right\n                                        : titleRect.left - itemRect.left;\n\n          let popup = this.parentNode.parentNode;\n          let itemWidth = itemRect.width - titleStart - popup.overflowPadding -\n                          (popup.margins ? popup.margins.end : 0);\n\n          if (this._tags.hasAttribute(\"empty\")) {\n            // The tags box is not displayed in this case.\n            tagsRect.width = 0;\n          }\n\n          let titleTagsWidth = titleRect.width + tagsRect.width;\n          if (titleTagsWidth + separatorURLActionWidth > itemWidth) {\n            // Title + tags + URL/action overflows the item width.\n\n            // The percentage of the item width allocated to the title and tags.\n            let titleTagsPct = 0.66;\n\n            let titleTagsAvailable = itemWidth - separatorURLActionWidth;\n            let titleTagsMaxWidth = Math.max(\n              titleTagsAvailable,\n              itemWidth * titleTagsPct\n            );\n            if (titleTagsWidth > titleTagsMaxWidth) {\n              // Title + tags overflows the max title + tags width.\n\n              // The percentage of the title + tags width allocated to the\n              // title.\n              let titlePct = 0.33;\n\n              let titleAvailable = titleTagsMaxWidth - tagsRect.width;\n              let titleMaxWidth = Math.max(\n                titleAvailable,\n                titleTagsMaxWidth * titlePct\n              );\n              let tagsAvailable = titleTagsMaxWidth - titleRect.width;\n              let tagsMaxWidth = Math.max(\n                tagsAvailable,\n                titleTagsMaxWidth * (1 - titlePct)\n              );\n              this._titleText.style.maxWidth = titleMaxWidth + \"px\";\n              this._tagsText.style.maxWidth = tagsMaxWidth + \"px\";\n            }\n            let urlActionMaxWidth = Math.max(\n              itemWidth - titleTagsWidth,\n              itemWidth * (1 - titleTagsPct)\n            );\n            urlActionMaxWidth -= separatorRect.width;\n            this._urlText.style.maxWidth = urlActionMaxWidth + \"px\";\n            this._actionText.style.maxWidth = urlActionMaxWidth + \"px\";\n            this._hasMaxWidths = true;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"handleOverUnderflow\">\n        <body>\n          <![CDATA[\n          this._removeMaxWidths();\n          this._handleOverflow();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_parseActionUrl\">\n        <parameter name=\"aUrl\"/>\n        <body><![CDATA[\n          if (!aUrl.startsWith(\"moz-action:\"))\n            return null;\n\n          // URL is in the format moz-action:ACTION,PARAMS\n          // Where PARAMS is a JSON encoded object.\n          let [, type, params] = aUrl.match(/^moz-action:([^,]+),(.*)$/);\n\n          let action = {\n            type,\n          };\n\n          try {\n            action.params = JSON.parse(params);\n            for (let key in action.params) {\n              action.params[key] = decodeURIComponent(action.params[key]);\n            }\n          } catch (e) {\n            // If this failed, we assume that params is not a JSON object, and\n            // is instead just a flat string. This may happen for legacy\n            // search components.\n            action.params = {\n              url: params,\n            };\n          }\n\n          return action;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <!--\n        This overrides listitem's mousedown handler because we want to set the\n        selected item even when the shift or accel keys are pressed.\n      -->\n      <handler event=\"mousedown\"><![CDATA[\n        // Call this.control only once since it's not a simple getter.\n        let control = this.control;\n        if (!control || control.disabled) {\n          return;\n        }\n        if (!this.selected) {\n          control.selectItem(this);\n        }\n        control.currentItem = this;\n      ]]></handler>\n\n      <handler event=\"mouseover\"><![CDATA[\n        // The point of implementing this handler is to allow drags to change\n        // the selected item.  If the user mouses down on an item, it becomes\n        // selected.  If they then drag the mouse to another item, select it.\n        // Handle all three primary mouse buttons: right, left, and wheel, since\n        // all three change the selection on mousedown.\n        let mouseDown = event.buttons & 0b111;\n        if (!mouseDown) {\n          return;\n        }\n        // Call this.control only once since it's not a simple getter.\n        let control = this.control;\n        if (!control || control.disabled) {\n          return;\n        }\n        if (!this.selected) {\n          control.selectItem(this);\n        }\n        control.currentItem = this;\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"autocomplete-richlistbox\" extends=\"chrome://global/content/bindings/richlistbox.xml#richlistbox\">\n    <implementation>\n      <field name=\"mLastMoveTime\">Date.now()</field>\n      <field name=\"mousedOverIndex\">-1</field>\n    </implementation>\n    <handlers>\n      <handler event=\"mouseup\">\n        <![CDATA[\n        // Don't call onPopupClick for the scrollbar buttons, thumb, slider, etc.\n        // If we hit the richlistbox and not a richlistitem, we ignore the event.\n        if (event.originalTarget.closest(\"richlistbox,richlistitem\").localName == \"richlistbox\") {\n          return;\n        }\n\n        this.parentNode.onPopupClick(event);\n      ]]>\n      </handler>\n\n      <handler event=\"mousemove\">\n        <![CDATA[\n        if (Date.now() - this.mLastMoveTime <= 30) {\n          return;\n        }\n\n        let item = event.target.closest(\"richlistbox,richlistitem\");\n\n        // If we hit the richlistbox and not a richlistitem, we ignore the event.\n        if (item.localName == \"richlistbox\") {\n          return;\n        }\n\n        let index = this.getIndexOfItem(item);\n\n        this.mousedOverIndex = index;\n\n        if (item.selectedByMouseOver) {\n          this.selectedIndex = index;\n        }\n\n        this.mLastMoveTime = Date.now();\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"browser.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"browserBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n\n  <binding id=\"browser\">\n    <content clickthrough=\"never\">\n      <children/>\n    </content>\n    <implementation type=\"application/javascript\" implements=\"nsIObserver, nsIBrowser\">\n      <property name=\"autoscrollEnabled\">\n        <getter>\n          <![CDATA[\n            if (this.getAttribute(\"autoscroll\") == \"false\")\n              return false;\n\n            return this.mPrefs.getBoolPref(\"general.autoScroll\", true);\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"canGoBack\"\n                onget=\"return this.webNavigation.canGoBack;\"\n                readonly=\"true\"/>\n\n      <property name=\"canGoForward\"\n                onget=\"return this.webNavigation.canGoForward;\"\n                readonly=\"true\"/>\n\n      <method name=\"_wrapURIChangeCall\">\n        <parameter name=\"fn\"/>\n        <body>\n          <![CDATA[\n            if (!this.isRemoteBrowser) {\n              this.inLoadURI = true;\n              try {\n                fn();\n              } finally {\n                this.inLoadURI = false;\n              }\n            } else {\n              fn();\n            }\n          ]]>\n        </body>\n      </method>\n\n\n      <method name=\"goBack\">\n        <body>\n          <![CDATA[\n            var webNavigation = this.webNavigation;\n            if (webNavigation.canGoBack)\n              this._wrapURIChangeCall(() => webNavigation.goBack());\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"goForward\">\n        <body>\n          <![CDATA[\n            var webNavigation = this.webNavigation;\n            if (webNavigation.canGoForward)\n              this._wrapURIChangeCall(() => webNavigation.goForward());\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"reload\">\n        <body>\n          <![CDATA[\n            const nsIWebNavigation = Ci.nsIWebNavigation;\n            const flags = nsIWebNavigation.LOAD_FLAGS_NONE;\n            this.reloadWithFlags(flags);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"reloadWithFlags\">\n        <parameter name=\"aFlags\"/>\n        <body>\n          <![CDATA[\n            this.webNavigation.reload(aFlags);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"stop\">\n        <body>\n          <![CDATA[\n            const nsIWebNavigation = Ci.nsIWebNavigation;\n            const flags = nsIWebNavigation.STOP_ALL;\n            this.webNavigation.stop(flags);\n          ]]>\n        </body>\n      </method>\n\n      <!-- throws exception for unknown schemes -->\n      <method name=\"loadURI\">\n        <parameter name=\"aURI\"/>\n        <parameter name=\"aParams\"/>\n        <body>\n          <![CDATA[\n            if (!aURI) {\n              aURI = \"about:blank\";\n            }\n\n            let {\n              flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE,\n              referrerURI,\n              referrerPolicy = Ci.nsIHttpChannel.REFERRER_POLICY_UNSET,\n              triggeringPrincipal,\n              postData,\n            } = aParams || {};\n\n            this._wrapURIChangeCall(() =>\n              this.webNavigation.loadURIWithOptions(\n                  aURI, flags, referrerURI, referrerPolicy,\n                  postData, null, null, triggeringPrincipal));\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"gotoIndex\">\n        <parameter name=\"aIndex\"/>\n        <body>\n          <![CDATA[\n            this._wrapURIChangeCall(() => this.webNavigation.gotoIndex(aIndex));\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"currentURI\" readonly=\"true\">\n       <getter><![CDATA[\n          if (this.webNavigation) {\n            return this.webNavigation.currentURI;\n          }\n          return null;\n       ]]>\n       </getter>\n      </property>\n\n      <!--\n        Used by session restore to ensure that currentURI is set so\n        that switch-to-tab works before the tab is fully\n        restored. This function also invokes onLocationChanged\n        listeners in tabbrowser.xml.\n      -->\n      <method name=\"_setCurrentURI\">\n        <parameter name=\"aURI\"/>\n        <body><![CDATA[\n          if (this.isRemoteBrowser) {\n            this._remoteWebProgressManager.setCurrentURI(aURI);\n          } else {\n            this.docShell.setCurrentURI(aURI);\n          }\n        ]]></body>\n      </method>\n\n      <field name=\"_documentURI\">null</field>\n      <property name=\"documentURI\"\n                onget=\"return this.isRemoteBrowser ? this._documentURI : this.contentDocument.documentURIObject;\"\n                readonly=\"true\"/>\n\n\n      <field name=\"_documentContentType\">null</field>\n      <property name=\"documentContentType\"\n                readonly=\"true\">\n        <getter><![CDATA[\n          if (this.isRemoteBrowser) {\n            return this._documentContentType;\n          }\n          return this.contentDocument ? this.contentDocument.contentType : null;\n        ]]></getter>\n      </property>\n\n      <!--\n        Weak reference to an optional frame loader that can be used to influence\n        process selection for this browser.\n        See nsIBrowser.sameProcessAsFrameLoader.\n      -->\n      <field name=\"_sameProcessAsFrameLoader\">null</field>\n      <property name=\"sameProcessAsFrameLoader\">\n        <getter><![CDATA[\n          return this._sameProcessAsFrameLoader && this._sameProcessAsFrameLoader.get();\n        ]]></getter>\n        <setter><![CDATA[\n          this._sameProcessAsFrameLoader = Cu.getWeakReference(val);\n        ]]></setter>\n      </property>\n\n      <field name=\"_loadContext\">null</field>\n\n      <property name=\"loadContext\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._loadContext)\n            return this._loadContext;\n\n          let {frameLoader} = this;\n          if (!frameLoader)\n            return null;\n          this._loadContext = frameLoader.loadContext;\n          return this._loadContext;\n        ]]></getter>\n      </property>\n\n      <property name=\"autoCompletePopup\"\n                onget=\"return document.getElementById(this.getAttribute('autocompletepopup'))\"\n                readonly=\"true\"/>\n\n      <property name=\"dateTimePicker\"\n                onget=\"return document.getElementById(this.getAttribute('datetimepicker'))\"\n                readonly=\"true\"/>\n\n      <property name=\"docShellIsActive\">\n        <getter>\n          <![CDATA[\n            if (this.isRemoteBrowser) {\n              return this.frameLoader.tabParent.docShellIsActive;\n            }\n            return this.docShell && this.docShell.isActive;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            if (this.isRemoteBrowser) {\n              this.frameLoader.tabParent.docShellIsActive = val;\n              return val;\n            }\n            if (this.docShell)\n              return this.docShell.isActive = val;\n            return false;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"preserveLayers\">\n        <parameter name=\"preserve\"/>\n        <body><![CDATA[\n          if (!this.isRemoteBrowser) {\n            return;\n          }\n          let {frameLoader} = this;\n          if (frameLoader.tabParent) {\n            frameLoader.tabParent.preserveLayers(preserve);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"deprioritize\">\n        <body><![CDATA[\n          if (!this.isRemoteBrowser) {\n            return;\n          }\n          let {frameLoader} = this;\n          if (frameLoader.tabParent) {\n            frameLoader.tabParent.deprioritize();\n          }\n        ]]></body>\n      </method>\n\n\n      <property name=\"renderLayers\">\n        <getter>\n          <![CDATA[\n            if (this.isRemoteBrowser) {\n              let {frameLoader} = this;\n              if (frameLoader && frameLoader.tabParent) {\n                return frameLoader.tabParent.renderLayers;\n              }\n              return false;\n            }\n            return this.docShellIsActive;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            if (this.isRemoteBrowser) {\n              let {frameLoader} = this;\n              if (frameLoader && frameLoader.tabParent) {\n                return frameLoader.tabParent.renderLayers = val;\n              }\n              return false;\n            }\n            return this.docShellIsActive = val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"hasLayers\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (this.isRemoteBrowser) {\n              let {frameLoader} = this;\n              if (frameLoader.tabParent) {\n                return frameLoader.tabParent.hasLayers;\n              }\n              return false;\n            }\n\n            return this.docShellIsActive;\n          ]]>\n        </getter>\n      </property>\n\n      <method name=\"forceRepaint\">\n        <body>\n          <![CDATA[\n            if (!this.isRemoteBrowser) {\n              return;\n            }\n            let {frameLoader} = this;\n            if (frameLoader && frameLoader.tabParent) {\n              frameLoader.tabParent.forceRepaint();\n            }\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"_imageDocument\">null</field>\n      <property name=\"imageDocument\"\n                readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (this.isRemoteBrowser) {\n              return this._imageDocument;\n            }\n            var document = this.contentDocument;\n            if (!document || !(document instanceof Ci.nsIImageDocument))\n              return null;\n\n            try {\n                return {width: document.imageRequest.image.width, height: document.imageRequest.image.height };\n            } catch (e) {}\n            return null;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"isRemoteBrowser\"\n                onget=\"return (this.getAttribute('remote') == 'true');\"\n                readonly=\"true\"/>\n\n      <property name=\"remoteType\"\n                readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (!this.isRemoteBrowser) {\n              return null;\n            }\n\n            let remoteType = this.getAttribute(\"remoteType\");\n            if (remoteType) {\n              return remoteType;\n            }\n\n            let E10SUtils = ChromeUtils.import(\"resource://gre/modules/E10SUtils.jsm\", {}).E10SUtils;\n            return E10SUtils.DEFAULT_REMOTE_TYPE;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"messageManager\"\n                readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (this.frameLoader) {\n              return this.frameLoader.messageManager;\n            }\n            return null;\n          ]]>\n        </getter>\n\n      </property>\n\n      <field name=\"_webBrowserFind\">null</field>\n\n      <property name=\"webBrowserFind\"\n                readonly=\"true\">\n        <getter>\n        <![CDATA[\n          if (!this._webBrowserFind)\n            this._webBrowserFind = this.docShell.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebBrowserFind);\n          return this._webBrowserFind;\n        ]]>\n        </getter>\n      </property>\n\n      <method name=\"getTabBrowser\">\n        <body>\n          <![CDATA[\n            if (this.ownerGlobal.gBrowser &&\n                this.ownerGlobal.gBrowser.getTabForBrowser &&\n                this.ownerGlobal.gBrowser.getTabForBrowser(this)) {\n              return this.ownerGlobal.gBrowser;\n            }\n            return null;\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"_finder\">null</field>\n      <field name=\"_remoteFinder\">null</field>\n      <property name=\"finder\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.isRemoteBrowser) {\n            if (!this._remoteFinder) {\n              // Don't attempt to create the remote finder if the\n              // messageManager has already gone away\n              if (!this.messageManager)\n                return null;\n\n              let jsm = \"resource://gre/modules/FinderParent.jsm\";\n              let { FinderParent } = ChromeUtils.import(jsm, {});\n              this._remoteFinder = new FinderParent(this);\n            }\n            return this._remoteFinder;\n          }\n          if (!this._finder) {\n            if (!this.docShell)\n              return null;\n\n            let Finder = ChromeUtils.import(\"resource://gre/modules/Finder.jsm\", {}).Finder;\n            this._finder = new Finder(this.docShell);\n          }\n          return this._finder;\n        ]]></getter>\n      </property>\n\n      <field name=\"_fastFind\">null</field>\n      <property name=\"fastFind\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._fastFind) {\n            if (!(\"@mozilla.org/typeaheadfind;1\" in Cc))\n              return null;\n\n            var tabBrowser = this.getTabBrowser();\n            if (tabBrowser && \"fastFind\" in tabBrowser)\n              return this._fastFind = tabBrowser.fastFind;\n\n            if (!this.docShell)\n              return null;\n\n            this._fastFind = Cc[\"@mozilla.org/typeaheadfind;1\"]\n                               .createInstance(Ci.nsITypeAheadFind);\n            this._fastFind.init(this.docShell);\n          }\n          return this._fastFind;\n        ]]></getter>\n      </property>\n\n      <field name=\"_outerWindowID\">null</field>\n      <property name=\"outerWindowID\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.isRemoteBrowser) {\n            return this._outerWindowID;\n          }\n          return this.contentWindow.windowUtils.outerWindowID;\n        ]]></getter>\n      </property>\n\n      <field name=\"_innerWindowID\">null</field>\n      <property name=\"innerWindowID\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.isRemoteBrowser) {\n            return this._innerWindowID;\n          }\n          try {\n            return this.contentWindow.windowUtils.currentInnerWindowID;\n          } catch (e) {\n            if (e.result != Cr.NS_ERROR_NOT_AVAILABLE) {\n              throw e;\n            }\n            return null;\n          }\n        ]]></getter>\n      </property>\n\n      <field name=\"_lastSearchString\">null</field>\n\n\n      <field name=\"_controller\">null</field>\n\n      <field name=\"_selectParentHelper\">null</field>\n\n      <field name=\"_remoteWebNavigation\">null</field>\n      <!-- Note that this overrides webNavigation on XULFrameElement, and duplicates the return value for the non-remote case -->\n      <property name=\"webNavigation\"\n                readonly=\"true\"\n                onget=\"return this.isRemoteBrowser ? this._remoteWebNavigation : this.docShell.QueryInterface(Components.interfaces.nsIWebNavigation);\"/>\n\n      <field name=\"_remoteWebProgress\">null</field>\n      <property name=\"webProgress\"\n                readonly=\"true\"\n                onget=\"return this.isRemoteBrowser ? this._remoteWebProgress : this.docShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIWebProgress);\"/>\n\n      <property name=\"sessionHistory\"\n                onget=\"return this.webNavigation.sessionHistory;\"\n                readonly=\"true\"/>\n\n      <property name=\"markupDocumentViewer\"\n                onget=\"return this.docShell.contentViewer;\"\n                readonly=\"true\"/>\n\n      <field name=\"_contentTitle\">\"\"</field>\n      <property name=\"contentTitle\"\n                onget=\"return this.isRemoteBrowser ? this._contentTitle : this.contentDocument.title;\"\n                readonly=\"true\"/>\n\n      <field name=\"_characterSet\">\"\"</field>\n      <property name=\"characterSet\"\n                onget=\"return this.isRemoteBrowser ? this._characterSet : this.docShell.charset;\">\n        <setter><![CDATA[\n          if (this.isRemoteBrowser) {\n            this.messageManager.sendAsyncMessage(\"UpdateCharacterSet\", {value: val});\n            this._characterSet = val;\n          } else {\n            this.docShell.charset = val;\n            this.docShell.gatherCharsetMenuTelemetry();\n          }\n        ]]></setter>\n      </property>\n\n      <field name=\"_mayEnableCharacterEncodingMenu\">null</field>\n      <property name=\"mayEnableCharacterEncodingMenu\"\n                onget=\"return this.isRemoteBrowser ? this._mayEnableCharacterEncodingMenu : this.docShell.mayEnableCharacterEncodingMenu;\"\n                readonly=\"true\"/>\n\n      <field name=\"_contentPrincipal\">null</field>\n      <property name=\"contentPrincipal\"\n                onget=\"return this.isRemoteBrowser ? this._contentPrincipal : this.contentDocument.nodePrincipal;\"\n                readonly=\"true\"/>\n\n      <field name=\"_contentRequestContextID\">null</field>\n      <property name=\"contentRequestContextID\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.isRemoteBrowser) {\n            return this._contentRequestContextID;\n          }\n          try {\n            return this.contentDocument.documentLoadGroup\n                       .requestContextID;\n          } catch (e) {\n            return null;\n          }\n        ]]></getter>\n      </property>\n\n      <property name=\"showWindowResizer\"\n                onset=\"if (val) this.setAttribute('showresizer', 'true');\n                       else this.removeAttribute('showresizer');\n                       return val;\"\n                onget=\"return this.getAttribute('showresizer') == 'true';\"/>\n\n      <field name=\"_fullZoom\">1</field>\n      <property name=\"fullZoom\">\n        <getter><![CDATA[\n          if (this.isRemoteBrowser) {\n            return this._fullZoom;\n          }\n          return this.markupDocumentViewer.fullZoom;\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.isRemoteBrowser) {\n            let changed = val.toFixed(2) != this._fullZoom.toFixed(2);\n\n            if (changed) {\n              this._fullZoom = val;\n              try {\n                this.messageManager.sendAsyncMessage(\"FullZoom\", {value: val});\n              } catch (ex) {}\n\n              let event = new Event(\"FullZoomChange\", {bubbles: true});\n              this.dispatchEvent(event);\n            }\n          } else {\n            this.markupDocumentViewer.fullZoom = val;\n          }\n        ]]></setter>\n      </property>\n\n      <field name=\"_textZoom\">1</field>\n      <property name=\"textZoom\">\n        <getter><![CDATA[\n          if (this.isRemoteBrowser) {\n            return this._textZoom;\n          }\n          return this.markupDocumentViewer.textZoom;\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.isRemoteBrowser) {\n            let changed = val.toFixed(2) != this._textZoom.toFixed(2);\n\n            if (changed) {\n              this._textZoom = val;\n              try {\n                this.messageManager.sendAsyncMessage(\"TextZoom\", {value: val});\n              } catch (ex) {}\n\n              let event = new Event(\"TextZoomChange\", {bubbles: true});\n              this.dispatchEvent(event);\n            }\n          } else {\n            this.markupDocumentViewer.textZoom = val;\n          }\n\n        ]]></setter>\n        <setter><![CDATA[\n        ]]></setter>\n      </property>\n\n      <field name=\"_isSyntheticDocument\">false</field>\n      <property name=\"isSyntheticDocument\">\n        <getter><![CDATA[\n          if (this.isRemoteBrowser) {\n            return this._isSyntheticDocument;\n          }\n          return this.contentDocument.mozSyntheticDocument;\n        ]]></getter>\n      </property>\n\n      <property name=\"hasContentOpener\">\n        <getter><![CDATA[\n          if (this.isRemoteBrowser) {\n            return this.frameLoader.tabParent.hasContentOpener;\n          }\n          return !!this.contentWindow.opener;\n        ]]></getter>\n      </property>\n\n      <field name=\"mPrefs\" readonly=\"true\">\n        Cc[\"@mozilla.org/preferences-service;1\"].getService(Ci.nsIPrefBranch);\n      </field>\n\n      <field name=\"_mStrBundle\">null</field>\n\n      <property name=\"mStrBundle\">\n        <getter>\n        <![CDATA[\n          if (!this._mStrBundle) {\n            // need to create string bundle manually instead of using <xul:stringbundle/>\n            // see bug 63370 for details\n            this._mStrBundle = Cc[\"@mozilla.org/intl/stringbundle;1\"]\n                                 .getService(Ci.nsIStringBundleService)\n                                 .createBundle(\"chrome://global/locale/browser.properties\");\n          }\n          return this._mStrBundle;\n        ]]></getter>\n      </property>\n\n      <method name=\"addProgressListener\">\n        <parameter name=\"aListener\"/>\n        <parameter name=\"aNotifyMask\"/>\n        <body>\n          <![CDATA[\n            if (!aNotifyMask) {\n              aNotifyMask = Ci.nsIWebProgress.NOTIFY_ALL;\n            }\n            this.webProgress.addProgressListener(aListener, aNotifyMask);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeProgressListener\">\n        <parameter name=\"aListener\"/>\n        <body>\n          <![CDATA[\n            this.webProgress.removeProgressListener(aListener);\n         ]]>\n        </body>\n      </method>\n\n      <method name=\"onPageHide\">\n        <parameter name=\"aEvent\"/>\n        <body>\n          <![CDATA[\n            if (!this.docShell || !this.fastFind)\n              return;\n            var tabBrowser = this.getTabBrowser();\n            if (!tabBrowser || !(\"fastFind\" in tabBrowser) ||\n                tabBrowser.selectedBrowser == this)\n              this.fastFind.setDocShell(this.docShell);\n         ]]>\n        </body>\n      </method>\n\n      <method name=\"updateBlockedPopups\">\n        <body>\n          <![CDATA[\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"DOMUpdateBlockedPopups\", true, true);\n            this.dispatchEvent(event);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"retrieveListOfBlockedPopups\">\n        <body>\n          <![CDATA[\n          this.messageManager.sendAsyncMessage(\"PopupBlocking:GetBlockedPopupList\", null);\n          return new Promise(resolve => {\n            let self = this;\n            this.messageManager.addMessageListener(\"PopupBlocking:ReplyGetBlockedPopupList\",\n              function replyReceived(msg) {\n                self.messageManager.removeMessageListener(\"PopupBlocking:ReplyGetBlockedPopupList\",\n                                                          replyReceived);\n                resolve(msg.data.popupData);\n              }\n            );\n          });\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"unblockPopup\">\n        <parameter name=\"aPopupIndex\"/>\n        <body><![CDATA[\n          this.messageManager.sendAsyncMessage(\"PopupBlocking:UnblockPopup\",\n                                               {index: aPopupIndex});\n        ]]></body>\n      </method>\n\n      <field name=\"blockedPopups\">null</field>\n\n      <method name=\"audioPlaybackStarted\">\n        <body>\n          <![CDATA[\n            if (this._audioMuted) {\n              return;\n            }\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"DOMAudioPlaybackStarted\", true, false);\n            this.dispatchEvent(event);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"audioPlaybackStopped\">\n        <body>\n          <![CDATA[\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"DOMAudioPlaybackStopped\", true, false);\n            this.dispatchEvent(event);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"notifyAudibleAutoplayMediaOccurred\">\n        <body>\n          <![CDATA[\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"AudibleAutoplayMediaOccurred\", true, false);\n            this.dispatchEvent(event);\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        When the pref \"media.block-autoplay-until-in-foreground\" is on,\n        Gecko delays starting playback of media resources in tabs until the\n        tab has been in the foreground or resumed by tab's play tab icon.\n        - When Gecko delays starting playback of a media resource in a window,\n        it sends a message to call activeMediaBlockStarted(). This causes the\n        tab audio indicator to show.\n        - When a tab is foregrounded, Gecko starts playing all delayed media\n        resources in that tab, and sends a message to call\n        activeMediaBlockStopped(). This causes the tab audio indicator to hide.\n       -->\n      <method name=\"activeMediaBlockStarted\">\n        <body>\n          <![CDATA[\n            this._hasAnyPlayingMediaBeenBlocked = true;\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"DOMAudioPlaybackBlockStarted\", true, false);\n            this.dispatchEvent(event);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"activeMediaBlockStopped\">\n        <body>\n          <![CDATA[\n            if (!this._hasAnyPlayingMediaBeenBlocked) {\n              return;\n            }\n            this._hasAnyPlayingMediaBeenBlocked = false;\n            let event = document.createEvent(\"Events\");\n            event.initEvent(\"DOMAudioPlaybackBlockStopped\", true, false);\n            this.dispatchEvent(event);\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"_audioMuted\">false</field>\n      <property name=\"audioMuted\"\n                onget=\"return this._audioMuted;\"\n                readonly=\"true\"/>\n\n      <field name=\"_hasAnyPlayingMediaBeenBlocked\">false</field>\n\n      <method name=\"mute\">\n        <parameter name=\"transientState\"/>\n        <body>\n          <![CDATA[\n            if (!transientState) {\n              this._audioMuted = true;\n            }\n            this.messageManager.sendAsyncMessage(\"AudioPlayback\",\n                                                 {type: \"mute\"});\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"unmute\">\n        <body>\n          <![CDATA[\n            this._audioMuted = false;\n            this.messageManager.sendAsyncMessage(\"AudioPlayback\",\n                                                 {type: \"unmute\"});\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"pauseMedia\">\n        <parameter name=\"disposable\"/>\n        <body>\n          <![CDATA[\n            let suspendedReason;\n            if (disposable) {\n              suspendedReason = \"mediaControlPaused\";\n            } else {\n              suspendedReason = \"lostAudioFocusTransiently\";\n            }\n\n            this.messageManager.sendAsyncMessage(\"AudioPlayback\",\n                                                 {type: suspendedReason});\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"stopMedia\">\n        <body>\n          <![CDATA[\n            this.messageManager.sendAsyncMessage(\"AudioPlayback\",\n                                                 {type: \"mediaControlStopped\"});\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"resumeMedia\">\n        <body>\n          <![CDATA[\n            this.messageManager.sendAsyncMessage(\"AudioPlayback\",\n                                                 {type: \"resumeMedia\"});\n            if (this._hasAnyPlayingMediaBeenBlocked) {\n              this._hasAnyPlayingMediaBeenBlocked = false;\n              let event = document.createEvent(\"Events\");\n              event.initEvent(\"DOMAudioPlaybackBlockStopped\", true, false);\n              this.dispatchEvent(event);\n            }\n          ]]>\n        </body>\n      </method>\n\n      <!--\n        Only send the message \"Browser:UnselectedTabHover\" when someone requests\n        for the message, which can reduce non-necessary communication.\n      -->\n      <field name=\"_shouldSendUnselectedTabHover\">false</field>\n      <field name=\"_unselectedTabHoverMessageListenerCount\">0</field>\n      <property name=\"shouldHandleUnselectedTabHover\"\n                onget=\"return this._shouldSendUnselectedTabHover;\"\n                readonly=\"true\"/>\n\n      <method name=\"unselectedTabHover\">\n        <parameter name=\"hovered\"/>\n        <body>\n          <![CDATA[\n            if (!this._shouldSendUnselectedTabHover) {\n              return;\n            }\n            this.messageManager.sendAsyncMessage(\"Browser:UnselectedTabHover\",\n              { hovered });\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"_securityUI\">null</field>\n      <property name=\"securityUI\"\n                readonly=\"true\">\n        <getter>\n          <![CDATA[\n            if (this.isRemoteBrowser) {\n              if (!this._securityUI) {\n                // Don't attempt to create the remote web progress if the\n                // messageManager has already gone away\n                if (!this.messageManager)\n                  return null;\n\n                let jsm = \"resource://gre/modules/RemoteSecurityUI.jsm\";\n                let RemoteSecurityUI = ChromeUtils.import(jsm, {}).RemoteSecurityUI;\n                this._securityUI = new RemoteSecurityUI();\n              }\n\n              // We want to double-wrap the JS implemented interface, so that QI and instanceof works.\n              var ptr = Cc[\"@mozilla.org/supports-interface-pointer;1\"]\n                          .createInstance(Ci.nsISupportsInterfacePointer);\n              ptr.data = this._securityUI;\n              return ptr.data.QueryInterface(Ci.nsISecureBrowserUI);\n            }\n\n            if (!this.docShell.securityUI) {\n              const SECUREBROWSERUI_CONTRACTID = \"@mozilla.org/secure_browser_ui;1\";\n              var securityUI = Cc[SECUREBROWSERUI_CONTRACTID]\n                                 .createInstance(Ci.nsISecureBrowserUI);\n              securityUI.init(this.docShell);\n            }\n\n            return this.docShell.securityUI;\n          ]]>\n        </getter>\n      </property>\n\n      <field name=\"urlbarChangeTracker\">\n        ({\n          _startedLoadSinceLastUserTyping: false,\n\n          startedLoad() {\n            this._startedLoadSinceLastUserTyping = true;\n          },\n          finishedLoad() {\n            this._startedLoadSinceLastUserTyping = false;\n          },\n          userTyped() {\n            this._startedLoadSinceLastUserTyping = false;\n          },\n        })\n      </field>\n\n      <method name=\"didStartLoadSinceLastUserTyping\">\n        <body><![CDATA[\n          return !this.inLoadURI &&\n                 this.urlbarChangeTracker._startedLoadSinceLastUserTyping;\n        ]]></body>\n      </method>\n\n      <field name=\"_userTypedValue\">\n        null\n      </field>\n\n      <property name=\"userTypedValue\"\n                onget=\"return this._userTypedValue;\">\n        <setter><![CDATA[\n          this.urlbarChangeTracker.userTyped();\n          this._userTypedValue = val;\n          return val;\n        ]]></setter>\n      </property>\n\n      <field name=\"droppedLinkHandler\">\n        null\n      </field>\n\n      <field name=\"mIconURL\">null</field>\n\n      <!-- This is managed by the tabbrowser -->\n      <field name=\"lastURI\">null</field>\n\n      <field name=\"mDestroyed\">false</field>\n\n      <constructor>\n        <![CDATA[\n        this.construct();\n        ]]>\n      </constructor>\n\n      <method name=\"construct\">\n        <body><![CDATA[\n          if (this.isRemoteBrowser) {\n            /*\n            * Don't try to send messages from this function. The message manager for\n            * the <browser> element may not be initialized yet.\n            */\n\n            this._remoteWebNavigation = Cc[\"@mozilla.org/remote-web-navigation;1\"]\n                                          .createInstance(Ci.nsIWebNavigation);\n            this._remoteWebNavigationImpl = this._remoteWebNavigation.wrappedJSObject;\n            this._remoteWebNavigationImpl.swapBrowser(this);\n\n            // Initialize contentPrincipal to the about:blank principal for this loadcontext\n            let {Services} = ChromeUtils.import(\"resource://gre/modules/Services.jsm\", {});\n            let aboutBlank = Services.io.newURI(\"about:blank\");\n            let ssm = Services.scriptSecurityManager;\n            this._contentPrincipal = ssm.getLoadContextCodebasePrincipal(aboutBlank, this.loadContext);\n\n            this.messageManager.addMessageListener(\"Browser:Init\", this);\n            this.messageManager.addMessageListener(\"DOMTitleChanged\", this);\n            this.messageManager.addMessageListener(\"ImageDocumentLoaded\", this);\n            this.messageManager.addMessageListener(\"FullZoomChange\", this);\n            this.messageManager.addMessageListener(\"TextZoomChange\", this);\n            this.messageManager.addMessageListener(\"ZoomChangeUsingMouseWheel\", this);\n\n            // browser-child messages, such as Content:LocationChange, are handled in\n            // RemoteWebProgress, ensure it is loaded and ready.\n            let jsm = \"resource://gre/modules/RemoteWebProgress.jsm\";\n            let { RemoteWebProgressManager } = ChromeUtils.import(jsm, {});\n\n            let oldManager = this._remoteWebProgressManager;\n            this._remoteWebProgressManager = new RemoteWebProgressManager(this);\n            if (oldManager) {\n              // We're transitioning from one remote type to another. This means that\n              // the RemoteWebProgress listener is listening to the old message manager,\n              // and needs to be pointed at the new one.\n              this._remoteWebProgressManager.swapListeners(oldManager);\n            }\n\n            this._remoteWebProgress = this._remoteWebProgressManager.topLevelWebProgress;\n\n            this.messageManager.loadFrameScript(\"chrome://global/content/browser-child.js\", true);\n\n            if (this.hasAttribute(\"selectmenulist\")) {\n              this.messageManager.addMessageListener(\"Forms:ShowDropDown\", this);\n              this.messageManager.addMessageListener(\"Forms:HideDropDown\", this);\n            }\n\n            if (!this.hasAttribute(\"disablehistory\")) {\n              Services.obs.addObserver(this, \"browser:purge-session-history\", true);\n            }\n\n            let rc_js = \"resource://gre/modules/RemoteController.js\";\n            let scope = {};\n            Services.scriptloader.loadSubScript(rc_js, scope);\n            let RemoteController = scope.RemoteController;\n            this._controller = new RemoteController(this);\n            this.controllers.appendController(this._controller);\n          }\n\n          try {\n            // |webNavigation.sessionHistory| will have been set by the frame\n            // loader when creating the docShell as long as this xul:browser\n            // doesn't have the 'disablehistory' attribute set.\n            if (this.docShell && this.webNavigation.sessionHistory) {\n              var os = Cc[\"@mozilla.org/observer-service;1\"]\n                         .getService(Ci.nsIObserverService);\n              os.addObserver(this, \"browser:purge-session-history\", true);\n\n              // enable global history if we weren't told otherwise\n              if (!this.hasAttribute(\"disableglobalhistory\") && !this.isRemoteBrowser) {\n                try {\n                  this.docShell.useGlobalHistory = true;\n                } catch (ex) {\n                  // This can occur if the Places database is locked\n                  Cu.reportError(\"Error enabling browser global history: \" + ex);\n                }\n              }\n            }\n          } catch (e) {\n            Cu.reportError(e);\n          }\n          try {\n            // Ensures the securityUI is initialized.\n            var securityUI = this.securityUI; // eslint-disable-line no-unused-vars\n          } catch (e) {\n          }\n\n          // tabbrowser.xml sets \"sameProcessAsFrameLoader\" as a direct property\n          // on some browsers before they are put into a DOM (and get a\n          // binding).  This hack makes sure that we hold a weak reference to\n          // the other browser (and go through the proper getter and setter).\n          if (this.hasOwnProperty(\"sameProcessAsFrameLoader\")) {\n            var sameProcessAsFrameLoader = this.sameProcessAsFrameLoader;\n            delete this.sameProcessAsFrameLoader;\n            this.sameProcessAsFrameLoader = sameProcessAsFrameLoader;\n          }\n\n          if (!this.isRemoteBrowser) {\n            // If we've transitioned from remote to non-remote, we'll give up trying to\n            // keep the web progress listeners persisted during the transition.\n            delete this._remoteWebProgressManager;\n            delete this._remoteWebProgress;\n\n            this.addEventListener(\"pagehide\", this.onPageHide, true);\n          }\n\n          if (this.messageManager) {\n            this.messageManager.addMessageListener(\"PopupBlocking:UpdateBlockedPopups\", this);\n            this.messageManager.addMessageListener(\"Autoscroll:Start\", this);\n            this.messageManager.addMessageListener(\"Autoscroll:Cancel\", this);\n            this.messageManager.addMessageListener(\"AudioPlayback:Start\", this);\n            this.messageManager.addMessageListener(\"AudioPlayback:Stop\", this);\n            this.messageManager.addMessageListener(\"AudioPlayback:ActiveMediaBlockStart\", this);\n            this.messageManager.addMessageListener(\"AudioPlayback:ActiveMediaBlockStop\", this);\n            this.messageManager.addMessageListener(\"UnselectedTabHover:Toggle\", this);\n            this.messageManager.addMessageListener(\"AudibleAutoplayMediaOccurred\", this);\n\n            if (this.hasAttribute(\"selectmenulist\")) {\n              this.messageManager.addMessageListener(\"Forms:ShowDropDown\", this);\n              this.messageManager.addMessageListener(\"Forms:HideDropDown\", this);\n            }\n\n          }\n        ]]></body>\n      </method>\n\n      <destructor>\n        <![CDATA[\n          this.destroy();\n        ]]>\n      </destructor>\n\n      <!-- This is necessary because the destructor doesn't always get called when\n           we are removed from a tabbrowser. This will be explicitly called by tabbrowser.-->\n      <method name=\"destroy\">\n        <body><![CDATA[\n          // Make sure that any open select is closed.\n          if (this._selectParentHelper) {\n            let menulist = document.getElementById(this.getAttribute(\"selectmenulist\"));\n            this._selectParentHelper.hide(menulist, this);\n          }\n          if (this.mDestroyed)\n            return;\n          this.mDestroyed = true;\n\n          if (this.isRemoteBrowser) {\n            try {\n              this.controllers.removeController(this._controller);\n            } catch (ex) {\n              // This can fail when this browser element is not attached to a\n              // BrowserDOMWindow.\n            }\n\n            if (!this.hasAttribute(\"disablehistory\")) {\n              let Services = ChromeUtils.import(\"resource://gre/modules/Services.jsm\", {}).Services;\n              try {\n                Services.obs.removeObserver(this, \"browser:purge-session-history\");\n              } catch (ex) {\n                // It's not clear why this sometimes throws an exception.\n              }\n            }\n\n            return;\n          }\n\n          if (this.docShell && this.webNavigation.sessionHistory) {\n            var os = Cc[\"@mozilla.org/observer-service;1\"]\n                       .getService(Ci.nsIObserverService);\n            try {\n              os.removeObserver(this, \"browser:purge-session-history\");\n            } catch (ex) {\n              // It's not clear why this sometimes throws an exception.\n            }\n          }\n\n          this._fastFind = null;\n          this._webBrowserFind = null;\n\n          this.lastURI = null;\n\n          if (!this.isRemoteBrowser) {\n            this.removeEventListener(\"pagehide\", this.onPageHide, true);\n          }\n\n          if (this._autoScrollNeedsCleanup) {\n            // we polluted the global scope, so clean it up\n            this._autoScrollPopup.remove();\n          }\n        ]]></body>\n      </method>\n\n\n      <!--\n        We call this _receiveMessage (and alias receiveMessage to it) so that\n        bindings that inherit from this one can delegate to it.\n      -->\n      <method name=\"_receiveMessage\">\n        <parameter name=\"aMessage\"/>\n        <body><![CDATA[\n          let data = aMessage.data;\n          switch (aMessage.name) {\n            case \"PopupBlocking:UpdateBlockedPopups\": {\n              this.blockedPopups = {\n                length: data.count,\n                reported: !data.freshPopup,\n              };\n\n              this.updateBlockedPopups();\n              break;\n            }\n            case \"Autoscroll:Start\": {\n              if (!this.autoscrollEnabled) {\n                return {autoscrollEnabled: false, usingApz: false};\n              }\n              this.startScroll(data.scrolldir, data.screenX, data.screenY);\n              let usingApz = false;\n              if (this.isRemoteBrowser && data.scrollId != null &&\n                  this.mPrefs.getBoolPref(\"apz.autoscroll.enabled\", false)) {\n                let { tabParent } = this.frameLoader;\n                if (tabParent) {\n                  // If APZ is handling the autoscroll, it may decide to cancel\n                  // it of its own accord, so register an observer to allow it\n                  // to notify us of that.\n                  var os = Cc[\"@mozilla.org/observer-service;1\"]\n                             .getService(Ci.nsIObserverService);\n                  os.addObserver(this, \"apz:cancel-autoscroll\", true);\n\n                  usingApz = tabParent.startApzAutoscroll(\n                      data.screenX, data.screenY,\n                      data.scrollId, data.presShellId);\n                }\n                // Save the IDs for later\n                this._autoScrollScrollId = data.scrollId;\n                this._autoScrollPresShellId = data.presShellId;\n              }\n              return {autoscrollEnabled: true, usingApz};\n            }\n            case \"Autoscroll:Cancel\":\n              this._autoScrollPopup.hidePopup();\n              break;\n            case \"AudioPlayback:Start\":\n              this.audioPlaybackStarted();\n              break;\n            case \"AudioPlayback:Stop\":\n              this.audioPlaybackStopped();\n              break;\n            case \"AudioPlayback:ActiveMediaBlockStart\":\n              this.activeMediaBlockStarted();\n              break;\n            case \"AudioPlayback:ActiveMediaBlockStop\":\n              this.activeMediaBlockStopped();\n              break;\n            case \"UnselectedTabHover:Toggle\":\n              this._shouldSendUnselectedTabHover = data.enable ?\n                ++this._unselectedTabHoverMessageListenerCount > 0 :\n                --this._unselectedTabHoverMessageListenerCount == 0;\n              break;\n            case \"AudibleAutoplayMediaOccurred\":\n              this.notifyAudibleAutoplayMediaOccurred();\n              break;\n            case \"Forms:ShowDropDown\": {\n              if (!this._selectParentHelper) {\n                this._selectParentHelper =\n                  ChromeUtils.import(\"resource://gre/modules/SelectParentHelper.jsm\", {}).SelectParentHelper;\n              }\n\n              let menulist = document.getElementById(this.getAttribute(\"selectmenulist\"));\n              menulist.menupopup.style.direction = data.direction;\n              this._selectParentHelper.populate(menulist, data.options, data.selectedIndex, this._fullZoom,\n                                                data.uaBackgroundColor, data.uaColor,\n                                                data.uaSelectBackgroundColor, data.uaSelectColor,\n                                                data.selectBackgroundColor, data.selectColor, data.selectTextShadow);\n              this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);\n              break;\n            }\n\n            case \"Forms:HideDropDown\": {\n              if (this._selectParentHelper) {\n                let menulist = document.getElementById(this.getAttribute(\"selectmenulist\"));\n                this._selectParentHelper.hide(menulist, this);\n              }\n              break;\n            }\n\n          }\n          return undefined;\n        ]]></body>\n      </method>\n\n      <method name=\"receiveMessage\">\n        <parameter name=\"aMessage\"/>\n        <body><![CDATA[\n          if (!this.isRemoteBrowser) {\n            return this._receiveMessage(aMessage);\n          }\n\n          let data = aMessage.data;\n          switch (aMessage.name) {\n            case \"Browser:Init\":\n              this._outerWindowID = data.outerWindowID;\n              break;\n            case \"DOMTitleChanged\":\n              this._contentTitle = data.title;\n              break;\n            case \"ImageDocumentLoaded\":\n              this._imageDocument = {\n                width: data.width,\n                height: data.height,\n              };\n              break;\n\n            case \"Forms:ShowDropDown\": {\n              if (!this._selectParentHelper) {\n                this._selectParentHelper =\n                  ChromeUtils.import(\"resource://gre/modules/SelectParentHelper.jsm\", {}).SelectParentHelper;\n              }\n\n              let menulist = document.getElementById(this.getAttribute(\"selectmenulist\"));\n              menulist.menupopup.style.direction = data.direction;\n\n              let zoom = Services.prefs.getBoolPref(\"browser.zoom.full\") ||\n                         this.isSyntheticDocument ? this._fullZoom : this._textZoom;\n              this._selectParentHelper.populate(menulist, data.options, data.selectedIndex,\n                                                zoom, data.uaBackgroundColor, data.uaColor,\n                                                data.uaSelectBackgroundColor, data.uaSelectColor,\n                                                data.selectBackgroundColor, data.selectColor, data.selectTextShadow);\n              this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);\n              break;\n            }\n\n            case \"FullZoomChange\": {\n              this._fullZoom = data.value;\n              let event = document.createEvent(\"Events\");\n              event.initEvent(\"FullZoomChange\", true, false);\n              this.dispatchEvent(event);\n              break;\n            }\n\n            case \"TextZoomChange\": {\n              this._textZoom = data.value;\n              let event = document.createEvent(\"Events\");\n              event.initEvent(\"TextZoomChange\", true, false);\n              this.dispatchEvent(event);\n              break;\n            }\n\n            case \"ZoomChangeUsingMouseWheel\": {\n              let event = document.createEvent(\"Events\");\n              event.initEvent(\"ZoomChangeUsingMouseWheel\", true, false);\n              this.dispatchEvent(event);\n              break;\n            }\n\n            default:\n              return this._receiveMessage(aMessage);\n          }\n          return undefined;\n\n        ]]></body>\n      </method>\n\n      <method name=\"enableDisableCommandsRemoteOnly\">\n        <parameter name=\"aAction\"/>\n        <parameter name=\"aEnabledLength\"/>\n        <parameter name=\"aEnabledCommands\"/>\n        <parameter name=\"aDisabledLength\"/>\n        <parameter name=\"aDisabledCommands\"/>\n        <body>\n          <![CDATA[\n          if (this._controller) {\n            this._controller.enableDisableCommands(aAction,\n                                                   aEnabledLength, aEnabledCommands,\n                                                   aDisabledLength, aDisabledCommands);\n          }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"observe\">\n        <parameter name=\"aSubject\"/>\n        <parameter name=\"aTopic\"/>\n        <parameter name=\"aState\"/>\n        <body>\n          <![CDATA[\n            if (aTopic == \"browser:purge-session-history\") {\n              this.purgeSessionHistory();\n            } else if (aTopic == \"apz:cancel-autoscroll\") {\n              if (aState == this._autoScrollScrollId) {\n                // Set this._autoScrollScrollId to null, so in stopScroll() we\n                // don't call stopApzAutoscroll() (since it's APZ that\n                // initiated the stopping).\n                this._autoScrollScrollId = null;\n                this._autoScrollPresShellId = null;\n\n                this._autoScrollPopup.hidePopup();\n              }\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"purgeSessionHistory\">\n        <body>\n          <![CDATA[\n            if (this.isRemoteBrowser) {\n              try {\n                this.messageManager.sendAsyncMessage(\"Browser:PurgeSessionHistory\");\n              } catch (ex) {\n                // This can throw if the browser has started to go away.\n                if (ex.result != Cr.NS_ERROR_NOT_INITIALIZED) {\n                  throw ex;\n                }\n              }\n              this._remoteWebNavigationImpl.canGoBack = false;\n              this._remoteWebNavigationImpl.canGoForward = false;\n              return;\n            }\n            this.messageManager.sendAsyncMessage(\"Browser:PurgeSessionHistory\");\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"createAboutBlankContentViewer\">\n        <parameter name=\"aPrincipal\"/>\n        <body>\n          <![CDATA[\n            if (this.isRemoteBrowser) {\n              // Ensure that the content process has the permissions which are\n              // needed to create a document with the given principal.\n              let permissionPrincipal =\n                BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);\n              this.frameLoader.tabParent.transmitPermissionsForPrincipal(permissionPrincipal);\n\n              // Create the about blank content viewer in the content process\n              this.messageManager.sendAsyncMessage(\"Browser:CreateAboutBlank\", aPrincipal);\n              return;\n            }\n            let principal = BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);\n            this.docShell.createAboutBlankContentViewer(principal);\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"_AUTOSCROLL_SNAP\">10</field>\n      <field name=\"_scrolling\">false</field>\n      <field name=\"_startX\">null</field>\n      <field name=\"_startY\">null</field>\n      <field name=\"_autoScrollPopup\">null</field>\n      <field name=\"_autoScrollNeedsCleanup\">false</field>\n      <!-- These IDs identify the scroll frame being autoscrolled. -->\n      <field name=\"_autoScrollScrollId\">null</field>\n      <field name=\"_autoScrollPresShellId\">null</field>\n\n      <method name=\"stopScroll\">\n        <body>\n          <![CDATA[\n            if (this._scrolling) {\n              this._scrolling = false;\n              window.removeEventListener(\"mousemove\", this, true);\n              window.removeEventListener(\"mousedown\", this, true);\n              window.removeEventListener(\"mouseup\", this, true);\n              window.removeEventListener(\"DOMMouseScroll\", this, true);\n              window.removeEventListener(\"contextmenu\", this, true);\n              window.removeEventListener(\"keydown\", this, true);\n              window.removeEventListener(\"keypress\", this, true);\n              window.removeEventListener(\"keyup\", this, true);\n              this.messageManager.sendAsyncMessage(\"Autoscroll:Stop\");\n\n              var os = Cc[\"@mozilla.org/observer-service;1\"]\n                         .getService(Ci.nsIObserverService);\n              try {\n                os.removeObserver(this, \"apz:cancel-autoscroll\");\n              } catch (ex) {\n                // It's not clear why this sometimes throws an exception\n              }\n\n              if (this.isRemoteBrowser && this._autoScrollScrollId != null) {\n                let { tabParent } = this.frameLoader;\n                if (tabParent) {\n                  tabParent.stopApzAutoscroll(this._autoScrollScrollId,\n                                              this._autoScrollPresShellId);\n                }\n                this._autoScrollScrollId = null;\n                this._autoScrollPresShellId = null;\n              }\n            }\n         ]]>\n       </body>\n     </method>\n\n      <method name=\"_createAutoScrollPopup\">\n        <body>\n          <![CDATA[\n            var popup = document.createXULElement(\"panel\");\n            popup.className = \"autoscroller\";\n            // We set this attribute on the element so that mousemove\n            // events can be handled by browser-content.js.\n            popup.setAttribute(\"mousethrough\", \"always\");\n            popup.setAttribute(\"consumeoutsideclicks\", \"true\");\n            popup.setAttribute(\"rolluponmousewheel\", \"true\");\n            popup.setAttribute(\"hidden\", \"true\");\n            return popup;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"startScroll\">\n        <parameter name=\"scrolldir\"/>\n        <parameter name=\"screenX\"/>\n        <parameter name=\"screenY\"/>\n        <body><![CDATA[\n            const POPUP_SIZE = 32;\n            if (!this._autoScrollPopup) {\n              if (this.hasAttribute(\"autoscrollpopup\")) {\n                // our creator provided a popup to share\n                this._autoScrollPopup = document.getElementById(this.getAttribute(\"autoscrollpopup\"));\n              } else {\n                // we weren't provided a popup; we have to use the global scope\n                this._autoScrollPopup = this._createAutoScrollPopup();\n                document.documentElement.appendChild(this._autoScrollPopup);\n                this._autoScrollNeedsCleanup = true;\n              }\n              this._autoScrollPopup.removeAttribute(\"hidden\");\n              this._autoScrollPopup.setAttribute(\"noautofocus\", \"true\");\n              this._autoScrollPopup.style.height = POPUP_SIZE + \"px\";\n              this._autoScrollPopup.style.width = POPUP_SIZE + \"px\";\n              this._autoScrollPopup.style.margin = -POPUP_SIZE / 2 + \"px\";\n            }\n\n            let screenManager = Cc[\"@mozilla.org/gfx/screenmanager;1\"]\n              .getService(Ci.nsIScreenManager);\n            let screen = screenManager.screenForRect(screenX, screenY, 1, 1);\n\n            // we need these attributes so themers don't need to create per-platform packages\n            if (screen.colorDepth > 8) { // need high color for transparency\n              // Exclude second-rate platforms\n              this._autoScrollPopup.setAttribute(\"transparent\", !/BeOS|OS\\/2/.test(navigator.appVersion));\n              // Enable translucency on Windows and Mac\n              this._autoScrollPopup.setAttribute(\"translucent\", /Win|Mac/.test(navigator.platform));\n            }\n\n            this._autoScrollPopup.setAttribute(\"scrolldir\", scrolldir);\n            this._autoScrollPopup.addEventListener(\"popuphidden\", this, true);\n\n            // Sanitize screenX/screenY for available screen size with half the size\n            // of the popup removed. The popup uses negative margins to center on the\n            // coordinates we pass. Unfortunately `window.screen.availLeft` can be negative\n            // on Windows in multi-monitor setups, so we use nsIScreenManager instead:\n            let left = {}, top = {}, width = {}, height = {};\n            screen.GetAvailRect(left, top, width, height);\n\n            // We need to get screen CSS-pixel (rather than display-pixel) coordinates.\n            // With 175% DPI, the actual ratio of display pixels to CSS pixels is\n            // 1.7647 because of rounding inside gecko. Unfortunately defaultCSSScaleFactor\n            // returns the original 1.75 dpi factor. While window.devicePixelRatio would\n            // get us the correct ratio, if the window is split between 2 screens,\n            // window.devicePixelRatio isn't guaranteed to match the screen we're\n            // autoscrolling on. So instead we do the same math as Gecko.\n            const scaleFactor = 60 / Math.round(60 / screen.defaultCSSScaleFactor);\n            let minX = left.value / scaleFactor + 0.5 * POPUP_SIZE;\n            let maxX = (left.value + width.value) / scaleFactor - 0.5 * POPUP_SIZE;\n            let minY = top.value / scaleFactor + 0.5 * POPUP_SIZE;\n            let maxY = (top.value + height.value) / scaleFactor - 0.5 * POPUP_SIZE;\n            let popupX = Math.max(minX, Math.min(maxX, screenX));\n            let popupY = Math.max(minY, Math.min(maxY, screenY));\n            this._autoScrollPopup.openPopupAtScreen(popupX, popupY);\n            this._ignoreMouseEvents = true;\n            this._scrolling = true;\n            this._startX = screenX;\n            this._startY = screenY;\n\n            window.addEventListener(\"mousemove\", this, true);\n            window.addEventListener(\"mousedown\", this, true);\n            window.addEventListener(\"mouseup\", this, true);\n            window.addEventListener(\"DOMMouseScroll\", this, true);\n            window.addEventListener(\"contextmenu\", this, true);\n            window.addEventListener(\"keydown\", this, true);\n            window.addEventListener(\"keypress\", this, true);\n            window.addEventListener(\"keyup\", this, true);\n         ]]>\n        </body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          if (this._scrolling) {\n            switch (aEvent.type) {\n              case \"mousemove\": {\n                var x = aEvent.screenX - this._startX;\n                var y = aEvent.screenY - this._startY;\n\n                if ((x > this._AUTOSCROLL_SNAP || x < -this._AUTOSCROLL_SNAP) ||\n                    (y > this._AUTOSCROLL_SNAP || y < -this._AUTOSCROLL_SNAP))\n                  this._ignoreMouseEvents = false;\n                break;\n              }\n              case \"mouseup\":\n              case \"mousedown\":\n              case \"contextmenu\": {\n                if (!this._ignoreMouseEvents) {\n                  // Use a timeout to prevent the mousedown from opening the popup again.\n                  // Ideally, we could use preventDefault here, but contenteditable\n                  // and middlemouse paste don't interact well. See bug 1188536.\n                  setTimeout(() => this._autoScrollPopup.hidePopup(), 0);\n                }\n                this._ignoreMouseEvents = false;\n                break;\n              }\n              case \"DOMMouseScroll\": {\n                this._autoScrollPopup.hidePopup();\n                aEvent.preventDefault();\n                break;\n              }\n              case \"popuphidden\": {\n                this._autoScrollPopup.removeEventListener(\"popuphidden\", this, true);\n                this.stopScroll();\n                break;\n              }\n              case \"keydown\": {\n                if (aEvent.keyCode == aEvent.DOM_VK_ESCAPE) {\n                  // the escape key will be processed by\n                  // nsXULPopupManager::KeyDown and the panel will be closed.\n                  // So, don't consume the key event here.\n                  break;\n                }\n                // don't break here. we need to eat keydown events.\n              }\n              case \"keypress\":\n              case \"keyup\": {\n                // All keyevents should be eaten here during autoscrolling.\n                aEvent.stopPropagation();\n                aEvent.preventDefault();\n                break;\n              }\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"closeBrowser\">\n        <body>\n        <![CDATA[\n          // The request comes from a XPCOM component, we'd want to redirect\n          // the request to tabbrowser.\n          let tabbrowser = this.getTabBrowser();\n          if (tabbrowser) {\n            let tab = tabbrowser.getTabForBrowser(this);\n            if (tab) {\n              tabbrowser.removeTab(tab);\n              return;\n            }\n          }\n\n          throw new Error(\"Closing a browser which was not attached to a tabbrowser is unsupported.\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"swapBrowsers\">\n        <parameter name=\"aOtherBrowser\"/>\n        <parameter name=\"aFlags\"/>\n        <body>\n        <![CDATA[\n          // The request comes from a XPCOM component, we'd want to redirect\n          // the request to tabbrowser so tabbrowser will be setup correctly,\n          // and it will eventually call swapDocShells.\n          let ourTabBrowser = this.getTabBrowser();\n          let otherTabBrowser = aOtherBrowser.getTabBrowser();\n          if (ourTabBrowser && otherTabBrowser) {\n            let ourTab = ourTabBrowser.getTabForBrowser(this);\n            let otherTab = otherTabBrowser.getTabForBrowser(aOtherBrowser);\n            ourTabBrowser.swapBrowsers(ourTab, otherTab, aFlags);\n            return;\n          }\n\n          // One of us is not connected to a tabbrowser, so just swap.\n          this.swapDocShells(aOtherBrowser);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"swapDocShells\">\n        <parameter name=\"aOtherBrowser\"/>\n        <body>\n        <![CDATA[\n          if (this.isRemoteBrowser != aOtherBrowser.isRemoteBrowser)\n            throw new Error(\"Can only swap docshells between browsers in the same process.\");\n\n          // Give others a chance to swap state.\n          // IMPORTANT: Since a swapDocShells call does not swap the messageManager\n          //            instances attached to a browser to aOtherBrowser, others\n          //            will need to add the message listeners to the new\n          //            messageManager.\n          //            This is not a bug in swapDocShells or the FrameLoader,\n          //            merely a design decision: If message managers were swapped,\n          //            so that no new listeners were needed, the new\n          //            aOtherBrowser.messageManager would have listeners pointing\n          //            to the JS global of the current browser, which would rather\n          //            easily create leaks while swapping.\n          // IMPORTANT2: When the current browser element is removed from DOM,\n          //             which is quite common after a swpDocShells call, its\n          //             frame loader is destroyed, and that destroys the relevant\n          //             message manager, which will remove the listeners.\n          let event = new CustomEvent(\"SwapDocShells\", {\"detail\": aOtherBrowser});\n          this.dispatchEvent(event);\n          event = new CustomEvent(\"SwapDocShells\", {\"detail\": this});\n          aOtherBrowser.dispatchEvent(event);\n\n          // We need to swap fields that are tied to our docshell or related to\n          // the loaded page\n          // Fields which are built as a result of notifactions (pageshow/hide,\n          // DOMLinkAdded/Removed, onStateChange) should not be swapped here,\n          // because these notifications are dispatched again once the docshells\n          // are swapped.\n          var fieldsToSwap = [\n            \"_webBrowserFind\",\n          ];\n\n          if (this.isRemoteBrowser) {\n            fieldsToSwap.push(...[\n              \"_remoteWebNavigation\",\n              \"_remoteWebNavigationImpl\",\n              \"_remoteWebProgressManager\",\n              \"_remoteWebProgress\",\n              \"_remoteFinder\",\n              \"_securityUI\",\n              \"_documentURI\",\n              \"_documentContentType\",\n              \"_contentTitle\",\n              \"_characterSet\",\n              \"_mayEnableCharacterEncodingMenu\",\n              \"_contentPrincipal\",\n              \"_imageDocument\",\n              \"_fullZoom\",\n              \"_textZoom\",\n              \"_isSyntheticDocument\",\n              \"_innerWindowID\",\n            ]);\n          }\n\n          var ourFieldValues = {};\n          var otherFieldValues = {};\n          for (let field of fieldsToSwap) {\n            ourFieldValues[field] = this[field];\n            otherFieldValues[field] = aOtherBrowser[field];\n          }\n\n          if (window.PopupNotifications)\n            PopupNotifications._swapBrowserNotifications(aOtherBrowser, this);\n\n          try {\n            this.swapFrameLoaders(aOtherBrowser);\n          } catch (ex) {\n            // This may not be implemented for browser elements that are not\n            // attached to a BrowserDOMWindow.\n          }\n\n          for (let field of fieldsToSwap) {\n            this[field] = otherFieldValues[field];\n            aOtherBrowser[field] = ourFieldValues[field];\n          }\n\n          if (!this.isRemoteBrowser) {\n            // Null the current nsITypeAheadFind instances so that they're\n            // lazily re-created on access. We need to do this because they\n            // might have attached the wrong docShell.\n            this._fastFind = aOtherBrowser._fastFind = null;\n          } else {\n            // Rewire the remote listeners\n            this._remoteWebNavigationImpl.swapBrowser(this);\n            aOtherBrowser._remoteWebNavigationImpl.swapBrowser(aOtherBrowser);\n\n            if (this._remoteWebProgressManager && aOtherBrowser._remoteWebProgressManager) {\n              this._remoteWebProgressManager.swapBrowser(this);\n              aOtherBrowser._remoteWebProgressManager.swapBrowser(aOtherBrowser);\n            }\n\n            if (this._remoteFinder)\n              this._remoteFinder.swapBrowser(this);\n            if (aOtherBrowser._remoteFinder)\n              aOtherBrowser._remoteFinder.swapBrowser(aOtherBrowser);\n          }\n\n          event = new CustomEvent(\"EndSwapDocShells\", {\"detail\": aOtherBrowser});\n          this.dispatchEvent(event);\n          event = new CustomEvent(\"EndSwapDocShells\", {\"detail\": this});\n          aOtherBrowser.dispatchEvent(event);\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"_permitUnloadId\">0</field>\n      <method name=\"getInPermitUnload\">\n        <parameter name=\"aCallback\"/>\n        <body>\n        <![CDATA[\n          if (this.isRemoteBrowser) {\n            let id = this._permitUnloadId++;\n            let mm = this.messageManager;\n            mm.sendAsyncMessage(\"InPermitUnload\", {id});\n            mm.addMessageListener(\"InPermitUnload\", function listener(msg) {\n              if (msg.data.id != id) {\n                return;\n              }\n              aCallback(msg.data.inPermitUnload);\n            });\n            return;\n          }\n\n          if (!this.docShell || !this.docShell.contentViewer) {\n            aCallback(false);\n            return;\n          }\n          aCallback(this.docShell.contentViewer.inPermitUnload);\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"dontPromptAndDontUnload\"\n                onget=\"return 1;\"\n                readonly=\"true\"/>\n\n      <property name=\"dontPromptAndUnload\"\n                onget=\"return 2;\"\n                readonly=\"true\"/>\n\n      <method name=\"permitUnload\">\n        <parameter name=\"aPermitUnloadFlags\"/>\n        <body>\n        <![CDATA[\n          if (this.isRemoteBrowser) {\n            let {tabParent} = this.frameLoader;\n\n            if (!tabParent.hasBeforeUnload) {\n              return { permitUnload: true, timedOut: false };\n            }\n\n            const kTimeout = 1000;\n\n            let finished = false;\n            let responded = false;\n            let permitUnload;\n            let id = this._permitUnloadId++;\n            let mm = this.messageManager;\n            let Services = ChromeUtils.import(\"resource://gre/modules/Services.jsm\", {}).Services;\n\n            let msgListener = msg => {\n              if (msg.data.id != id) {\n                return;\n              }\n              if (msg.data.kind == \"start\") {\n                responded = true;\n                return;\n              }\n              done(msg.data.permitUnload);\n            };\n\n            let observer = subject => {\n              if (subject == mm) {\n                done(true);\n              }\n            };\n\n            function done(result) {\n              finished = true;\n              permitUnload = result;\n              mm.removeMessageListener(\"PermitUnload\", msgListener);\n              Services.obs.removeObserver(observer, \"message-manager-close\");\n            }\n\n            mm.sendAsyncMessage(\"PermitUnload\", {id, aPermitUnloadFlags});\n            mm.addMessageListener(\"PermitUnload\", msgListener);\n            Services.obs.addObserver(observer, \"message-manager-close\");\n\n            let timedOut = false;\n            function timeout() {\n              if (!responded) {\n                timedOut = true;\n              }\n\n              // Dispatch something to ensure that the main thread wakes up.\n              Services.tm.dispatchToMainThread(function() {});\n            }\n\n            let timer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n            timer.initWithCallback(timeout, kTimeout, timer.TYPE_ONE_SHOT);\n\n            while (!finished && !timedOut) {\n              Services.tm.currentThread.processNextEvent(true);\n            }\n\n            return {permitUnload, timedOut};\n          }\n\n          if (!this.docShell || !this.docShell.contentViewer) {\n            return {permitUnload: true, timedOut: false};\n          }\n          return {permitUnload: this.docShell.contentViewer.permitUnload(aPermitUnloadFlags),\n                  timedOut: false};\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"print\">\n        <parameter name=\"aOuterWindowID\"/>\n        <parameter name=\"aPrintSettings\"/>\n        <parameter name=\"aPrintProgressListener\"/>\n        <body>\n          <![CDATA[\n            if (!this.frameLoader) {\n              throw Components.Exception(\"No frame loader.\",\n                                         Cr.NS_ERROR_FAILURE);\n            }\n\n            this.frameLoader.print(aOuterWindowID, aPrintSettings,\n                                   aPrintProgressListener);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"drawSnapshot\">\n        <parameter name=\"x\"/>\n        <parameter name=\"y\"/>\n        <parameter name=\"w\"/>\n        <parameter name=\"h\"/>\n        <parameter name=\"scale\"/>\n        <parameter name=\"backgroundColor\"/>\n        <body>\n          <![CDATA[\n            if (!this.frameLoader) {\n              throw Components.Exception(\"No frame loader.\",\n                                         Cr.NS_ERROR_FAILURE);\n            }\n            return this.frameLoader.drawSnapshot(x, y, w, h, scale, backgroundColor);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"dropLinks\">\n        <parameter name=\"aLinksCount\"/>\n        <parameter name=\"aLinks\"/>\n        <parameter name=\"aTriggeringPrincipal\"/>\n        <body><![CDATA[\n          if (!this.droppedLinkHandler) {\n            return false;\n          }\n          let links = [];\n          for (let i = 0; i < aLinksCount; i += 3) {\n            links.push({\n              url: aLinks[i],\n              name: aLinks[i + 1],\n              type: aLinks[i + 2],\n            });\n          }\n          this.droppedLinkHandler(null, links, aTriggeringPrincipal);\n          return true;\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_F7\" group=\"system\">\n        <![CDATA[\n          if (event.defaultPrevented || !event.isTrusted)\n            return;\n\n          const kPrefShortcutEnabled = \"accessibility.browsewithcaret_shortcut.enabled\";\n          const kPrefWarnOnEnable    = \"accessibility.warn_on_browsewithcaret\";\n          const kPrefCaretBrowsingOn = \"accessibility.browsewithcaret\";\n\n          var isEnabled = this.mPrefs.getBoolPref(kPrefShortcutEnabled);\n          if (!isEnabled)\n            return;\n\n          // Toggle browse with caret mode\n          var browseWithCaretOn = this.mPrefs.getBoolPref(kPrefCaretBrowsingOn, false);\n          var warn = this.mPrefs.getBoolPref(kPrefWarnOnEnable, true);\n          if (warn && !browseWithCaretOn) {\n            var checkValue = {value: false};\n            var promptService = Cc[\"@mozilla.org/embedcomp/prompt-service;1\"]\n                                  .getService(Ci.nsIPromptService);\n\n            var buttonPressed = promptService.confirmEx(window,\n              this.mStrBundle.GetStringFromName(\"browsewithcaret.checkWindowTitle\"),\n              this.mStrBundle.GetStringFromName(\"browsewithcaret.checkLabel\"),\n              // Make \"No\" the default:\n              promptService.STD_YES_NO_BUTTONS | promptService.BUTTON_POS_1_DEFAULT,\n              null, null, null, this.mStrBundle.GetStringFromName(\"browsewithcaret.checkMsg\"),\n              checkValue);\n            if (buttonPressed != 0) {\n              if (checkValue.value) {\n                try {\n                  this.mPrefs.setBoolPref(kPrefShortcutEnabled, false);\n                } catch (ex) {\n                }\n              }\n              return;\n            }\n            if (checkValue.value) {\n              try {\n                this.mPrefs.setBoolPref(kPrefWarnOnEnable, false);\n              } catch (ex) {\n              }\n            }\n          }\n\n          // Toggle the pref\n          try {\n            this.mPrefs.setBoolPref(kPrefCaretBrowsingOn, !browseWithCaretOn);\n          } catch (ex) {\n          }\n        ]]>\n      </handler>\n      <handler event=\"dragover\" group=\"system\">\n      <![CDATA[\n        if (!this.droppedLinkHandler || event.defaultPrevented)\n          return;\n\n        // For drags that appear to be internal text (for example, tab drags),\n        // set the dropEffect to 'none'. This prevents the drop even if some\n        // other listener cancelled the event.\n        var types = event.dataTransfer.types;\n        if (types.includes(\"text/x-moz-text-internal\") && !types.includes(\"text/plain\")) {\n          event.dataTransfer.dropEffect = \"none\";\n          event.stopPropagation();\n          event.preventDefault();\n        }\n\n        // No need to handle \"dragover\" in e10s, since nsDocShellTreeOwner.cpp in the child process\n        // handles that case using \"@mozilla.org/content/dropped-link-handler;1\" service.\n        if (this.isRemoteBrowser)\n          return;\n\n        let linkHandler = Cc[\"@mozilla.org/content/dropped-link-handler;1\"].\n                            getService(Ci.nsIDroppedLinkHandler);\n        if (linkHandler.canDropLink(event, false))\n          event.preventDefault();\n      ]]>\n      </handler>\n      <handler event=\"drop\" group=\"system\">\n      <![CDATA[\n        // No need to handle \"drop\" in e10s, since nsDocShellTreeOwner.cpp in the child process\n        // handles that case using \"@mozilla.org/content/dropped-link-handler;1\" service.\n        if (!this.droppedLinkHandler || event.defaultPrevented || this.isRemoteBrowser)\n          return;\n\n        let linkHandler = Cc[\"@mozilla.org/content/dropped-link-handler;1\"].\n                            getService(Ci.nsIDroppedLinkHandler);\n        try {\n          // Pass true to prevent the dropping of javascript:/data: URIs\n          var links = linkHandler.dropLinks(event, true);\n        } catch (ex) {\n          return;\n        }\n\n        if (links.length) {\n          let triggeringPrincipal = linkHandler.getTriggeringPrincipal(event);\n          this.droppedLinkHandler(event, links, triggeringPrincipal);\n        }\n      ]]>\n      </handler>\n      <handler event=\"dragstart\">\n      <![CDATA[\n        // If we're a remote browser dealing with a dragstart, stop it\n        // from propagating up, since our content process should be dealing\n        // with the mouse movement.\n        if (this.isRemoteBrowser) {\n          event.stopPropagation();\n        }\n      ]]>\n      </handler>\n    </handlers>\n\n  </binding>\n\n</bindings>\n"},{"file":"button.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"buttonBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"button-base\" extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <implementation implements=\"nsIDOMXULButtonElement\">\n      <property name=\"type\"\n                onget=\"return this.getAttribute('type');\"\n                onset=\"this.setAttribute('type', val); return val;\"/>\n\n      <property name=\"dlgType\"\n                onget=\"return this.getAttribute('dlgtype');\"\n                onset=\"this.setAttribute('dlgtype', val); return val;\"/>\n\n      <property name=\"group\"\n                onget=\"return this.getAttribute('group');\"\n                onset=\"this.setAttribute('group', val); return val;\"/>\n\n      <property name=\"open\" onget=\"return this.hasAttribute('open');\">\n        <setter><![CDATA[\n          if (this.hasMenu()) {\n            this.openMenu(val);\n          } else if (val) {\n            // Fall back to just setting the attribute\n            this.setAttribute(\"open\", \"true\");\n          } else {\n            this.removeAttribute(\"open\");\n          }\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"checked\" onget=\"return this.hasAttribute('checked');\">\n        <setter><![CDATA[\n          if (this.type == \"radio\" && val) {\n            var sibs = this.parentNode.getElementsByAttribute(\"group\", this.group);\n            for (var i = 0; i < sibs.length; ++i)\n              sibs[i].removeAttribute(\"checked\");\n          }\n\n          if (val)\n            this.setAttribute(\"checked\", \"true\");\n          else\n            this.removeAttribute(\"checked\");\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <method name =\"filterButtons\">\n        <parameter name=\"node\"/>\n        <body>\n        <![CDATA[\n          // if the node isn't visible, don't descend into it.\n          var cs = node.ownerGlobal.getComputedStyle(node);\n          if (cs.visibility != \"visible\" || cs.display == \"none\") {\n            return NodeFilter.FILTER_REJECT;\n          }\n          // but it may be a popup element, in which case we look at \"state\"...\n          if (cs.display == \"-moz-popup\" && node.state != \"open\") {\n            return NodeFilter.FILTER_REJECT;\n          }\n          // OK - the node seems visible, so it is a candidate.\n          if (node.localName == \"button\" && node.accessKey && !node.disabled)\n            return NodeFilter.FILTER_ACCEPT;\n          return NodeFilter.FILTER_SKIP;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"fireAccessKeyButton\">\n        <parameter name=\"aSubtree\"/>\n        <parameter name=\"aAccessKeyLower\"/>\n        <body>\n        <![CDATA[\n          var iterator = aSubtree.ownerDocument.createTreeWalker(aSubtree,\n                                                                 NodeFilter.SHOW_ELEMENT,\n                                                                 this.filterButtons);\n          while (iterator.nextNode()) {\n            var test = iterator.currentNode;\n            if (test.accessKey.toLowerCase() == aAccessKeyLower &&\n                !test.disabled && !test.collapsed && !test.hidden) {\n              test.focus();\n              test.click();\n              return true;\n            }\n          }\n          return false;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_handleClick\">\n        <body>\n        <![CDATA[\n          if (!this.disabled) {\n            if (this.type == \"checkbox\") {\n              this.checked = !this.checked;\n            } else if (this.type == \"radio\") {\n              this.checked = true;\n            }\n          }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <!-- While it would seem we could do this by handling oncommand, we can't\n           because any external oncommand handlers might get called before ours,\n           and then they would see the incorrect value of checked. Additionally\n           a command attribute would redirect the command events anyway.-->\n      <handler event=\"click\" button=\"0\" action=\"this._handleClick();\"/>\n      <handler event=\"keypress\" key=\" \">\n      <![CDATA[\n        this._handleClick();\n        // Prevent page from scrolling on the space key.\n        event.preventDefault();\n      ]]>\n      </handler>\n\n      <handler event=\"keypress\">\n      <![CDATA[\n        if (this.hasMenu()) {\n          if (this.open)\n            return;\n        } else {\n          if (event.keyCode == KeyEvent.DOM_VK_UP ||\n              (event.keyCode == KeyEvent.DOM_VK_LEFT &&\n                document.defaultView.getComputedStyle(this.parentNode)\n                        .direction == \"ltr\") ||\n              (event.keyCode == KeyEvent.DOM_VK_RIGHT &&\n                document.defaultView.getComputedStyle(this.parentNode)\n                        .direction == \"rtl\")) {\n            event.preventDefault();\n            window.document.commandDispatcher.rewindFocus();\n            return;\n          }\n\n          if (event.keyCode == KeyEvent.DOM_VK_DOWN ||\n              (event.keyCode == KeyEvent.DOM_VK_RIGHT &&\n                document.defaultView.getComputedStyle(this.parentNode)\n                        .direction == \"ltr\") ||\n              (event.keyCode == KeyEvent.DOM_VK_LEFT &&\n                document.defaultView.getComputedStyle(this.parentNode)\n                        .direction == \"rtl\")) {\n            event.preventDefault();\n            window.document.commandDispatcher.advanceFocus();\n            return;\n          }\n        }\n\n        if (event.keyCode || event.charCode <= 32 || event.altKey ||\n            event.ctrlKey || event.metaKey)\n          return; // No printable char pressed, not a potential accesskey\n\n        // Possible accesskey pressed\n        var charPressedLower = String.fromCharCode(event.charCode).toLowerCase();\n\n        // If the accesskey of the current button is pressed, just activate it\n        if (this.accessKey.toLowerCase() == charPressedLower) {\n          this.click();\n          return;\n        }\n\n        // Search for accesskey in the list of buttons for this doc and each subdoc\n        // Get the buttons for the main document and all sub-frames\n        for (var frameCount = -1; frameCount < window.top.frames.length; frameCount++) {\n          var doc = (frameCount == -1) ? window.top.document :\n            window.top.frames[frameCount].document;\n          if (this.fireAccessKeyButton(doc.documentElement, charPressedLower))\n            return;\n        }\n\n        // Test anonymous buttons\n        var dlg = window.top.document;\n        var buttonBox = dlg.getAnonymousElementByAttribute(dlg.documentElement,\n                                                         \"anonid\", \"buttons\");\n        if (buttonBox)\n          this.fireAccessKeyButton(buttonBox, charPressedLower);\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"button\" display=\"xul:button\"\n           extends=\"chrome://global/content/bindings/button.xml#button-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/skin/button.css\"/>\n    </resources>\n\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:hbox class=\"box-inherit button-box\" xbl:inherits=\"align,dir,pack,orient\"\n                align=\"center\" pack=\"center\" flex=\"1\" anonid=\"button-box\">\n        <xul:image class=\"button-icon\" xbl:inherits=\"src=image\"/>\n        <xul:label class=\"button-text\" xbl:inherits=\"value=label,accesskey,crop,highlightable\"/>\n        <xul:label class=\"button-highlightable-text\" xbl:inherits=\"xbl:text=label,accesskey,crop,highlightable\"/>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"menu\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/button.xml#button\">\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:hbox class=\"box-inherit button-box\" xbl:inherits=\"align,dir,pack,orient\"\n                align=\"center\" pack=\"center\" flex=\"1\">\n        <xul:hbox class=\"box-inherit\" xbl:inherits=\"align,dir,pack,orient\"\n                  align=\"center\" pack=\"center\" flex=\"1\">\n          <xul:image class=\"button-icon\" xbl:inherits=\"src=image\"/>\n          <xul:label class=\"button-text\" xbl:inherits=\"value=label,accesskey,crop\"/>\n        </xul:hbox>\n        <xul:dropmarker class=\"button-menu-dropmarker\" xbl:inherits=\"open,disabled,label\"/>\n      </xul:hbox>\n    </content>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\" action=\"this.open = true;\"/>\n      <handler event=\"keypress\" key=\" \">\n      <![CDATA[\n        this.open = true;\n        // Prevent page from scrolling on the space key.\n        event.preventDefault();\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"checkbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"checkboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"checkbox\"\n    extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <content>\n      <xul:image class=\"checkbox-check\" xbl:inherits=\"checked,disabled\"/>\n      <xul:hbox class=\"checkbox-label-box\" flex=\"1\">\n        <xul:image class=\"checkbox-icon\" xbl:inherits=\"src\"/>\n        <xul:label class=\"checkbox-label\" xbl:inherits=\"xbl:text=label,accesskey,crop\" flex=\"1\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <method name=\"setChecked\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          var change = (aValue != (this.getAttribute(\"checked\") == \"true\"));\n          if (aValue)\n            this.setAttribute(\"checked\", \"true\");\n          else\n            this.removeAttribute(\"checked\");\n          if (change) {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"CheckboxStateChange\", true, true);\n            this.dispatchEvent(event);\n          }\n          return aValue;\n        ]]>\n        </body>\n      </method>\n\n      <!-- public implementation -->\n      <property name=\"checked\"    onset=\"return this.setChecked(val);\"\n                                  onget=\"return this.getAttribute('checked') == 'true';\"/>\n    </implementation>\n\n    <handlers>\n      <!-- While it would seem we could do this by handling oncommand, we need can't\n           because any external oncommand handlers might get called before ours, and\n           then they would see the incorrect value of checked. -->\n      <handler event=\"click\" button=\"0\" action=\"if (!this.disabled) this.checked = !this.checked;\"/>\n      <handler event=\"keypress\" key=\" \">\n        <![CDATA[\n          this.checked = !this.checked;\n          // Prevent page from scrolling on the space key.\n          event.preventDefault();\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"datetimebox.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings [\n<!ENTITY % datetimeboxDTD SYSTEM \"chrome://global/locale/datetimebox.dtd\">\n%datetimeboxDTD;\n]>\n\n<bindings id=\"datetimeboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"date-input\"\n           simpleScopeChain=\"true\"\n           extends=\"chrome://global/content/bindings/datetimebox.xml#datetime-input-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/content/bindings/datetimebox.css\"/>\n    </resources>\n\n    <implementation>\n      <constructor>\n      <![CDATA[\n        /* eslint-disable no-multi-spaces */\n        this.mYearPlaceHolder = ]]>\"FROM-DTD.date.year.placeholder;\"<![CDATA[;\n        this.mMonthPlaceHolder = ]]>\"FROM-DTD.date.month.placeholder;\"<![CDATA[;\n        this.mDayPlaceHolder = ]]>\"FROM-DTD.date.day.placeholder;\"<![CDATA[;\n\n        this.mYearLabel = ]]>\"FROM-DTD.date.year.label;\"<![CDATA[;\n        this.mMonthLabel = ]]>\"FROM-DTD.date.month.label;\"<![CDATA[;\n        this.mDayLabel = ]]>\"FROM-DTD.date.day.label;\"<![CDATA[;\n        /* eslint-enable no-multi-spaces */\n\n        this.mMinMonth = 1;\n        this.mMaxMonth = 12;\n        this.mMinDay = 1;\n        this.mMaxDay = 31;\n        this.mMinYear = 1;\n        // Maximum year limited by ECMAScript date object range, year <= 275760.\n        this.mMaxYear = 275760;\n        this.mMonthDayLength = 2;\n        this.mYearLength = 4;\n        this.mMonthPageUpDownInterval = 3;\n        this.mDayPageUpDownInterval = 7;\n        this.mYearPageUpDownInterval = 10;\n\n        this.buildEditFields();\n\n        if (this.mInputElement.value) {\n          this.setFieldsFromInputValue();\n        }\n      ]]>\n      </constructor>\n\n      <method name=\"buildEditFields\">\n        <body>\n        <![CDATA[\n          const HTML_NS = \"http://www.w3.org/1999/xhtml\";\n          let root =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n\n          let yearMaxLength = this.mMaxYear.toString().length;\n          this.mYearField = this.createEditField(this.mYearPlaceHolder,\n            this.mYearLabel, true, this.mYearLength, yearMaxLength,\n            this.mMinYear, this.mMaxYear, this.mYearPageUpDownInterval);\n          this.mMonthField = this.createEditField(this.mMonthPlaceHolder,\n            this.mMonthLabel, true, this.mMonthDayLength, this.mMonthDayLength,\n            this.mMinMonth, this.mMaxMonth, this.mMonthPageUpDownInterval);\n          this.mDayField = this.createEditField(this.mDayPlaceHolder,\n            this.mDayLabel, true, this.mMonthDayLength, this.mMonthDayLength,\n            this.mMinDay, this.mMaxDay, this.mDayPageUpDownInterval);\n\n          let fragment = document.createDocumentFragment();\n          let formatter = Intl.DateTimeFormat(this.mLocales, {\n            year: \"numeric\",\n            month: \"numeric\",\n            day: \"numeric\",\n          });\n          formatter.formatToParts(Date.now()).map(part => {\n            switch (part.type) {\n              case \"year\":\n                fragment.appendChild(this.mYearField);\n                break;\n              case \"month\":\n                fragment.appendChild(this.mMonthField);\n                break;\n              case \"day\":\n                fragment.appendChild(this.mDayField);\n                break;\n              default:\n                let span = document.createElementNS(HTML_NS, \"span\");\n                span.textContent = part.value;\n                fragment.appendChild(span);\n                break;\n            }\n          });\n\n          root.appendChild(fragment);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"clearInputFields\">\n        <parameter name=\"aFromInputElement\"/>\n        <body>\n        <![CDATA[\n          this.log(\"clearInputFields\");\n\n          if (this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          if (this.mMonthField && !this.mMonthField.disabled &&\n              !this.mMonthField.readOnly) {\n            this.clearFieldValue(this.mMonthField);\n          }\n\n          if (this.mDayField && !this.mDayField.disabled &&\n              !this.mDayField.readOnly) {\n            this.clearFieldValue(this.mDayField);\n          }\n\n          if (this.mYearField && !this.mYearField.disabled &&\n              !this.mYearField.readOnly) {\n            this.clearFieldValue(this.mYearField);\n          }\n\n          if (!aFromInputElement) {\n            if (this.mInputElement.value) {\n              this.mInputElement.setUserInput(\"\");\n            } else {\n              this.mInputElement.updateValidityState();\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setFieldsFromInputValue\">\n        <body>\n        <![CDATA[\n          let value = this.mInputElement.value;\n          if (!value) {\n            this.clearInputFields(true);\n            return;\n          }\n\n          this.log(\"setFieldsFromInputValue: \" + value);\n          let [year, month, day] = value.split(\"-\");\n\n          this.setFieldValue(this.mYearField, year);\n          this.setFieldValue(this.mMonthField, month);\n          this.setFieldValue(this.mDayField, day);\n\n          this.notifyPicker();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setInputValueFromFields\">\n        <body>\n        <![CDATA[\n          if (this.isAnyFieldEmpty()) {\n            // Clear input element's value if any of the field has been cleared,\n            // otherwise update the validity state, since it may become \"not\"\n            // invalid if fields are not complete.\n            if (this.mInputElement.value) {\n              this.mInputElement.setUserInput(\"\");\n            } else {\n              this.mInputElement.updateValidityState();\n            }\n            // We still need to notify picker in case any of the field has\n            // changed.\n            this.notifyPicker();\n            return;\n          }\n\n          let { year, month, day } = this.getCurrentValue();\n\n          // Convert to a valid date string according to:\n          // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-date-string\n          year = year.toString().padStart(this.mYearLength, \"0\");\n          month = (month < 10) ? (\"0\" + month) : month;\n          day = (day < 10) ? (\"0\" + day) : day;\n\n          let date = [year, month, day].join(\"-\");\n\n          if (date == this.mInputElement.value) {\n            return;\n          }\n\n          this.log(\"setInputValueFromFields: \" + date);\n          this.notifyPicker();\n          this.mInputElement.setUserInput(date);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setFieldsFromPicker\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          let year = aValue.year;\n          let month = aValue.month;\n          let day = aValue.day;\n\n          if (!this.isEmpty(year)) {\n            this.setFieldValue(this.mYearField, year);\n          }\n\n          if (!this.isEmpty(month)) {\n            this.setFieldValue(this.mMonthField, month);\n          }\n\n          if (!this.isEmpty(day)) {\n            this.setFieldValue(this.mDayField, day);\n          }\n\n          // Update input element's .value if needed.\n          this.setInputValueFromFields();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"handleKeypress\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          if (this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          let targetField = aEvent.originalTarget;\n          let key = aEvent.key;\n\n          if (targetField.classList.contains(\"numeric\") && key.match(/[0-9]/)) {\n            let buffer = targetField.getAttribute(\"typeBuffer\") || \"\";\n\n            buffer = buffer.concat(key);\n            this.setFieldValue(targetField, buffer);\n\n            let n = Number(buffer);\n            let max = targetField.getAttribute(\"max\");\n            let maxLength = targetField.getAttribute(\"maxlength\");\n            if (buffer.length >= maxLength || n * 10 > max) {\n              buffer = \"\";\n              this.advanceToNextField();\n            }\n            targetField.setAttribute(\"typeBuffer\", buffer);\n            this.setInputValueFromFields();\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"incrementFieldValue\">\n        <parameter name=\"aTargetField\"/>\n        <parameter name=\"aTimes\"/>\n        <body>\n        <![CDATA[\n          let value = this.getFieldValue(aTargetField);\n\n          // Use current date if field is empty.\n          if (this.isEmpty(value)) {\n            let now = new Date();\n\n            if (aTargetField == this.mYearField) {\n              value = now.getFullYear();\n            } else if (aTargetField == this.mMonthField) {\n              value = now.getMonth() + 1;\n            } else if (aTargetField == this.mDayField) {\n              value = now.getDate();\n            } else {\n              this.log(\"Field not supported in incrementFieldValue.\");\n              return;\n            }\n          }\n\n          let min = Number(aTargetField.getAttribute(\"min\"));\n          let max = Number(aTargetField.getAttribute(\"max\"));\n\n          value += Number(aTimes);\n          if (value > max) {\n            value -= (max - min + 1);\n          } else if (value < min) {\n            value += (max - min + 1);\n          }\n\n          this.setFieldValue(aTargetField, value);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"handleKeyboardNav\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          if (this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          let targetField = aEvent.originalTarget;\n          let key = aEvent.key;\n\n          // Home/End key does nothing on year field.\n          if (targetField == this.mYearField && (key == \"Home\" ||\n                                                 key == \"End\")) {\n            return;\n          }\n\n          switch (key) {\n            case \"ArrowUp\":\n              this.incrementFieldValue(targetField, 1);\n              break;\n            case \"ArrowDown\":\n              this.incrementFieldValue(targetField, -1);\n              break;\n            case \"PageUp\": {\n              let interval = targetField.getAttribute(\"pginterval\");\n              this.incrementFieldValue(targetField, interval);\n              break;\n            }\n            case \"PageDown\": {\n              let interval = targetField.getAttribute(\"pginterval\");\n              this.incrementFieldValue(targetField, 0 - interval);\n              break;\n            }\n            case \"Home\":\n              let min = targetField.getAttribute(\"min\");\n              this.setFieldValue(targetField, min);\n              break;\n            case \"End\":\n              let max = targetField.getAttribute(\"max\");\n              this.setFieldValue(targetField, max);\n              break;\n          }\n          this.setInputValueFromFields();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getCurrentValue\">\n        <body>\n        <![CDATA[\n          let year = this.getFieldValue(this.mYearField);\n          let month = this.getFieldValue(this.mMonthField);\n          let day = this.getFieldValue(this.mDayField);\n\n          let date = { year, month, day };\n\n          this.log(\"getCurrentValue: \" + JSON.stringify(date));\n          return date;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setFieldValue\">\n       <parameter name=\"aField\"/>\n       <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          if (!aField || !aField.classList.contains(\"numeric\")) {\n            return;\n          }\n\n          let value = Number(aValue);\n          if (isNaN(value)) {\n            this.log(\"NaN on setFieldValue!\");\n            return;\n          }\n\n          let maxLength = aField.getAttribute(\"maxlength\");\n          if (aValue.length == maxLength) {\n            let min = Number(aField.getAttribute(\"min\"));\n            let max = Number(aField.getAttribute(\"max\"));\n\n            if (value < min) {\n              value = min;\n            } else if (value > max) {\n              value = max;\n            }\n          }\n\n          aField.setAttribute(\"rawValue\", value);\n\n          // Display formatted value based on locale.\n          let minDigits = aField.getAttribute(\"mindigits\");\n          let formatted = value.toLocaleString(this.mLocales, {\n            minimumIntegerDigits: minDigits,\n            useGrouping: false,\n          });\n\n          aField.textContent = formatted;\n          aField.setAttribute(\"aria-valuetext\", formatted);\n          this.updateResetButtonVisibility();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isAnyFieldAvailable\">\n        <parameter name=\"aForPicker\"/>\n        <body>\n        <![CDATA[\n          let { year, month, day } = this.getCurrentValue();\n\n          return !this.isEmpty(year) || !this.isEmpty(month) ||\n                 !this.isEmpty(day);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isAnyFieldEmpty\">\n        <body>\n        <![CDATA[\n          let { year, month, day } = this.getCurrentValue();\n\n          return (this.isEmpty(year) || this.isEmpty(month) ||\n                  this.isEmpty(day));\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n  </binding>\n\n  <binding id=\"time-input\"\n           simpleScopeChain=\"true\"\n           extends=\"chrome://global/content/bindings/datetimebox.xml#datetime-input-base\">\n    <resources>\n      <stylesheet src=\"chrome://global/content/bindings/datetimebox.css\"/>\n    </resources>\n\n    <implementation>\n      <property name=\"kMsPerSecond\" readonly=\"true\" onget=\"return 1000;\" />\n      <property name=\"kMsPerMinute\" readonly=\"true\" onget=\"return (60 * 1000);\" />\n\n      <constructor>\n      <![CDATA[\n        const kDefaultAMString = \"AM\";\n        const kDefaultPMString = \"PM\";\n\n        let { amString, pmString } =\n          this.getStringsForLocale(this.mLocales);\n\n        this.mAMIndicator = amString || kDefaultAMString;\n        this.mPMIndicator = pmString || kDefaultPMString;\n\n        /* eslint-disable no-multi-spaces */\n        this.mHourPlaceHolder = ]]>\"FROM-DTD.time.hour.placeholder;\"<![CDATA[;\n        this.mMinutePlaceHolder = ]]>\"FROM-DTD.time.minute.placeholder;\"<![CDATA[;\n        this.mSecondPlaceHolder = ]]>\"FROM-DTD.time.second.placeholder;\"<![CDATA[;\n        this.mMillisecPlaceHolder = ]]>\"FROM-DTD.time.millisecond.placeholder;\"<![CDATA[;\n        this.mDayPeriodPlaceHolder = ]]>\"FROM-DTD.time.dayperiod.placeholder;\"<![CDATA[;\n\n        this.mHourLabel = ]]>\"FROM-DTD.time.hour.label;\"<![CDATA[;\n        this.mMinuteLabel = ]]>\"FROM-DTD.time.minute.label;\"<![CDATA[;\n        this.mSecondLabel = ]]>\"FROM-DTD.time.second.label;\"<![CDATA[;\n        this.mMillisecLabel = ]]>\"FROM-DTD.time.millisecond.label;\"<![CDATA[;\n        this.mDayPeriodLabel = ]]>\"FROM-DTD.time.dayperiod.label;\"<![CDATA[;\n        /* eslint-enable no-multi-spaces */\n\n        this.mHour12 = this.is12HourTime(this.mLocales);\n        this.mMillisecSeparatorText = \".\";\n        this.mMaxLength = 2;\n        this.mMillisecMaxLength = 3;\n        this.mDefaultStep = 60 * 1000; // in milliseconds\n\n        this.mMinHour = this.mHour12 ? 1 : 0;\n        this.mMaxHour = this.mHour12 ? 12 : 23;\n        this.mMinMinute = 0;\n        this.mMaxMinute = 59;\n        this.mMinSecond = 0;\n        this.mMaxSecond = 59;\n        this.mMinMillisecond = 0;\n        this.mMaxMillisecond = 999;\n\n        this.mHourPageUpDownInterval = 3;\n        this.mMinSecPageUpDownInterval = 10;\n\n        this.buildEditFields();\n\n        if (this.mInputElement.value) {\n          this.setFieldsFromInputValue();\n        }\n        ]]>\n      </constructor>\n\n      <method name=\"getInputElementValues\">\n        <body>\n        <![CDATA[\n          let value = this.mInputElement.value;\n          if (value.length === 0) {\n            return {};\n          }\n\n          let hour, minute, second, millisecond;\n          [hour, minute, second] = value.split(\":\");\n          if (second) {\n            [second, millisecond] = second.split(\".\");\n\n            // Convert fraction of second to milliseconds.\n            if (millisecond && millisecond.length === 1) {\n              millisecond *= 100;\n            } else if (millisecond && millisecond.length === 2) {\n              millisecond *= 10;\n            }\n          }\n\n          return { hour, minute, second, millisecond };\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"hasSecondField\">\n        <body>\n        <![CDATA[\n          return !!this.mSecondField;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"hasMillisecField\">\n        <body>\n        <![CDATA[\n          return !!this.mMillisecField;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"hasDayPeriodField\">\n        <body>\n        <![CDATA[\n          return !!this.mDayPeriodField;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"shouldShowSecondField\">\n        <body>\n        <![CDATA[\n          let { second } = this.getInputElementValues();\n          if (second != undefined) {\n            return true;\n          }\n\n          let stepBase = this.mInputElement.getStepBase();\n          if ((stepBase % this.kMsPerMinute) != 0) {\n            return true;\n          }\n\n          let step = this.mInputElement.getStep();\n          if ((step % this.kMsPerMinute) != 0) {\n            return true;\n          }\n\n          return false;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"shouldShowMillisecField\">\n        <body>\n        <![CDATA[\n          let { millisecond } = this.getInputElementValues();\n          if (millisecond != undefined) {\n            return true;\n          }\n\n          let stepBase = this.mInputElement.getStepBase();\n          if ((stepBase % this.kMsPerSecond) != 0) {\n            return true;\n          }\n\n          let step = this.mInputElement.getStep();\n          if ((step % this.kMsPerSecond) != 0) {\n            return true;\n          }\n\n          return false;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"rebuildEditFieldsIfNeeded\">\n        <body>\n        <![CDATA[\n          if ((this.shouldShowSecondField() == this.hasSecondField()) &&\n              (this.shouldShowMillisecField() == this.hasMillisecField())) {\n            return;\n          }\n\n          let root =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n          while (root.firstChild) {\n            root.firstChild.remove();\n          }\n\n          this.mHourField = null;\n          this.mMinuteField = null;\n          this.mSecondField = null;\n          this.mMillisecField = null;\n\n          this.buildEditFields();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"buildEditFields\">\n        <body>\n        <![CDATA[\n          const HTML_NS = \"http://www.w3.org/1999/xhtml\";\n          let root =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n\n          let options = {\n            hour: \"numeric\",\n            minute: \"numeric\",\n            hour12: this.mHour12,\n          };\n\n          this.mHourField = this.createEditField(this.mHourPlaceHolder,\n            this.mHourLabel, true, this.mMaxLength, this.mMaxLength,\n            this.mMinHour, this.mMaxHour, this.mHourPageUpDownInterval);\n          this.mMinuteField = this.createEditField(this.mMinutePlaceHolder,\n            this.mMinuteLabel, true, this.mMaxLength, this.mMaxLength,\n            this.mMinMinute, this.mMaxMinute, this.mMinSecPageUpDownInterval);\n\n          if (this.mHour12) {\n            this.mDayPeriodField = this.createEditField(\n              this.mDayPeriodPlaceHolder, this.mDayPeriodLabel, false);\n\n            // Give aria autocomplete hint for am/pm\n            this.mDayPeriodField.setAttribute(\"aria-autocomplete\", \"inline\");\n          }\n\n          if (this.shouldShowSecondField()) {\n            options.second = \"numeric\";\n            this.mSecondField = this.createEditField(this.mSecondPlaceHolder,\n              this.mSecondLabel, true, this.mMaxLength, this.mMaxLength,\n              this.mMinSecond, this.mMaxSecond, this.mMinSecPageUpDownInterval);\n\n            if (this.shouldShowMillisecField()) {\n              this.mMillisecField = this.createEditField(\n                this.mMillisecPlaceHolder, this.mMillisecLabel, true,\n                this.mMillisecMaxLength, this.mMillisecMaxLength,\n                this.mMinMillisecond, this.mMaxMillisecond,\n                this.mMinSecPageUpDownInterval);\n            }\n          }\n\n          let fragment = document.createDocumentFragment();\n          let formatter = Intl.DateTimeFormat(this.mLocales, options);\n          formatter.formatToParts(Date.now()).map(part => {\n            switch (part.type) {\n              case \"hour\":\n                fragment.appendChild(this.mHourField);\n                break;\n              case \"minute\":\n                fragment.appendChild(this.mMinuteField);\n                break;\n              case \"second\":\n                fragment.appendChild(this.mSecondField);\n                if (this.shouldShowMillisecField()) {\n                  // Intl.DateTimeFormat does not support millisecond, so we\n                  // need to handle this on our own.\n                  let span = document.createElementNS(HTML_NS, \"span\");\n                  span.textContent = this.mMillisecSeparatorText;\n                  fragment.appendChild(span);\n                  fragment.appendChild(this.mMillisecField);\n                }\n                break;\n              case \"dayPeriod\":\n                fragment.appendChild(this.mDayPeriodField);\n                break;\n              default:\n                let span = document.createElementNS(HTML_NS, \"span\");\n                span.textContent = part.value;\n                fragment.appendChild(span);\n                break;\n            }\n          });\n\n          root.appendChild(fragment);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getStringsForLocale\">\n        <parameter name=\"aLocales\"/>\n        <body>\n        <![CDATA[\n          this.log(\"getStringsForLocale: \" + aLocales);\n\n          let intlUtils = window.intlUtils;\n          if (!intlUtils) {\n            return {};\n          }\n\n          let amString, pmString;\n          let keys = [ \"dates/gregorian/dayperiods/am\",\n                       \"dates/gregorian/dayperiods/pm\" ];\n\n          let result = intlUtils.getDisplayNames(this.mLocales, {\n            style: \"short\",\n            keys,\n          });\n\n          [ amString, pmString ] = keys.map(key => result.values[key]);\n\n          return { amString, pmString };\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"is12HourTime\">\n        <parameter name=\"aLocales\"/>\n          <body>\n          <![CDATA[\n            let options = (new Intl.DateTimeFormat(aLocales, {\n              hour: \"numeric\",\n            })).resolvedOptions();\n\n            return options.hour12;\n          ]]>\n          </body>\n      </method>\n\n      <method name=\"setFieldsFromInputValue\">\n        <body>\n        <![CDATA[\n          let { hour, minute, second, millisecond } =\n            this.getInputElementValues();\n\n          if (this.isEmpty(hour) && this.isEmpty(minute)) {\n            this.clearInputFields(true);\n            return;\n          }\n\n          // Second and millisecond part are optional, rebuild edit fields if\n          // needed.\n          this.rebuildEditFieldsIfNeeded();\n\n          this.setFieldValue(this.mHourField, hour);\n          this.setFieldValue(this.mMinuteField, minute);\n          if (this.mHour12) {\n            this.setDayPeriodValue(hour >= this.mMaxHour ? this.mPMIndicator\n                                                         : this.mAMIndicator);\n          }\n\n          if (this.hasSecondField()) {\n            this.setFieldValue(this.mSecondField,\n              (second != undefined) ? second : 0);\n          }\n\n          if (this.hasMillisecField()) {\n            this.setFieldValue(this.mMillisecField,\n              (millisecond != undefined) ? millisecond : 0);\n          }\n\n          this.notifyPicker();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setInputValueFromFields\">\n        <body>\n        <![CDATA[\n          if (this.isAnyFieldEmpty()) {\n            // Clear input element's value if any of the field has been cleared,\n            // otherwise update the validity state, since it may become \"not\"\n            // invalid if fields are not complete.\n            if (this.mInputElement.value) {\n              this.mInputElement.setUserInput(\"\");\n            } else {\n              this.mInputElement.updateValidityState();\n            }\n            // We still need to notify picker in case any of the field has\n            // changed.\n            this.notifyPicker();\n            return;\n          }\n\n          let { hour, minute, second, millisecond } = this.getCurrentValue();\n          let dayPeriod = this.getDayPeriodValue();\n\n          // Convert to a valid time string according to:\n          // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-time-string\n          if (this.mHour12) {\n            if (dayPeriod == this.mPMIndicator && hour < this.mMaxHour) {\n              hour += this.mMaxHour;\n            } else if (dayPeriod == this.mAMIndicator &&\n                       hour == this.mMaxHour) {\n              hour = 0;\n            }\n          }\n\n          hour = (hour < 10) ? (\"0\" + hour) : hour;\n          minute = (minute < 10) ? (\"0\" + minute) : minute;\n\n          let time = hour + \":\" + minute;\n          if (second != undefined) {\n            second = (second < 10) ? (\"0\" + second) : second;\n            time += \":\" + second;\n          }\n\n          if (millisecond != undefined) {\n            // Convert milliseconds to fraction of second.\n            millisecond = millisecond.toString().padStart(\n              this.mMillisecMaxLength, \"0\");\n            time += \".\" + millisecond;\n          }\n\n          if (time == this.mInputElement.value) {\n            return;\n          }\n\n          this.log(\"setInputValueFromFields: \" + time);\n          this.notifyPicker();\n          this.mInputElement.setUserInput(time);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setFieldsFromPicker\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          let hour = aValue.hour;\n          let minute = aValue.minute;\n          this.log(\"setFieldsFromPicker: \" + hour + \":\" + minute);\n\n          if (!this.isEmpty(hour)) {\n            this.setFieldValue(this.mHourField, hour);\n            if (this.mHour12) {\n              this.setDayPeriodValue(hour >= this.mMaxHour ? this.mPMIndicator\n                                                           : this.mAMIndicator);\n            }\n          }\n\n          if (!this.isEmpty(minute)) {\n            this.setFieldValue(this.mMinuteField, minute);\n          }\n\n          // Update input element's .value if needed.\n          this.setInputValueFromFields();\n        ]]>\n        </body>\n       </method>\n\n      <method name=\"clearInputFields\">\n        <parameter name=\"aFromInputElement\"/>\n        <body>\n        <![CDATA[\n          this.log(\"clearInputFields\");\n\n          if (this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          if (this.mHourField && !this.mHourField.disabled &&\n              !this.mHourField.readOnly) {\n            this.clearFieldValue(this.mHourField);\n          }\n\n          if (this.mMinuteField && !this.mMinuteField.disabled &&\n              !this.mMinuteField.readOnly) {\n            this.clearFieldValue(this.mMinuteField);\n          }\n\n          if (this.hasSecondField() && !this.mSecondField.disabled &&\n              !this.mSecondField.readOnly) {\n            this.clearFieldValue(this.mSecondField);\n          }\n\n          if (this.hasMillisecField() && !this.mMillisecField.disabled &&\n              !this.mMillisecField.readOnly) {\n            this.clearFieldValue(this.mMillisecField);\n          }\n\n          if (this.hasDayPeriodField() && !this.mDayPeriodField.disabled &&\n              !this.mDayPeriodField.readOnly) {\n            this.clearFieldValue(this.mDayPeriodField);\n          }\n\n          if (!aFromInputElement) {\n            if (this.mInputElement.value) {\n              this.mInputElement.setUserInput(\"\");\n            } else {\n              this.mInputElement.updateValidityState();\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"notifyMinMaxStepAttrChanged\">\n        <body>\n        <![CDATA[\n          // Second and millisecond part are optional, rebuild edit fields if\n          // needed.\n          this.rebuildEditFieldsIfNeeded();\n          // Fill in values again.\n          this.setFieldsFromInputValue();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"incrementFieldValue\">\n        <parameter name=\"aTargetField\"/>\n        <parameter name=\"aTimes\"/>\n        <body>\n        <![CDATA[\n          let value = this.getFieldValue(aTargetField);\n\n          // Use current time if field is empty.\n          if (this.isEmpty(value)) {\n            let now = new Date();\n\n            if (aTargetField == this.mHourField) {\n              value = now.getHours();\n              if (this.mHour12) {\n                value = (value % this.mMaxHour) || this.mMaxHour;\n              }\n            } else if (aTargetField == this.mMinuteField) {\n              value = now.getMinutes();\n            } else if (aTargetField == this.mSecondField) {\n              value = now.getSeconds();\n            } else if (aTargetField == this.mMillisecField) {\n              value = now.getMilliseconds();\n            } else {\n              this.log(\"Field not supported in incrementFieldValue.\");\n              return;\n            }\n          }\n\n          let min = aTargetField.getAttribute(\"min\");\n          let max = aTargetField.getAttribute(\"max\");\n\n          value += Number(aTimes);\n          if (value > max) {\n            value -= (max - min + 1);\n          } else if (value < min) {\n            value += (max - min + 1);\n          }\n\n          this.setFieldValue(aTargetField, value);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"handleKeyboardNav\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          if (this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          let targetField = aEvent.originalTarget;\n          let key = aEvent.key;\n\n          if (this.hasDayPeriodField() &&\n              targetField == this.mDayPeriodField) {\n            // Home/End key does nothing on AM/PM field.\n            if (key == \"Home\" || key == \"End\") {\n              return;\n            }\n\n            this.setDayPeriodValue(\n              this.getDayPeriodValue() == this.mAMIndicator ? this.mPMIndicator\n                                                            : this.mAMIndicator);\n            this.setInputValueFromFields();\n            return;\n          }\n\n          switch (key) {\n            case \"ArrowUp\":\n              this.incrementFieldValue(targetField, 1);\n              break;\n            case \"ArrowDown\":\n              this.incrementFieldValue(targetField, -1);\n              break;\n            case \"PageUp\": {\n              let interval = targetField.getAttribute(\"pginterval\");\n              this.incrementFieldValue(targetField, interval);\n              break;\n            }\n            case \"PageDown\": {\n              let interval = targetField.getAttribute(\"pginterval\");\n              this.incrementFieldValue(targetField, 0 - interval);\n              break;\n            }\n            case \"Home\":\n              let min = targetField.getAttribute(\"min\");\n              this.setFieldValue(targetField, min);\n              break;\n            case \"End\":\n              let max = targetField.getAttribute(\"max\");\n              this.setFieldValue(targetField, max);\n              break;\n          }\n          this.setInputValueFromFields();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"handleKeypress\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          if (this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          let targetField = aEvent.originalTarget;\n          let key = aEvent.key;\n\n          if (this.hasDayPeriodField() &&\n              targetField == this.mDayPeriodField) {\n            if (key == \"a\" || key == \"A\") {\n              this.setDayPeriodValue(this.mAMIndicator);\n            } else if (key == \"p\" || key == \"P\") {\n              this.setDayPeriodValue(this.mPMIndicator);\n            }\n            this.setInputValueFromFields();\n            return;\n          }\n\n          if (targetField.classList.contains(\"numeric\") && key.match(/[0-9]/)) {\n            let buffer = targetField.getAttribute(\"typeBuffer\") || \"\";\n\n            buffer = buffer.concat(key);\n            this.setFieldValue(targetField, buffer);\n\n            let n = Number(buffer);\n            let max = targetField.getAttribute(\"max\");\n            let maxLength = targetField.getAttribute(\"maxLength\");\n            if (buffer.length >= maxLength || n * 10 > max) {\n              buffer = \"\";\n              this.advanceToNextField();\n            }\n            targetField.setAttribute(\"typeBuffer\", buffer);\n            this.setInputValueFromFields();\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setFieldValue\">\n       <parameter name=\"aField\"/>\n       <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          if (!aField || !aField.classList.contains(\"numeric\")) {\n            return;\n          }\n\n          let value = Number(aValue);\n          if (isNaN(value)) {\n            this.log(\"NaN on setFieldValue!\");\n            return;\n          }\n\n          if (aField == this.mHourField) {\n            if (this.mHour12) {\n              // Try to change to 12hr format if user input is 0 or greater\n              // than 12.\n              let maxLength = aField.getAttribute(\"maxlength\");\n              if (value == 0 && aValue.length == maxLength) {\n                value = this.mMaxHour;\n              } else {\n                value = (value > this.mMaxHour) ? value % this.mMaxHour : value;\n              }\n            } else if (value > this.mMaxHour) {\n              value = this.mMaxHour;\n            }\n          }\n\n          aField.setAttribute(\"rawValue\", value);\n\n          let minDigits = aField.getAttribute(\"mindigits\");\n          let formatted = value.toLocaleString(this.mLocales, {\n            minimumIntegerDigits: minDigits,\n            useGrouping: false,\n          });\n\n          aField.textContent = formatted;\n          aField.setAttribute(\"aria-valuetext\", formatted);\n          this.updateResetButtonVisibility();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getDayPeriodValue\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          if (!this.hasDayPeriodField()) {\n            return \"\";\n          }\n\n          let placeholder = this.mDayPeriodField.placeholder;\n          let value = this.mDayPeriodField.textContent;\n\n          return (value == placeholder ? \"\" : value);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setDayPeriodValue\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          if (!this.hasDayPeriodField()) {\n            return;\n          }\n\n          this.mDayPeriodField.textContent = aValue;\n          this.updateResetButtonVisibility();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isAnyFieldAvailable\">\n        <parameter name=\"aForPicker\"/>\n        <body>\n        <![CDATA[\n          let { hour, minute, second, millisecond } = this.getCurrentValue();\n          let dayPeriod = this.getDayPeriodValue();\n\n          let available = !this.isEmpty(hour) || !this.isEmpty(minute);\n          if (available) {\n            return true;\n          }\n\n          // Picker only cares about hour:minute.\n          if (aForPicker) {\n            return false;\n          }\n\n          return (this.hasDayPeriodField() && !this.isEmpty(dayPeriod)) ||\n                 (this.hasSecondField() && !this.isEmpty(second)) ||\n                 (this.hasMillisecField() && !this.isEmpty(millisecond));\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isAnyFieldEmpty\">\n        <body>\n        <![CDATA[\n          let { hour, minute, second, millisecond } = this.getCurrentValue();\n          let dayPeriod = this.getDayPeriodValue();\n\n          return (this.isEmpty(hour) || this.isEmpty(minute) ||\n                  (this.hasDayPeriodField() && this.isEmpty(dayPeriod)) ||\n                  (this.hasSecondField() && this.isEmpty(second)) ||\n                  (this.hasMillisecField() && this.isEmpty(millisecond)));\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getCurrentValue\">\n        <body>\n        <![CDATA[\n          let hour = this.getFieldValue(this.mHourField);\n          if (!this.isEmpty(hour)) {\n            if (this.mHour12) {\n              let dayPeriod = this.getDayPeriodValue();\n              if (dayPeriod == this.mPMIndicator && hour < this.mMaxHour) {\n                hour += this.mMaxHour;\n              } else if (dayPeriod == this.mAMIndicator &&\n                         hour == this.mMaxHour) {\n                hour = 0;\n              }\n            }\n          }\n\n          let minute = this.getFieldValue(this.mMinuteField);\n          let second = this.getFieldValue(this.mSecondField);\n          let millisecond = this.getFieldValue(this.mMillisecField);\n\n          let time = { hour, minute, second, millisecond };\n\n          this.log(\"getCurrentValue: \" + JSON.stringify(time));\n          return time;\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"datetime-input-base\"\n           simpleScopeChain=\"true\">\n    <resources>\n      <stylesheet src=\"chrome://global/content/bindings/datetimebox.css\"/>\n    </resources>\n\n    <content>\n      <html:div class=\"datetime-input-box-wrapper\" anonid=\"input-box-wrapper\"\n                xbl:inherits=\"context,disabled,readonly\" role=\"presentation\">\n        <html:span class=\"datetime-input-edit-wrapper\"\n                   anonid=\"edit-wrapper\">\n          <!-- Each of the date/time input types will append their input child\n             - elements here -->\n        </html:span>\n\n        <html:button class=\"datetime-reset-button\" anonid=\"reset-button\"\n                     tabindex=\"-1\" xbl:inherits=\"disabled\" aria-label=\"FROM-DTD.datetime.reset.label;\">\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"12\">\n            <path d=\"M 3.9,3 3,3.9 5.1,6 3,8.1 3.9,9 6,6.9 8.1,9 9,8.1 6.9,6 9,3.9 8.1,3 6,5.1 Z M 12,6 A 6,6 0 0 1 6,12 6,6 0 0 1 0,6 6,6 0 0 1 6,0 6,6 0 0 1 12,6 Z\"/>\n          </svg>\n        </html:button>\n      </html:div>\n    </content>\n\n    <implementation implements=\"nsIDateTimeInputArea\">\n      <constructor>\n      <![CDATA[\n        this.DEBUG = false;\n        this.mInputElement = this.parentNode;\n        this.mLocales = window.getRegionalPrefsLocales();\n\n        this.mIsRTL = false;\n        let intlUtils = window.intlUtils;\n        if (intlUtils) {\n          this.mIsRTL =\n            intlUtils.getLocaleInfo(this.mLocales).direction === \"rtl\";\n        }\n\n        if (this.mIsRTL) {\n          let inputBoxWrapper =\n            document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                    \"input-box-wrapper\");\n          inputBoxWrapper.dir = \"rtl\";\n        }\n\n        this.mMin = this.mInputElement.min;\n        this.mMax = this.mInputElement.max;\n        this.mStep = this.mInputElement.step;\n        this.mIsPickerOpen = false;\n\n        this.mResetButton =\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"reset-button\");\n        this.mResetButton.style.visibility = \"hidden\";\n\n        this.EVENTS.forEach((eventName) => {\n          this.addEventListener(eventName, this, { mozSystemGroup: true }, false);\n        });\n        // Handle keypress separately since we need to catch it on capturing.\n        this.addEventListener(\"keypress\", this, {\n          capture: true,\n          mozSystemGroup: true,\n        }, false);\n        // This is to open the picker when input element is clicked (this\n        // includes padding area).\n        this.mInputElement.addEventListener(\"click\", this,\n                                            { mozSystemGroup: true },\n                                            false);\n      ]]>\n      </constructor>\n\n      <destructor>\n      <![CDATA[\n        this.EVENTS.forEach((eventName) => {\n          this.removeEventListener(eventName, this, { mozSystemGroup: true });\n        });\n        this.removeEventListener(\"keypress\", this, {\n          capture: true,\n          mozSystemGroup: true,\n        });\n        this.mInputElement.removeEventListener(\"click\", this,\n                                               { mozSystemGroup: true });\n\n        this.mInputElement = null;\n      ]]>\n      </destructor>\n\n      <property name=\"EVENTS\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          return [\"focus\", \"blur\", \"copy\", \"cut\", \"paste\", \"mousedown\"];\n        ]]>\n        </getter>\n      </property>\n\n      <method name=\"log\">\n        <parameter name=\"aMsg\"/>\n        <body>\n        <![CDATA[\n          if (this.DEBUG) {\n            dump(\"[DateTimeBox] \" + aMsg + \"\\n\");\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"createEditField\">\n        <parameter name=\"aPlaceHolder\"/>\n        <parameter name=\"aLabel\"/>\n        <parameter name=\"aIsNumeric\"/>\n        <parameter name=\"aMinDigits\"/>\n        <parameter name=\"aMaxLength\"/>\n        <parameter name=\"aMinValue\"/>\n        <parameter name=\"aMaxValue\"/>\n        <parameter name=\"aPageUpDownInterval\"/>\n        <body>\n        <![CDATA[\n          const HTML_NS = \"http://www.w3.org/1999/xhtml\";\n\n          let field = document.createElementNS(HTML_NS, \"span\");\n          field.classList.add(\"datetime-edit-field\");\n          field.textContent = aPlaceHolder;\n          field.placeholder = aPlaceHolder;\n          field.tabIndex = this.mInputElement.tabIndex;\n\n          field.setAttribute(\"readonly\", this.mInputElement.readOnly);\n          field.setAttribute(\"disabled\", this.mInputElement.disabled);\n          // Set property as well for convenience.\n          field.disabled = this.mInputElement.disabled;\n          field.readOnly = this.mInputElement.readOnly;\n          field.setAttribute(\"aria-label\", aLabel);\n\n          if (aIsNumeric) {\n            field.classList.add(\"numeric\");\n            // Maximum value allowed.\n            field.setAttribute(\"min\", aMinValue);\n            // Minumim value allowed.\n            field.setAttribute(\"max\", aMaxValue);\n            // Interval when pressing pageUp/pageDown key.\n            field.setAttribute(\"pginterval\", aPageUpDownInterval);\n            // Used to store what the user has already typed in the field,\n            // cleared when value is cleared and when field is blurred.\n            field.setAttribute(\"typeBuffer\", \"\");\n            // Used to store the non-formatted number, clered when value is\n            // cleared.\n            field.setAttribute(\"rawValue\", \"\");\n            // Minimum digits to display, padded with leading 0s.\n            field.setAttribute(\"mindigits\", aMinDigits);\n            // Maximum length for the field, will be advance to the next field\n            // automatically if exceeded.\n            field.setAttribute(\"maxlength\", aMaxLength);\n            // Set spinbutton ARIA role\n            field.setAttribute(\"role\", \"spinbutton\");\n\n            if (this.mIsRTL) {\n              // Force the direction to be \"ltr\", so that the field stays in the\n              // same order even when it's empty (with placeholder). By using\n              // \"embed\", the text inside the element is still displayed based\n              // on its directionality.\n              field.style.unicodeBidi = \"embed\";\n              field.style.direction = \"ltr\";\n            }\n          } else {\n            // Set generic textbox ARIA role\n            field.setAttribute(\"role\", \"textbox\");\n          }\n\n          return field;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"updateResetButtonVisibility\">\n        <body>\n          <![CDATA[\n            if (this.isAnyFieldAvailable(false)) {\n              this.mResetButton.style.visibility = \"visible\";\n            } else {\n              this.mResetButton.style.visibility = \"hidden\";\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"focusInnerTextBox\">\n        <body>\n        <![CDATA[\n          this.log(\"Focus inner editable field.\");\n\n          let editRoot =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n\n          for (let child = editRoot.firstChild; child; child = child.nextSibling) {\n            if ((child instanceof HTMLSpanElement) &&\n                child.classList.contains(\"datetime-edit-field\")) {\n              this.mLastFocusedField = child;\n              child.focus();\n              break;\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"blurInnerTextBox\">\n        <body>\n        <![CDATA[\n          this.log(\"Blur inner editable field.\");\n\n          if (this.mLastFocusedField) {\n            this.mLastFocusedField.blur();\n          } else {\n            // If .mLastFocusedField hasn't been set, blur all editable fields,\n            // so that the bound element will actually be blurred. Note that\n            // blurring on a element that has no focus won't have any effect.\n            let editRoot =\n              document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n            for (let child = editRoot.firstChild; child; child = child.nextSibling) {\n              if ((child instanceof HTMLSpanElement) &&\n                  child.classList.contains(\"datetime-edit-field\")) {\n                child.blur();\n              }\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"notifyInputElementValueChanged\">\n        <body>\n        <![CDATA[\n          this.log(\"inputElementValueChanged\");\n          this.setFieldsFromInputValue();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"notifyMinMaxStepAttrChanged\">\n        <body>\n        <!-- No operation by default -->\n        </body>\n      </method>\n\n      <method name=\"setValueFromPicker\">\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          this.setFieldsFromPicker(aValue);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"hasBadInput\">\n        <body>\n        <![CDATA[\n          // Incomplete field does not imply bad input.\n          if (this.isAnyFieldEmpty()) {\n            return false;\n          }\n\n          // All fields are available but input element's value is empty implies\n          // it has been sanitized.\n          if (!this.mInputElement.value) {\n            return true;\n          }\n\n          return false;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"advanceToNextField\">\n        <parameter name=\"aReverse\"/>\n        <body>\n        <![CDATA[\n          this.log(\"advanceToNextField\");\n\n          let focusedInput = this.mLastFocusedField;\n          let next = aReverse ? focusedInput.previousElementSibling\n                              : focusedInput.nextElementSibling;\n          if (!next && !aReverse) {\n            this.setInputValueFromFields();\n            return;\n          }\n\n          while (next) {\n            if ((next instanceof HTMLSpanElement) &&\n                next.classList.contains(\"datetime-edit-field\")) {\n              next.focus();\n              break;\n            }\n            next = aReverse ? next.previousElementSibling\n                            : next.nextElementSibling;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setPickerState\">\n        <parameter name=\"aIsOpen\"/>\n        <body>\n        <![CDATA[\n          this.log(\"picker is now \" + (aIsOpen ? \"opened\" : \"closed\"));\n          this.mIsPickerOpen = aIsOpen;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setEditAttribute\">\n        <parameter name=\"aName\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n        <![CDATA[\n          this.log(\"setAttribute: \" + aName + \"=\" + aValue);\n\n          if (aName != \"tabindex\" && aName != \"disabled\" &&\n              aName != \"readonly\") {\n            return;\n          }\n\n          let editRoot =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n\n          for (let child = editRoot.firstChild; child; child = child.nextSibling) {\n            if ((child instanceof HTMLSpanElement) &&\n                child.classList.contains(\"datetime-edit-field\")) {\n\n              switch (aName) {\n                case \"tabindex\":\n                  child.setAttribute(aName, aValue);\n                  break;\n                case \"disabled\": {\n                  let value = this.mInputElement.disabled;\n                  child.setAttribute(\"disabled\", value);\n                  child.disabled = value;\n                  break;\n                }\n                case \"readonly\": {\n                  let value = this.mInputElement.readOnly;\n                  child.setAttribute(\"readonly\", value);\n                  child.readOnly = value;\n                  break;\n                }\n              }\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"removeEditAttribute\">\n        <parameter name=\"aName\"/>\n        <body>\n        <![CDATA[\n          this.log(\"removeAttribute: \" + aName);\n\n          if (aName != \"tabindex\" && aName != \"disabled\" &&\n              aName != \"readonly\") {\n            return;\n          }\n\n          let editRoot =\n            document.getAnonymousElementByAttribute(this, \"anonid\", \"edit-wrapper\");\n\n          for (let child = editRoot.firstChild; child; child = child.nextSibling) {\n            if ((child instanceof HTMLSpanElement) &&\n                child.classList.contains(\"datetime-edit-field\")) {\n              child.removeAttribute(aName);\n              // Update property as well.\n              if (aName == \"readonly\") {\n                child.readOnly = false;\n              } else if (aName == \"disabled\") {\n                child.disabled = false;\n              }\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isEmpty\">\n        <parameter name=\"aValue\"/>\n        <body>\n          return (aValue == undefined || 0 === aValue.length);\n        </body>\n      </method>\n\n      <method name=\"getFieldValue\">\n        <parameter name=\"aField\"/>\n        <body>\n        <![CDATA[\n          if (!aField || !aField.classList.contains(\"numeric\")) {\n            return undefined;\n          }\n\n          let value = aField.getAttribute(\"rawValue\");\n          // Avoid returning 0 when field is empty.\n          return (this.isEmpty(value) ? undefined : Number(value));\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"clearFieldValue\">\n        <parameter name=\"aField\"/>\n        <body>\n        <![CDATA[\n          aField.textContent = aField.placeholder;\n          if (aField.classList.contains(\"numeric\")) {\n            aField.setAttribute(\"typeBuffer\", \"\");\n            aField.setAttribute(\"rawValue\", \"\");\n          }\n          this.updateResetButtonVisibility();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"setFieldValue\">\n        <body>\n          throw Cr.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"clearInputFields\">\n        <body>\n          throw Cr.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"setFieldsFromInputValue\">\n        <body>\n          throw Cr.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"setInputValueFromFields\">\n        <body>\n          throw Cr.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"setFieldsFromPicker\">\n        <body>\n          throw Cr.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"handleKeypress\">\n        <body>\n          throw Cr.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"handleKeyboardNav\">\n        <body>\n          throw Cr.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"getCurrentValue\">\n        <body>\n          throw Cr.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"isAnyFieldAvailable\">\n        <body>\n          throw Cr.NS_ERROR_NOT_IMPLEMENTED;\n        </body>\n      </method>\n\n      <method name=\"notifyPicker\">\n        <body>\n        <![CDATA[\n          if (this.mIsPickerOpen && this.isAnyFieldAvailable(true)) {\n            this.mInputElement.updateDateTimePicker(this.getCurrentValue());\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isDisabled\">\n        <body>\n        <![CDATA[\n          return this.mInputElement.hasAttribute(\"disabled\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"isReadonly\">\n        <body>\n        <![CDATA[\n          return this.mInputElement.hasAttribute(\"readonly\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          this.log(\"handleEvent: \" + aEvent.type);\n\n          switch (aEvent.type) {\n            case \"keypress\": {\n              this.onKeyPress(aEvent);\n              break;\n            }\n            case \"click\": {\n              this.onClick(aEvent);\n              break;\n            }\n            case \"focus\": {\n              this.onFocus(aEvent);\n              break;\n            }\n            case \"blur\": {\n              this.onBlur(aEvent);\n              break;\n            }\n            case \"mousedown\": {\n              if (aEvent.originalTarget == this.mResetButton) {\n                aEvent.preventDefault();\n              }\n              break;\n            }\n            case \"copy\":\n            case \"cut\":\n            case \"paste\": {\n              aEvent.preventDefault();\n              break;\n            }\n            default:\n              break;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"onFocus\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          this.log(\"onFocus originalTarget: \" + aEvent.originalTarget);\n\n          if (document.activeElement != this.mInputElement) {\n            return;\n          }\n\n          let target = aEvent.originalTarget;\n          if ((target instanceof HTMLSpanElement) &&\n              target.classList.contains(\"datetime-edit-field\")) {\n            if (target.disabled) {\n              return;\n            }\n            this.mLastFocusedField = target;\n            this.mInputElement.setFocusState(true);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"onBlur\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          this.log(\"onBlur originalTarget: \" + aEvent.originalTarget +\n            \" target: \" + aEvent.target);\n\n          let target = aEvent.originalTarget;\n          target.setAttribute(\"typeBuffer\", \"\");\n          this.setInputValueFromFields();\n          this.mInputElement.setFocusState(false);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"onKeyPress\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          this.log(\"onKeyPress key: \" + aEvent.key);\n\n          switch (aEvent.key) {\n            // Close picker on Enter, Escape or Space key.\n            case \"Enter\":\n            case \"Escape\":\n            case \" \": {\n              if (this.mIsPickerOpen) {\n                this.mInputElement.closeDateTimePicker();\n                aEvent.preventDefault();\n              }\n              break;\n            }\n            case \"Backspace\": {\n              let targetField = aEvent.originalTarget;\n              this.clearFieldValue(targetField);\n              this.setInputValueFromFields();\n              aEvent.preventDefault();\n              break;\n            }\n            case \"ArrowRight\":\n            case \"ArrowLeft\": {\n              this.advanceToNextField(!(aEvent.key == \"ArrowRight\"));\n              aEvent.preventDefault();\n              break;\n            }\n            case \"ArrowUp\":\n            case \"ArrowDown\":\n            case \"PageUp\":\n            case \"PageDown\":\n            case \"Home\":\n            case \"End\": {\n              this.handleKeyboardNav(aEvent);\n              aEvent.preventDefault();\n              break;\n            }\n            default: {\n              // printable characters\n              if (aEvent.keyCode == 0 &&\n                  !(aEvent.ctrlKey || aEvent.altKey || aEvent.metaKey)) {\n                this.handleKeypress(aEvent);\n                aEvent.preventDefault();\n              }\n              break;\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"onClick\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          this.log(\"onClick originalTarget: \" + aEvent.originalTarget +\n                   \" target: \" + aEvent.target);\n\n          if (aEvent.defaultPrevented || this.isDisabled() || this.isReadonly()) {\n            return;\n          }\n\n          if (aEvent.originalTarget == this.mResetButton) {\n            this.clearInputFields(false);\n          } else if (!this.mIsPickerOpen) {\n            this.mInputElement.openDateTimePicker(this.getCurrentValue());\n          }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"datetimepopup.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"dateTimePopupBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n  <binding id=\"datetime-popup\"\n           extends=\"chrome://global/content/bindings/popup.xml#arrowpanel\">\n    <implementation>\n      <property name=\"dateTimePopupFrame\">\n        <getter>\n          let frame = this.querySelector(\"#dateTimePopupFrame\");\n          if (!frame) {\n            frame = this.ownerDocument.createXULElement(\"iframe\");\n            frame.id = \"dateTimePopupFrame\";\n            this.appendChild(frame);\n          }\n          return frame;\n        </getter>\n      </property>\n      <field name=\"TIME_PICKER_WIDTH\" readonly=\"true\">\"12em\"</field>\n      <field name=\"TIME_PICKER_HEIGHT\" readonly=\"true\">\"21em\"</field>\n      <field name=\"DATE_PICKER_WIDTH\" readonly=\"true\">\"23.1em\"</field>\n      <field name=\"DATE_PICKER_HEIGHT\" readonly=\"true\">\"20.7em\"</field>\n      <constructor><![CDATA[\n        this.mozIntl = Cc[\"@mozilla.org/mozintl;1\"]\n                         .getService(Ci.mozIMozIntl);\n        // Notify DateTimePickerParent.jsm that binding is ready.\n        this.dispatchEvent(new CustomEvent(\"DateTimePickerBindingReady\"));\n      ]]></constructor>\n      <method name=\"openPicker\">\n        <parameter name=\"type\"/>\n        <parameter name=\"anchor\"/>\n        <parameter name=\"detail\"/>\n        <body><![CDATA[\n          this.type = type;\n          this.pickerState = {};\n          // TODO: Resize picker according to content zoom level\n          this.style.fontSize = \"10px\";\n          switch (type) {\n            case \"time\": {\n              this.detail = detail;\n              this.dateTimePopupFrame.addEventListener(\"load\", this, true);\n              this.dateTimePopupFrame.setAttribute(\"src\", \"chrome://global/content/timepicker.xhtml\");\n              this.dateTimePopupFrame.style.width = this.TIME_PICKER_WIDTH;\n              this.dateTimePopupFrame.style.height = this.TIME_PICKER_HEIGHT;\n              break;\n            }\n            case \"date\": {\n              this.detail = detail;\n              this.dateTimePopupFrame.addEventListener(\"load\", this, true);\n              this.dateTimePopupFrame.setAttribute(\"src\", \"chrome://global/content/datepicker.xhtml\");\n              this.dateTimePopupFrame.style.width = this.DATE_PICKER_WIDTH;\n              this.dateTimePopupFrame.style.height = this.DATE_PICKER_HEIGHT;\n              break;\n            }\n          }\n          this.hidden = false;\n          this.openPopup(anchor, \"after_start\", 0, 0);\n        ]]></body>\n      </method>\n      <method name=\"closePicker\">\n        <body><![CDATA[\n          this.setInputBoxValue(true);\n          this.pickerState = {};\n          this.type = undefined;\n          this.dateTimePopupFrame.removeEventListener(\"load\", this, true);\n          this.dateTimePopupFrame.contentDocument.removeEventListener(\"message\", this);\n          this.dateTimePopupFrame.setAttribute(\"src\", \"\");\n          this.hidden = true;\n        ]]></body>\n      </method>\n      <method name=\"setPopupValue\">\n        <parameter name=\"data\"/>\n        <body><![CDATA[\n          switch (this.type) {\n            case \"time\": {\n              this.postMessageToPicker({\n                name: \"PickerSetValue\",\n                detail: data.value,\n              });\n              break;\n            }\n            case \"date\": {\n              const { year, month, day } = data.value;\n              this.postMessageToPicker({\n                name: \"PickerSetValue\",\n                detail: {\n                  year,\n                  // Month value from input box starts from 1 instead of 0\n                  month: month == undefined ? undefined : month - 1,\n                  day,\n                },\n              });\n              break;\n            }\n          }\n        ]]></body>\n      </method>\n      <method name=\"initPicker\">\n        <parameter name=\"detail\"/>\n        <body><![CDATA[\n          // TODO: When bug 1376616 lands, replace this.setGregorian with\n          //       mozIntl.Locale for setting calendar to Gregorian\n          const locale = this.setGregorian(Services.locale.appLocaleAsBCP47);\n          const dir = this.mozIntl.getLocaleInfo(locale).direction;\n\n          switch (this.type) {\n            case \"time\": {\n              const { hour, minute } = detail.value;\n              const format = detail.format || \"12\";\n\n              this.postMessageToPicker({\n                name: \"PickerInit\",\n                detail: {\n                  hour,\n                  minute,\n                  format,\n                  locale,\n                  min: detail.min,\n                  max: detail.max,\n                  step: detail.step,\n                },\n              });\n              break;\n            }\n            case \"date\": {\n              const { year, month, day } = detail.value;\n              const { firstDayOfWeek, weekends } =\n                this.getCalendarInfo(locale);\n              const monthStrings = this.getDisplayNames(\n                locale, [\n                  \"dates/gregorian/months/january\",\n                  \"dates/gregorian/months/february\",\n                  \"dates/gregorian/months/march\",\n                  \"dates/gregorian/months/april\",\n                  \"dates/gregorian/months/may\",\n                  \"dates/gregorian/months/june\",\n                  \"dates/gregorian/months/july\",\n                  \"dates/gregorian/months/august\",\n                  \"dates/gregorian/months/september\",\n                  \"dates/gregorian/months/october\",\n                  \"dates/gregorian/months/november\",\n                  \"dates/gregorian/months/december\",\n                ], \"short\");\n              const weekdayStrings = this.getDisplayNames(\n                locale, [\n                  \"dates/gregorian/weekdays/sunday\",\n                  \"dates/gregorian/weekdays/monday\",\n                  \"dates/gregorian/weekdays/tuesday\",\n                  \"dates/gregorian/weekdays/wednesday\",\n                  \"dates/gregorian/weekdays/thursday\",\n                  \"dates/gregorian/weekdays/friday\",\n                  \"dates/gregorian/weekdays/saturday\",\n                ], \"short\");\n\n              this.postMessageToPicker({\n                name: \"PickerInit\",\n                detail: {\n                  year,\n                  // Month value from input box starts from 1 instead of 0\n                  month: month == undefined ? undefined : month - 1,\n                  day,\n                  firstDayOfWeek,\n                  weekends,\n                  monthStrings,\n                  weekdayStrings,\n                  locale,\n                  dir,\n                  min: detail.min,\n                  max: detail.max,\n                  step: detail.step,\n                  stepBase: detail.stepBase,\n                },\n              });\n              break;\n            }\n          }\n        ]]></body>\n      </method>\n      <method name=\"setInputBoxValue\">\n        <parameter name=\"passAllValues\"/>\n        <body><![CDATA[\n          /**\n           * @param {Boolean} passAllValues: Pass spinner values regardless if they've been set/changed or not\n           */\n          switch (this.type) {\n            case \"time\": {\n              const { hour, minute, isHourSet, isMinuteSet, isDayPeriodSet } = this.pickerState;\n              const isAnyValueSet = isHourSet || isMinuteSet || isDayPeriodSet;\n              if (passAllValues && isAnyValueSet) {\n                this.sendPickerValueChanged({ hour, minute });\n              } else {\n                this.sendPickerValueChanged({\n                  hour: isHourSet || isDayPeriodSet ? hour : undefined,\n                  minute: isMinuteSet ? minute : undefined,\n                });\n              }\n              break;\n            }\n            case \"date\": {\n              this.sendPickerValueChanged(this.pickerState);\n              break;\n            }\n          }\n        ]]></body>\n      </method>\n      <method name=\"sendPickerValueChanged\">\n        <parameter name=\"value\"/>\n        <body><![CDATA[\n          switch (this.type) {\n            case \"time\": {\n              this.dispatchEvent(new CustomEvent(\"DateTimePickerValueChanged\", {\n                detail: {\n                  hour: value.hour,\n                  minute: value.minute,\n                },\n              }));\n              break;\n            }\n            case \"date\": {\n              this.dispatchEvent(new CustomEvent(\"DateTimePickerValueChanged\", {\n                detail: {\n                  year: value.year,\n                  // Month value from input box starts from 1 instead of 0\n                  month: value.month == undefined ? undefined : value.month + 1,\n                  day: value.day,\n                },\n              }));\n              break;\n            }\n          }\n        ]]></body>\n      </method>\n      <method name=\"getCalendarInfo\">\n        <parameter name=\"locale\"/>\n        <body><![CDATA[\n          const calendarInfo = this.mozIntl.getCalendarInfo(locale);\n\n          // Day of week from calendarInfo starts from 1 as Sunday to 7 as Saturday,\n          // so they need to be mapped to JavaScript convention with 0 as Sunday\n          // and 6 as Saturday\n          let firstDayOfWeek = calendarInfo.firstDayOfWeek - 1,\n              weekendStart = calendarInfo.weekendStart - 1,\n              weekendEnd = calendarInfo.weekendEnd - 1;\n\n          let weekends = [];\n\n          // Make sure weekendEnd is greater than weekendStart\n          if (weekendEnd < weekendStart) {\n            weekendEnd += 7;\n          }\n\n          // We get the weekends by incrementing weekendStart up to weekendEnd.\n          // If the start and end is the same day, then weekends only has one day.\n          for (let day = weekendStart; day <= weekendEnd; day++) {\n            weekends.push(day % 7);\n          }\n\n          return {\n            firstDayOfWeek,\n            weekends,\n          };\n        ]]></body>\n      </method>\n      <method name=\"getDisplayNames\">\n        <parameter name=\"locale\"/>\n        <parameter name=\"keys\"/>\n        <parameter name=\"style\"/>\n        <body><![CDATA[\n          const displayNames = this.mozIntl.getDisplayNames(locale, {keys, style});\n          return keys.map(key => displayNames.values[key]);\n        ]]></body>\n      </method>\n      <method name=\"setGregorian\">\n        <parameter name=\"locale\"/>\n        <body><![CDATA[\n          if (locale.match(/u-ca-/)) {\n            return locale.replace(/u-ca-[^-]+/, \"u-ca-gregory\");\n          }\n          return locale + \"-u-ca-gregory\";\n        ]]></body>\n      </method>\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          switch (aEvent.type) {\n            case \"load\": {\n              this.initPicker(this.detail);\n              this.dateTimePopupFrame.contentWindow.addEventListener(\"message\", this);\n              break;\n            }\n            case \"message\": {\n              this.handleMessage(aEvent);\n              break;\n            }\n          }\n        ]]></body>\n      </method>\n      <method name=\"handleMessage\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (!this.dateTimePopupFrame.contentDocument.nodePrincipal.isSystemPrincipal) {\n            return;\n          }\n\n          switch (aEvent.data.name) {\n            case \"PickerPopupChanged\": {\n              this.pickerState = aEvent.data.detail;\n              this.setInputBoxValue();\n              break;\n            }\n            case \"ClosePopup\": {\n              this.hidePopup();\n              this.closePicker();\n              break;\n            }\n          }\n        ]]></body>\n      </method>\n      <method name=\"postMessageToPicker\">\n        <parameter name=\"data\"/>\n        <body><![CDATA[\n          if (this.dateTimePopupFrame.contentDocument.nodePrincipal.isSystemPrincipal) {\n            this.dateTimePopupFrame.contentWindow.postMessage(data, \"*\");\n          }\n        ]]></body>\n      </method>\n\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"dialog.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings [\n  <!ENTITY % globalKeysDTD SYSTEM \"chrome://global/locale/globalKeys.dtd\">\n  %globalKeysDTD;\n]>\n\n<bindings id=\"dialogBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"dialog\">\n    <content>\n      <xul:vbox class=\"box-inherit dialog-content-box\" flex=\"1\">\n        <children/>\n      </xul:vbox>\n\n      <xul:hbox class=\"dialog-button-box\" anonid=\"buttons\"\n                xbl:inherits=\"pack=buttonpack,align=buttonalign,dir=buttondir,orient=buttonorient\"\n\n                pack=\"end\">\n        <xul:button dlgtype=\"extra2\" class=\"dialog-button\" hidden=\"true\"/>\n        <xul:spacer anonid=\"spacer\" flex=\"1\" hidden=\"true\"/>\n        <xul:button dlgtype=\"accept\" class=\"dialog-button\" xbl:inherits=\"disabled=buttondisabledaccept\"/>\n        <xul:button dlgtype=\"extra1\" class=\"dialog-button\" hidden=\"true\"/>\n        <xul:button dlgtype=\"cancel\" class=\"dialog-button\"/>\n        <xul:button dlgtype=\"help\" class=\"dialog-button\" hidden=\"true\"/>\n        <xul:button dlgtype=\"disclosure\" class=\"dialog-button\" hidden=\"true\"/>\n\n      </xul:hbox>\n\n    <xul:keyset>\n      <xul:key phase=\"capturing\" oncommand=\"document.documentElement.openHelp(event)\"\n\n           keycode=\"FROM-DTD.openHelp.commandkey;\"/>\n\n    </xul:keyset>\n\n    </content>\n\n    <implementation>\n      <field name=\"_mStrBundle\">null</field>\n      <field name=\"_closeHandler\">(function(event) {\n        if (!document.documentElement.cancelDialog())\n          event.preventDefault();\n      })</field>\n\n      <property name=\"buttons\"\n                onget=\"return this.getAttribute('buttons');\"\n                onset=\"this._configureButtons(val); return val;\"/>\n\n      <property name=\"defaultButton\">\n        <getter>\n        <![CDATA[\n          if (this.hasAttribute(\"defaultButton\"))\n            return this.getAttribute(\"defaultButton\");\n          return \"accept\"; // default to the accept button\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          this._setDefaultButton(val);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"acceptDialog\">\n        <body>\n        <![CDATA[\n          return this._doButtonCommand(\"accept\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"cancelDialog\">\n        <body>\n        <![CDATA[\n          return this._doButtonCommand(\"cancel\");\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getButton\">\n        <parameter name=\"aDlgType\"/>\n        <body>\n        <![CDATA[\n          return this._buttons[aDlgType];\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"moveToAlertPosition\">\n        <body>\n        <![CDATA[\n          // hack. we need this so the window has something like its final size\n          if (window.outerWidth == 1) {\n            dump(\"Trying to position a sizeless window; caller should have called sizeToContent() or sizeTo(). See bug 75649.\\n\");\n            sizeToContent();\n          }\n\n          if (opener) {\n            var xOffset = (opener.outerWidth - window.outerWidth) / 2;\n            var yOffset = opener.outerHeight / 5;\n\n            var newX = opener.screenX + xOffset;\n            var newY = opener.screenY + yOffset;\n          } else {\n            newX = (screen.availWidth - window.outerWidth) / 2;\n            newY = (screen.availHeight - window.outerHeight) / 2;\n          }\n\n          // ensure the window is fully onscreen (if smaller than the screen)\n          if (newX < screen.availLeft)\n            newX = screen.availLeft + 20;\n          if ((newX + window.outerWidth) > (screen.availLeft + screen.availWidth))\n            newX = (screen.availLeft + screen.availWidth) - window.outerWidth - 20;\n\n          if (newY < screen.availTop)\n            newY = screen.availTop + 20;\n          if ((newY + window.outerHeight) > (screen.availTop + screen.availHeight))\n            newY = (screen.availTop + screen.availHeight) - window.outerHeight - 60;\n\n          window.moveTo( newX, newY );\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"centerWindowOnScreen\">\n        <body>\n        <![CDATA[\n          var xOffset = screen.availWidth / 2 - window.outerWidth / 2;\n          var yOffset = screen.availHeight / 2 - window.outerHeight / 2;\n\n          xOffset = xOffset > 0 ? xOffset : 0;\n          yOffset = yOffset > 0 ? yOffset : 0;\n          window.moveTo(xOffset, yOffset);\n        ]]>\n        </body>\n      </method>\n\n      <constructor>\n      <![CDATA[\n        this._configureButtons(this.buttons);\n\n        // listen for when window is closed via native close buttons\n        window.addEventListener(\"close\", this._closeHandler);\n\n        // for things that we need to initialize after onload fires\n        window.addEventListener(\"load\", this.postLoadInit);\n\n        window.moveToAlertPosition = this.moveToAlertPosition;\n        window.centerWindowOnScreen = this.centerWindowOnScreen;\n      ]]>\n      </constructor>\n\n      <method name=\"postLoadInit\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          function focusInit() {\n            const dialog = document.documentElement;\n            const defaultButton = dialog.getButton(dialog.defaultButton);\n            // give focus to the first focusable element in the dialog\n            if (!document.commandDispatcher.focusedElement) {\n              document.commandDispatcher.advanceFocusIntoSubtree(dialog);\n\n              var focusedElt = document.commandDispatcher.focusedElement;\n              if (focusedElt) {\n                var initialFocusedElt = focusedElt;\n                while (focusedElt.localName == \"tab\" ||\n                       focusedElt.getAttribute(\"noinitialfocus\") == \"true\") {\n                  document.commandDispatcher.advanceFocusIntoSubtree(focusedElt);\n                  focusedElt = document.commandDispatcher.focusedElement;\n                  if (focusedElt == initialFocusedElt) {\n                    if (focusedElt.getAttribute(\"noinitialfocus\") == \"true\") {\n                      focusedElt.blur();\n                    }\n                    break;\n                  }\n                }\n\n                if (initialFocusedElt.localName == \"tab\") {\n                  if (focusedElt.hasAttribute(\"dlgtype\")) {\n                    // We don't want to focus on anonymous OK, Cancel, etc. buttons,\n                    // so return focus to the tab itself\n                    initialFocusedElt.focus();\n                  }\n                } else if (!/Mac/.test(navigator.platform) &&\n                           focusedElt.hasAttribute(\"dlgtype\") && focusedElt != defaultButton) {\n                  defaultButton.focus();\n                }\n              }\n            }\n\n            try {\n              if (defaultButton)\n                window.notifyDefaultButtonLoaded(defaultButton);\n            } catch (e) { }\n          }\n\n          // Give focus after onload completes, see bug 103197.\n          setTimeout(focusInit, 0);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"openHelp\">\n        <parameter name=\"event\"/>\n        <body>\n        <![CDATA[\n          var helpButton = document.documentElement.getButton(\"help\");\n          if (helpButton.disabled || helpButton.hidden)\n            return;\n          this._fireButtonEvent(\"help\");\n          event.stopPropagation();\n          event.preventDefault();\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"mStrBundle\">\n        <getter>\n        <![CDATA[\n          if (!this._mStrBundle) {\n            // need to create string bundle manually instead of using <xul:stringbundle/>\n            // see bug 63370 for details\n            this._mStrBundle = Cc[\"@mozilla.org/intl/stringbundle;1\"]\n                                 .getService(Ci.nsIStringBundleService)\n                                 .createBundle(\"chrome://global/locale/dialog.properties\");\n          }\n          return this._mStrBundle;\n        ]]></getter>\n      </property>\n\n      <method name=\"_configureButtons\">\n        <parameter name=\"aButtons\"/>\n        <body>\n        <![CDATA[\n          // by default, get all the anonymous button elements\n          var buttons = {};\n          this._buttons = buttons;\n          buttons.accept = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"accept\");\n          buttons.cancel = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"cancel\");\n          buttons.extra1 = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"extra1\");\n          buttons.extra2 = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"extra2\");\n          buttons.help = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"help\");\n          buttons.disclosure = document.getAnonymousElementByAttribute(this, \"dlgtype\", \"disclosure\");\n\n          // look for any overriding explicit button elements\n          var exBtns = this.getElementsByAttribute(\"dlgtype\", \"*\");\n          var dlgtype;\n          var i;\n          for (i = 0; i < exBtns.length; ++i) {\n            dlgtype = exBtns[i].getAttribute(\"dlgtype\");\n            buttons[dlgtype].hidden = true; // hide the anonymous button\n            buttons[dlgtype] = exBtns[i];\n          }\n\n          // add the label and oncommand handler to each button\n          for (dlgtype in buttons) {\n            var button = buttons[dlgtype];\n            button.addEventListener(\"command\", this._handleButtonCommand, true);\n\n            // don't override custom labels with pre-defined labels on explicit buttons\n            if (!button.hasAttribute(\"label\")) {\n              // dialog attributes override the default labels in dialog.properties\n              if (this.hasAttribute(\"buttonlabel\" + dlgtype)) {\n                button.setAttribute(\"label\", this.getAttribute(\"buttonlabel\" + dlgtype));\n                if (this.hasAttribute(\"buttonaccesskey\" + dlgtype))\n                  button.setAttribute(\"accesskey\", this.getAttribute(\"buttonaccesskey\" + dlgtype));\n              } else if (dlgtype != \"extra1\" && dlgtype != \"extra2\") {\n                button.setAttribute(\"label\", this.mStrBundle.GetStringFromName(\"button-\" + dlgtype));\n                var accessKey = this.mStrBundle.GetStringFromName(\"accesskey-\" + dlgtype);\n                if (accessKey)\n                  button.setAttribute(\"accesskey\", accessKey);\n              }\n            }\n            // allow specifying alternate icons in the dialog header\n            if (!button.hasAttribute(\"icon\")) {\n              // if there's an icon specified, use that\n              if (this.hasAttribute(\"buttonicon\" + dlgtype))\n                button.setAttribute(\"icon\", this.getAttribute(\"buttonicon\" + dlgtype));\n              // otherwise set defaults\n              else\n                switch (dlgtype) {\n                  case \"accept\":\n                    button.setAttribute(\"icon\", \"accept\");\n                    break;\n                  case \"cancel\":\n                    button.setAttribute(\"icon\", \"cancel\");\n                    break;\n                  case \"disclosure\":\n                    button.setAttribute(\"icon\", \"properties\");\n                    break;\n                  case \"help\":\n                    button.setAttribute(\"icon\", \"help\");\n                    break;\n                  default:\n                    break;\n                }\n            }\n          }\n\n          // ensure that hitting enter triggers the default button command\n          this.defaultButton = this.defaultButton;\n\n          // if there is a special button configuration, use it\n          if (aButtons) {\n            // expect a comma delimited list of dlgtype values\n            var list = aButtons.split(\",\");\n\n            // mark shown dlgtypes as true\n            var shown = { accept: false, cancel: false, help: false,\n                          disclosure: false, extra1: false, extra2: false };\n            for (i = 0; i < list.length; ++i)\n              shown[list[i].replace(/ /g, \"\")] = true;\n\n            // hide/show the buttons we want\n            for (dlgtype in buttons)\n              buttons[dlgtype].hidden = !shown[dlgtype];\n\n            // show the spacer on Windows only when the extra2 button is present\n            if (/Win/.test(navigator.platform)) {\n              var spacer = document.getAnonymousElementByAttribute(this, \"anonid\", \"spacer\");\n              spacer.removeAttribute(\"hidden\");\n              spacer.setAttribute(\"flex\", shown.extra2 ? \"1\" : \"0\");\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_setDefaultButton\">\n        <parameter name=\"aNewDefault\"/>\n        <body>\n        <![CDATA[\n          // remove the default attribute from the previous default button, if any\n          var oldDefaultButton = this.getButton(this.defaultButton);\n          if (oldDefaultButton)\n            oldDefaultButton.removeAttribute(\"default\");\n\n          var newDefaultButton = this.getButton(aNewDefault);\n          if (newDefaultButton) {\n            this.setAttribute(\"defaultButton\", aNewDefault);\n            newDefaultButton.setAttribute(\"default\", \"true\");\n          } else {\n            this.setAttribute(\"defaultButton\", \"none\");\n            if (aNewDefault != \"none\")\n              dump(\"invalid new default button: \" + aNewDefault + \", assuming: none\\n\");\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_handleButtonCommand\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          return document.documentElement._doButtonCommand(\n                                        aEvent.target.getAttribute(\"dlgtype\"));\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_doButtonCommand\">\n        <parameter name=\"aDlgType\"/>\n        <body>\n        <![CDATA[\n          var button = this.getButton(aDlgType);\n          if (!button.disabled) {\n            var noCancel = this._fireButtonEvent(aDlgType);\n            if (noCancel) {\n              if (aDlgType == \"accept\" || aDlgType == \"cancel\") {\n                var closingEvent = new CustomEvent(\"dialogclosing\", {\n                  bubbles: true,\n                  detail: { button: aDlgType },\n                });\n                this.dispatchEvent(closingEvent);\n                window.close();\n              }\n            }\n            return noCancel;\n          }\n          return true;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_fireButtonEvent\">\n        <parameter name=\"aDlgType\"/>\n        <body>\n        <![CDATA[\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"dialog\" + aDlgType, true, true);\n\n          // handle dom event handlers\n          var noCancel = this.dispatchEvent(event);\n\n          // handle any xml attribute event handlers\n          var handler = this.getAttribute(\"ondialog\" + aDlgType);\n          if (handler != \"\") {\n            var fn = new Function(\"event\", handler);\n            var returned = fn(event);\n            // eslint-disable-next-line mozilla/no-compare-against-boolean-literals\n            if (returned == false)\n              noCancel = false;\n          }\n\n          return noCancel;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_hitEnter\">\n        <parameter name=\"evt\"/>\n        <body>\n        <![CDATA[\n          if (evt.defaultPrevented)\n            return;\n\n          var btn = this.getButton(this.defaultButton);\n          if (btn)\n            this._doButtonCommand(this.defaultButton);\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\"\n               group=\"system\" action=\"this._hitEnter(event);\"/>\n      <handler event=\"keypress\" keycode=\"VK_ESCAPE\" group=\"system\">\n        if (!event.defaultPrevented)\n          this.cancelDialog();\n      </handler>\n\n      <handler event=\"focus\" phase=\"capturing\">\n        var btn = this.getButton(this.defaultButton);\n        if (btn)\n          btn.setAttribute(\"default\", event.originalTarget == btn || !(event.originalTarget instanceof Ci.nsIDOMXULButtonElement));\n      </handler>\n\n    </handlers>\n\n  </binding>\n\n</bindings>\n"},{"file":"general.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"generalBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"basecontrol\">\n    <implementation implements=\"nsIDOMXULControlElement\">\n      <!-- public implementation -->\n      <property name=\"disabled\" onset=\"if (val) this.setAttribute('disabled', 'true');\n                                       else this.removeAttribute('disabled');\n                                       return val;\"\n                                onget=\"return this.getAttribute('disabled') == 'true';\"/>\n      <property name=\"tabIndex\" onget=\"return parseInt(this.getAttribute('tabindex')) || 0\"\n                                onset=\"if (val) this.setAttribute('tabindex', val);\n                                       else this.removeAttribute('tabindex'); return val;\"/>\n    </implementation>\n  </binding>\n\n  <binding id=\"basetext\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <implementation>\n      <!-- public implementation -->\n      <property name=\"label\"      onset=\"this.setAttribute('label',val); return val;\"\n                                  onget=\"return this.getAttribute('label');\"/>\n      <property name=\"crop\"       onset=\"this.setAttribute('crop',val); return val;\"\n                                  onget=\"return this.getAttribute('crop');\"/>\n      <property name=\"image\"      onset=\"this.setAttribute('image',val); return val;\"\n                                  onget=\"return this.getAttribute('image');\"/>\n      <property name=\"command\"    onset=\"this.setAttribute('command',val); return val;\"\n                                  onget=\"return this.getAttribute('command');\"/>\n      <property name=\"accessKey\">\n        <getter>\n          <![CDATA[\n            return this.labelElement ? this.labelElement.accessKey : this.getAttribute(\"accesskey\");\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            // Always store on the control\n            this.setAttribute(\"accesskey\", val);\n            // If there is a label, change the accesskey on the labelElement\n            // if it's also set there\n            if (this.labelElement) {\n              this.labelElement.accessKey = val;\n            }\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <field name=\"labelElement\"/>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"menu.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"menuitemBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"menuitem-base\"\n           extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <implementation implements=\"nsIDOMXULSelectControlItemElement, nsIDOMXULContainerItemElement\">\n      <property name=\"value\" onset=\"this.setAttribute('value', val); return val;\"\n                             onget=\"return this.getAttribute('value');\"/>\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"selected\" readonly=\"true\"\n                onget=\"return this.getAttribute('selected') == 'true';\"/>\n      <property name=\"control\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var parent = this.parentNode;\n            if (parent &&\n                parent.parentNode instanceof Ci.nsIDOMXULSelectControlElement)\n              return parent.parentNode;\n            return null;\n          ]]>\n        </getter>\n      </property>\n\n      <!-- nsIDOMXULContainerItemElement -->\n      <property name=\"parentContainer\" readonly=\"true\">\n        <getter>\n          for (var parent = this.parentNode; parent; parent = parent.parentNode) {\n            if (parent instanceof Ci.nsIDOMXULContainerElement)\n              return parent;\n          }\n          return null;\n        </getter>\n      </property>\n    </implementation>\n  </binding>\n\n  <binding id=\"menu-base\"\n           extends=\"chrome://global/content/bindings/menu.xml#menuitem-base\">\n\n    <implementation implements=\"nsIDOMXULContainerElement\">\n      <property name=\"open\" onget=\"return this.hasAttribute('open');\">\n        <setter><![CDATA[\n          this.openMenu(val);\n          return val;\n        ]]></setter>\n      </property>\n\n      <!-- nsIDOMXULContainerElement interface -->\n      <method name=\"appendItem\">\n        <parameter name=\"aLabel\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n          var menupopup = this.menupopup;\n          if (!menupopup) {\n            menupopup = this.ownerDocument.createXULElement(\"menupopup\");\n            this.appendChild(menupopup);\n          }\n\n          var menuitem = this.ownerDocument.createXULElement(\"menuitem\");\n          menuitem.setAttribute(\"label\", aLabel);\n          menuitem.setAttribute(\"value\", aValue);\n\n          return menupopup.appendChild(menuitem);\n        </body>\n      </method>\n\n      <property name=\"itemCount\" readonly=\"true\">\n        <getter>\n          var menupopup = this.menupopup;\n          return menupopup ? menupopup.children.length : 0;\n        </getter>\n      </property>\n\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          var menupopup = this.menupopup;\n          if (menupopup) {\n            var items = menupopup.children;\n            var length = items.length;\n            for (var index = 0; index < length; ++index) {\n              if (items[index] == aItem)\n                return index;\n            }\n          }\n          return -1;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"aIndex\"/>\n        <body>\n        <![CDATA[\n          var menupopup = this.menupopup;\n          if (!menupopup || aIndex < 0 || aIndex >= menupopup.children.length)\n            return null;\n\n          return menupopup.children[aIndex];\n        ]]>\n        </body>\n      </method>\n\n      <property name=\"menupopup\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          const XUL_NS =\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\n          for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\n            if (child.namespaceURI == XUL_NS && child.localName == \"menupopup\")\n              return child;\n          }\n          return null;\n        ]]>\n        </getter>\n      </property>\n    </implementation>\n  </binding>\n\n  <binding id=\"menu\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:label class=\"menu-text\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\"/>\n      <xul:hbox class=\"menu-accel-container\" anonid=\"accel\">\n        <xul:label class=\"menu-accel\" xbl:inherits=\"value=acceltext\"/>\n      </xul:hbox>\n      <xul:hbox align=\"center\" class=\"menu-right\" xbl:inherits=\"_moz-menuactive,disabled\">\n        <xul:image/>\n      </xul:hbox>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menuitem\" extends=\"chrome://global/content/bindings/menu.xml#menuitem-base\">\n    <content>\n      <xul:label class=\"menu-text\" xbl:inherits=\"value=label,accesskey,crop,highlightable\" crop=\"right\"/>\n      <xul:hbox class=\"menu-accel-container\" anonid=\"accel\">\n        <xul:label class=\"menu-accel\" xbl:inherits=\"value=acceltext\"/>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"menu-menubar\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:label class=\"menubar-text\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menu-menubar-iconic\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:image class=\"menubar-left\" xbl:inherits=\"src=image\"/>\n      <xul:label class=\"menubar-text\" xbl:inherits=\"value=label,accesskey,crop\" crop=\"right\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menuitem-iconic\" extends=\"chrome://global/content/bindings/menu.xml#menuitem\">\n    <content>\n      <xul:hbox class=\"menu-iconic-left\" align=\"center\" pack=\"center\"\n                xbl:inherits=\"selected,_moz-menuactive,disabled,checked\">\n        <xul:image class=\"menu-iconic-icon\" xbl:inherits=\"src=image,triggeringprincipal=iconloadingprincipal,validate,src\"/>\n      </xul:hbox>\n      <xul:label class=\"menu-iconic-text\" flex=\"1\" xbl:inherits=\"value=label,accesskey,crop,highlightable\" crop=\"right\"/>\n      <xul:label class=\"menu-iconic-highlightable-text\" xbl:inherits=\"xbl:text=label,crop,accesskey,highlightable\" crop=\"right\"/>\n      <children/>\n      <xul:hbox class=\"menu-accel-container\" anonid=\"accel\">\n        <xul:label class=\"menu-iconic-accel\" xbl:inherits=\"value=acceltext\"/>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"menuitem-iconic-noaccel\" extends=\"chrome://global/content/bindings/menu.xml#menuitem\">\n    <content>\n      <xul:hbox class=\"menu-iconic-left\" align=\"center\" pack=\"center\"\n                xbl:inherits=\"selected,disabled,checked\">\n        <xul:image class=\"menu-iconic-icon\" xbl:inherits=\"src=image,validate,src\"/>\n      </xul:hbox>\n      <xul:label class=\"menu-iconic-text\" flex=\"1\" xbl:inherits=\"value=label,accesskey,crop,highlightable\" crop=\"right\"/>\n      <xul:label class=\"menu-iconic-highlightable-text\" xbl:inherits=\"xbl:text=label,crop,accesskey,highlightable\" crop=\"right\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menucaption\" extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:hbox class=\"menu-iconic-left\" align=\"center\" pack=\"center\"\n                xbl:inherits=\"selected,disabled,checked\">\n        <xul:image class=\"menu-iconic-icon\" xbl:inherits=\"src=image,validate,src\"/>\n      </xul:hbox>\n      <xul:label class=\"menu-iconic-text\" flex=\"1\" xbl:inherits=\"value=label,crop,highlightable\" crop=\"right\"/>\n      <xul:label class=\"menu-iconic-highlightable-text\" xbl:inherits=\"xbl:text=label,crop,highlightable\" crop=\"right\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menu-iconic\"\n           extends=\"chrome://global/content/bindings/menu.xml#menu-base\">\n    <content>\n      <xul:hbox class=\"menu-iconic-left\" align=\"center\" pack=\"center\">\n        <xul:image class=\"menu-iconic-icon\" xbl:inherits=\"src=image\"/>\n      </xul:hbox>\n      <xul:label class=\"menu-iconic-text\" flex=\"1\" xbl:inherits=\"value=label,accesskey,crop,highlightable\" crop=\"right\"/>\n      <xul:label class=\"menu-iconic-highlightable-text\" xbl:inherits=\"xbl:text=label,crop,accesskey,highlightable\" crop=\"right\"/>\n      <xul:hbox class=\"menu-accel-container\" anonid=\"accel\">\n        <xul:label class=\"menu-iconic-accel\" xbl:inherits=\"value=acceltext\"/>\n      </xul:hbox>\n      <xul:hbox align=\"center\" class=\"menu-right\" xbl:inherits=\"_moz-menuactive,disabled\">\n        <xul:image/>\n      </xul:hbox>\n      <children includes=\"menupopup|template\"/>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"menulist.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"menulistBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"menulist\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <content sizetopopup=\"pref\">\n      <xul:hbox class=\"menulist-label-box\" flex=\"1\">\n        <xul:image class=\"menulist-icon\" xbl:inherits=\"src=image\"/>\n        <xul:label class=\"menulist-label\" xbl:inherits=\"value=label,crop,accesskey,highlightable\" crop=\"right\" flex=\"1\"/>\n        <xul:label class=\"menulist-highlightable-label\" xbl:inherits=\"xbl:text=label,crop,accesskey,highlightable\" crop=\"right\" flex=\"1\"/>\n      </xul:hbox>\n      <xul:dropmarker class=\"menulist-dropmarker\" type=\"menu\" xbl:inherits=\"disabled,open\"/>\n      <children includes=\"menupopup\"/>\n    </content>\n\n    <handlers>\n      <handler event=\"command\" phase=\"capturing\"\n        action=\"if (event.target.parentNode.parentNode == this) this.selectedItem = event.target;\"/>\n\n      <handler event=\"popupshowing\">\n        <![CDATA[\n          if (event.target.parentNode == this) {\n            this.activeChild = null;\n            if (this.selectedItem)\n              // Not ready for auto-setting the active child in hierarchies yet.\n              // For now, only do this when the outermost menupopup opens.\n              this.activeChild = this.mSelectedInternal;\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"keypress\" modifiers=\"shift any\" group=\"system\">\n        <![CDATA[\n          if (!event.defaultPrevented &&\n              (event.keyCode == KeyEvent.DOM_VK_UP ||\n               event.keyCode == KeyEvent.DOM_VK_DOWN ||\n               event.keyCode == KeyEvent.DOM_VK_PAGE_UP ||\n               event.keyCode == KeyEvent.DOM_VK_PAGE_DOWN ||\n               event.keyCode == KeyEvent.DOM_VK_HOME ||\n               event.keyCode == KeyEvent.DOM_VK_END ||\n               event.keyCode == KeyEvent.DOM_VK_BACK_SPACE ||\n               event.charCode > 0)) {\n            // Moving relative to an item: start from the currently selected item\n            this.activeChild = this.mSelectedInternal;\n            if (this.handleKeyPress(event)) {\n              this.activeChild.doCommand();\n              event.preventDefault();\n            }\n          }\n        ]]>\n      </handler>\n    </handlers>\n\n    <implementation implements=\"nsIDOMXULMenuListElement\">\n      <constructor>\n        this.mSelectedInternal = null;\n        this.mAttributeObserver = null;\n        this.setInitialSelection();\n      </constructor>\n\n      <method name=\"setInitialSelection\">\n        <body>\n          <![CDATA[\n            var popup = this.menupopup;\n            if (popup) {\n              var arr = popup.getElementsByAttribute(\"selected\", \"true\");\n\n              var editable = this.editable;\n              var value = this.value;\n              if (!arr.item(0) && value)\n                arr = popup.getElementsByAttribute(editable ? \"label\" : \"value\", value);\n\n              if (arr.item(0))\n                this.selectedItem = arr[0];\n              else if (!editable)\n                this.selectedIndex = 0;\n            }\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"value\" onget=\"return this.getAttribute('value');\">\n        <setter>\n          <![CDATA[\n            // if the new value is null, we still need to remove the old value\n            if (val == null)\n              return this.selectedItem = val;\n\n            var arr = null;\n            var popup = this.menupopup;\n            if (popup)\n              arr = popup.getElementsByAttribute(\"value\", val);\n\n            if (arr && arr.item(0))\n              this.selectedItem = arr[0];\n            else {\n              this.selectedItem = null;\n              this.setAttribute(\"value\", val);\n            }\n\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"crop\" onset=\"this.setAttribute('crop',val); return val;\"\n                            onget=\"return this.getAttribute('crop');\"/>\n      <property name=\"image\"  onset=\"this.setAttribute('image',val); return val;\"\n                              onget=\"return this.getAttribute('image');\"/>\n      <property name=\"label\" readonly=\"true\" onget=\"return this.getAttribute('label');\"/>\n      <property name=\"description\" onset=\"this.setAttribute('description',val); return val;\"\n                                   onget=\"return this.getAttribute('description');\"/>\n\n      <property name=\"open\" onset=\"this.openMenu(val); return val;\"\n                            onget=\"return this.hasAttribute('open');\"/>\n\n      <property name=\"itemCount\" readonly=\"true\"\n                onget=\"return this.menupopup ? this.menupopup.children.length : 0\"/>\n\n      <property name=\"menupopup\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var popup = this.firstElementChild;\n            while (popup && popup.localName != \"menupopup\")\n              popup = popup.nextElementSibling;\n            return popup;\n          ]]>\n        </getter>\n      </property>\n\n      <method name=\"contains\">\n        <parameter name=\"item\"/>\n        <body>\n          <![CDATA[\n            if (!item)\n              return false;\n\n            var parent = item.parentNode;\n            return (parent && parent.parentNode == this);\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"selectedIndex\">\n        <getter>\n          <![CDATA[\n            // Quick and dirty. We won't deal with hierarchical menulists yet.\n            if (!this.selectedItem ||\n                !this.mSelectedInternal.parentNode ||\n                this.mSelectedInternal.parentNode.parentNode != this)\n              return -1;\n\n            var children = this.mSelectedInternal.parentNode.children;\n            var i = children.length;\n            while (i--)\n              if (children[i] == this.mSelectedInternal)\n                break;\n\n            return i;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            var popup = this.menupopup;\n            if (popup && 0 <= val) {\n              if (val < popup.children.length)\n                this.selectedItem = popup.children[val];\n            } else\n              this.selectedItem = null;\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedItem\">\n        <getter>\n          <![CDATA[\n            return this.mSelectedInternal;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            var oldval = this.mSelectedInternal;\n            if (oldval == val)\n              return val;\n\n            if (val && !this.contains(val))\n              return val;\n\n            if (oldval) {\n              oldval.removeAttribute(\"selected\");\n              this.mAttributeObserver.disconnect();\n            }\n\n            this.mSelectedInternal = val;\n            let attributeFilter = [\"value\", \"label\", \"image\", \"description\"];\n            if (val) {\n              val.setAttribute(\"selected\", \"true\");\n              for (let attr of attributeFilter) {\n                if (val.hasAttribute(attr)) {\n                  this.setAttribute(attr, val.getAttribute(attr));\n                } else {\n                  this.removeAttribute(attr);\n                }\n              }\n\n              this.mAttributeObserver = new MutationObserver(this.handleMutation.bind(this));\n              this.mAttributeObserver.observe(val, { attributeFilter });\n            } else {\n              for (let attr of attributeFilter) {\n                this.removeAttribute(attr);\n              }\n            }\n\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"select\", true, true);\n            this.dispatchEvent(event);\n\n            event = document.createEvent(\"Events\");\n            event.initEvent(\"ValueChange\", true, true);\n            this.dispatchEvent(event);\n\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <method name=\"handleMutation\">\n        <parameter name=\"aRecords\"/>\n        <body>\n          <![CDATA[\n            for (let record of aRecords) {\n              let t = record.target;\n              if (t == this.mSelectedInternal) {\n                let attrName = record.attributeName;\n                switch (attrName) {\n                  case \"value\":\n                  case \"label\":\n                  case \"image\":\n                  case \"description\":\n                    if (t.hasAttribute(attrName)) {\n                      this.setAttribute(attrName, t.getAttribute(attrName));\n                    } else {\n                      this.removeAttribute(attrName);\n                    }\n                }\n              }\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"item\"/>\n        <body>\n        <![CDATA[\n          var popup = this.menupopup;\n          if (popup) {\n            var children = popup.children;\n            var i = children.length;\n            while (i--)\n              if (children[i] == item)\n                return i;\n          }\n          return -1;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"index\"/>\n        <body>\n        <![CDATA[\n          var popup = this.menupopup;\n          if (popup) {\n            var children = popup.children;\n            if (index >= 0 && index < children.length)\n              return children[index];\n          }\n          return null;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"appendItem\">\n        <parameter name=\"label\"/>\n        <parameter name=\"value\"/>\n        <parameter name=\"description\"/>\n        <body>\n        <![CDATA[\n          var popup = this.menupopup ||\n                      this.appendChild(document.createXULElement(\"menupopup\"));\n          var item = document.createXULElement(\"menuitem\");\n          item.setAttribute(\"label\", label);\n          item.setAttribute(\"value\", value);\n          if (description)\n            item.setAttribute(\"description\", description);\n\n          popup.appendChild(item);\n          return item;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"removeAllItems\">\n        <body>\n        <![CDATA[\n          this.selectedItem = null;\n          var popup = this.menupopup;\n          if (popup)\n            this.removeChild(popup);\n        ]]>\n        </body>\n      </method>\n\n      <destructor>\n        <![CDATA[\n          if (this.mAttributeObserver) {\n            this.mAttributeObserver.disconnect();\n          }\n        ]]>\n      </destructor>\n    </implementation>\n  </binding>\n\n  <binding id=\"menulist-popuponly\"\n           extends=\"chrome://global/content/bindings/menulist.xml#menulist\">\n    <content sizetopopup=\"pref\">\n      <children includes=\"menupopup\"/>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"notification.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE bindings [\n<!ENTITY % notificationDTD SYSTEM \"chrome://global/locale/notification.dtd\">\n%notificationDTD;\n]>\n\n<bindings id=\"notificationBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:html = \"http://www.w3.org/1999/xhtml\">\n\n  <binding id=\"notificationbox\">\n    <content>\n      <xul:stack xbl:inherits=\"hidden=notificationshidden\"\n                 class=\"notificationbox-stack\">\n        <xul:spacer/>\n        <children includes=\"notification\"/>\n      </xul:stack>\n      <children/>\n    </content>\n\n    <implementation>\n      <field name=\"PRIORITY_INFO_LOW\" readonly=\"true\">1</field>\n      <field name=\"PRIORITY_INFO_MEDIUM\" readonly=\"true\">2</field>\n      <field name=\"PRIORITY_INFO_HIGH\" readonly=\"true\">3</field>\n      <field name=\"PRIORITY_WARNING_LOW\" readonly=\"true\">4</field>\n      <field name=\"PRIORITY_WARNING_MEDIUM\" readonly=\"true\">5</field>\n      <field name=\"PRIORITY_WARNING_HIGH\" readonly=\"true\">6</field>\n      <field name=\"PRIORITY_CRITICAL_LOW\" readonly=\"true\">7</field>\n      <field name=\"PRIORITY_CRITICAL_MEDIUM\" readonly=\"true\">8</field>\n      <field name=\"PRIORITY_CRITICAL_HIGH\" readonly=\"true\">9</field>\n      <field name=\"PRIORITY_CRITICAL_BLOCK\" readonly=\"true\">10</field>\n\n      <field name=\"currentNotification\">null</field>\n\n      <field name=\"_closedNotification\">null</field>\n      <field name=\"_blockingCanvas\">null</field>\n      <field name=\"_animating\">false</field>\n\n      <property name=\"_allowAnimation\">\n        <getter>\n          <![CDATA[\n            var prefs = Cc[\"@mozilla.org/preferences-service;1\"]\n                          .getService(Ci.nsIPrefBranch);\n            return prefs.getBoolPref(\"toolkit.cosmeticAnimations.enabled\");\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"notificationsHidden\"\n                onget=\"return this.getAttribute('notificationshidden') == 'true';\">\n        <setter>\n          <![CDATA[\n            if (val)\n              this.setAttribute(\"notificationshidden\", true);\n            else this.removeAttribute(\"notificationshidden\");\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"allNotifications\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var closedNotification = this._closedNotification;\n            var notifications = this.getElementsByTagName(\"notification\");\n            return Array.filter(notifications, n => n != closedNotification);\n          ]]>\n        </getter>\n      </property>\n\n      <method name=\"getNotificationWithValue\">\n        <parameter name=\"aValue\"/>\n        <body>\n          <![CDATA[\n            var notifications = this.allNotifications;\n            for (var n = notifications.length - 1; n >= 0; n--) {\n              if (aValue == notifications[n].getAttribute(\"value\"))\n                return notifications[n];\n            }\n            return null;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"appendNotification\">\n        <parameter name=\"aLabel\"/>\n        <parameter name=\"aValue\"/>\n        <parameter name=\"aImage\"/>\n        <parameter name=\"aPriority\"/>\n        <parameter name=\"aButtons\"/>\n        <parameter name=\"aEventCallback\"/>\n        <body>\n          <![CDATA[\n            if (aPriority < this.PRIORITY_INFO_LOW ||\n                aPriority > this.PRIORITY_CRITICAL_BLOCK)\n              throw \"Invalid notification priority \" + aPriority;\n\n            // check for where the notification should be inserted according to\n            // priority. If two are equal, the existing one appears on top.\n            var notifications = this.allNotifications;\n            var insertPos = null;\n            for (var n = notifications.length - 1; n >= 0; n--) {\n              if (notifications[n].priority < aPriority)\n                break;\n              insertPos = notifications[n];\n            }\n\n            var newitem = document.createXULElement(\"notification\");\n            // Can't use instanceof in case this was created from a different document:\n            let labelIsDocFragment = aLabel && typeof aLabel == \"object\" && aLabel.nodeType &&\n                                     aLabel.nodeType == aLabel.DOCUMENT_FRAGMENT_NODE;\n            if (!labelIsDocFragment)\n              newitem.setAttribute(\"label\", aLabel);\n            newitem.setAttribute(\"value\", aValue);\n            if (aImage)\n              newitem.setAttribute(\"image\", aImage);\n            newitem.eventCallback = aEventCallback;\n\n            if (aButtons) {\n              // The notification-button-default class is added to the button\n              // with isDefault set to true. If there is no such button, it is\n              // added to the first button (unless that button has isDefault\n              // set to false). There cannot be multiple default buttons.\n              var defaultElem;\n\n              for (var b = 0; b < aButtons.length; b++) {\n                var button = aButtons[b];\n                var buttonElem = document.createXULElement(\"button\");\n                buttonElem.setAttribute(\"label\", button.label);\n                if (typeof button.accessKey == \"string\")\n                  buttonElem.setAttribute(\"accesskey\", button.accessKey);\n                buttonElem.classList.add(\"notification-button\");\n\n                if (button.isDefault ||\n                    b == 0 && !(\"isDefault\" in button))\n                  defaultElem = buttonElem;\n\n                newitem.appendChild(buttonElem);\n                buttonElem.buttonInfo = button;\n              }\n\n              if (defaultElem)\n                defaultElem.classList.add(\"notification-button-default\");\n            }\n\n            newitem.setAttribute(\"priority\", aPriority);\n            if (aPriority >= this.PRIORITY_CRITICAL_LOW)\n              newitem.setAttribute(\"type\", \"critical\");\n            else if (aPriority <= this.PRIORITY_INFO_HIGH)\n              newitem.setAttribute(\"type\", \"info\");\n            else\n              newitem.setAttribute(\"type\", \"warning\");\n\n            if (!insertPos) {\n              newitem.style.position = \"fixed\";\n              newitem.style.top = \"100%\";\n              newitem.style.marginTop = \"-15px\";\n              newitem.style.opacity = \"0\";\n            }\n            this.insertBefore(newitem, insertPos);\n            // Can only insert the document fragment after the item has been created because\n            // otherwise the XBL structure isn't there yet:\n            if (labelIsDocFragment) {\n              document.getAnonymousElementByAttribute(newitem, \"anonid\", \"messageText\")\n                .appendChild(aLabel);\n            }\n\n            if (!insertPos)\n              this._showNotification(newitem, true);\n\n            // Fire event for accessibility APIs\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"AlertActive\", true, true);\n            newitem.dispatchEvent(event);\n\n            return newitem;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeNotification\">\n        <parameter name=\"aItem\"/>\n        <parameter name=\"aSkipAnimation\"/>\n        <body>\n          <![CDATA[\n            if (aItem == this.currentNotification)\n              this.removeCurrentNotification(aSkipAnimation);\n            else if (aItem != this._closedNotification)\n              this._removeNotificationElement(aItem);\n            return aItem;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_removeNotificationElement\">\n        <parameter name=\"aChild\"/>\n        <body>\n          <![CDATA[\n            if (aChild.eventCallback)\n              aChild.eventCallback(\"removed\");\n            this.removeChild(aChild);\n\n            // make sure focus doesn't get lost (workaround for bug 570835)\n            let fm = Cc[\"@mozilla.org/focus-manager;1\"]\n                       .getService(Ci.nsIFocusManager);\n            if (!fm.getFocusedElementForWindow(window, false, {}))\n              fm.moveFocus(window, this, fm.MOVEFOCUS_FORWARD, 0);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeCurrentNotification\">\n        <parameter name=\"aSkipAnimation\"/>\n        <body>\n          <![CDATA[\n            this._showNotification(this.currentNotification, false, aSkipAnimation);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeAllNotifications\">\n        <parameter name=\"aImmediate\"/>\n        <body>\n          <![CDATA[\n            var notifications = this.allNotifications;\n            for (var n = notifications.length - 1; n >= 0; n--) {\n              if (aImmediate)\n                this._removeNotificationElement(notifications[n]);\n              else\n                this.removeNotification(notifications[n]);\n            }\n            this.currentNotification = null;\n\n            // Clean up any currently-animating notification; this is necessary\n            // if a notification was just opened and is still animating, but we\n            // want to close it *without* animating.  This can even happen if\n            // the user toggled `toolkit.cosmeticAnimations.enabled` to false\n            // and called this method immediately after an animated notification\n            // displayed (although this case isn't very likely).\n            if (aImmediate || !this._allowAnimation)\n              this._finishAnimation();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"removeTransientNotifications\">\n        <body>\n          <![CDATA[\n            var notifications = this.allNotifications;\n            for (var n = notifications.length - 1; n >= 0; n--) {\n              var notification = notifications[n];\n              if (notification.persistence)\n                notification.persistence--;\n              else if (Date.now() > notification.timeout)\n                this.removeNotification(notification);\n            }\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_showNotification\">\n        <parameter name=\"aNotification\"/>\n        <parameter name=\"aSlideIn\"/>\n        <parameter name=\"aSkipAnimation\"/>\n        <body>\n          <![CDATA[\n            this._finishAnimation();\n\n            var height = aNotification.boxObject.height;\n            var skipAnimation = aSkipAnimation || height == 0 ||\n                                !this._allowAnimation;\n            aNotification.classList.toggle(\"animated\", !skipAnimation);\n\n            if (aSlideIn) {\n              this.currentNotification = aNotification;\n              aNotification.style.removeProperty(\"position\");\n              aNotification.style.removeProperty(\"top\");\n              aNotification.style.removeProperty(\"margin-top\");\n              aNotification.style.removeProperty(\"opacity\");\n\n              if (skipAnimation) {\n                this._setBlockingState(this.currentNotification);\n                return;\n              }\n            } else {\n              this._closedNotification = aNotification;\n              var notifications = this.allNotifications;\n              var idx = notifications.length - 1;\n              this.currentNotification = (idx >= 0) ? notifications[idx] : null;\n\n              if (skipAnimation) {\n                this._removeNotificationElement(this._closedNotification);\n                this._closedNotification = null;\n                this._setBlockingState(this.currentNotification);\n                return;\n              }\n\n              aNotification.style.marginTop = -height + \"px\";\n              aNotification.style.opacity = 0;\n            }\n\n            this._animating = true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_finishAnimation\">\n        <body><![CDATA[\n          if (this._animating) {\n            this._animating = false;\n            if (this._closedNotification) {\n              this._removeNotificationElement(this._closedNotification);\n              this._closedNotification = null;\n            }\n            this._setBlockingState(this.currentNotification);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_setBlockingState\">\n        <parameter name=\"aNotification\"/>\n        <body>\n          <![CDATA[\n            var isblock = aNotification &&\n                          aNotification.priority == this.PRIORITY_CRITICAL_BLOCK;\n            var canvas = this._blockingCanvas;\n            if (isblock) {\n              if (!canvas)\n                canvas = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n              const XULNS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n              let content = this.firstChild;\n              if (!content ||\n                   content.namespaceURI != XULNS ||\n                   content.localName != \"browser\")\n                return;\n\n              var width = content.boxObject.width;\n              var height = content.boxObject.height;\n              content.collapsed = true;\n\n              canvas.setAttribute(\"width\", width);\n              canvas.setAttribute(\"height\", height);\n              canvas.setAttribute(\"flex\", \"1\");\n\n              this.appendChild(canvas);\n              this._blockingCanvas = canvas;\n\n              var bgcolor = \"white\";\n              try {\n                var prefService = Cc[\"@mozilla.org/preferences-service;1\"].\n                                    getService(Ci.nsIPrefBranch);\n                bgcolor = prefService.getCharPref(\"browser.display.background_color\");\n\n                var win = content.contentWindow;\n                var context = canvas.getContext(\"2d\");\n                context.globalAlpha = 0.5;\n                context.drawWindow(win, win.scrollX, win.scrollY,\n                                   width, height, bgcolor);\n              } catch (ex) { }\n            } else if (canvas) {\n              canvas.remove();\n              this._blockingCanvas = null;\n              let content = this.firstChild;\n              if (content)\n                content.collapsed = false;\n            }\n          ]]>\n        </body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"transitionend\"><![CDATA[\n        if (event.target.localName == \"notification\" &&\n            event.propertyName == \"margin-top\")\n          this._finishAnimation();\n      ]]></handler>\n    </handlers>\n\n  </binding>\n\n  <binding id=\"notification\">\n    <content>\n      <xul:hbox anonid=\"details\" align=\"center\" flex=\"1\"\n                oncommand=\"this.parentNode._doButtonCommand(event);\">\n        <xul:image anonid=\"messageImage\" class=\"messageImage\" xbl:inherits=\"src=image,type,value\"/>\n        <xul:description anonid=\"messageText\" class=\"messageText\" flex=\"1\" xbl:inherits=\"xbl:text=label\"/>\n        <xul:spacer flex=\"1\"/>\n        <children/>\n      </xul:hbox>\n      <xul:toolbarbutton ondblclick=\"event.stopPropagation();\"\n                         class=\"messageCloseButton close-icon tabbable\"\n                         anonid=\"close-button\"\n                         xbl:inherits=\"hidden=hideclose\"\n                         tooltiptext=\"FROM-DTD.closeNotification.tooltip;\"\n                         oncommand=\"document.getBindingParent(this).dismiss();\"/>\n    </content>\n    <implementation>\n      <property name=\"label\" onset=\"this.setAttribute('label', val); return val;\"\n                             onget=\"return this.getAttribute('label');\"/>\n      <property name=\"value\" onset=\"this.setAttribute('value', val); return val;\"\n                             onget=\"return this.getAttribute('value');\"/>\n      <property name=\"image\" onset=\"this.setAttribute('image', val); return val;\"\n                             onget=\"return this.getAttribute('image');\"/>\n      <property name=\"type\" onset=\"this.setAttribute('type', val); return val;\"\n                            onget=\"return this.getAttribute('type');\"/>\n      <property name=\"priority\" onget=\"return parseInt(this.getAttribute('priority')) || 0;\"\n                                onset=\"this.setAttribute('priority', val); return val;\"/>\n      <property name=\"persistence\" onget=\"return parseInt(this.getAttribute('persistence')) || 0;\"\n                                   onset=\"this.setAttribute('persistence', val); return val;\"/>\n      <field name=\"timeout\">0</field>\n\n      <property name=\"control\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var parent = this.parentNode;\n            while (parent) {\n              if (parent.localName == \"notificationbox\")\n                return parent;\n              parent = parent.parentNode;\n            }\n            return null;\n          ]]>\n        </getter>\n      </property>\n\n      <!-- This method should only be called when the user has\n           manually closed the notification. If you want to\n           programmatically close the notification, you should\n           call close() instead. -->\n      <method name=\"dismiss\">\n        <body>\n          <![CDATA[\n            if (this.eventCallback) {\n              this.eventCallback(\"dismissed\");\n            }\n            this.close();\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"close\">\n        <body>\n          <![CDATA[\n            var control = this.control;\n            if (control)\n              control.removeNotification(this);\n            else\n              this.hidden = true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_doButtonCommand\">\n        <parameter name=\"aEvent\"/>\n        <body>\n          <![CDATA[\n            if (!(\"buttonInfo\" in aEvent.target))\n              return;\n\n            var button = aEvent.target.buttonInfo;\n            if (button.popup) {\n              document.getElementById(button.popup).\n                openPopup(aEvent.originalTarget, \"after_start\", 0, 0, false, false, aEvent);\n              aEvent.stopPropagation();\n            } else {\n              var callback = button.callback;\n              if (callback) {\n                var result = callback(this, button, aEvent.target, aEvent);\n                if (!result)\n                  this.close();\n                aEvent.stopPropagation();\n              }\n            }\n          ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"popup-notification\">\n    <content orient=\"vertical\">\n      <xul:hbox class=\"popup-notification-header-container\">\n        <children includes=\"popupnotificationheader\"/>\n      </xul:hbox>\n      <xul:hbox align=\"start\" class=\"popup-notification-body-container\">\n        <xul:image class=\"popup-notification-icon\"\n                   xbl:inherits=\"popupid,src=icon,class=iconclass\"/>\n        <xul:vbox flex=\"1\" pack=\"start\"\n                  class=\"popup-notification-body\" xbl:inherits=\"popupid\">\n          <xul:hbox align=\"start\">\n            <xul:vbox flex=\"1\">\n              <xul:label class=\"popup-notification-origin header\"\n                         xbl:inherits=\"value=origin,tooltiptext=origin\"\n                         crop=\"center\"/>\n              <!-- These need to be on the same line to avoid creating\n                   whitespace between them (whitespace is added in the\n                   localization file, if necessary). -->\n              <xul:description class=\"popup-notification-description\" xbl:inherits=\"popupid\"><html:span\n                xbl:inherits=\"xbl:text=label,popupid\"/><html:b xbl:inherits=\"xbl:text=name,popupid\"/><html:span\n              xbl:inherits=\"xbl:text=endlabel,popupid\"/></xul:description>\n            </xul:vbox>\n            <xul:toolbarbutton anonid=\"closebutton\"\n                               class=\"messageCloseButton close-icon popup-notification-closebutton tabbable\"\n                               xbl:inherits=\"oncommand=closebuttoncommand,hidden=closebuttonhidden\"\n                               tooltiptext=\"FROM-DTD.closeNotification.tooltip;\"/>\n          </xul:hbox>\n          <children includes=\"popupnotificationcontent\"/>\n          <xul:label class=\"text-link popup-notification-learnmore-link\"\n                     xbl:inherits=\"onclick=learnmoreclick,href=learnmoreurl\">FROM-DTD.learnMore;</xul:label>\n          <xul:checkbox anonid=\"checkbox\"\n                        xbl:inherits=\"hidden=checkboxhidden,checked=checkboxchecked,label=checkboxlabel,oncommand=checkboxcommand\" />\n          <xul:description class=\"popup-notification-warning\" xbl:inherits=\"hidden=warninghidden,xbl:text=warninglabel\"/>\n        </xul:vbox>\n      </xul:hbox>\n      <xul:hbox class=\"popup-notification-footer-container\">\n        <children includes=\"popupnotificationfooter\"/>\n      </xul:hbox>\n      <xul:hbox class=\"popup-notification-button-container\">\n        <children includes=\"button\"/>\n        <xul:button anonid=\"secondarybutton\"\n                    class=\"popup-notification-button\"\n                    xbl:inherits=\"oncommand=secondarybuttoncommand,label=secondarybuttonlabel,accesskey=secondarybuttonaccesskey,hidden=secondarybuttonhidden\"/>\n        <xul:toolbarseparator xbl:inherits=\"hidden=dropmarkerhidden\"/>\n        <xul:button anonid=\"menubutton\"\n                    type=\"menu\"\n                    class=\"popup-notification-button popup-notification-dropmarker\"\n                    aria-label=\"FROM-DTD.moreActionsButton.accessibleLabel;\"\n                    xbl:inherits=\"onpopupshown=dropmarkerpopupshown,hidden=dropmarkerhidden\">\n          <xul:menupopup anonid=\"menupopup\"\n                         position=\"after_end\"\n                         aria-label=\"FROM-DTD.moreActionsButton.accessibleLabel;\"\n                         xbl:inherits=\"oncommand=menucommand\">\n            <children/>\n          </xul:menupopup>\n        </xul:button>\n        <xul:button anonid=\"button\"\n                    class=\"popup-notification-button\"\n                    default=\"true\"\n                    label=\"FROM-DTD.defaultButton.label;\"\n                    accesskey=\"FROM-DTD.defaultButton.accesskey;\"\n                    xbl:inherits=\"oncommand=buttoncommand,label=buttonlabel,accesskey=buttonaccesskey,highlight=buttonhighlight,disabled=mainactiondisabled\"/>\n      </xul:hbox>\n    </content>\n    <implementation>\n      <field name=\"checkbox\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"checkbox\");\n      </field>\n      <field name=\"closebutton\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"closebutton\");\n      </field>\n      <field name=\"button\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"button\");\n      </field>\n      <field name=\"secondaryButton\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"secondarybutton\");\n      </field>\n      <field name=\"menubutton\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"menubutton\");\n      </field>\n      <field name=\"menupopup\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"menupopup\");\n      </field>\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"numberbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"numberboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"numberbox\"\n           extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content>\n      <xul:moz-input-box anonid=\"moz-input-box\" class=\"numberbox-input-box\" flex=\"1\" xbl:inherits=\"context,disabled,focused\">\n        <html:input class=\"numberbox-input textbox-input\" type=\"number\" anonid=\"input\"\n                    xbl:inherits=\"value,min,max,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey\"/>\n      </xul:moz-input-box>\n    </content>\n\n    <implementation>\n      <field name=\"_valueEntered\">false</field>\n      <field name=\"_value\">0</field>\n\n      <property name=\"value\" onget=\"return String(this.valueNumber)\"\n                             onset=\"return this.valueNumber = val;\"/>\n\n      <property name=\"valueNumber\">\n        <getter>\n          if (this._valueEntered) {\n            var newval = this.inputField.value;\n            this._validateValue(newval);\n          }\n          return this._value;\n        </getter>\n        <setter>\n          this._validateValue(val);\n          return val;\n        </setter>\n      </property>\n      <property name=\"min\">\n        <getter>\n          var min = this.getAttribute(\"min\");\n          return min ? Number(min) : 0;\n        </getter>\n        <setter>\n        <![CDATA[\n          if (typeof val == \"number\") {\n            this.setAttribute(\"min\", val);\n            if (this.valueNumber < val)\n              this._validateValue(val);\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"max\">\n        <getter>\n          var max = this.getAttribute(\"max\");\n          return max ? Number(max) : Infinity;\n        </getter>\n        <setter>\n        <![CDATA[\n          if (typeof val != \"number\")\n            return val;\n          var min = this.min;\n          if (val < min)\n            val = min;\n          this.setAttribute(\"max\", val);\n          if (this.valueNumber > val)\n            this._validateValue(val);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"_validateValue\">\n        <parameter name=\"aValue\"/>\n        <body>\n          <![CDATA[\n            aValue = Number(aValue) || 0;\n            aValue = Math.round(aValue);\n\n            var min = this.min;\n            var max = this.max;\n            if (aValue < min)\n              aValue = min;\n            else if (aValue > max)\n              aValue = max;\n\n            this._valueEntered = false;\n            this._value = Number(aValue);\n            this.inputField.value = aValue;\n\n            return aValue;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_fireChange\">\n        <body>\n          var evt = document.createEvent(\"Events\");\n          evt.initEvent(\"change\", true, true);\n          this.dispatchEvent(evt);\n        </body>\n      </method>\n\n      <constructor><![CDATA[\n        if (this.max < this.min)\n          this.max = this.min;\n\n        var value = this.inputField.value || 0;\n        this._validateValue(value);\n      ]]></constructor>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"input\" phase=\"capturing\">\n        this._valueEntered = true;\n      </handler>\n\n      <handler event=\"keypress\">\n        <![CDATA[\n          if (!event.ctrlKey && !event.metaKey && !event.altKey && event.charCode) {\n            if (event.charCode == 45 && this.min < 0)\n              return;\n\n            if (event.charCode < 48 || event.charCode > 57)\n              event.preventDefault();\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"change\">\n        if (event.originalTarget == this.inputField) {\n          this._validateValue(this.inputField.value);\n        }\n      </handler>\n    </handlers>\n\n  </binding>\n\n</bindings>\n"},{"file":"popup.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This files relies on these specific Chrome/XBL globals -->\n<!-- globals PopupBoxObject -->\n\n<bindings id=\"popupBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"popup\">\n    <content>\n      <xul:arrowscrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\"\n                          smoothscroll=\"false\">\n        <children/>\n      </xul:arrowscrollbox>\n    </content>\n\n    <implementation>\n      <field name=\"scrollBox\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"class\", \"popup-internal-box\");\n      </field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\">\n        <![CDATA[\n          var array = [];\n          var width = 0;\n          for (var menuitem = this.firstElementChild; menuitem; menuitem = menuitem.nextElementSibling) {\n            if (menuitem.localName == \"menuitem\" && menuitem.hasAttribute(\"acceltext\")) {\n              var accel = document.getAnonymousElementByAttribute(menuitem, \"anonid\", \"accel\");\n              if (accel && accel.boxObject) {\n                array.push(accel);\n                if (accel.boxObject.width > width)\n                  width = accel.boxObject.width;\n              }\n            }\n          }\n          for (var i = 0; i < array.length; i++)\n            array[i].width = width;\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"panel\">\n    <implementation>\n      <field name=\"_prevFocus\">0</field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"popupshowing\"><![CDATA[\n        // Capture the previous focus before has a chance to get set inside the panel\n        try {\n          this._prevFocus = Cu\n                            .getWeakReference(document.commandDispatcher.focusedElement);\n          if (this._prevFocus.get())\n            return;\n        } catch (ex) { }\n\n        this._prevFocus = Cu.getWeakReference(document.activeElement);\n      ]]></handler>\n      <handler event=\"popupshown\"><![CDATA[\n        // Fire event for accessibility APIs\n        var alertEvent = document.createEvent(\"Events\");\n        alertEvent.initEvent(\"AlertActive\", true, true);\n        this.dispatchEvent(alertEvent);\n       ]]></handler>\n      <handler event=\"popuphiding\"><![CDATA[\n        try {\n          this._currentFocus = document.commandDispatcher.focusedElement;\n        } catch (e) {\n          this._currentFocus = document.activeElement;\n        }\n      ]]></handler>\n      <handler event=\"popuphidden\"><![CDATA[\n        function doFocus() {\n          // Focus was set on an element inside this panel,\n          // so we need to move it back to where it was previously\n          try {\n            let fm = Cc[\"@mozilla.org/focus-manager;1\"]\n                       .getService(Ci.nsIFocusManager);\n            fm.setFocus(prevFocus, fm.FLAG_NOSCROLL);\n          } catch (e) {\n            prevFocus.focus();\n          }\n        }\n        var currentFocus = this._currentFocus;\n        var prevFocus = this._prevFocus ? this._prevFocus.get() : null;\n        this._currentFocus = null;\n        this._prevFocus = null;\n\n        // Avoid changing focus if focus changed while we hide the popup\n        // (This can happen e.g. if the popup is hiding as a result of a\n        // click/keypress that focused something)\n        let nowFocus;\n        try {\n          nowFocus = document.commandDispatcher.focusedElement;\n        } catch (e) {\n          nowFocus = document.activeElement;\n        }\n        if (nowFocus && nowFocus != currentFocus)\n          return;\n\n        if (prevFocus && this.getAttribute(\"norestorefocus\") != \"true\") {\n          // Try to restore focus\n          try {\n            if (document.commandDispatcher.focusedWindow != window)\n              return; // Focus has already been set to a window outside of this panel\n          } catch (ex) {}\n\n          if (!currentFocus) {\n            doFocus();\n            return;\n          }\n          while (currentFocus) {\n            if (currentFocus == this) {\n              doFocus();\n              return;\n            }\n            currentFocus = currentFocus.parentNode;\n          }\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"arrowpanel\" extends=\"chrome://global/content/bindings/popup.xml#panel\">\n    <resources>\n      <!-- Fixes an issue with the \"test_arrowpanel.xul\" animation on Mac, see bug 1470880. -->\n      <stylesheet src=\"data:text/css,\"/>\n    </resources>\n\n    <content flip=\"both\" side=\"top\" position=\"bottomcenter topleft\" consumeoutsideclicks=\"false\">\n      <xul:vbox anonid=\"container\" class=\"panel-arrowcontainer\" flex=\"1\"\n               xbl:inherits=\"side,panelopen\">\n        <xul:box anonid=\"arrowbox\" class=\"panel-arrowbox\">\n          <xul:image anonid=\"arrow\" class=\"panel-arrow\" xbl:inherits=\"side\"/>\n        </xul:box>\n        <xul:box class=\"panel-arrowcontent\" xbl:inherits=\"side,align,dir,orient,pack\" flex=\"1\">\n          <children/>\n        </xul:box>\n      </xul:vbox>\n    </content>\n    <implementation>\n      <field name=\"_fadeTimer\">null</field>\n      <method name=\"adjustArrowPosition\">\n        <body>\n        <![CDATA[\n        var anchor = this.anchorNode;\n        if (!anchor) {\n          return;\n        }\n\n        var container = document.getAnonymousElementByAttribute(this, \"anonid\", \"container\");\n        var arrowbox = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\");\n\n        var position = this.alignmentPosition;\n        var offset = this.alignmentOffset;\n\n        this.setAttribute(\"arrowposition\", position);\n\n        if (position.indexOf(\"start_\") == 0 || position.indexOf(\"end_\") == 0) {\n          container.orient = \"horizontal\";\n          arrowbox.orient = \"vertical\";\n          if (position.indexOf(\"_after\") > 0) {\n            arrowbox.pack = \"end\";\n          } else {\n            arrowbox.pack = \"start\";\n          }\n          arrowbox.style.transform = \"translate(0, \" + -offset + \"px)\";\n\n          // The assigned side stays the same regardless of direction.\n          var isRTL = (window.getComputedStyle(this).direction == \"rtl\");\n\n          if (position.indexOf(\"start_\") == 0) {\n            container.dir = \"reverse\";\n            this.setAttribute(\"side\", isRTL ? \"left\" : \"right\");\n          } else {\n            container.dir = \"\";\n            this.setAttribute(\"side\", isRTL ? \"right\" : \"left\");\n          }\n        } else if (position.indexOf(\"before_\") == 0 || position.indexOf(\"after_\") == 0) {\n          container.orient = \"\";\n          arrowbox.orient = \"\";\n          if (position.indexOf(\"_end\") > 0) {\n            arrowbox.pack = \"end\";\n          } else {\n            arrowbox.pack = \"start\";\n          }\n          arrowbox.style.transform = \"translate(\" + -offset + \"px, 0)\";\n\n          if (position.indexOf(\"before_\") == 0) {\n            container.dir = \"reverse\";\n            this.setAttribute(\"side\", \"bottom\");\n          } else {\n            container.dir = \"\";\n            this.setAttribute(\"side\", \"top\");\n          }\n        }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"popupshowing\" phase=\"target\">\n      <![CDATA[\n        var arrow = document.getAnonymousElementByAttribute(this, \"anonid\", \"arrow\");\n        arrow.hidden = this.anchorNode == null;\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"arrowbox\")\n                .style.removeProperty(\"transform\");\n\n        if (this.getAttribute(\"animate\") != \"false\") {\n          this.setAttribute(\"animate\", \"open\");\n          // the animating attribute prevents user interaction during transition\n          // it is removed when popupshown fires\n          this.setAttribute(\"animating\", \"true\");\n        }\n\n        // set fading\n        var fade = this.getAttribute(\"fade\");\n        var fadeDelay = 0;\n        if (fade == \"fast\") {\n          fadeDelay = 1;\n        } else if (fade == \"slow\") {\n          fadeDelay = 4000;\n        } else {\n          return;\n        }\n\n        this._fadeTimer = setTimeout(() => this.hidePopup(true), fadeDelay, this);\n      ]]>\n      </handler>\n      <handler event=\"popuphiding\" phase=\"target\">\n        let animate = (this.getAttribute(\"animate\") != \"false\");\n\n        if (this._fadeTimer) {\n          clearTimeout(this._fadeTimer);\n          if (animate) {\n            this.setAttribute(\"animate\", \"fade\");\n          }\n        } else if (animate) {\n          this.setAttribute(\"animate\", \"cancel\");\n        }\n      </handler>\n      <handler event=\"popupshown\" phase=\"target\">\n        this.removeAttribute(\"animating\");\n        this.setAttribute(\"panelopen\", \"true\");\n      </handler>\n      <handler event=\"popuphidden\" phase=\"target\">\n        this.removeAttribute(\"panelopen\");\n        if (this.getAttribute(\"animate\") != \"false\") {\n          this.removeAttribute(\"animate\");\n        }\n      </handler>\n      <handler event=\"popuppositioned\" phase=\"target\">\n        this.adjustArrowPosition();\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"popup-scrollbars\" extends=\"chrome://global/content/bindings/popup.xml#popup\">\n    <content>\n      <xul:scrollbox class=\"popup-internal-box\" flex=\"1\" orient=\"vertical\" style=\"overflow: auto;\">\n        <children/>\n      </xul:scrollbox>\n    </content>\n    <implementation>\n      <field name=\"AUTOSCROLL_INTERVAL\">25</field>\n      <field name=\"NOT_DRAGGING\">0</field>\n      <field name=\"DRAG_OVER_BUTTON\">-1</field>\n      <field name=\"DRAG_OVER_POPUP\">1</field>\n\n      <field name=\"_draggingState\">this.NOT_DRAGGING</field>\n      <field name=\"_scrollTimer\">0</field>\n\n      <method name=\"enableDragScrolling\">\n        <!-- when overItem is true, drag started over menuitem; when false, drag\n             started while the popup was opening.\n          -->\n        <parameter name=\"overItem\"/>\n        <body>\n        <![CDATA[\n          if (!this._draggingState) {\n            this.setCaptureAlways();\n            this._draggingState = overItem ? this.DRAG_OVER_POPUP : this.DRAG_OVER_BUTTON;\n          }\n        ]]>\n        </body>\n      </method>\n      <method name=\"_clearScrollTimer\">\n        <body>\n        <![CDATA[\n          if (this._scrollTimer) {\n            this.ownerGlobal.clearInterval(this._scrollTimer);\n            this._scrollTimer = 0;\n          }\n        ]]>\n        </body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"popupshown\">\n        // Enable drag scrolling even when the mouse wasn't used. The mousemove\n        // handler will remove it if the mouse isn't down.\n        this.enableDragScrolling(false);\n      </handler>\n\n      <handler event=\"popuphidden\">\n      <![CDATA[\n        this._draggingState = this.NOT_DRAGGING;\n        this._clearScrollTimer();\n        this.releaseCapture();\n      ]]>\n      </handler>\n\n      <handler event=\"mousedown\" button=\"0\">\n      <![CDATA[\n        if (this.state == \"open\" &&\n            (event.target.localName == \"menuitem\" ||\n             event.target.localName == \"menu\" ||\n             event.target.localName == \"menucaption\")) {\n          this.enableDragScrolling(true);\n        }\n      ]]>\n      </handler>\n      <handler event=\"mouseup\" button=\"0\">\n      <![CDATA[\n        this._draggingState = this.NOT_DRAGGING;\n        this._clearScrollTimer();\n      ]]>\n      </handler>\n      <handler event=\"mousemove\">\n      <![CDATA[\n        if (!this._draggingState) {\n          return;\n        }\n\n        this._clearScrollTimer();\n\n        // If the user released the mouse before the popup opens, we will\n        // still be capturing, so check that the button is still pressed. If\n        // not, release the capture and do nothing else. This also handles if\n        // the dropdown was opened via the keyboard.\n        if (!(event.buttons & 1)) {\n          this._draggingState = this.NOT_DRAGGING;\n          this.releaseCapture();\n          return;\n        }\n\n        // If dragging outside the top or bottom edge of the popup, but within\n        // the popup area horizontally, scroll the list in that direction. The\n        // _draggingState flag is used to ensure that scrolling does not start\n        // until the mouse has moved over the popup first, preventing scrolling\n        // while over the dropdown button.\n        let popupRect = this.getOuterScreenRect();\n        if (event.screenX >= popupRect.left && event.screenX <= popupRect.right) {\n          if (this._draggingState == this.DRAG_OVER_BUTTON) {\n            if (event.screenY > popupRect.top && event.screenY < popupRect.bottom) {\n              this._draggingState = this.DRAG_OVER_POPUP;\n            }\n          }\n\n          if (this._draggingState == this.DRAG_OVER_POPUP &&\n              (event.screenY <= popupRect.top || event.screenY >= popupRect.bottom)) {\n            let scrollAmount = event.screenY <= popupRect.top ? -1 : 1;\n            this.scrollBox.scrollByIndex(scrollAmount);\n\n            let win = this.ownerGlobal;\n            this._scrollTimer = win.setInterval(() => {\n              this.scrollBox.scrollByIndex(scrollAmount);\n            }, this.AUTOSCROLL_INTERVAL);\n          }\n        }\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"radio.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"radioBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"radio\"\n    extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <content>\n      <xul:image class=\"radio-check\" xbl:inherits=\"disabled,selected\"/>\n      <xul:hbox class=\"radio-label-box\" align=\"center\" flex=\"1\">\n        <xul:image class=\"radio-icon\" xbl:inherits=\"src\"/>\n        <xul:label class=\"radio-label\" xbl:inherits=\"xbl:text=label,accesskey,crop\" flex=\"1\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <constructor>\n        <![CDATA[\n          // Just clear out the parent's cached list of radio children\n          var control = this.control;\n          if (control)\n            control.radioChildConstructed(this);\n        ]]>\n      </constructor>\n      <destructor>\n        <![CDATA[\n          if (!this.control)\n            return;\n\n          var radioList = this.control._radioChildren;\n          if (!radioList)\n            return;\n          for (var i = 0; i < radioList.length; ++i) {\n            if (radioList[i] == this) {\n              radioList.splice(i, 1);\n              return;\n            }\n          }\n        ]]>\n      </destructor>\n      <property name=\"value\" onset=\"this.setAttribute('value', val); return val;\"\n                             onget=\"return this.getAttribute('value');\"/>\n      <property name=\"selected\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            return this.hasAttribute(\"selected\");\n          ]]>\n        </getter>\n      </property>\n      <property name=\"radioGroup\" readonly=\"true\" onget=\"return this.control\"/>\n      <property name=\"control\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          var radiogroup = this.closest(\"radiogroup\");\n          if (radiogroup) {\n            return radiogroup;\n          }\n\n          var group = this.getAttribute(\"group\");\n          if (!group) {\n            return null;\n          }\n\n          var parent = this.ownerDocument.getElementById(group);\n          if (!parent || parent.localName != \"radiogroup\") {\n            parent = null;\n          }\n          return parent;\n        ]]>\n        </getter>\n      </property>\n    </implementation>\n    <handlers>\n      <handler event=\"click\" button=\"0\">\n        <![CDATA[\n          if (!this.disabled)\n            this.control.selectedItem = this;\n         ]]>\n      </handler>\n\n      <handler event=\"mousedown\" button=\"0\">\n        <![CDATA[\n          if (!this.disabled)\n            this.control.focusedItem = this;\n         ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"richlistbox.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This file relies on these specific Chrome/XBL globals -->\n<!-- globals ChromeNodeList -->\n\n<bindings id=\"richlistboxBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"richlistbox\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <content>\n      <children includes=\"listheader\"/>\n      <xul:scrollbox allowevents=\"true\" orient=\"vertical\" anonid=\"main-box\"\n                     flex=\"1\" style=\"overflow: auto;\" xbl:inherits=\"dir,pack\">\n        <children/>\n      </xul:scrollbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULMultiSelectControlElement\">\n      <field name=\"_scrollbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"main-box\");\n      </field>\n      <constructor>\n        <![CDATA[\n          this._refreshSelection();\n        ]]>\n      </constructor>\n\n      <method name=\"_fireOnSelect\">\n        <body>\n          <![CDATA[\n            // make sure not to modify last-selected when suppressing select events\n            // (otherwise we'll lose the selection when a template gets rebuilt)\n            if (this._suppressOnSelect || this.suppressOnSelect)\n              return;\n\n            // remember the current item and all selected items with IDs\n            var state = this.currentItem ? this.currentItem.id : \"\";\n            if (this.selType == \"multiple\" && this.selectedCount) {\n              let getId = function getId(aItem) { return aItem.id; };\n              state += \" \" + [...this.selectedItems].filter(getId).map(getId).join(\" \");\n            }\n            if (state)\n              this.setAttribute(\"last-selected\", state);\n            else\n              this.removeAttribute(\"last-selected\");\n\n            // preserve the index just in case no IDs are available\n            if (this.currentIndex > -1)\n              this._currentIndex = this.currentIndex + 1;\n\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"select\", true, true);\n            this.dispatchEvent(event);\n\n            // always call this (allows a commandupdater without controller)\n            document.commandDispatcher.updateCommands(\"richlistbox-select\");\n          ]]>\n        </body>\n      </method>\n\n      <!-- We override base-listbox here because those methods don't take dir\n           into account on listbox (which doesn't support dir yet) -->\n      <method name=\"getNextItem\">\n        <parameter name=\"aStartItem\"/>\n        <parameter name=\"aDelta\"/>\n        <body>\n        <![CDATA[\n          var prop = this.dir == \"reverse\" && this._mayReverse ?\n                                                \"previousSibling\" :\n                                                \"nextSibling\";\n          while (aStartItem) {\n            aStartItem = aStartItem[prop];\n            if (aStartItem && aStartItem instanceof\n                Ci.nsIDOMXULSelectControlItemElement &&\n                (!this._userSelecting || this._canUserSelect(aStartItem))) {\n              --aDelta;\n              if (aDelta == 0)\n                return aStartItem;\n            }\n          }\n          return null;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getPreviousItem\">\n        <parameter name=\"aStartItem\"/>\n        <parameter name=\"aDelta\"/>\n        <body>\n        <![CDATA[\n          var prop = this.dir == \"reverse\" && this._mayReverse ?\n                                                \"nextSibling\" :\n                                                \"previousSibling\";\n          while (aStartItem) {\n            aStartItem = aStartItem[prop];\n            if (aStartItem && aStartItem instanceof\n                Ci.nsIDOMXULSelectControlItemElement &&\n                (!this._userSelecting || this._canUserSelect(aStartItem))) {\n              --aDelta;\n              if (aDelta == 0)\n                return aStartItem;\n            }\n          }\n          return null;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"appendItem\">\n        <parameter name=\"aLabel\"/>\n        <parameter name=\"aValue\"/>\n        <body>\n          var item =\n            this.ownerDocument.createXULElement(\"richlistitem\");\n          item.setAttribute(\"value\", aValue);\n\n          var label = this.ownerDocument.createXULElement(\"label\");\n          label.setAttribute(\"value\", aLabel);\n          label.setAttribute(\"flex\", \"1\");\n          label.setAttribute(\"crop\", \"end\");\n          item.appendChild(label);\n\n          this.appendChild(item);\n\n          return item;\n        </body>\n      </method>\n\n      <!-- nsIDOMXULSelectControlElement -->\n      <property name=\"selectedItem\"\n                onset=\"this.selectItem(val);\">\n        <getter>\n        <![CDATA[\n          return this.selectedItems.length > 0 ? this.selectedItems[0] : null;\n        ]]>\n        </getter>\n      </property>\n\n      <!-- nsIDOMXULSelectControlElement -->\n      <property name=\"selectedIndex\">\n        <getter>\n        <![CDATA[\n          if (this.selectedItems.length > 0)\n            return this.getIndexOfItem(this.selectedItems[0]);\n          return -1;\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          if (val >= 0) {\n            // This is a micro-optimization so that a call to getIndexOfItem or\n            // getItemAtIndex caused by _fireOnSelect (especially for derived\n            // widgets) won't loop the children.\n            this._selecting = {\n              item: this.getItemAtIndex(val),\n              index: val,\n            };\n            this.selectItem(this._selecting.item);\n            delete this._selecting;\n          } else {\n            this.clearSelection();\n            this.currentItem = null;\n          }\n        ]]>\n        </setter>\n      </property>\n\n      <!-- nsIDOMXULSelectControlElement -->\n      <property name=\"value\">\n        <getter>\n        <![CDATA[\n          if (this.selectedItems.length > 0)\n            return this.selectedItem.value;\n          return null;\n        ]]>\n        </getter>\n        <setter>\n        <![CDATA[\n          var kids = this.getElementsByAttribute(\"value\", val);\n          if (kids && kids.item(0))\n            this.selectItem(kids[0]);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <!-- nsIDOMXULSelectControlElement -->\n      <property name=\"itemCount\" readonly=\"true\"\n                onget=\"return this.children.length\"/>\n\n      <!-- nsIDOMXULSelectControlElement -->\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"aItem\"/>\n        <body>\n          <![CDATA[\n            // don't search the children, if we're looking for none of them\n            if (aItem == null)\n              return -1;\n            if (this._selecting && this._selecting.item == aItem)\n              return this._selecting.index;\n            return this.children.indexOf(aItem);\n          ]]>\n        </body>\n      </method>\n\n      <!-- nsIDOMXULSelectControlElement -->\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"aIndex\"/>\n        <body>\n          <![CDATA[\n            if (this._selecting && this._selecting.index == aIndex)\n              return this._selecting.item;\n            return this.children[aIndex] || null;\n          ]]>\n        </body>\n      </method>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <property name=\"selType\"\n                onget=\"return this.getAttribute('seltype');\"\n                onset=\"this.setAttribute('seltype', val); return val;\"/>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <property name=\"currentItem\" onget=\"return this._currentItem;\">\n        <setter>\n          if (this._currentItem == val)\n            return val;\n\n          if (this._currentItem)\n            this._currentItem.current = false;\n          this._currentItem = val;\n\n          if (val)\n            val.current = true;\n\n          return val;\n        </setter>\n      </property>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <property name=\"currentIndex\">\n        <getter>\n          return this.currentItem ? this.getIndexOfItem(this.currentItem) : -1;\n        </getter>\n        <setter>\n        <![CDATA[\n          if (val >= 0)\n            this.currentItem = this.getItemAtIndex(val);\n          else\n            this.currentItem = null;\n        ]]>\n        </setter>\n      </property>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <field name=\"selectedItems\">new ChromeNodeList()</field>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <method name=\"addItemToSelection\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          if (this.selType != \"multiple\" && this.selectedCount)\n            return;\n\n          if (aItem.selected)\n            return;\n\n          this.selectedItems.append(aItem);\n          aItem.selected = true;\n\n          this._fireOnSelect();\n        ]]>\n        </body>\n      </method>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <method name=\"removeItemFromSelection\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          if (!aItem.selected)\n            return;\n\n          this.selectedItems.remove(aItem);\n          aItem.selected = false;\n          this._fireOnSelect();\n        ]]>\n        </body>\n      </method>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <method name=\"toggleItemSelection\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          if (aItem.selected)\n            this.removeItemFromSelection(aItem);\n          else\n            this.addItemToSelection(aItem);\n        ]]>\n        </body>\n      </method>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <method name=\"selectItem\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          if (!aItem)\n            return;\n\n          if (this.selectedItems.length == 1 && this.selectedItems[0] == aItem)\n            return;\n\n          this._selectionStart = null;\n\n          var suppress = this._suppressOnSelect;\n          this._suppressOnSelect = true;\n\n          this.clearSelection();\n          this.addItemToSelection(aItem);\n          this.currentItem = aItem;\n\n          this._suppressOnSelect = suppress;\n          this._fireOnSelect();\n        ]]>\n        </body>\n      </method>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <method name=\"selectItemRange\">\n        <parameter name=\"aStartItem\"/>\n        <parameter name=\"aEndItem\"/>\n        <body>\n        <![CDATA[\n          if (this.selType != \"multiple\")\n            return;\n\n          if (!aStartItem)\n            aStartItem = this._selectionStart ?\n              this._selectionStart : this.currentItem;\n\n          if (!aStartItem)\n            aStartItem = aEndItem;\n\n          var suppressSelect = this._suppressOnSelect;\n          this._suppressOnSelect = true;\n\n          this._selectionStart = aStartItem;\n\n          var currentItem;\n          var startIndex = this.getIndexOfItem(aStartItem);\n          var endIndex = this.getIndexOfItem(aEndItem);\n          if (endIndex < startIndex) {\n            currentItem = aEndItem;\n            aEndItem = aStartItem;\n            aStartItem = currentItem;\n          } else {\n            currentItem = aStartItem;\n          }\n\n          while (currentItem) {\n            this.addItemToSelection(currentItem);\n            if (currentItem == aEndItem) {\n              currentItem = this.getNextItem(currentItem, 1);\n              break;\n            }\n            currentItem = this.getNextItem(currentItem, 1);\n          }\n\n          // Clear around new selection\n          // Don't use clearSelection() because it causes a lot of noise\n          // with respect to selection removed notifications used by the\n          // accessibility API support.\n          var userSelecting = this._userSelecting;\n          this._userSelecting = false; // that's US automatically unselecting\n          for (; currentItem; currentItem = this.getNextItem(currentItem, 1))\n            this.removeItemFromSelection(currentItem);\n\n          for (currentItem = this.getItemAtIndex(0); currentItem != aStartItem;\n               currentItem = this.getNextItem(currentItem, 1))\n            this.removeItemFromSelection(currentItem);\n          this._userSelecting = userSelecting;\n\n          this._suppressOnSelect = suppressSelect;\n\n          this._fireOnSelect();\n        ]]>\n        </body>\n      </method>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <method name=\"selectAll\">\n        <body>\n          this._selectionStart = null;\n\n          var suppress = this._suppressOnSelect;\n          this._suppressOnSelect = true;\n\n          var item = this.getItemAtIndex(0);\n          while (item) {\n            this.addItemToSelection(item);\n            item = this.getNextItem(item, 1);\n          }\n\n          this._suppressOnSelect = suppress;\n          this._fireOnSelect();\n        </body>\n      </method>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <method name=\"invertSelection\">\n        <body>\n          this._selectionStart = null;\n\n          var suppress = this._suppressOnSelect;\n          this._suppressOnSelect = true;\n\n          var item = this.getItemAtIndex(0);\n          while (item) {\n            if (item.selected)\n              this.removeItemFromSelection(item);\n            else\n              this.addItemToSelection(item);\n            item = this.getNextItem(item, 1);\n          }\n\n          this._suppressOnSelect = suppress;\n          this._fireOnSelect();\n        </body>\n      </method>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <method name=\"clearSelection\">\n        <body>\n        <![CDATA[\n          if (this.selectedItems) {\n            while (this.selectedItems.length > 0) {\n              let item = this.selectedItems[0];\n              item.selected = false;\n              this.selectedItems.remove(item);\n            }\n          }\n\n          this._selectionStart = null;\n          this._fireOnSelect();\n        ]]>\n        </body>\n      </method>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <property name=\"selectedCount\" readonly=\"true\"\n                onget=\"return this.selectedItems.length;\"/>\n\n      <!-- nsIDOMXULMultiSelectControlElement -->\n      <method name=\"getSelectedItem\">\n        <parameter name=\"aIndex\"/>\n        <body>\n        <![CDATA[\n          return aIndex < this.selectedItems.length ?\n            this.selectedItems[aIndex] : null;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"ensureIndexIsVisible\">\n        <parameter name=\"aIndex\"/>\n        <body>\n          <![CDATA[\n            return this.ensureElementIsVisible(this.getItemAtIndex(aIndex));\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"ensureElementIsVisible\">\n        <parameter name=\"aElement\"/>\n        <body>\n          <![CDATA[\n            if (!aElement)\n              return;\n            var targetRect = aElement.getBoundingClientRect();\n            var scrollRect = this._scrollbox.getBoundingClientRect();\n            var offset = targetRect.top - scrollRect.top;\n            if (offset >= 0) {\n              // scrollRect.bottom wouldn't take a horizontal scroll bar into account\n              let scrollRectBottom = scrollRect.top + this._scrollbox.clientHeight;\n              offset = targetRect.bottom - scrollRectBottom;\n              if (offset <= 0)\n                return;\n            }\n            this._scrollbox.scrollTop += offset;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"scrollToIndex\">\n        <parameter name=\"aIndex\"/>\n        <body>\n          <![CDATA[\n            var item = this.getItemAtIndex(aIndex);\n            if (item)\n              this._scrollbox.scrollToElement(item);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getIndexOfFirstVisibleRow\">\n        <body>\n          <![CDATA[\n            var children = this.children;\n\n            for (var ix = 0; ix < children.length; ix++)\n              if (this._isItemVisible(children[ix]))\n                return ix;\n\n            return -1;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"getRowCount\">\n        <body>\n          <![CDATA[\n            return this.children.length;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"scrollOnePage\">\n        <parameter name=\"aDirection\"/> <!-- Must be -1 or 1 -->\n        <body>\n          <![CDATA[\n            var children = this.children;\n\n            if (children.length == 0)\n              return 0;\n\n            // If nothing is selected, we just select the first element\n            // at the extreme we're moving away from\n            if (!this.currentItem)\n              return aDirection == -1 ? children.length : 0;\n\n            // If the current item is visible, scroll by one page so that\n            // the new current item is at approximately the same position as\n            // the existing current item.\n            if (this._isItemVisible(this.currentItem))\n              this._scrollbox.scrollBy(0, this._scrollbox.boxObject.height * aDirection);\n\n            // Figure out, how many items fully fit into the view port\n            // (including the currently selected one), and determine\n            // the index of the first one lying (partially) outside\n            var height = this._scrollbox.boxObject.height;\n            var startBorder = this.currentItem.boxObject.y;\n            if (aDirection == -1)\n              startBorder += this.currentItem.boxObject.height;\n\n            var index = this.currentIndex;\n            for (var ix = index; 0 <= ix && ix < children.length; ix += aDirection) {\n              var boxObject = children[ix].boxObject;\n              if (boxObject.height == 0)\n                continue; // hidden children have a y of 0\n              var endBorder = boxObject.y + (aDirection == -1 ? boxObject.height : 0);\n              if ((endBorder - startBorder) * aDirection > height)\n                break; // we've reached the desired distance\n              index = ix;\n            }\n\n            return index != this.currentIndex ? index - this.currentIndex : aDirection;\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"children\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            let iface = Ci.nsIDOMXULSelectControlItemElement;\n            let children = Array.from(this.childNodes)\n                                .filter(node => node.nodeType == 1 && node instanceof iface);\n            if (this.dir == \"reverse\" && this._mayReverse) {\n              children.reverse();\n            }\n            return children;\n          ]]>\n        </getter>\n      </property>\n\n      <method name=\"_refreshSelection\">\n        <body>\n          <![CDATA[\n            // when this method is called, we know that either the currentItem\n            // and selectedItems we have are null (ctor) or a reference to an\n            // element no longer in the DOM (template).\n\n            // first look for the last-selected attribute\n            var state = this.getAttribute(\"last-selected\");\n            if (state) {\n              var ids = state.split(\" \");\n\n              var suppressSelect = this._suppressOnSelect;\n              this._suppressOnSelect = true;\n              this.clearSelection();\n              for (let i = 1; i < ids.length; i++) {\n                var selectedItem = document.getElementById(ids[i]);\n                if (selectedItem)\n                  this.addItemToSelection(selectedItem);\n              }\n\n              var currentItem = document.getElementById(ids[0]);\n              if (!currentItem && this._currentIndex)\n                currentItem = this.getItemAtIndex(Math.min(\n                  this._currentIndex - 1, this.getRowCount()));\n              if (currentItem) {\n                this.currentItem = currentItem;\n                if (this.selType != \"multiple\" && this.selectedCount == 0)\n                  this.selectedItem = currentItem;\n\n                if (this._scrollbox.boxObject.height) {\n                  this.ensureElementIsVisible(currentItem);\n                } else {\n                  // XXX hack around a bug in ensureElementIsVisible as it will\n                  // scroll beyond the last element, bug 493645.\n                  var previousElement = this.dir == \"reverse\" ? currentItem.nextElementSibling :\n                                                                currentItem.previousElementSibling;\n                  this.ensureElementIsVisible(previousElement);\n                }\n              }\n              this._suppressOnSelect = suppressSelect;\n              // XXX actually it's just a refresh, but at least\n              // the Extensions manager expects this:\n              this._fireOnSelect();\n              return;\n            }\n\n            // try to restore the selected items according to their IDs\n            // (applies after a template rebuild, if last-selected was not set)\n            if (this.selectedItems) {\n              let itemIds = [];\n              for (let i = this.selectedCount - 1; i >= 0; i--) {\n                let selectedItem = this.selectedItems[i];\n                itemIds.push(selectedItem.id);\n                this.selectedItems.remove(selectedItem);\n              }\n              for (let i = 0; i < itemIds.length; i++) {\n                let selectedItem = document.getElementById(itemIds[i]);\n                if (selectedItem) {\n                  this.selectedItems.append(selectedItem);\n                }\n              }\n            }\n            if (this.currentItem && this.currentItem.id)\n              this.currentItem = document.getElementById(this.currentItem.id);\n            else\n              this.currentItem = null;\n\n            // if we have no previously current item or if the above check fails to\n            // find the previous nodes (which causes it to clear selection)\n            if (!this.currentItem && this.selectedCount == 0) {\n              this.currentIndex = this._currentIndex ? this._currentIndex - 1 : 0;\n\n              // cf. listbox constructor:\n              // select items according to their attributes\n              var children = this.children;\n              for (let i = 0; i < children.length; ++i) {\n                if (children[i].getAttribute(\"selected\") == \"true\")\n                  this.selectedItems.append(children[i]);\n              }\n            }\n\n            if (this.selType != \"multiple\" && this.selectedCount == 0)\n              this.selectedItem = this.currentItem;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_isItemVisible\">\n        <parameter name=\"aItem\"/>\n        <body>\n          <![CDATA[\n            if (!aItem)\n              return false;\n\n            var y = this._scrollbox.scrollTop + this._scrollbox.boxObject.y;\n\n            // Partially visible items are also considered visible\n            return (aItem.boxObject.y + aItem.boxObject.height > y) &&\n                   (aItem.boxObject.y < y + this._scrollbox.boxObject.height);\n          ]]>\n        </body>\n      </method>\n\n      <property name=\"disableKeyNavigation\"\n                onget=\"return this.hasAttribute('disableKeyNavigation');\">\n        <setter>\n          if (val)\n            this.setAttribute(\"disableKeyNavigation\", \"true\");\n          else\n            this.removeAttribute(\"disableKeyNavigation\");\n          return val;\n        </setter>\n      </property>\n\n      <property name=\"suppressOnSelect\"\n                onget=\"return this.getAttribute('suppressonselect') == 'true';\"\n                onset=\"this.setAttribute('suppressonselect', val);\"/>\n\n      <property name=\"_selectDelay\"\n                onset=\"this.setAttribute('_selectDelay', val);\"\n                onget=\"return this.getAttribute('_selectDelay') || 50;\"/>\n\n      <method name=\"moveByOffset\">\n        <parameter name=\"aOffset\"/>\n        <parameter name=\"aIsSelecting\"/>\n        <parameter name=\"aIsSelectingRange\"/>\n        <body>\n        <![CDATA[\n          if ((aIsSelectingRange || !aIsSelecting) &&\n              this.selType != \"multiple\")\n            return;\n\n          var newIndex = this.currentIndex + aOffset;\n          if (newIndex < 0)\n            newIndex = 0;\n\n          var numItems = this.getRowCount();\n          if (newIndex > numItems - 1)\n            newIndex = numItems - 1;\n\n          var newItem = this.getItemAtIndex(newIndex);\n          // make sure that the item is actually visible/selectable\n          if (this._userSelecting && newItem && !this._canUserSelect(newItem))\n            newItem =\n              aOffset > 0 ? this.getNextItem(newItem, 1) || this.getPreviousItem(newItem, 1) :\n                            this.getPreviousItem(newItem, 1) || this.getNextItem(newItem, 1);\n          if (newItem) {\n            this.ensureIndexIsVisible(this.getIndexOfItem(newItem));\n            if (aIsSelectingRange)\n              this.selectItemRange(null, newItem);\n            else if (aIsSelecting)\n              this.selectItem(newItem);\n\n            this.currentItem = newItem;\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByOffsetFromUserEvent\">\n        <parameter name=\"aOffset\"/>\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          if (!aEvent.defaultPrevented) {\n            this._userSelecting = true;\n            this._mayReverse = true;\n            this.moveByOffset(aOffset, !aEvent.ctrlKey, aEvent.shiftKey);\n            this._userSelecting = false;\n            this._mayReverse = false;\n            aEvent.preventDefault();\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_canUserSelect\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          var style = document.defaultView.getComputedStyle(aItem);\n          return style.display != \"none\" && style.visibility == \"visible\";\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_selectTimeoutHandler\">\n        <parameter name=\"aMe\"/>\n        <body>\n          aMe._fireOnSelect();\n          aMe._selectTimeout = null;\n        </body>\n      </method>\n\n      <method name=\"timedSelect\">\n        <parameter name=\"aItem\"/>\n        <parameter name=\"aTimeout\"/>\n        <body>\n        <![CDATA[\n          var suppress = this._suppressOnSelect;\n          if (aTimeout != -1)\n            this._suppressOnSelect = true;\n\n          this.selectItem(aItem);\n\n          this._suppressOnSelect = suppress;\n\n          if (aTimeout != -1) {\n            if (this._selectTimeout)\n              window.clearTimeout(this._selectTimeout);\n            this._selectTimeout =\n              window.setTimeout(this._selectTimeoutHandler, aTimeout, this);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"_currentIndex\">null</field>\n      <field name=\"_lastKeyTime\">0</field>\n      <field name=\"_incrementalString\">\"\"</field>\n      <field name=\"_suppressOnSelect\">false</field>\n      <field name=\"_userSelecting\">false</field>\n      <field name=\"_mayReverse\">false</field>\n      <field name=\"_selectTimeout\">null</field>\n      <field name=\"_currentItem\">null</field>\n      <field name=\"_selectionStart\">null</field>\n\n      <!-- For backwards-compatibility and for convenience.\n        Use ensureElementIsVisible instead -->\n      <method name=\"ensureSelectedElementIsVisible\">\n        <body>\n          <![CDATA[\n            return this.ensureElementIsVisible(this.selectedItem);\n          ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_UP\" modifiers=\"control shift any\"\n               action=\"this._moveByOffsetFromUserEvent(-1, event);\"\n               group=\"system\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_DOWN\" modifiers=\"control shift any\"\n               action=\"this._moveByOffsetFromUserEvent(1, event);\"\n               group=\"system\"/>\n\n      <handler event=\"keypress\" keycode=\"VK_HOME\" modifiers=\"control shift any\"\n               group=\"system\">\n        <![CDATA[\n          this._mayReverse = true;\n          this._moveByOffsetFromUserEvent(-this.currentIndex, event);\n          this._mayReverse = false;\n        ]]>\n      </handler>\n\n      <handler event=\"keypress\" keycode=\"VK_END\" modifiers=\"control shift any\"\n               group=\"system\">\n        <![CDATA[\n          this._mayReverse = true;\n          this._moveByOffsetFromUserEvent(this.getRowCount() - this.currentIndex - 1, event);\n          this._mayReverse = false;\n        ]]>\n      </handler>\n\n      <handler event=\"keypress\" keycode=\"VK_PAGE_UP\" modifiers=\"control shift any\"\n               group=\"system\">\n        <![CDATA[\n          this._mayReverse = true;\n          this._moveByOffsetFromUserEvent(this.scrollOnePage(-1), event);\n          this._mayReverse = false;\n        ]]>\n      </handler>\n\n      <handler event=\"keypress\" keycode=\"VK_PAGE_DOWN\" modifiers=\"control shift any\"\n               group=\"system\">\n        <![CDATA[\n          this._mayReverse = true;\n          this._moveByOffsetFromUserEvent(this.scrollOnePage(1), event);\n          this._mayReverse = false;\n        ]]>\n      </handler>\n\n      <handler event=\"keypress\" key=\" \" modifiers=\"control\" phase=\"target\">\n        <![CDATA[\n          if (this.currentItem && this.selType == \"multiple\")\n            this.toggleItemSelection(this.currentItem);\n        ]]>\n      </handler>\n\n      <handler event=\"focus\">\n        <![CDATA[\n          if (this.getRowCount() > 0) {\n            if (this.currentIndex == -1) {\n              this.currentIndex = this.getIndexOfFirstVisibleRow();\n              let currentItem = this.getItemAtIndex(this.currentIndex);\n              if (currentItem) {\n                this.selectItem(currentItem);\n              }\n            } else {\n              this.currentItem._fireEvent(\"DOMMenuItemActive\");\n            }\n          }\n          this._lastKeyTime = 0;\n        ]]>\n      </handler>\n\n      <handler event=\"keypress\" phase=\"target\">\n        <![CDATA[\n          if (this.disableKeyNavigation || !event.charCode ||\n              event.altKey || event.ctrlKey || event.metaKey)\n            return;\n\n          if (event.timeStamp - this._lastKeyTime > 1000)\n            this._incrementalString = \"\";\n\n          var key = String.fromCharCode(event.charCode).toLowerCase();\n          this._incrementalString += key;\n          this._lastKeyTime = event.timeStamp;\n\n          // If all letters in the incremental string are the same, just\n          // try to match the first one\n          var incrementalString = /^(.)\\1+$/.test(this._incrementalString) ?\n                                  RegExp.$1 : this._incrementalString;\n          var length = incrementalString.length;\n\n          var rowCount = this.getRowCount();\n          var l = this.selectedItems.length;\n          var start = l > 0 ? this.getIndexOfItem(this.selectedItems[l - 1]) : -1;\n          // start from the first element if none was selected or from the one\n          // following the selected one if it's a new or a repeated-letter search\n          if (start == -1 || length == 1)\n            start++;\n\n          for (var i = 0; i < rowCount; i++) {\n            var k = (start + i) % rowCount;\n            var listitem = this.getItemAtIndex(k);\n            if (!this._canUserSelect(listitem))\n              continue;\n            // allow richlistitems to specify the string being searched for\n            var searchText = \"searchLabel\" in listitem ? listitem.searchLabel :\n                             listitem.getAttribute(\"label\"); // (see also bug 250123)\n            searchText = searchText.substring(0, length).toLowerCase();\n            if (searchText == incrementalString) {\n              this.ensureIndexIsVisible(k);\n              this.timedSelect(listitem, this._selectDelay);\n              break;\n            }\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"click\">\n        <![CDATA[\n          // clicking into nothing should unselect\n          if (event.originalTarget == this._scrollbox) {\n            this.clearSelection();\n            this.currentItem = null;\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"MozSwipeGesture\">\n        <![CDATA[\n          // Only handle swipe gestures up and down\n          switch (event.direction) {\n            case event.DIRECTION_DOWN:\n              this._scrollbox.scrollTop = this._scrollbox.scrollHeight;\n              break;\n            case event.DIRECTION_UP:\n              this._scrollbox.scrollTop = 0;\n              break;\n          }\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"richlistitem\"\n           extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <field name=\"selectedByMouseOver\">false</field>\n\n      <destructor>\n        <![CDATA[\n          var control = this.control;\n          if (!control)\n            return;\n          // When we are destructed and we are current or selected, unselect ourselves\n          // so that richlistbox's selection doesn't point to something not in the DOM.\n          // We don't want to reset last-selected, so we set _suppressOnSelect.\n          if (this.selected) {\n            var suppressSelect = control._suppressOnSelect;\n            control._suppressOnSelect = true;\n            control.removeItemFromSelection(this);\n            control._suppressOnSelect = suppressSelect;\n          }\n          if (this.current)\n            control.currentItem = null;\n        ]]>\n      </destructor>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"label\" readonly=\"true\">\n        <!-- Setter purposely not implemented; the getter returns a\n             concatentation of label text to expose via accessibility APIs -->\n        <getter>\n          <![CDATA[\n            const XULNS =\n              \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n            return Array.map(this.getElementsByTagNameNS(XULNS, \"label\"),\n                             label => label.value)\n                        .join(\" \");\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"searchLabel\">\n        <getter>\n          <![CDATA[\n            return this.hasAttribute(\"searchlabel\") ?\n                   this.getAttribute(\"searchlabel\") : this.label;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            if (val !== null)\n              this.setAttribute(\"searchlabel\", val);\n            else\n              // fall back to the label property (default value)\n              this.removeAttribute(\"searchlabel\");\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"value\" onget=\"return this.getAttribute('value');\"\n                             onset=\"this.setAttribute('value', val); return val;\"/>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"selected\" onget=\"return this.getAttribute('selected') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.setAttribute(\"selected\", \"true\");\n          else\n            this.removeAttribute(\"selected\");\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <!-- nsIDOMXULSelectControlItemElement -->\n      <property name=\"control\">\n        <getter><![CDATA[\n          var parent = this.parentNode;\n          while (parent) {\n            if (parent instanceof Ci.nsIDOMXULSelectControlElement)\n              return parent;\n            parent = parent.parentNode;\n          }\n          return null;\n        ]]></getter>\n      </property>\n\n      <property name=\"current\" onget=\"return this.getAttribute('current') == 'true';\">\n        <setter><![CDATA[\n          if (val)\n            this.setAttribute(\"current\", \"true\");\n          else\n            this.removeAttribute(\"current\");\n\n          let control = this.control;\n          if (!control || !control.suppressMenuItemEvent) {\n            this._fireEvent(val ? \"DOMMenuItemActive\" : \"DOMMenuItemInactive\");\n          }\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <method name=\"_fireEvent\">\n        <parameter name=\"name\"/>\n        <body>\n        <![CDATA[\n          var event = document.createEvent(\"Events\");\n          event.initEvent(name, true, true);\n          this.dispatchEvent(event);\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <!-- If there is no modifier key, we select on mousedown, not\n           click, so that drags work correctly. -->\n      <handler event=\"mousedown\">\n        <![CDATA[\n          var control = this.control;\n          if (!control || control.disabled)\n            return;\n          if ((!event.ctrlKey || (/Mac/.test(navigator.platform) && event.button == 2)) &&\n              !event.shiftKey && !event.metaKey) {\n            if (!this.selected) {\n              control.selectItem(this);\n            }\n            control.currentItem = this;\n          }\n        ]]>\n      </handler>\n\n      <!-- On a click (up+down on the same item), deselect everything\n           except this item. -->\n      <handler event=\"click\" button=\"0\">\n        <![CDATA[\n          var control = this.control;\n          if (!control || control.disabled)\n            return;\n          control._userSelecting = true;\n          if (control.selType != \"multiple\") {\n            control.selectItem(this);\n          } else if (event.ctrlKey || event.metaKey) {\n            control.toggleItemSelection(this);\n            control.currentItem = this;\n          } else if (event.shiftKey) {\n            control.selectItemRange(null, this);\n            control.currentItem = this;\n          } else {\n            /* We want to deselect all the selected items except what was\n              clicked, UNLESS it was a right-click.  We have to do this\n              in click rather than mousedown so that you can drag a\n              selected group of items */\n\n            // use selectItemRange instead of selectItem, because this\n            // doesn't de- and reselect this item if it is selected\n            control.selectItemRange(this, this);\n          }\n          control._userSelecting = false;\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"scrollbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"arrowscrollboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"scrollbox\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <content>\n      <xul:box class=\"box-inherit scrollbox-innerbox\" xbl:inherits=\"orient,align,pack,dir\" flex=\"1\">\n        <children/>\n      </xul:box>\n    </content>\n  </binding>\n\n  <binding id=\"arrowscrollbox\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <content>\n      <xul:toolbarbutton class=\"scrollbutton-up\"\n                         anonid=\"scrollbutton-up\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtostart\"\n                         onmouseover=\"_startScroll(-1);\"\n                         onmouseout=\"_stopScroll();\"/>\n      <xul:spacer class=\"arrowscrollbox-overflow-start-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtostart\"/>\n      <xul:scrollbox class=\"arrowscrollbox-scrollbox\"\n                     anonid=\"scrollbox\"\n                     flex=\"1\"\n                     xbl:inherits=\"orient,align,pack,dir,smoothscroll\">\n        <children/>\n      </xul:scrollbox>\n      <xul:spacer class=\"arrowscrollbox-overflow-end-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtoend\"/>\n      <xul:toolbarbutton class=\"scrollbutton-down\"\n                         anonid=\"scrollbutton-down\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtoend\"\n                         onmouseover=\"_startScroll(1);\"\n                         onmouseout=\"_stopScroll();\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (!this.hasAttribute(\"smoothscroll\")) {\n          this.smoothScroll = this._prefBranch\n                                  .getBoolPref(\"toolkit.scrollbox.smoothScroll\", true);\n        }\n\n        this.setAttribute(\"notoverflowing\", \"true\");\n        this._updateScrollButtonsDisabledState();\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // Release timer to avoid reference cycles.\n        if (this._scrollTimer) {\n          this._scrollTimer.cancel();\n          this._scrollTimer = null;\n        }\n      ]]></destructor>\n\n      <field name=\"_scrollbox\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbox\");\n      </field>\n      <field name=\"_scrollButtonUp\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbutton-up\");\n      </field>\n      <field name=\"_scrollButtonDown\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"scrollbutton-down\");\n      </field>\n\n      <field name=\"__prefBranch\">null</field>\n      <property name=\"_prefBranch\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.__prefBranch === null) {\n            this.__prefBranch = Cc[\"@mozilla.org/preferences-service;1\"]\n                                  .getService(Ci.nsIPrefBranch);\n          }\n          return this.__prefBranch;\n        ]]></getter>\n      </property>\n\n      <field name=\"_scrollIncrement\">null</field>\n      <property name=\"scrollIncrement\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this._scrollIncrement === null) {\n            this._scrollIncrement = this._prefBranch\n                                        .getIntPref(\"toolkit.scrollbox.scrollIncrement\", 20);\n          }\n          return this._scrollIncrement;\n        ]]></getter>\n      </property>\n\n      <property name=\"smoothScroll\">\n        <getter><![CDATA[\n          return this.getAttribute(\"smoothscroll\") == \"true\";\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"smoothscroll\", !!val);\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"scrollBoxObject\" readonly=\"true\">\n        <getter><![CDATA[\n          return this._scrollbox.boxObject;\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollClientRect\" readonly=\"true\">\n        <getter><![CDATA[\n          return this._scrollbox.getBoundingClientRect();\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollClientSize\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this._scrollbox.clientHeight :\n                 this._scrollbox.clientWidth;\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollSize\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this._scrollbox.scrollHeight :\n                 this._scrollbox.scrollWidth;\n        ]]></getter>\n      </property>\n\n      <property name=\"lineScrollAmount\" readonly=\"true\">\n        <getter><![CDATA[\n          // line scroll amout should be the width (at horizontal scrollbox) or\n          // the height (at vertical scrollbox) of the scrolled elements.\n          // However, the elements may have different width or height.  So,\n          // for consistent speed, let's use avalage with of the elements.\n          var elements = this._getScrollableElements();\n          return elements.length && (this.scrollSize / elements.length);\n        ]]></getter>\n      </property>\n\n      <property name=\"scrollPosition\" readonly=\"true\">\n        <getter><![CDATA[\n          return this.orient == \"vertical\" ?\n                 this._scrollbox.scrollTop :\n                 this._scrollbox.scrollLeft;\n        ]]></getter>\n      </property>\n\n      <field name=\"_startEndProps\"><![CDATA[\n        this.orient == \"vertical\" ? [\"top\", \"bottom\"] : [\"left\", \"right\"];\n      ]]></field>\n\n      <field name=\"_isRTLScrollbox\"><![CDATA[\n        this.orient != \"vertical\" &&\n        document.defaultView.getComputedStyle(this._scrollbox).direction == \"rtl\";\n      ]]></field>\n\n      <method name=\"_boundsWithoutFlushing\">\n        <parameter name=\"element\"/>\n        <body><![CDATA[\n          if (!(\"_DOMWindowUtils\" in this)) {\n            this._DOMWindowUtils = window.windowUtils;\n          }\n\n          return this._DOMWindowUtils ?\n                 this._DOMWindowUtils.getBoundsWithoutFlushing(element) :\n                 element.getBoundingClientRect();\n        ]]></body>\n      </method>\n\n      <method name=\"_canScrollToElement\">\n        <parameter name=\"element\"/>\n        <body><![CDATA[\n          if (element.hidden) {\n            return false;\n          }\n\n          // See if the element is hidden via CSS without the hidden attribute.\n          // If we get only zeros for the client rect, this means the element\n          // is hidden. As a performance optimization, we don't flush layout\n          // here which means that on the fly changes aren't fully supported.\n          let rect = this._boundsWithoutFlushing(element);\n          return !!(rect.top || rect.left || rect.width || rect.height);\n        ]]></body>\n      </method>\n\n      <field name=\"_ensureElementIsVisibleAnimationFrame\">0</field>\n      <method name=\"ensureElementIsVisible\">\n        <parameter name=\"element\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (!this._canScrollToElement(element))\n            return;\n\n          if (this._ensureElementIsVisibleAnimationFrame) {\n            window.cancelAnimationFrame(this._ensureElementIsVisibleAnimationFrame);\n          }\n          this._ensureElementIsVisibleAnimationFrame = window.requestAnimationFrame(() => {\n            element.scrollIntoView({ behavior: aInstant ? \"instant\" : \"auto\" });\n            this._ensureElementIsVisibleAnimationFrame = 0;\n          });\n        ]]></body>\n      </method>\n\n      <method name=\"scrollByIndex\">\n        <parameter name=\"index\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          if (index == 0)\n            return;\n\n          var rect = this.scrollClientRect;\n          var [start, end] = this._startEndProps;\n          var x = index > 0 ? rect[end] + 1 : rect[start] - 1;\n          var nextElement = this._elementFromPoint(x, index);\n          if (!nextElement)\n            return;\n\n          var targetElement;\n          if (this._isRTLScrollbox)\n            index *= -1;\n          while (index < 0 && nextElement) {\n            if (this._canScrollToElement(nextElement))\n              targetElement = nextElement;\n            nextElement = nextElement.previousElementSibling;\n            index++;\n          }\n          while (index > 0 && nextElement) {\n            if (this._canScrollToElement(nextElement))\n              targetElement = nextElement;\n            nextElement = nextElement.nextElementSibling;\n            index--;\n          }\n          if (!targetElement)\n            return;\n\n          this.ensureElementIsVisible(targetElement, aInstant);\n        ]]></body>\n      </method>\n\n      <method name=\"_getScrollableElements\">\n        <body><![CDATA[\n          var nodes = this.children;\n          if (nodes.length == 1 &&\n              nodes[0].localName == \"children\" &&\n              nodes[0].namespaceURI == \"http://www.mozilla.org/xbl\") {\n            nodes = document.getBindingParent(this).children;\n          }\n\n          return Array.filter(nodes, this._canScrollToElement, this);\n        ]]></body>\n      </method>\n\n      <method name=\"_elementFromPoint\">\n        <parameter name=\"aX\"/>\n        <parameter name=\"aPhysicalScrollDir\"/>\n        <body><![CDATA[\n          var elements = this._getScrollableElements();\n          if (!elements.length)\n            return null;\n\n          if (this._isRTLScrollbox)\n            elements.reverse();\n\n          var [start, end] = this._startEndProps;\n          var low = 0;\n          var high = elements.length - 1;\n\n          if (aX < elements[low].getBoundingClientRect()[start] ||\n              aX > elements[high].getBoundingClientRect()[end])\n            return null;\n\n          var mid, rect;\n          while (low <= high) {\n            mid = Math.floor((low + high) / 2);\n            rect = elements[mid].getBoundingClientRect();\n            if (rect[start] > aX)\n              high = mid - 1;\n            else if (rect[end] < aX)\n              low = mid + 1;\n            else\n              return elements[mid];\n          }\n\n          // There's no element at the requested coordinate, but the algorithm\n          // from above yields an element next to it, in a random direction.\n          // The desired scrolling direction leads to the correct element.\n\n          if (!aPhysicalScrollDir)\n            return null;\n\n          if (aPhysicalScrollDir < 0 && rect[start] > aX)\n            mid = Math.max(mid - 1, 0);\n          else if (aPhysicalScrollDir > 0 && rect[end] < aX)\n            mid = Math.min(mid + 1, elements.length - 1);\n\n          return elements[mid];\n        ]]></body>\n      </method>\n\n      <method name=\"_startScroll\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._isRTLScrollbox) {\n            index *= -1;\n          }\n\n          if (!this._scrollTimer) {\n            this._scrollTimer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n          } else {\n            this._scrollTimer.cancel();\n          }\n\n          let callback = () => this.scrollByPixels(this.scrollIncrement * index);\n\n          // Use the same REPEAT_DELAY as \"nsRepeatService.h\".\n          let scrollDelay = /Mac/.test(navigator.platform) ? 25 : 50;\n\n          this._scrollTimer.initWithCallback(callback, scrollDelay,\n                                             Ci.nsITimer.TYPE_REPEATING_SLACK);\n          callback();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_stopScroll\">\n        <body><![CDATA[\n          if (this._scrollTimer)\n            this._scrollTimer.cancel();\n        ]]></body>\n      </method>\n\n      <method name=\"scrollByPixels\">\n        <parameter name=\"aPixels\"/>\n        <parameter name=\"aInstant\"/>\n        <body><![CDATA[\n          let scrollOptions = { behavior: aInstant ? \"instant\" : \"auto\" };\n          scrollOptions[this._startEndProps[0]] = aPixels;\n          this._scrollbox.scrollBy(scrollOptions);\n        ]]></body>\n      </method>\n\n      <field name=\"_prevMouseScrolls\">[null, null]</field>\n\n      <field name=\"_touchStart\">-1</field>\n\n      <field name=\"_scrollButtonUpdatePending\">false</field>\n      <method name=\"_updateScrollButtonsDisabledState\">\n        <body><![CDATA[\n          if (this.hasAttribute(\"notoverflowing\")) {\n            this.setAttribute(\"scrolledtoend\", \"true\");\n            this.setAttribute(\"scrolledtostart\", \"true\");\n            return;\n          }\n\n          if (this._scrollButtonUpdatePending) {\n            return;\n          }\n          this._scrollButtonUpdatePending = true;\n\n          // Wait until after the next paint to get current layout data from\n          // getBoundsWithoutFlushing.\n          window.requestAnimationFrame(() => {\n            setTimeout(() => {\n              this._scrollButtonUpdatePending = false;\n\n              let scrolledToStart = false;\n              let scrolledToEnd = false;\n\n              if (this.hasAttribute(\"notoverflowing\")) {\n                scrolledToStart = true;\n                scrolledToEnd = true;\n              } else {\n                let [leftOrTop, rightOrBottom] = this._startEndProps;\n                let leftOrTopEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[leftOrTop]);\n                let rightOrBottomEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[rightOrBottom]);\n\n                let elements = this._getScrollableElements();\n                let [leftOrTopElement, rightOrBottomElement] = [elements[0], elements[elements.length - 1]];\n                if (this._isRTLScrollbox) {\n                  [leftOrTopElement, rightOrBottomElement] = [rightOrBottomElement, leftOrTopElement];\n                }\n\n                if (leftOrTopElement &&\n                    leftOrTopEdge(leftOrTopElement) >= leftOrTopEdge(this._scrollbox)) {\n                  scrolledToStart = !this._isRTLScrollbox;\n                  scrolledToEnd = this._isRTLScrollbox;\n                } else if (rightOrBottomElement &&\n                           rightOrBottomEdge(rightOrBottomElement) <= rightOrBottomEdge(this._scrollbox)) {\n                  scrolledToStart = this._isRTLScrollbox;\n                  scrolledToEnd = !this._isRTLScrollbox;\n                }\n              }\n\n              if (scrolledToEnd) {\n                this.setAttribute(\"scrolledtoend\", \"true\");\n              } else {\n                this.removeAttribute(\"scrolledtoend\");\n              }\n\n              if (scrolledToStart) {\n                this.setAttribute(\"scrolledtostart\", \"true\");\n              } else {\n                this.removeAttribute(\"scrolledtostart\");\n              }\n            }, 0);\n          });\n        ]]></body>\n      </method>\n\n      <field name=\"_isScrolling\">false</field>\n      <field name=\"_destination\">0</field>\n      <field name=\"_direction\">0</field>\n    </implementation>\n\n    <handlers>\n      <handler event=\"wheel\"><![CDATA[\n        let doScroll = false;\n        let instant;\n        let scrollAmount = 0;\n        if (this.orient == \"vertical\") {\n          doScroll = true;\n          if (event.deltaMode == event.DOM_DELTA_PIXEL)\n            scrollAmount = event.deltaY;\n          else if (event.deltaMode == event.DOM_DELTA_PAGE)\n            scrollAmount = event.deltaY * this.scrollClientSize;\n          else\n            scrollAmount = event.deltaY * this.lineScrollAmount;\n        } else {\n          // We allow vertical scrolling to scroll a horizontal scrollbox\n          // because many users have a vertical scroll wheel but no\n          // horizontal support.\n          // Because of this, we need to avoid scrolling chaos on trackpads\n          // and mouse wheels that support simultaneous scrolling in both axes.\n          // We do this by scrolling only when the last two scroll events were\n          // on the same axis as the current scroll event.\n          // For diagonal scroll events we only respect the dominant axis.\n          let isVertical = Math.abs(event.deltaY) > Math.abs(event.deltaX);\n          let delta = isVertical ? event.deltaY : event.deltaX;\n          let scrollByDelta = isVertical && this._isRTLScrollbox ? -delta : delta;\n\n          if (this._prevMouseScrolls.every(prev => prev == isVertical)) {\n            doScroll = true;\n            if (event.deltaMode == event.DOM_DELTA_PIXEL) {\n              scrollAmount = scrollByDelta;\n              instant = true;\n            } else if (event.deltaMode == event.DOM_DELTA_PAGE) {\n              scrollAmount = scrollByDelta * this.scrollClientSize;\n            } else {\n              scrollAmount = scrollByDelta * this.lineScrollAmount;\n            }\n          }\n\n          if (this._prevMouseScrolls.length > 1)\n            this._prevMouseScrolls.shift();\n          this._prevMouseScrolls.push(isVertical);\n        }\n\n        if (doScroll) {\n          let direction = scrollAmount < 0 ? -1 : 1;\n          let startPos = this.scrollPosition;\n\n          if (!this._isScrolling || this._direction != direction) {\n            this._destination = startPos + scrollAmount;\n            this._direction = direction;\n          } else {\n            // We were already in the process of scrolling in this direction\n            this._destination = this._destination + scrollAmount;\n            scrollAmount = this._destination - startPos;\n          }\n          this.scrollByPixels(scrollAmount, instant);\n        }\n\n        event.stopPropagation();\n        event.preventDefault();\n      ]]></handler>\n\n      <handler event=\"touchstart\"><![CDATA[\n        if (event.touches.length > 1) {\n          // Multiple touch points detected, abort. In particular this aborts\n          // the panning gesture when the user puts a second finger down after\n          // already panning with one finger. Aborting at this point prevents\n          // the pan gesture from being resumed until all fingers are lifted\n          // (as opposed to when the user is back down to one finger).\n          this._touchStart = -1;\n        } else {\n          this._touchStart = (this.orient == \"vertical\"\n                ? event.touches[0].screenY\n                : event.touches[0].screenX);\n        }\n      ]]></handler>\n\n      <handler event=\"touchmove\"><![CDATA[\n        if (event.touches.length == 1 &&\n            this._touchStart >= 0) {\n          var touchPoint = (this.orient == \"vertical\"\n                ? event.touches[0].screenY\n                : event.touches[0].screenX);\n          var delta = this._touchStart - touchPoint;\n          if (Math.abs(delta) > 0) {\n            this.scrollByPixels(delta, true);\n            this._touchStart = touchPoint;\n          }\n          event.preventDefault();\n        }\n      ]]></handler>\n\n      <handler event=\"touchend\"><![CDATA[\n        this._touchStart = -1;\n      ]]></handler>\n\n      <handler event=\"underflow\" phase=\"capturing\"><![CDATA[\n        // Ignore underflow events:\n        // - from nested scrollable elements\n        // - corresponding to an overflow event that we ignored\n        if (event.target != this ||\n            this.hasAttribute(\"notoverflowing\")) {\n          return;\n        }\n\n        // Ignore events that doesn't match our orientation.\n        // Scrollport event orientation:\n        //   0: vertical\n        //   1: horizontal\n        //   2: both\n        if (this.orient == \"vertical\") {\n          if (event.detail == 1)\n            return;\n        } else if (event.detail == 0) {\n          // horizontal scrollbox\n          return;\n        }\n\n        this.setAttribute(\"notoverflowing\", \"true\");\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"overflow\" phase=\"capturing\"><![CDATA[\n        // Ignore overflow events:\n        // - from nested scrollable elements\n        if (event.target != this) {\n          return;\n        }\n\n        // Ignore events that doesn't match our orientation.\n        // Scrollport event orientation:\n        //   0: vertical\n        //   1: horizontal\n        //   2: both\n        if (this.orient == \"vertical\") {\n          if (event.detail == 1)\n            return;\n        } else if (event.detail == 0) {\n          // horizontal scrollbox\n          return;\n        }\n\n        this.removeAttribute(\"notoverflowing\");\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"scroll\"><![CDATA[\n        this._isScrolling = true;\n        this._updateScrollButtonsDisabledState();\n      ]]></handler>\n\n      <handler event=\"scrollend\"><![CDATA[\n        this._isScrolling = false;\n        this._destination = 0;\n        this._direction = 0;\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"arrowscrollbox-clicktoscroll\" extends=\"chrome://global/content/bindings/scrollbox.xml#arrowscrollbox\">\n    <content>\n      <xul:toolbarbutton class=\"scrollbutton-up\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtostart\"\n                         anonid=\"scrollbutton-up\"\n                         onclick=\"_distanceScroll(event);\"\n                         onmousedown=\"if (event.button == 0) _startScroll(-1);\"\n                         onmouseup=\"if (event.button == 0) _stopScroll();\"\n                         onmouseover=\"_continueScroll(-1);\"\n                         onmouseout=\"_pauseScroll();\"/>\n      <xul:spacer class=\"arrowscrollbox-overflow-start-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtostart\"/>\n      <xul:scrollbox class=\"arrowscrollbox-scrollbox\"\n                     anonid=\"scrollbox\"\n                     flex=\"1\"\n                     xbl:inherits=\"orient,align,pack,dir,smoothscroll\">\n        <children/>\n      </xul:scrollbox>\n      <xul:spacer class=\"arrowscrollbox-overflow-end-indicator\"\n                  xbl:inherits=\"collapsed=scrolledtoend\"/>\n      <xul:toolbarbutton class=\"scrollbutton-down\"\n                         xbl:inherits=\"orient,collapsed=notoverflowing,disabled=scrolledtoend\"\n                         anonid=\"scrollbutton-down\"\n                         onclick=\"_distanceScroll(event);\"\n                         onmousedown=\"if (event.button == 0) _startScroll(1);\"\n                         onmouseup=\"if (event.button == 0) _stopScroll();\"\n                         onmouseover=\"_continueScroll(1);\"\n                         onmouseout=\"_pauseScroll();\"/>\n    </content>\n    <implementation implements=\"nsITimerCallback\">\n      <constructor><![CDATA[\n        this._scrollDelay =\n          this._prefBranch.getIntPref(\"toolkit.scrollbox.clickToScroll.scrollDelay\",\n                                      this._scrollDelay);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        // Release timer to avoid reference cycles.\n        if (this._scrollTimer) {\n          this._scrollTimer.cancel();\n          this._scrollTimer = null;\n        }\n      ]]></destructor>\n\n      <field name=\"_scrollIndex\">0</field>\n      <field name=\"_scrollDelay\">150</field>\n\n      <method name=\"notify\">\n        <parameter name=\"aTimer\"/>\n        <body>\n        <![CDATA[\n          if (!document)\n            aTimer.cancel();\n\n          this.scrollByIndex(this._scrollIndex);\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"_arrowScrollAnim\"><![CDATA[({\n        scrollbox: this,\n        requestHandle: 0, /* 0 indicates there is no pending request */\n        start: function arrowSmoothScroll_start() {\n          this.lastFrameTime = window.performance.now();\n          if (!this.requestHandle)\n            this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));\n        },\n        stop: function arrowSmoothScroll_stop() {\n          window.cancelAnimationFrame(this.requestHandle);\n          this.requestHandle = 0;\n        },\n        sample: function arrowSmoothScroll_handleEvent(timeStamp) {\n          const scrollIndex = this.scrollbox._scrollIndex;\n          const timePassed = timeStamp - this.lastFrameTime;\n          this.lastFrameTime = timeStamp;\n\n          const scrollDelta = 0.5 * timePassed * scrollIndex;\n          this.scrollbox.scrollByPixels(scrollDelta, true);\n          this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));\n        },\n      })]]></field>\n\n      <method name=\"_startScroll\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._isRTLScrollbox)\n            index *= -1;\n          this._scrollIndex = index;\n          this._mousedown = true;\n\n          if (this.smoothScroll) {\n            this._arrowScrollAnim.start();\n            return;\n          }\n\n          if (!this._scrollTimer)\n            this._scrollTimer =\n              Cc[\"@mozilla.org/timer;1\"]\n                .createInstance(Ci.nsITimer);\n          else\n            this._scrollTimer.cancel();\n\n          this._scrollTimer.initWithCallback(this, this._scrollDelay,\n                                             this._scrollTimer.TYPE_REPEATING_SLACK);\n          this.notify(this._scrollTimer);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_stopScroll\">\n        <body><![CDATA[\n          if (this._scrollTimer)\n            this._scrollTimer.cancel();\n          this._mousedown = false;\n          if (!this._scrollIndex || !this.smoothScroll)\n            return;\n\n          this.scrollByIndex(this._scrollIndex);\n          this._scrollIndex = 0;\n\n          this._arrowScrollAnim.stop();\n        ]]></body>\n      </method>\n\n      <method name=\"_pauseScroll\">\n        <body><![CDATA[\n          if (this._mousedown) {\n            this._stopScroll();\n            this._mousedown = true;\n            document.addEventListener(\"mouseup\", this);\n            document.addEventListener(\"blur\", this, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_continueScroll\">\n        <parameter name=\"index\"/>\n        <body><![CDATA[\n          if (this._mousedown)\n            this._startScroll(index);\n        ]]></body>\n      </method>\n\n      <method name=\"handleEvent\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.type == \"mouseup\" ||\n              aEvent.type == \"blur\" && aEvent.target == document) {\n            this._mousedown = false;\n            document.removeEventListener(\"mouseup\", this);\n            document.removeEventListener(\"blur\", this, true);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_distanceScroll\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          if (aEvent.detail < 2 || aEvent.detail > 3)\n            return;\n\n          var scrollBack = (aEvent.originalTarget == this._scrollButtonUp);\n          var scrollLeftOrUp = this._isRTLScrollbox ? !scrollBack : scrollBack;\n          var targetElement;\n\n          if (aEvent.detail == 2) {\n            // scroll by the size of the scrollbox\n            let [start, end] = this._startEndProps;\n            let x;\n            if (scrollLeftOrUp)\n              x = this.scrollClientRect[start] - this.scrollClientSize;\n            else\n              x = this.scrollClientRect[end] + this.scrollClientSize;\n            targetElement = this._elementFromPoint(x, scrollLeftOrUp ? -1 : 1);\n\n            // the next partly-hidden element will become fully visible,\n            // so don't scroll too far\n            if (targetElement)\n              targetElement = scrollBack ?\n                              targetElement.nextElementSibling :\n                              targetElement.previousElementSibling;\n          }\n\n          if (!targetElement) {\n            // scroll to the first resp. last element\n            let elements = this._getScrollableElements();\n            targetElement = scrollBack ?\n                            elements[0] :\n                            elements[elements.length - 1];\n          }\n\n          this.ensureElementIsVisible(targetElement);\n        ]]></body>\n      </method>\n\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"tabbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"tabBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n  <binding id=\"tabs\"\n           extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <content>\n      <xul:spacer class=\"tabs-left\"/>\n      <children/>\n      <xul:spacer class=\"tabs-right\" flex=\"1\"/>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlElement, nsIDOMXULRelatedElement\">\n      <constructor>\n      <![CDATA[\n\n        if (!this.hasAttribute(\"orient\"))\n          this.setAttribute(\"orient\", \"horizontal\");\n\n        if (this.tabbox && this.tabbox.hasAttribute(\"selectedIndex\")) {\n          let selectedIndex = parseInt(this.tabbox.getAttribute(\"selectedIndex\"));\n          this.selectedIndex = selectedIndex > 0 ? selectedIndex : 0;\n          return;\n        }\n\n        var children = this.children;\n        var length = children.length;\n        for (var i = 0; i < length; i++) {\n          if (children[i].getAttribute(\"selected\") == \"true\") {\n            this.selectedIndex = i;\n            return;\n          }\n        }\n\n        var value = this.value;\n        if (value)\n          this.value = value;\n        else\n          this.selectedIndex = 0;\n      ]]>\n      </constructor>\n\n      <!-- nsIDOMXULRelatedElement -->\n      <method name=\"getRelatedElement\">\n        <parameter name=\"aTabElm\"/>\n        <body>\n        <![CDATA[\n          if (!aTabElm)\n            return null;\n\n          let tabboxElm = this.tabbox;\n          if (!tabboxElm)\n            return null;\n\n          let tabpanelsElm = tabboxElm.tabpanels;\n          if (!tabpanelsElm)\n            return null;\n\n          // Get linked tab panel by 'linkedpanel' attribute on the given tab\n          // element.\n          let linkedPanelId = aTabElm.linkedPanel;\n          if (linkedPanelId) {\n            let ownerDoc = this.ownerDocument;\n\n            // XXX bug 565858: if XUL tab element is anonymous element then\n            // suppose linked tab panel is hosted within the same XBL binding\n            // and search it by ID attribute inside an anonymous content of\n            // the binding. This is not robust assumption since tab elements may\n            // live outside a tabbox element so that for example tab elements\n            // can be explicit content but tab panels can be anonymous.\n\n            let bindingParent = ownerDoc.getBindingParent(aTabElm);\n            if (bindingParent)\n              return ownerDoc.getAnonymousElementByAttribute(bindingParent,\n                                                             \"id\",\n                                                             linkedPanelId);\n\n            return ownerDoc.getElementById(linkedPanelId);\n          }\n\n          // otherwise linked tabpanel element has the same index as the given\n          // tab element.\n          let tabElmIdx = this.getIndexOfItem(aTabElm);\n          return tabpanelsElm.children[tabElmIdx];\n        ]]>\n        </body>\n      </method>\n\n      <!-- nsIDOMXULSelectControlElement -->\n      <property name=\"itemCount\" readonly=\"true\"\n                onget=\"return this.children.length\"/>\n\n      <property name=\"value\" onget=\"return this.getAttribute('value');\">\n        <setter>\n          <![CDATA[\n            this.setAttribute(\"value\", val);\n            var children = this.children;\n            for (var c = children.length - 1; c >= 0; c--) {\n              if (children[c].value == val) {\n                this.selectedIndex = c;\n                break;\n              }\n            }\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <field name=\"_tabbox\">null</field>\n      <property name=\"tabbox\" readonly=\"true\">\n        <getter><![CDATA[\n          // Memoize the result in a field rather than replacing this property,\n          // so that it can be reset along with the binding.\n          if (this._tabbox) {\n            return this._tabbox;\n          }\n\n          let parent = this.parentNode;\n          while (parent) {\n            if (parent.localName == \"tabbox\") {\n              break;\n            }\n            parent = parent.parentNode;\n          }\n\n          return this._tabbox = parent;\n        ]]></getter>\n      </property>\n\n      <!-- _tabbox is deprecated, it exists only for backwards compatibility. -->\n      <field name=\"_tabbox\" readonly=\"true\"><![CDATA[\n        this.tabbox;\n      ]]></field>\n\n      <property name=\"selectedIndex\">\n        <getter>\n        <![CDATA[\n          const tabs = this.children;\n          for (var i = 0; i < tabs.length; i++) {\n            if (tabs[i].selected)\n              return i;\n          }\n          return -1;\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          var tab = this.getItemAtIndex(val);\n          if (tab) {\n            Array.forEach(this.children, function(aTab) {\n              if (aTab.selected && aTab != tab)\n                aTab._selected = false;\n            });\n            tab._selected = true;\n\n            this.setAttribute(\"value\", tab.value);\n\n            let linkedPanel = this.getRelatedElement(tab);\n            if (linkedPanel) {\n              this.tabbox.setAttribute(\"selectedIndex\", val);\n\n              // This will cause an onselect event to fire for the tabpanel\n              // element.\n              this.tabbox.tabpanels.selectedPanel = linkedPanel;\n            }\n          }\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"selectedItem\">\n        <getter>\n        <![CDATA[\n          const tabs = this.children;\n          for (var i = 0; i < tabs.length; i++) {\n            if (tabs[i].selected)\n              return tabs[i];\n          }\n          return null;\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          if (val && !val.selected)\n            // The selectedIndex setter ignores invalid values\n            // such as -1 if |val| isn't one of our child nodes.\n            this.selectedIndex = this.getIndexOfItem(val);\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <field name=\"ACTIVE_DESCENDANT_ID\" readonly=\"true\"><![CDATA[\n        \"keyboard-focused-tab-\" + Math.trunc(Math.random() * 1000000);\n      ]]></field>\n\n      <property name=\"ariaFocusedIndex\" readonly=\"true\">\n        <getter>\n        <![CDATA[\n          const tabs = this.children;\n          for (var i = 0; i < tabs.length; i++) {\n            if (tabs[i].id == this.ACTIVE_DESCENDANT_ID)\n              return i;\n          }\n          return -1;\n        ]]>\n        </getter>\n      </property>\n\n      <property name=\"ariaFocusedItem\">\n        <getter>\n        <![CDATA[\n          return document.getElementById(this.ACTIVE_DESCENDANT_ID);\n        ]]>\n        </getter>\n\n        <setter>\n        <![CDATA[\n          let setNewItem = val && this.getIndexOfItem(val) != -1;\n          let clearExistingItem = this.ariaFocusedItem && (!val || setNewItem);\n          if (clearExistingItem) {\n            let ariaFocusedItem = this.ariaFocusedItem;\n            ariaFocusedItem.classList.remove(\"keyboard-focused-tab\");\n            ariaFocusedItem.id = \"\";\n            this.selectedItem.removeAttribute(\"aria-activedescendant\");\n          }\n\n          if (setNewItem) {\n            this.ariaFocusedItem = null;\n            val.id = this.ACTIVE_DESCENDANT_ID;\n            val.classList.add(\"keyboard-focused-tab\");\n            this.selectedItem.setAttribute(\"aria-activedescendant\", this.ACTIVE_DESCENDANT_ID);\n          }\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <method name=\"getIndexOfItem\">\n        <parameter name=\"item\"/>\n        <body>\n        <![CDATA[\n          return Array.indexOf(this.children, item);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"getItemAtIndex\">\n        <parameter name=\"index\"/>\n        <body>\n        <![CDATA[\n          return this.children.item(index);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_selectNewTab\">\n        <parameter name=\"aNewTab\"/>\n        <parameter name=\"aFallbackDir\"/>\n        <parameter name=\"aWrap\"/>\n        <body>\n        <![CDATA[\n          this.ariaFocusedItem = null;\n\n          var requestedTab = aNewTab;\n          while (aNewTab.hidden || aNewTab.disabled || !this._canAdvanceToTab(aNewTab)) {\n            aNewTab = aFallbackDir == -1 ? aNewTab.previousElementSibling : aNewTab.nextElementSibling;\n            if (!aNewTab && aWrap)\n              aNewTab = aFallbackDir == -1 ? this.children[this.children.length - 1] :\n                                             this.children[0];\n            if (!aNewTab || aNewTab == requestedTab)\n              return;\n          }\n\n          var isTabFocused = false;\n          try {\n            isTabFocused =\n              (document.commandDispatcher.focusedElement == this.selectedItem);\n          } catch (e) {}\n          this.selectedItem = aNewTab;\n          if (isTabFocused) {\n            aNewTab.focus();\n          } else if (this.getAttribute(\"setfocus\") != \"false\") {\n            let selectedPanel = this.tabbox.selectedPanel;\n            document.commandDispatcher.advanceFocusIntoSubtree(selectedPanel);\n\n            // Make sure that the focus doesn't move outside the tabbox\n            if (this.tabbox) {\n              try {\n                let el = document.commandDispatcher.focusedElement;\n                while (el && el != this.tabbox.tabpanels) {\n                  if (el == this.tabbox || el == selectedPanel)\n                    return;\n                  el = el.parentNode;\n                }\n                aNewTab.focus();\n              } catch (e) {\n              }\n            }\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_canAdvanceToTab\">\n        <parameter name=\"aTab\"/>\n        <body>\n        <![CDATA[\n          return true;\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"advanceSelectedTab\">\n        <parameter name=\"aDir\"/>\n        <parameter name=\"aWrap\"/>\n        <body>\n        <![CDATA[\n          var startTab = this.ariaFocusedItem || this.selectedItem;\n          var next = startTab[(aDir == -1 ? \"previous\" : \"next\") + \"ElementSibling\"];\n          if (!next && aWrap) {\n            next = aDir == -1 ? this.children[this.children.length - 1] :\n                                this.children[0];\n          }\n          if (next && next != startTab) {\n            this._selectNewTab(next, aDir, aWrap);\n          }\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"appendItem\">\n        <parameter name=\"label\"/>\n        <parameter name=\"value\"/>\n        <body>\n        <![CDATA[\n          var tab = document.createXULElement(\"tab\");\n          tab.setAttribute(\"label\", label);\n          tab.setAttribute(\"value\", value);\n          this.appendChild(tab);\n          return tab;\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n\n  </binding>\n\n  <binding id=\"tab\" display=\"xul:button\"\n           extends=\"chrome://global/content/bindings/general.xml#basetext\">\n    <content>\n      <xul:hbox class=\"tab-middle box-inherit\" xbl:inherits=\"align,dir,pack,orient,selected,visuallyselected\" flex=\"1\">\n        <xul:image class=\"tab-icon\"\n                   xbl:inherits=\"validate,src=image\"\n                   role=\"presentation\"/>\n        <xul:label class=\"tab-text\"\n                   xbl:inherits=\"value=label,accesskey,crop,disabled\"\n                   flex=\"1\"\n                   role=\"presentation\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULSelectControlItemElement\">\n      <property name=\"value\" onset=\"this.setAttribute('value', val); return val;\"\n                             onget=\"return this.getAttribute('value');\"/>\n      <property name=\"control\" readonly=\"true\">\n        <getter>\n          <![CDATA[\n            var parent = this.parentNode;\n            if (parent instanceof Ci.nsIDOMXULSelectControlElement)\n              return parent;\n            return null;\n          ]]>\n        </getter>\n      </property>\n\n      <property name=\"selected\" readonly=\"true\"\n                onget=\"return this.getAttribute('selected') == 'true';\"/>\n\n      <property name=\"_selected\">\n        <setter><![CDATA[\n          if (val) {\n            this.setAttribute(\"selected\", \"true\");\n            this.setAttribute(\"visuallyselected\", \"true\");\n          } else {\n            this.removeAttribute(\"selected\");\n            this.removeAttribute(\"visuallyselected\");\n          }\n\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"linkedPanel\" onget=\"return this.getAttribute('linkedpanel')\"\n                                   onset=\"this.setAttribute('linkedpanel', val); return val;\"/>\n\n      <field name=\"arrowKeysShouldWrap\" readonly=\"true\">\n        /Mac/.test(navigator.platform)\n      </field>\n      <property name=\"TelemetryStopwatch\" readonly=\"true\">\n        <getter><![CDATA[\n          let module = {};\n          ChromeUtils.import(\"resource://gre/modules/TelemetryStopwatch.jsm\", module);\n          Object.defineProperty(this, \"TelemetryStopwatch\", {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: module.TelemetryStopwatch,\n          });\n          return module.TelemetryStopwatch;\n        ]]></getter>\n      </property>\n    </implementation>\n\n    <handlers>\n      <handler event=\"mousedown\" button=\"0\">\n      <![CDATA[\n        if (this.disabled)\n          return;\n\n        this.parentNode.ariaFocusedItem = null;\n\n        if (this != this.parentNode.selectedItem) { // Not selected yet\n          let stopwatchid = this.parentNode.getAttribute(\"stopwatchid\");\n          if (stopwatchid) {\n            this.TelemetryStopwatch.start(stopwatchid);\n          }\n\n          // Call this before setting the 'ignorefocus' attribute because this\n          // will pass on focus if the formerly selected tab was focused as well.\n          this.parentNode._selectNewTab(this);\n\n          var isTabFocused = false;\n          try {\n            isTabFocused = (document.commandDispatcher.focusedElement == this);\n          } catch (e) {}\n\n          // Set '-moz-user-focus' to 'ignore' so that PostHandleEvent() can't\n          // focus the tab; we only want tabs to be focusable by the mouse if\n          // they are already focused. After a short timeout we'll reset\n          // '-moz-user-focus' so that tabs can be focused by keyboard again.\n          if (!isTabFocused) {\n            this.setAttribute(\"ignorefocus\", \"true\");\n            setTimeout(tab => tab.removeAttribute(\"ignorefocus\"), 0, this);\n          }\n\n          if (stopwatchid) {\n            this.TelemetryStopwatch.finish(stopwatchid);\n          }\n        }\n        // Otherwise this tab is already selected and we will fall\n        // through to mousedown behavior which sets focus on the current tab,\n        // Only a click on an already selected tab should focus the tab itself.\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_LEFT\" preventdefault=\"true\">\n      <![CDATA[\n        var direction = window.getComputedStyle(this.parentNode).direction;\n        this.parentNode.advanceSelectedTab(direction == \"ltr\" ? -1 : 1, this.arrowKeysShouldWrap);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_RIGHT\" preventdefault=\"true\">\n      <![CDATA[\n        var direction = window.getComputedStyle(this.parentNode).direction;\n        this.parentNode.advanceSelectedTab(direction == \"ltr\" ? 1 : -1, this.arrowKeysShouldWrap);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_UP\" preventdefault=\"true\">\n      <![CDATA[\n        this.parentNode.advanceSelectedTab(-1, this.arrowKeysShouldWrap);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_DOWN\" preventdefault=\"true\">\n      <![CDATA[\n        this.parentNode.advanceSelectedTab(1, this.arrowKeysShouldWrap);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_HOME\" preventdefault=\"true\">\n      <![CDATA[\n        this.parentNode._selectNewTab(this.parentNode.children[0]);\n      ]]>\n      </handler>\n\n      <handler event=\"keydown\" keycode=\"VK_END\" preventdefault=\"true\">\n      <![CDATA[\n        var tabs = this.parentNode.children;\n        this.parentNode._selectNewTab(tabs[tabs.length - 1], -1);\n      ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"text.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"textBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\">\n\n  <binding id=\"label-control\">\n    <content>\n      <children/><html:span anonid=\"accessKeyParens\"></html:span>\n    </content>\n    <implementation>\n      <constructor>\n        <![CDATA[\n          this.formatAccessKey(true);\n        ]]>\n      </constructor>\n\n      <method name=\"formatAccessKey\">\n        <parameter name=\"firstTime\"/>\n        <body>\n          <![CDATA[\n            var control = this.labeledControlElement;\n            if (!control) {\n              var bindingParent = document.getBindingParent(this);\n              if (\"accessKey\" in bindingParent) {\n                control = bindingParent; // For controls that make the <label> an anon child\n              }\n            }\n            if (control) {\n              control.labelElement = this;\n              var controlAccessKey = control.getAttribute(\"accesskey\");\n              if (controlAccessKey) {\n                this.setAttribute(\"accesskey\", controlAccessKey);\n              }\n            }\n\n            var accessKey = this.accessKey;\n            // No need to remove existing formatting the first time.\n            if (firstTime && !accessKey)\n              return;\n\n            if (this.mInsertSeparator === undefined) {\n              try {\n                var prefs = Cc[\"@mozilla.org/preferences-service;1\"].\n                                       getService(Ci.nsIPrefBranch);\n                this.mUnderlineAccesskey = (prefs.getIntPref(\"ui.key.menuAccessKey\") != 0);\n\n                const nsIPrefLocalizedString =\n                  Ci.nsIPrefLocalizedString;\n\n                const prefNameInsertSeparator =\n                  \"intl.menuitems.insertseparatorbeforeaccesskeys\";\n                const prefNameAlwaysAppendAccessKey =\n                  \"intl.menuitems.alwaysappendaccesskeys\";\n\n                var val = prefs.getComplexValue(prefNameInsertSeparator,\n                                                nsIPrefLocalizedString).data;\n                this.mInsertSeparator = (val == \"true\");\n\n                val = prefs.getComplexValue(prefNameAlwaysAppendAccessKey,\n                                            nsIPrefLocalizedString).data;\n                this.mAlwaysAppendAccessKey = (val == \"true\");\n              } catch (e) {\n                this.mInsertSeparator = true;\n              }\n            }\n\n            if (!this.mUnderlineAccesskey)\n              return;\n\n            var afterLabel = document.getAnonymousElementByAttribute(this, \"anonid\", \"accessKeyParens\");\n            afterLabel.textContent = \"\";\n\n            var oldAccessKey = this.getElementsByAttribute(\"class\", \"accesskey\").item(0);\n            if (oldAccessKey) { // Clear old accesskey\n              this.mergeElement(oldAccessKey);\n            }\n\n            var oldHiddenSpan =\n              this.getElementsByAttribute(\"class\", \"hiddenColon\").item(0);\n            if (oldHiddenSpan) {\n              this.mergeElement(oldHiddenSpan);\n            }\n\n            var labelText = this.textContent;\n            if (!accessKey || !labelText || !control) {\n              return;\n            }\n            var accessKeyIndex = -1;\n            if (!this.mAlwaysAppendAccessKey) {\n              accessKeyIndex = labelText.indexOf(accessKey);\n              if (accessKeyIndex < 0) { // Try again in upper case\n                accessKeyIndex =\n                  labelText.toUpperCase().indexOf(accessKey.toUpperCase());\n              }\n            } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {\n              accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.\n            }\n\n            const HTML_NS = \"http://www.w3.org/1999/xhtml\";\n            var span = document.createElementNS(HTML_NS, \"span\");\n            span.className = \"accesskey\";\n\n            // Note that if you change the following code, see the comment of\n            // nsTextBoxFrame::UpdateAccessTitle.\n\n            // If accesskey is not in string, append in parentheses\n            if (accessKeyIndex < 0) {\n              // If end is colon, we should insert before colon.\n              // i.e., \"label:\" -> \"label(X):\"\n              var colonHidden = false;\n              if (/:$/.test(labelText)) {\n                labelText = labelText.slice(0, -1);\n                var hiddenSpan = document.createElementNS(HTML_NS, \"span\");\n                hiddenSpan.className = \"hiddenColon\";\n                hiddenSpan.style.display = \"none\";\n                // Hide the last colon by using span element.\n                // I.e., label<span style=\"display:none;\">:</span>\n                this.wrapChar(hiddenSpan, labelText.length);\n                colonHidden = true;\n              }\n              // If end is space(U+20),\n              // we should not add space before parentheses.\n              var endIsSpace = false;\n              if (/ $/.test(labelText)) {\n                endIsSpace = true;\n              }\n              if (this.mInsertSeparator && !endIsSpace)\n                afterLabel.textContent = \" (\";\n              else\n                afterLabel.textContent = \"(\";\n              span.textContent = accessKey.toUpperCase();\n              afterLabel.appendChild(span);\n              if (!colonHidden)\n                afterLabel.appendChild(document.createTextNode(\")\"));\n              else\n                afterLabel.appendChild(document.createTextNode(\"):\"));\n              return;\n            }\n            this.wrapChar(span, accessKeyIndex);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"wrapChar\">\n        <parameter name=\"element\"/>\n        <parameter name=\"index\"/>\n        <body>\n          <![CDATA[\n             var treeWalker = document.createTreeWalker(this,\n                                                        NodeFilter.SHOW_TEXT,\n                                                        null);\n             var node = treeWalker.nextNode();\n             while (index >= node.length) {\n               index -= node.length;\n               node = treeWalker.nextNode();\n             }\n             if (index) {\n               node = node.splitText(index);\n             }\n             node.parentNode.insertBefore(element, node);\n             if (node.length > 1) {\n               node.splitText(1);\n             }\n             element.appendChild(node);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"mergeElement\">\n        <parameter name=\"element\"/>\n        <body>\n          <![CDATA[\n            if (element.previousSibling instanceof Text) {\n              element.previousSibling.appendData(element.textContent);\n            } else {\n              element.parentNode.insertBefore(element.firstChild, element);\n            }\n            element.remove();\n          ]]>\n        </body>\n      </method>\n\n      <field name=\"mUnderlineAccesskey\">\n        !/Mac/.test(navigator.platform)\n      </field>\n      <field name=\"mInsertSeparator\"/>\n      <field name=\"mAlwaysAppendAccessKey\">false</field>\n\n      <property name=\"accessKey\">\n        <getter>\n          <![CDATA[\n            var accessKey = this.getAttribute(\"accesskey\");\n            return accessKey ? accessKey[0] : null;\n          ]]>\n        </getter>\n        <setter>\n          <![CDATA[\n            // If this label already has an accesskey attribute store it here as well\n            if (this.hasAttribute(\"accesskey\")) {\n              this.setAttribute(\"accesskey\", val);\n            }\n            var control = this.labeledControlElement;\n            if (control) {\n              control.setAttribute(\"accesskey\", val);\n            }\n            this.formatAccessKey(false);\n            return val;\n          ]]>\n        </setter>\n      </property>\n\n      <property name=\"labeledControlElement\" readonly=\"true\"\n                onget=\"var control = this.control; return control ? document.getElementById(control) : null;\" />\n\n      <property name=\"control\" onget=\"return this.getAttribute('control');\">\n        <setter>\n          <![CDATA[\n            var control = this.labeledControlElement;\n            if (control) {\n              control.labelElement = null; // No longer pointed to be this label\n            }\n            this.setAttribute(\"control\", val);\n            this.formatAccessKey(false);\n            return val;\n          ]]>\n        </setter>\n      </property>\n    </implementation>\n\n    <handlers>\n      <handler event=\"click\"><![CDATA[\n        if (this.disabled) {\n          return;\n        }\n        var controlElement = this.labeledControlElement;\n        if (!controlElement) {\n          return;\n        }\n        controlElement.focus();\n        const XUL_NS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\n        if (controlElement.namespaceURI != XUL_NS) {\n          return;\n        }\n        if (controlElement.localName == \"checkbox\") {\n          controlElement.checked = !controlElement.checked;\n        } else if (controlElement.localName == \"radio\") {\n          controlElement.control.selectedItem = controlElement;\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"text-link\">\n    <implementation>\n      <property name=\"href\" onget=\"return this.getAttribute('href');\"\n                            onset=\"this.setAttribute('href', val); return val;\" />\n      <method name=\"open\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          var href = this.href;\n          if (!href || this.disabled || aEvent.defaultPrevented)\n            return;\n\n          var uri = null;\n          try {\n            const nsISSM = Ci.nsIScriptSecurityManager;\n            const secMan =\n                     Cc[\"@mozilla.org/scriptsecuritymanager;1\"]\n                       .getService(nsISSM);\n\n            const ioService =\n                     Cc[\"@mozilla.org/network/io-service;1\"]\n                       .getService(Ci.nsIIOService);\n\n            uri = ioService.newURI(href);\n\n            let principal;\n            if (this.getAttribute(\"useoriginprincipal\") == \"true\") {\n              principal = this.nodePrincipal;\n            } else {\n              principal = secMan.createNullPrincipal({});\n            }\n            try {\n              secMan.checkLoadURIWithPrincipal(principal, uri,\n                                               nsISSM.DISALLOW_INHERIT_PRINCIPAL);\n            } catch (ex) {\n              var msg = \"Error: Cannot open a \" + uri.scheme + \": link using \\\n                         the text-link binding.\";\n              Cu.reportError(msg);\n              return;\n            }\n\n            const cID = \"@mozilla.org/uriloader/external-protocol-service;1\";\n            const nsIEPS = Ci.nsIExternalProtocolService;\n            var protocolSvc = Cc[cID].getService(nsIEPS);\n\n            // if the scheme is not an exposed protocol, then opening this link\n            // should be deferred to the system's external protocol handler\n            if (!protocolSvc.isExposedProtocol(uri.scheme)) {\n              protocolSvc.loadURI(uri);\n              aEvent.preventDefault();\n              return;\n            }\n\n          } catch (ex) {\n            Cu.reportError(ex);\n          }\n\n          aEvent.preventDefault();\n          href = uri ? uri.spec : href;\n\n          // Try handing off the link to the host application, e.g. for\n          // opening it in a tabbed browser.\n          var linkHandled = Cc[\"@mozilla.org/supports-PRBool;1\"]\n                              .createInstance(Ci.nsISupportsPRBool);\n          linkHandled.data = false;\n          let {shiftKey, ctrlKey, metaKey, altKey, button} = aEvent;\n          let data = {shiftKey, ctrlKey, metaKey, altKey, button, href};\n          Cc[\"@mozilla.org/observer-service;1\"]\n            .getService(Ci.nsIObserverService)\n            .notifyObservers(linkHandled, \"handle-xul-text-link\", JSON.stringify(data));\n          if (linkHandled.data)\n            return;\n\n          // otherwise, fall back to opening the anchor directly\n          var win = window;\n          if (window.isChromeWindow) {\n            while (win.opener && !win.opener.closed)\n              win = win.opener;\n          }\n          win.open(href);\n        ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"click\" phase=\"capturing\" button=\"0\" action=\"this.open(event)\"/>\n      <handler event=\"click\" phase=\"capturing\" button=\"1\" action=\"this.open(event)\"/>\n      <handler event=\"keypress\" preventdefault=\"true\" keycode=\"VK_RETURN\" action=\"this.click()\" />\n    </handlers>\n  </binding>\n\n</bindings>\n"},{"file":"textbox.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!-- This files relies on these specific Chrome/XBL globals -->\n<!-- globals ChromeWindow -->\n\n\n<!DOCTYPE bindings [\n  <!ENTITY % textcontextDTD SYSTEM \"chrome://global/locale/textcontext.dtd\" >\n  %textcontextDTD;\n]>\n\n<bindings id=\"textboxBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"textbox\">\n    <content>\n      <children/>\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\" xbl:inherits=\"context,spellcheck\">\n        <html:input class=\"textbox-input\" anonid=\"input\"\n                    xbl:inherits=\"value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,noinitialfocus,mozactionhint,spellcheck\"/>\n      </xul:moz-input-box>\n    </content>\n\n    <implementation>\n      <!-- nsIDOMXULLabeledControlElement -->\n      <field name=\"crop\">\"\"</field>\n      <field name=\"image\">\"\"</field>\n      <field name=\"command\">\"\"</field>\n      <field name=\"accessKey\">\"\"</field>\n\n      <field name=\"mInputField\">null</field>\n      <field name=\"mIgnoreClick\">false</field>\n      <field name=\"mIgnoreFocus\">false</field>\n      <field name=\"mEditor\">null</field>\n\n      <property name=\"inputField\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.mInputField)\n            this.mInputField = document.getAnonymousElementByAttribute(this, \"anonid\", \"input\");\n          return this.mInputField;\n        ]]></getter>\n      </property>\n\n      <property name=\"value\"      onset=\"this.inputField.value = val; return val;\"\n                                  onget=\"return this.inputField.value;\"/>\n      <property name=\"defaultValue\" onset=\"this.inputField.defaultValue = val; return val;\"\n                                  onget=\"return this.inputField.defaultValue;\"/>\n      <property name=\"label\"      onset=\"this.setAttribute('label', val); return val;\"\n                                  onget=\"return this.getAttribute('label') ||\n                                                (this.labelElement ? this.labelElement.value :\n                                                 this.placeholder);\"/>\n      <property name=\"placeholder\" onset=\"this.inputField.placeholder = val; return val;\"\n                                  onget=\"return this.inputField.placeholder;\"/>\n      <property name=\"emptyText\"  onset=\"this.placeholder = val; return val;\"\n                                  onget=\"return this.placeholder;\"/>\n      <property name=\"type\"       onset=\"if (val) this.setAttribute('type', val);\n                                         else this.removeAttribute('type'); return val;\"\n                                  onget=\"return this.getAttribute('type');\"/>\n      <property name=\"maxLength\"  onset=\"this.inputField.maxLength = val; return val;\"\n                                  onget=\"return this.inputField.maxLength;\"/>\n      <property name=\"disabled\"   onset=\"this.inputField.disabled = val;\n                                         if (val) this.setAttribute('disabled', 'true');\n                                         else this.removeAttribute('disabled'); return val;\"\n                                  onget=\"return this.inputField.disabled;\"/>\n      <property name=\"tabIndex\"   onget=\"return parseInt(this.getAttribute('tabindex'));\"\n                                  onset=\"this.inputField.tabIndex = val;\n                                         if (val) this.setAttribute('tabindex', val);\n                                         else this.removeAttribute('tabindex'); return val;\"/>\n      <property name=\"size\"       onset=\"this.inputField.size = val; return val;\"\n                                  onget=\"return this.inputField.size;\"/>\n      <property name=\"readOnly\"   onset=\"this.inputField.readOnly = val;\n                                         if (val) this.setAttribute('readonly', 'true');\n                                         else this.removeAttribute('readonly'); return val;\"\n                                  onget=\"return this.inputField.readOnly;\"/>\n      <property name=\"clickSelectsAll\"\n                onget=\"return this.getAttribute('clickSelectsAll') == 'true';\"\n                onset=\"if (val) this.setAttribute('clickSelectsAll', 'true');\n                       else this.removeAttribute('clickSelectsAll'); return val;\" />\n\n      <property name=\"editor\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this.mEditor) {\n            this.mEditor = this.inputField.editor;\n          }\n          return this.mEditor;\n        ]]></getter>\n      </property>\n\n      <method name=\"reset\">\n        <body><![CDATA[\n          this.value = this.defaultValue;\n          try {\n            this.editor.transactionManager.clear();\n            return true;\n          } catch (e) {}\n          return false;\n        ]]></body>\n      </method>\n\n      <method name=\"select\">\n        <body>\n          this.inputField.select();\n        </body>\n      </method>\n\n      <property name=\"controllers\"    readonly=\"true\" onget=\"return this.inputField.controllers\"/>\n      <property name=\"textLength\"     readonly=\"true\"\n                                      onget=\"return this.inputField.textLength;\"/>\n      <property name=\"selectionStart\" onset=\"this.inputField.selectionStart = val; return val;\"\n                                      onget=\"return this.inputField.selectionStart;\"/>\n      <property name=\"selectionEnd\"   onset=\"this.inputField.selectionEnd = val; return val;\"\n                                      onget=\"return this.inputField.selectionEnd;\"/>\n\n      <method name=\"setSelectionRange\">\n        <parameter name=\"aSelectionStart\"/>\n        <parameter name=\"aSelectionEnd\"/>\n        <body>\n          // According to https://html.spec.whatwg.org/#do-not-apply,\n          // setSelectionRange() is only available on a limited set of input types.\n          if (this.inputField.type == \"text\" ||\n              this.inputField.tagName == \"html:textarea\") {\n            this.inputField.setSelectionRange( aSelectionStart, aSelectionEnd );\n          }\n        </body>\n      </method>\n\n      <method name=\"_setNewlineHandling\">\n        <body><![CDATA[\n          var str = this.getAttribute(\"newlines\");\n          if (str && this.editor) {\n            const nsIPlaintextEditor = Ci.nsIPlaintextEditor;\n            for (var x in nsIPlaintextEditor) {\n              if (/^eNewlines/.test(x)) {\n                if (str == RegExp.rightContext.toLowerCase()) {\n                  this.editor.QueryInterface(nsIPlaintextEditor)\n                      .newlineHandling = nsIPlaintextEditor[x];\n                  break;\n                }\n              }\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_maybeSelectAll\">\n        <body><![CDATA[\n          if (!this.mIgnoreClick && this.clickSelectsAll &&\n              document.activeElement == this.inputField &&\n              this.inputField.selectionStart == this.inputField.selectionEnd)\n            this.editor.selectAll();\n        ]]></body>\n      </method>\n\n      <constructor><![CDATA[\n        var str = this.boxObject.getProperty(\"value\");\n        if (str) {\n          this.inputField.value = str;\n          this.boxObject.removeProperty(\"value\");\n        }\n\n        this._setNewlineHandling();\n\n        if (this.hasAttribute(\"emptytext\"))\n          this.placeholder = this.getAttribute(\"emptytext\");\n      ]]></constructor>\n\n      <destructor>\n        <![CDATA[\n          var field = this.inputField;\n          if (field && field.value)\n            this.boxObject.setProperty(\"value\", field.value);\n          this.mInputField = null;\n        ]]>\n      </destructor>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"focus\" phase=\"capturing\">\n        <![CDATA[\n          if (this.hasAttribute(\"focused\"))\n            return;\n\n          let { originalTarget } = event;\n          if (originalTarget == this) {\n            // Forward focus to actual HTML input\n            this.inputField.focus();\n            this.setAttribute(\"focused\", \"true\");\n            return;\n          }\n\n          // We check for the parent nodes to support input[type=number] where originalTarget may be an\n          // anonymous child input.\n          if (originalTarget == this.inputField ||\n              originalTarget.localName == \"input\" && originalTarget.parentNode.parentNode == this.inputField) {\n            if (this.mIgnoreFocus) {\n              this.mIgnoreFocus = false;\n            } else if (this.clickSelectsAll) {\n              try {\n                if (!this.editor || !this.editor.composing)\n                  this.editor.selectAll();\n              } catch (e) {}\n            }\n            this.setAttribute(\"focused\", \"true\");\n          }\n          // Otherwise, allow other children (e.g. URL bar buttons) to get focus\n        ]]>\n      </handler>\n\n      <handler event=\"blur\" phase=\"capturing\">\n        <![CDATA[\n          this.removeAttribute(\"focused\");\n\n          // don't trigger clickSelectsAll when switching application windows\n          if (window == window.top &&\n              window.isChromeWindow &&\n              document.activeElement == this.inputField)\n            this.mIgnoreFocus = true;\n        ]]>\n      </handler>\n\n      <handler event=\"mousedown\">\n        <![CDATA[\n          this.mIgnoreClick = this.hasAttribute(\"focused\");\n\n          if (!this.mIgnoreClick) {\n            this.mIgnoreFocus = true;\n            this.setSelectionRange(0, 0);\n            if (event.originalTarget == this ||\n                event.originalTarget == this.inputField.parentNode)\n              this.inputField.focus();\n          }\n        ]]>\n      </handler>\n\n      <handler event=\"click\" action=\"this._maybeSelectAll();\"/>\n\n\n    </handlers>\n  </binding>\n\n  <binding id=\"search-textbox\" extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content>\n      <children/>\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\" xbl:inherits=\"context,spellcheck\" align=\"center\">\n        <xul:image class=\"textbox-search-sign\"/>\n        <html:input class=\"textbox-input\" anonid=\"input\" mozactionhint=\"search\"\n                    xbl:inherits=\"value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,mozactionhint,spellcheck\"/>\n        <xul:deck class=\"textbox-search-icons\" anonid=\"search-icons\">\n          <xul:image class=\"textbox-search-icon\" anonid=\"searchbutton-icon\"\n                     xbl:inherits=\"src=image,label=searchbuttonlabel,searchbutton,disabled\"/>\n          <xul:image class=\"textbox-search-clear\"\n                     onclick=\"document.getBindingParent(this)._clearSearch();\"\n                     label=\"FROM-DTD.searchTextBox.clear.label;\"\n                     xbl:inherits=\"disabled\"/>\n        </xul:deck>\n      </xul:moz-input-box>\n    </content>\n    <implementation>\n      <field name=\"_timer\">null</field>\n      <field name=\"_searchIcons\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"search-icons\");\n      </field>\n      <field name=\"_searchButtonIcon\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"searchbutton-icon\");\n      </field>\n      <property name=\"timeout\"\n                onset=\"this.setAttribute('timeout', val); return val;\"\n                onget=\"return parseInt(this.getAttribute('timeout')) || 500;\"/>\n      <property name=\"searchButton\"\n                onget=\"return this.getAttribute('searchbutton') == 'true';\">\n        <setter><![CDATA[\n          if (val) {\n            this.setAttribute(\"searchbutton\", \"true\");\n            this.removeAttribute(\"aria-autocomplete\");\n            // Hack for the button to get the right accessible:\n            this._searchButtonIcon.setAttribute(\"onclick\", \"true\");\n          } else {\n            this.removeAttribute(\"searchbutton\");\n            this._searchButtonIcon.removeAttribute(\"onclick\");\n            this.setAttribute(\"aria-autocomplete\", \"list\");\n          }\n          return val;\n        ]]></setter>\n      </property>\n      <property name=\"value\"\n                onget=\"return this.inputField.value;\">\n        <setter><![CDATA[\n          this.inputField.value = val;\n\n          if (val)\n            this._searchIcons.selectedIndex = this.searchButton ? 0 : 1;\n          else\n            this._searchIcons.selectedIndex = 0;\n\n          if (this._timer)\n            clearTimeout(this._timer);\n\n          return val;\n        ]]></setter>\n      </property>\n      <constructor><![CDATA[\n        // Ensure the button state is up to date:\n        this.searchButton = this.searchButton;\n        this._searchButtonIcon.addEventListener(\"click\", (e) => this._iconClick(e));\n      ]]></constructor>\n      <method name=\"_fireCommand\">\n        <parameter name=\"me\"/>\n        <body><![CDATA[\n          if (me._timer)\n            clearTimeout(me._timer);\n          me._timer = null;\n          me.doCommand();\n        ]]></body>\n      </method>\n      <method name=\"_iconClick\">\n        <body><![CDATA[\n          if (this.searchButton)\n            this._enterSearch();\n          else\n            this.focus();\n        ]]></body>\n      </method>\n      <method name=\"_enterSearch\">\n        <body><![CDATA[\n          if (this.disabled)\n            return;\n          if (this.searchButton && this.value && !this.readOnly)\n            this._searchIcons.selectedIndex = 1;\n          this._fireCommand(this);\n        ]]></body>\n      </method>\n      <method name=\"_clearSearch\">\n        <body><![CDATA[\n          if (!this.disabled && !this.readOnly && this.value) {\n            this.value = \"\";\n            this._fireCommand(this);\n            this._searchIcons.selectedIndex = 0;\n            return true;\n          }\n          return false;\n        ]]></body>\n      </method>\n    </implementation>\n    <handlers>\n      <handler event=\"input\">\n        <![CDATA[\n          if (this.searchButton) {\n            this._searchIcons.selectedIndex = 0;\n            return;\n          }\n          if (this._timer)\n            clearTimeout(this._timer);\n          this._timer = this.timeout && setTimeout(this._fireCommand, this.timeout, this);\n          this._searchIcons.selectedIndex = this.value ? 1 : 0;\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_ESCAPE\">\n        <![CDATA[\n          if (this._clearSearch()) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        ]]>\n      </handler>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\">\n        <![CDATA[\n          this._enterSearch();\n          event.preventDefault();\n          event.stopPropagation();\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"textarea\" extends=\"chrome://global/content/bindings/textbox.xml#textbox\">\n    <content>\n      <xul:moz-input-box anonid=\"moz-input-box\" flex=\"1\" xbl:inherits=\"context,spellcheck\">\n        <html:textarea class=\"textbox-textarea\" anonid=\"input\"\n                       xbl:inherits=\"xbl:text=value,disabled,tabindex,rows,cols,readonly,wrap,placeholder,mozactionhint,spellcheck\"><children/></html:textarea>\n      </xul:moz-input-box>\n    </content>\n  </binding>\n</bindings>\n"},{"file":"toolbar.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"toolbarBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"toolbar-drag\">\n    <implementation>\n      <field name=\"_dragBindingAlive\">true</field>\n      <constructor><![CDATA[\n        if (!this._draggableStarted) {\n          this._draggableStarted = true;\n          try {\n            let tmp = {};\n            ChromeUtils.import(\"resource://gre/modules/WindowDraggingUtils.jsm\", tmp);\n            let draggableThis = new tmp.WindowDraggingElement(this);\n            draggableThis.mouseDownCheck = function(e) {\n              // Don't move while customizing.\n              return this._dragBindingAlive &&\n                     this.getAttribute(\"customizing\") != \"true\";\n            };\n          } catch (e) {}\n        }\n      ]]></constructor>\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"toolbarbutton.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<bindings id=\"toolbarbuttonBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"toolbarbutton\" display=\"xul:button\"\n           extends=\"chrome://global/content/bindings/button.xml#button-base\">\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:image class=\"toolbarbutton-icon\" xbl:inherits=\"validate,src=image,label,type,consumeanchor,triggeringprincipal=iconloadingprincipal\"/>\n      <xul:label class=\"toolbarbutton-text\" crop=\"right\" flex=\"1\"\n                 xbl:inherits=\"value=label,accesskey,crop,dragover-top,wrap\"/>\n      <xul:label class=\"toolbarbutton-multiline-text\" flex=\"1\"\n                 xbl:inherits=\"xbl:text=label,accesskey,wrap\"/>\n      <children includes=\"box\"/>\n      <xul:dropmarker anonid=\"dropmarker\" type=\"menu\"\n                      class=\"toolbarbutton-menu-dropmarker\" xbl:inherits=\"disabled,label\"/>\n    </content>\n  </binding>\n\n  <binding id=\"menu\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton\">\n  </binding>\n\n  <binding id=\"toolbarbutton-badged\"\n           extends=\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton\">\n    <content>\n      <children includes=\"observes|template|menupopup|panel|tooltip\"/>\n      <xul:stack class=\"toolbarbutton-badge-stack\">\n        <children/>\n        <xul:image class=\"toolbarbutton-icon\" xbl:inherits=\"validate,src=image,label,consumeanchor\"/>\n        <xul:label class=\"toolbarbutton-badge\" xbl:inherits=\"value=badge,style=badgeStyle\" top=\"0\" end=\"0\" crop=\"none\"/>\n      </xul:stack>\n      <xul:label class=\"toolbarbutton-text\" crop=\"right\" flex=\"1\"\n                 xbl:inherits=\"value=label,accesskey,crop,wrap\"/>\n      <xul:label class=\"toolbarbutton-multiline-text\" flex=\"1\"\n                 xbl:inherits=\"xbl:text=label,accesskey,wrap\"/>\n      <xul:dropmarker anonid=\"dropmarker\" type=\"menu\"\n                      class=\"toolbarbutton-menu-dropmarker\" xbl:inherits=\"disabled,label\"/>\n    </content>\n  </binding>\n\n  <binding id=\"toolbarbutton-badged-menu\" display=\"xul:menu\"\n           extends=\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton-badged\">\n  </binding>\n</bindings>\n"},{"file":"tree.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE bindings [\n<!ENTITY % treeDTD SYSTEM \"chrome://global/locale/tree.dtd\">\n%treeDTD;\n]>\n\n<bindings id=\"treeBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"tree-base\" extends=\"chrome://global/content/bindings/general.xml#basecontrol\">\n    <implementation>\n      <method name=\"_isAccelPressed\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          return aEvent.getModifierState(\"Accel\");\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"tree\" extends=\"chrome://global/content/bindings/tree.xml#tree-base\">\n    <content hidevscroll=\"true\" hidehscroll=\"true\" clickthrough=\"never\">\n      <children includes=\"treecols\"/>\n      <xul:stack class=\"tree-stack\" flex=\"1\">\n        <xul:treerows class=\"tree-rows\" flex=\"1\" xbl:inherits=\"hidevscroll\">\n          <children/>\n        </xul:treerows>\n        <xul:textbox anonid=\"input\" class=\"tree-input\" left=\"0\" top=\"0\" hidden=\"true\"/>\n      </xul:stack>\n      <xul:hbox xbl:inherits=\"collapsed=hidehscroll\">\n        <xul:scrollbar orient=\"horizontal\" flex=\"1\" increment=\"16\" style=\"position:relative; z-index:2147483647;\"\n          oncontextmenu=\"event.stopPropagation(); event.preventDefault();\"\n          onclick=\"event.stopPropagation(); event.preventDefault();\"\n          ondblclick=\"event.stopPropagation();\"\n          oncommand=\"event.stopPropagation();\"/>\n        <xul:scrollcorner xbl:inherits=\"collapsed=hidevscroll\"\n          oncontextmenu=\"event.stopPropagation(); event.preventDefault();\"\n          onclick=\"event.stopPropagation(); event.preventDefault();\"\n          ondblclick=\"event.stopPropagation();\"\n          oncommand=\"event.stopPropagation();\"/>\n      </xul:hbox>\n    </content>\n\n    <implementation implements=\"nsIDOMXULMultiSelectControlElement\">\n      <property name=\"columns\"\n                onget=\"return this.treeBoxObject.columns;\"/>\n\n      <property name=\"view\"\n                onget=\"return this.treeBoxObject.view\"\n                onset=\"return this.treeBoxObject.view = val;\"/>\n\n      <property name=\"body\"\n                onget=\"return this.treeBoxObject.treeBody;\"/>\n\n      <property name=\"editable\"\n                onget=\"return this.getAttribute('editable') == 'true';\"\n                onset=\"if (val) this.setAttribute('editable', 'true');\n                       else this.removeAttribute('editable'); return val;\"/>\n\n      <!-- ///////////////// nsIDOMXULSelectControlElement ///////////////// -->\n\n      <!-- ///////////////// nsIDOMXULMultiSelectControlElement ///////////////// -->\n\n      <property name=\"selType\"\n                onget=\"return this.getAttribute('seltype')\"\n                onset=\"this.setAttribute('seltype', val); return val;\"/>\n\n      <property name=\"currentIndex\"\n                onget=\"return this.view ? this.view.selection.currentIndex: - 1;\"\n                onset=\"if (this.view) return this.view.selection.currentIndex = val; return val;\"/>\n\n      <property name=\"treeBoxObject\"\n                onget=\"return this.boxObject;\"\n                readonly=\"true\"/>\n\n      <property name=\"contentView\"\n                onget=\"return this.view;\"\n                readonly=\"true\"/>\n\n      <property name=\"builderView\"\n                onget=\"return this.view; /*.QueryInterface(Components.interfaces.nsIXULTreeBuilder)*/\"\n                readonly=\"true\"/>\n      <field name=\"pageUpOrDownMovesSelection\">\n        !/Mac/.test(navigator.platform)\n      </field>\n      <property name=\"keepCurrentInView\"\n                onget=\"return (this.getAttribute('keepcurrentinview') == 'true');\"\n                onset=\"if (val) this.setAttribute('keepcurrentinview', 'true');\n                       else this.removeAttribute('keepcurrentinview'); return val;\"/>\n\n      <property name=\"enableColumnDrag\"\n                onget=\"return this.hasAttribute('enableColumnDrag');\"\n                onset=\"if (val) this.setAttribute('enableColumnDrag', 'true');\n                       else this.removeAttribute('enableColumnDrag'); return val;\"/>\n\n      <field name=\"_inputField\">null</field>\n\n      <property name=\"inputField\" readonly=\"true\">\n        <getter><![CDATA[\n          if (!this._inputField)\n            this._inputField = document.getAnonymousElementByAttribute(this, \"anonid\", \"input\");\n          return this._inputField;\n        ]]></getter>\n      </property>\n\n      <property name=\"disableKeyNavigation\"\n                onget=\"return this.hasAttribute('disableKeyNavigation');\"\n                onset=\"if (val) this.setAttribute('disableKeyNavigation', 'true');\n                       else this.removeAttribute('disableKeyNavigation'); return val;\"/>\n\n      <field name=\"_editingRow\">-1</field>\n      <field name=\"_editingColumn\">null</field>\n\n      <property name=\"editingRow\" readonly=\"true\"\n                onget=\"return this._editingRow;\"/>\n      <property name=\"editingColumn\" readonly=\"true\"\n                onget=\"return this._editingColumn;\"/>\n\n      <property name=\"_selectDelay\"\n                onset=\"this.setAttribute('_selectDelay', val);\"\n                onget=\"return this.getAttribute('_selectDelay') || 50;\"/>\n      <field name=\"_columnsDirty\">true</field>\n      <field name=\"_lastKeyTime\">0</field>\n      <field name=\"_incrementalString\">\"\"</field>\n\n      <field name=\"_touchY\">-1</field>\n\n      <method name=\"_ensureColumnOrder\">\n        <body><![CDATA[\n          if (!this._columnsDirty)\n            return;\n\n          if (this.columns) {\n            // update the ordinal position of each column to assure that it is\n            // an odd number and 2 positions above its next sibling\n            var cols = [];\n            var i;\n            for (var col = this.columns.getFirstColumn(); col; col = col.getNext())\n              cols.push(col.element);\n            for (i = 0; i < cols.length; ++i)\n              cols[i].setAttribute(\"ordinal\", (i * 2) + 1);\n\n            // update the ordinal positions of splitters to even numbers, so that\n            // they are in between columns\n            var splitters = this.getElementsByTagName(\"splitter\");\n            for (i = 0; i < splitters.length; ++i)\n              splitters[i].setAttribute(\"ordinal\", (i + 1) * 2);\n          }\n          this._columnsDirty = false;\n        ]]></body>\n      </method>\n\n      <method name=\"_reorderColumn\">\n        <parameter name=\"aColMove\"/>\n        <parameter name=\"aColBefore\"/>\n        <parameter name=\"aBefore\"/>\n        <body><![CDATA[\n          this._ensureColumnOrder();\n\n          var i;\n          var cols = [];\n          var col = this.columns.getColumnFor(aColBefore);\n          if (parseInt(aColBefore.ordinal) < parseInt(aColMove.ordinal)) {\n            if (aBefore)\n              cols.push(aColBefore);\n            for (col = col.getNext(); col.element != aColMove;\n                 col = col.getNext())\n              cols.push(col.element);\n\n            aColMove.ordinal = cols[0].ordinal;\n            for (i = 0; i < cols.length; ++i)\n              cols[i].ordinal = parseInt(cols[i].ordinal) + 2;\n          } else if (aColBefore.ordinal != aColMove.ordinal) {\n            if (!aBefore)\n              cols.push(aColBefore);\n            for (col = col.getPrevious(); col.element != aColMove;\n                 col = col.getPrevious())\n              cols.push(col.element);\n\n            aColMove.ordinal = cols[0].ordinal;\n            for (i = 0; i < cols.length; ++i)\n              cols[i].ordinal = parseInt(cols[i].ordinal) - 2;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_getColumnAtX\">\n        <parameter name=\"aX\"/>\n        <parameter name=\"aThresh\"/>\n        <parameter name=\"aPos\"/>\n        <body><![CDATA[\n          var isRTL = document.defaultView.getComputedStyle(this)\n                              .direction == \"rtl\";\n\n          if (aPos)\n            aPos.value = isRTL ? \"after\" : \"before\";\n\n          var columns = [];\n          var col = this.columns.getFirstColumn();\n          while (col) {\n            columns.push(col);\n            col = col.getNext();\n          }\n          if (isRTL)\n            columns.reverse();\n          var currentX = this.boxObject.x;\n          var adjustedX = aX + this.treeBoxObject.horizontalPosition;\n          for (var i = 0; i < columns.length; ++i) {\n            col = columns[i];\n            var cw = col.element.boxObject.width;\n            if (cw > 0) {\n              currentX += cw;\n              if (currentX - (cw * aThresh) > adjustedX)\n                return col.element;\n            }\n          }\n\n          if (aPos)\n            aPos.value = isRTL ? \"before\" : \"after\";\n          return columns.pop().element;\n        ]]></body>\n      </method>\n\n      <method name=\"changeOpenState\">\n        <parameter name=\"row\"/>\n        <!-- Optional parameter openState == true or false to set.\n             No openState param == toggle -->\n        <parameter name=\"openState\"/>\n        <body><![CDATA[\n          if (row < 0 || !this.view.isContainer(row)) {\n            return false;\n          }\n\n          if (this.view.isContainerOpen(row) != openState) {\n            this.view.toggleOpenState(row);\n            if (row == this.currentIndex) {\n              // Only fire event when current row is expanded or collapsed\n              // because that's all the assistive technology really cares about.\n              var event = document.createEvent(\"Events\");\n              event.initEvent(\"OpenStateChange\", true, true);\n              this.dispatchEvent(event);\n            }\n            return true;\n          }\n          return false;\n        ]]></body>\n      </method>\n\n      <method name=\"_getNextColumn\">\n        <parameter name=\"row\"/>\n        <parameter name=\"left\"/>\n        <body><![CDATA[\n          var col = this.view.selection.currentColumn;\n          if (col) {\n            col = left ? col.getPrevious() : col.getNext();\n          } else {\n            col = this.columns.getKeyColumn();\n          }\n          while (col && (col.width == 0 || !col.selectable ||\n                 !this.view.isSelectable(row, col)))\n            col = left ? col.getPrevious() : col.getNext();\n          return col;\n        ]]></body>\n      </method>\n\n      <method name=\"_keyNavigate\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          var key = String.fromCharCode(event.charCode).toLowerCase();\n          if (event.timeStamp - this._lastKeyTime > 1000)\n            this._incrementalString = key;\n          else\n            this._incrementalString += key;\n          this._lastKeyTime = event.timeStamp;\n\n          var length = this._incrementalString.length;\n          var incrementalString = this._incrementalString;\n          var charIndex = 1;\n          while (charIndex < length && incrementalString[charIndex] == incrementalString[charIndex - 1])\n            charIndex++;\n          // If all letters in incremental string are same, just try to match the first one\n          if (charIndex == length) {\n            length = 1;\n            incrementalString = incrementalString.substring(0, length);\n          }\n\n          var keyCol = this.columns.getKeyColumn();\n          var rowCount = this.view.rowCount;\n          var start = 1;\n\n          var c = this.currentIndex;\n          if (length > 1) {\n            start = 0;\n            if (c < 0)\n              c = 0;\n          }\n\n          for (var i = 0; i < rowCount; i++) {\n            var l = (i + start + c) % rowCount;\n            var cellText = this.view.getCellText(l, keyCol);\n            cellText = cellText.substring(0, length).toLowerCase();\n            if (cellText == incrementalString)\n              return l;\n          }\n          return -1;\n        ]]></body>\n      </method>\n\n      <method name=\"startEditing\">\n        <parameter name=\"row\"/>\n        <parameter name=\"column\"/>\n        <body>\n          <![CDATA[\n            if (!this.editable)\n              return false;\n            if (row < 0 || row >= this.view.rowCount || !column)\n              return false;\n            if (column.type != window.TreeColumn.TYPE_TEXT &&\n                column.type != window.TreeColumn.TYPE_PASSWORD)\n              return false;\n            if (column.cycler || !this.view.isEditable(row, column))\n              return false;\n\n            // Beyond this point, we are going to edit the cell.\n            if (this._editingColumn)\n              this.stopEditing();\n\n            var input = this.inputField;\n\n            var box = this.treeBoxObject;\n            box.ensureCellIsVisible(row, column);\n\n            // Get the coordinates of the text inside the cell.\n            var textRect = box.getCoordsForCellItem(row, column, \"text\");\n\n            // Get the coordinates of the cell itself.\n            var cellRect = box.getCoordsForCellItem(row, column, \"cell\");\n\n            // Calculate the top offset of the textbox.\n            var style = window.getComputedStyle(input);\n            var topadj = parseInt(style.borderTopWidth) + parseInt(style.paddingTop);\n            input.top = textRect.y - topadj;\n\n            // The leftside of the textbox is aligned to the left side of the text\n            // in LTR mode, and left side of the cell in RTL mode.\n            var left, widthdiff;\n            if (style.direction == \"rtl\") {\n              left = cellRect.x;\n              widthdiff = cellRect.x - textRect.x;\n            } else {\n              left = textRect.x;\n              widthdiff = textRect.x - cellRect.x;\n            }\n\n            input.left = left;\n            input.height = textRect.height + topadj +\n                           parseInt(style.borderBottomWidth) +\n                           parseInt(style.paddingBottom);\n            input.width = cellRect.width - widthdiff;\n            input.hidden = false;\n\n            input.value = this.view.getCellText(row, column);\n\n            input.select();\n            input.inputField.focus();\n\n            this._editingRow = row;\n            this._editingColumn = column;\n            this.setAttribute(\"editing\", \"true\");\n\n            box.invalidateCell(row, column);\n            return true;\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"stopEditing\">\n        <parameter name=\"accept\"/>\n        <body>\n          <![CDATA[\n            if (!this._editingColumn)\n              return;\n\n            var input = this.inputField;\n            var editingRow = this._editingRow;\n            var editingColumn = this._editingColumn;\n            this._editingRow = -1;\n            this._editingColumn = null;\n\n            if (accept) {\n              var value = input.value;\n              this.view.setCellText(editingRow, editingColumn, value);\n            }\n            input.hidden = true;\n            input.value = \"\";\n            this.removeAttribute(\"editing\");\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByOffset\">\n        <parameter name=\"offset\"/>\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this._isAccelPressed(event) && this.view.selection.single) {\n              this.treeBoxObject.scrollByLines(offset);\n              return;\n            }\n\n            var c = this.currentIndex + offset;\n            if (offset > 0 ? c > edge : c < edge) {\n              if (this.view.selection.isSelected(edge) && this.view.selection.count <= 1)\n                return;\n              c = edge;\n            }\n\n            if (!this._isAccelPressed(event))\n              this.view.selection.timedSelect(c, this._selectDelay);\n            else // Ctrl+Up/Down moves the anchor without selecting\n              this.currentIndex = c;\n            this.treeBoxObject.ensureRowIsVisible(c);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByOffsetShift\">\n        <parameter name=\"offset\"/>\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.view.selection.single) {\n              this.treeBoxObject.scrollByLines(offset);\n              return;\n            }\n\n            if (this.view.rowCount == 1 && !this.view.selection.isSelected(0)) {\n              this.view.selection.timedSelect(0, this._selectDelay);\n              return;\n            }\n\n            var c = this.currentIndex;\n            if (c == -1)\n                c = 0;\n\n            if (c == edge) {\n              if (this.view.selection.isSelected(c))\n                return;\n            }\n\n            // Extend the selection from the existing pivot, if any\n            this.view.selection.rangedSelect(-1, c + offset,\n                                             this._isAccelPressed(event));\n            this.treeBoxObject.ensureRowIsVisible(c + offset);\n\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByPage\">\n        <parameter name=\"offset\"/>\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.pageUpOrDownMovesSelection == this._isAccelPressed(event)) {\n               this.treeBoxObject.scrollByPages(offset);\n               return;\n            }\n\n            if (this.view.rowCount == 1 && !this.view.selection.isSelected(0)) {\n              this.view.selection.timedSelect(0, this._selectDelay);\n              return;\n            }\n\n            var c = this.currentIndex;\n            if (c == -1)\n              return;\n\n            if (c == edge && this.view.selection.isSelected(c)) {\n              this.treeBoxObject.ensureRowIsVisible(c);\n              return;\n            }\n            var i = this.treeBoxObject.getFirstVisibleRow();\n            var p = this.treeBoxObject.getPageLength();\n\n            if (offset > 0) {\n              i += p - 1;\n              if (c >= i) {\n                 i = c + p;\n                 this.treeBoxObject.ensureRowIsVisible(i > edge ? edge : i);\n              }\n              i = i > edge ? edge : i;\n\n            } else if (c <= i) {\n               i = c <= p ? 0 : c - p;\n               this.treeBoxObject.ensureRowIsVisible(i);\n            }\n            this.view.selection.timedSelect(i, this._selectDelay);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveByPageShift\">\n        <parameter name=\"offset\"/>\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.view.rowCount == 1 && !this.view.selection.isSelected(0) &&\n                !(this.pageUpOrDownMovesSelection == this._isAccelPressed(event))) {\n              this.view.selection.timedSelect(0, this._selectDelay);\n              return;\n            }\n\n            if (this.view.selection.single)\n              return;\n\n            var c = this.currentIndex;\n            if (c == -1)\n              return;\n            if (c == edge && this.view.selection.isSelected(c)) {\n              this.treeBoxObject.ensureRowIsVisible(edge);\n              return;\n            }\n            var i = this.treeBoxObject.getFirstVisibleRow();\n            var p = this.treeBoxObject.getPageLength();\n\n            if (offset > 0) {\n              i += p - 1;\n              if (c >= i) {\n                 i = c + p;\n                 this.treeBoxObject.ensureRowIsVisible(i > edge ? edge : i);\n              }\n              // Extend the selection from the existing pivot, if any\n              this.view.selection.rangedSelect(-1, i > edge ? edge : i, this._isAccelPressed(event));\n\n            } else {\n\n              if (c <= i) {\n                 i = c <= p ? 0 : c - p;\n                 this.treeBoxObject.ensureRowIsVisible(i);\n              }\n              // Extend the selection from the existing pivot, if any\n              this.view.selection.rangedSelect(-1, i, this._isAccelPressed(event));\n            }\n\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveToEdge\">\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.view.selection.isSelected(edge) && this.view.selection.count == 1) {\n              this.currentIndex = edge;\n              return;\n            }\n\n            // Normal behaviour is to select the first/last row\n            if (!this._isAccelPressed(event))\n              this.view.selection.timedSelect(edge, this._selectDelay);\n\n            // In a multiselect tree Ctrl+Home/End moves the anchor\n            else if (!this.view.selection.single)\n              this.currentIndex = edge;\n\n            this.treeBoxObject.ensureRowIsVisible(edge);\n          ]]>\n        </body>\n      </method>\n\n      <method name=\"_moveToEdgeShift\">\n        <parameter name=\"edge\"/>\n        <parameter name=\"event\"/>\n        <body>\n          <![CDATA[\n            event.preventDefault();\n\n            if (this.view.rowCount == 0)\n              return;\n\n            if (this.view.rowCount == 1 && !this.view.selection.isSelected(0)) {\n              this.view.selection.timedSelect(0, this._selectDelay);\n              return;\n            }\n\n            if (this.view.selection.single ||\n                (this.view.selection.isSelected(edge)) && this.view.selection.isSelected(this.currentIndex))\n              return;\n\n            // Extend the selection from the existing pivot, if any.\n            // -1 doesn't work here, so using currentIndex instead\n            this.view.selection.rangedSelect(this.currentIndex, edge, this._isAccelPressed(event));\n\n            this.treeBoxObject.ensureRowIsVisible(edge);\n          ]]>\n        </body>\n      </method>\n      <method name=\"_handleEnter\">\n        <parameter name=\"event\"/>\n        <body><![CDATA[\n          if (this._editingColumn) {\n            this.stopEditing(true);\n            this.focus();\n            return true;\n          }\n\n          return this.changeOpenState(this.currentIndex);\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"touchstart\">\n        <![CDATA[\n          function isScrollbarElement(target) {\n            return (target.localName == \"thumb\" || target.localName == \"slider\")\n                && target.namespaceURI == \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          }\n          if (event.touches.length > 1 || isScrollbarElement(event.touches[0].target)) {\n            // Multiple touch points detected, abort. In particular this aborts\n            // the panning gesture when the user puts a second finger down after\n            // already panning with one finger. Aborting at this point prevents\n            // the pan gesture from being resumed until all fingers are lifted\n            // (as opposed to when the user is back down to one finger).\n            // Additionally, if the user lands on the scrollbar don't use this\n            // code for scrolling, instead allow gecko to handle scrollbar\n            // interaction normally.\n            this._touchY = -1;\n          } else {\n            this._touchY = event.touches[0].screenY;\n          }\n        ]]>\n      </handler>\n      <handler event=\"touchmove\">\n        <![CDATA[\n          if (event.touches.length == 1 &&\n              this._touchY >= 0) {\n            var deltaY = this._touchY - event.touches[0].screenY;\n            var lines = Math.trunc(deltaY / this.treeBoxObject.rowHeight);\n            if (Math.abs(lines) > 0) {\n              this.treeBoxObject.scrollByLines(lines);\n              deltaY -= lines * this.treeBoxObject.rowHeight;\n              this._touchY = event.touches[0].screenY + deltaY;\n            }\n            event.preventDefault();\n          }\n        ]]>\n      </handler>\n      <handler event=\"touchend\">\n        <![CDATA[\n          this._touchY = -1;\n        ]]>\n      </handler>\n      <handler event=\"MozMousePixelScroll\">\n        <![CDATA[\n          if (!(this.getAttribute(\"allowunderflowscroll\") == \"true\" &&\n                this.getAttribute(\"hidevscroll\") == \"true\"))\n            event.preventDefault();\n        ]]>\n      </handler>\n      <handler event=\"DOMMouseScroll\">\n        <![CDATA[\n          if (!(this.getAttribute(\"allowunderflowscroll\") == \"true\" &&\n                this.getAttribute(\"hidevscroll\") == \"true\"))\n            event.preventDefault();\n\n          if (this._editingColumn)\n            return;\n          if (event.axis == event.HORIZONTAL_AXIS)\n            return;\n\n          var rows = event.detail;\n          if (rows == UIEvent.SCROLL_PAGE_UP)\n            this.treeBoxObject.scrollByPages(-1);\n          else if (rows == UIEvent.SCROLL_PAGE_DOWN)\n            this.treeBoxObject.scrollByPages(1);\n          else\n            this.treeBoxObject.scrollByLines(rows);\n        ]]>\n      </handler>\n      <handler event=\"MozSwipeGesture\" preventdefault=\"true\">\n        <![CDATA[\n          // Figure out which row to show\n          let targetRow = 0;\n\n          // Only handle swipe gestures up and down\n          switch (event.direction) {\n            case event.DIRECTION_DOWN:\n              targetRow = this.view.rowCount - 1;\n              // Fall through for actual action\n            case event.DIRECTION_UP:\n              this.treeBoxObject.ensureRowIsVisible(targetRow);\n              break;\n          }\n        ]]>\n      </handler>\n      <handler event=\"select\" phase=\"target\"\n               action=\"if (event.originalTarget == this) this.stopEditing(true);\"/>\n      <handler event=\"focus\">\n        <![CDATA[\n          this.treeBoxObject.focused = true;\n          if (this.currentIndex == -1 && this.view.rowCount > 0) {\n            this.currentIndex = this.treeBoxObject.getFirstVisibleRow();\n          }\n        ]]>\n      </handler>\n      <handler event=\"blur\" action=\"this.treeBoxObject.focused = false;\"/>\n      <handler event=\"blur\" phase=\"capturing\"\n               action=\"if (event.originalTarget == this.inputField.inputField) this.stopEditing(true);\"/>\n      <handler event=\"keydown\" keycode=\"VK_RETURN\">\n        if (this._handleEnter(event)) {\n          event.stopPropagation();\n          event.preventDefault();\n        }\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_ESCAPE\">\n        <![CDATA[\n          if (this._editingColumn) {\n            this.stopEditing(false);\n            this.focus();\n            event.stopPropagation();\n            event.preventDefault();\n          }\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_LEFT\">\n        <![CDATA[\n         if (this._editingColumn)\n           return;\n\n         var row = this.currentIndex;\n         if (row < 0)\n           return;\n\n         var checkContainers = true;\n         if (checkContainers) {\n           if (this.changeOpenState(this.currentIndex, false)) {\n             event.preventDefault();\n             return;\n           }\n           var parentIndex = this.view.getParentIndex(this.currentIndex);\n           if (parentIndex >= 0) {\n             this.view.selection.select(parentIndex);\n             this.treeBoxObject.ensureRowIsVisible(parentIndex);\n             event.preventDefault();\n           }\n         }\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_RIGHT\">\n        <![CDATA[\n         if (this._editingColumn)\n           return;\n\n          var row = this.currentIndex;\n          if (row < 0)\n            return;\n\n          var checkContainers = true;\n          if (checkContainers) {\n            if (this.changeOpenState(row, true)) {\n              event.preventDefault();\n              return;\n            }\n            var c = row + 1;\n            var view = this.view;\n            if (c < view.rowCount &&\n                view.getParentIndex(c) == row) {\n              // If already opened, select the first child.\n              // The getParentIndex test above ensures that the children\n              // are already populated and ready.\n              this.view.selection.timedSelect(c, this._selectDelay);\n              this.treeBoxObject.ensureRowIsVisible(c);\n              event.preventDefault();\n            }\n          }\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_UP\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByOffset(-1, 0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_DOWN\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByOffset(1, this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_UP\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByOffsetShift(-1, 0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_DOWN\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByOffsetShift(1, this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_PAGE_UP\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByPage(-1, 0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_PAGE_DOWN\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByPage(1, this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_PAGE_UP\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByPageShift(-1, 0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_PAGE_DOWN\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveByPageShift(1, this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_HOME\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveToEdge(0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_END\" modifiers=\"accel any\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveToEdge(this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_HOME\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveToEdgeShift(0, event);\n        ]]>\n      </handler>\n      <handler event=\"keydown\" keycode=\"VK_END\" modifiers=\"accel any, shift\">\n        <![CDATA[\n          if (this._editingColumn)\n            return;\n          this._moveToEdgeShift(this.view.rowCount - 1, event);\n        ]]>\n      </handler>\n      <handler event=\"keypress\">\n        <![CDATA[\n         if (this._editingColumn)\n           return;\n\n         if (event.charCode == \" \".charCodeAt(0)) {\n           var c = this.currentIndex;\n           if (!this.view.selection.isSelected(c) ||\n               (!this.view.selection.single && this._isAccelPressed(event))) {\n             this.view.selection.toggleSelect(c);\n             event.preventDefault();\n           }\n         } else if (!this.disableKeyNavigation && event.charCode > 0 &&\n                    !event.altKey && !this._isAccelPressed(event) &&\n                    !event.metaKey && !event.ctrlKey) {\n           var l = this._keyNavigate(event);\n           if (l >= 0) {\n             this.view.selection.timedSelect(l, this._selectDelay);\n             this.treeBoxObject.ensureRowIsVisible(l);\n           }\n           event.preventDefault();\n         }\n         ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"treecols\">\n    <content orient=\"horizontal\">\n      <xul:hbox class=\"tree-scrollable-columns\" flex=\"1\">\n        <children includes=\"treecol|splitter\"/>\n      </xul:hbox>\n      <xul:treecolpicker class=\"treecol-image\" fixed=\"true\" xbl:inherits=\"tooltiptext=pickertooltiptext\"/>\n    </content>\n    <implementation>\n      <constructor><![CDATA[\n        // Set resizeafter=\"farthest\" on the splitters if nothing else has been\n        // specified.\n        Array.forEach(this.getElementsByTagName(\"splitter\"), function(splitter) {\n          if (!splitter.hasAttribute(\"resizeafter\"))\n            splitter.setAttribute(\"resizeafter\", \"farthest\");\n        });\n      ]]></constructor>\n    </implementation>\n  </binding>\n\n  <binding id=\"treerows\" extends=\"chrome://global/content/bindings/tree.xml#tree-base\">\n    <content>\n      <xul:hbox flex=\"1\" class=\"tree-bodybox\">\n        <children/>\n      </xul:hbox>\n      <xul:scrollbar height=\"0\" minwidth=\"0\" minheight=\"0\" orient=\"vertical\" xbl:inherits=\"collapsed=hidevscroll\" style=\"position:relative; z-index:2147483647;\"\n        oncontextmenu=\"event.stopPropagation(); event.preventDefault();\"\n        onclick=\"event.stopPropagation(); event.preventDefault();\"\n        ondblclick=\"event.stopPropagation();\"\n        oncommand=\"event.stopPropagation();\"/>\n    </content>\n    <handlers>\n      <handler event=\"underflow\">\n        <![CDATA[\n          // Scrollport event orientation\n          // 0: vertical\n          // 1: horizontal\n          // 2: both (not used)\n          var tree = document.getBindingParent(this);\n          if (event.detail == 1)\n            tree.setAttribute(\"hidehscroll\", \"true\");\n          else if (event.detail == 0)\n            tree.setAttribute(\"hidevscroll\", \"true\");\n          event.stopPropagation();\n        ]]>\n      </handler>\n      <handler event=\"overflow\">\n        <![CDATA[\n          var tree = document.getBindingParent(this);\n          if (event.detail == 1)\n            tree.removeAttribute(\"hidehscroll\");\n          else if (event.detail == 0)\n            tree.removeAttribute(\"hidevscroll\");\n          event.stopPropagation();\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"treebody\" extends=\"chrome://global/content/bindings/tree.xml#tree-base\">\n    <implementation>\n      <constructor>\n        if (\"_ensureColumnOrder\" in this.parentNode)\n          this.parentNode._ensureColumnOrder();\n      </constructor>\n\n      <field name=\"_lastSelectedRow\">\n        -1\n      </field>\n    </implementation>\n    <handlers>\n      <!-- If there is no modifier key, we select on mousedown, not\n           click, so that drags work correctly. -->\n      <handler event=\"mousedown\" clickcount=\"1\">\n      <![CDATA[\n         if (this.parentNode.disabled)\n           return;\n         if (((!this._isAccelPressed(event) ||\n             !this.parentNode.pageUpOrDownMovesSelection) &&\n             !event.shiftKey && !event.metaKey) ||\n             this.parentNode.view.selection.single) {\n           var b = this.parentNode.treeBoxObject;\n           var cell = b.getCellAt(event.clientX, event.clientY);\n           var view = this.parentNode.view;\n\n           // save off the last selected row\n           this._lastSelectedRow = cell.row;\n\n           if (cell.row == -1)\n             return;\n\n           if (cell.childElt == \"twisty\")\n             return;\n\n           if (cell.col && event.button == 0) {\n             if (cell.col.cycler) {\n               view.cycleCell(cell.row, cell.col);\n               return;\n             } else if (cell.col.type == window.TreeColumn.TYPE_CHECKBOX) {\n               if (this.parentNode.editable && cell.col.editable &&\n                   view.isEditable(cell.row, cell.col)) {\n                 var value = view.getCellValue(cell.row, cell.col);\n                 value = value == \"true\" ? \"false\" : \"true\";\n                 view.setCellValue(cell.row, cell.col, value);\n                 return;\n               }\n             }\n           }\n\n           if (!view.selection.isSelected(cell.row)) {\n             view.selection.select(cell.row);\n             b.ensureRowIsVisible(cell.row);\n           }\n         }\n      ]]>\n      </handler>\n\n      <!-- On a click (up+down on the same item), deselect everything\n           except this item. -->\n      <handler event=\"click\" button=\"0\" clickcount=\"1\">\n      <![CDATA[\n        if (this.parentNode.disabled)\n          return;\n        var b = this.parentNode.treeBoxObject;\n        var cell = b.getCellAt(event.clientX, event.clientY);\n        var view = this.parentNode.view;\n\n        if (cell.row == -1)\n          return;\n\n        if (cell.childElt == \"twisty\") {\n          if (view.selection.currentIndex >= 0 &&\n              view.isContainerOpen(cell.row)) {\n            var parentIndex = view.getParentIndex(view.selection.currentIndex);\n            while (parentIndex >= 0 && parentIndex != cell.row)\n              parentIndex = view.getParentIndex(parentIndex);\n            if (parentIndex == cell.row) {\n              var parentSelectable = true;\n              if (parentSelectable)\n                view.selection.select(parentIndex);\n            }\n          }\n          this.parentNode.changeOpenState(cell.row);\n          return;\n        }\n\n        if (!view.selection.single) {\n          var augment = this._isAccelPressed(event);\n          if (event.shiftKey) {\n            view.selection.rangedSelect(-1, cell.row, augment);\n            b.ensureRowIsVisible(cell.row);\n            return;\n          }\n          if (augment) {\n            view.selection.toggleSelect(cell.row);\n            b.ensureRowIsVisible(cell.row);\n            view.selection.currentIndex = cell.row;\n            return;\n          }\n        }\n\n        /* We want to deselect all the selected items except what was\n          clicked, UNLESS it was a right-click.  We have to do this\n          in click rather than mousedown so that you can drag a\n          selected group of items */\n\n        if (!cell.col) return;\n\n        // if the last row has changed in between the time we\n        // mousedown and the time we click, don't fire the select handler.\n        // see bug #92366\n        if (!cell.col.cycler && this._lastSelectedRow == cell.row &&\n            cell.col.type != window.TreeColumn.TYPE_CHECKBOX) {\n          view.selection.select(cell.row);\n          b.ensureRowIsVisible(cell.row);\n        }\n      ]]>\n      </handler>\n\n      <!-- double-click -->\n      <handler event=\"click\" clickcount=\"2\">\n      <![CDATA[\n        if (this.parentNode.disabled)\n          return;\n        var tbo = this.parentNode.treeBoxObject;\n        var view = this.parentNode.view;\n        var row = view.selection.currentIndex;\n\n        if (row == -1)\n          return;\n\n        var cell = tbo.getCellAt(event.clientX, event.clientY);\n\n        if (cell.childElt != \"twisty\") {\n          view.selection.currentColumn = cell.col;\n          this.parentNode.startEditing(row, cell.col);\n        }\n\n        if (this.parentNode._editingColumn || !view.isContainer(row))\n          return;\n\n        // Cyclers and twisties respond to single clicks, not double clicks\n        if (cell.col && !cell.col.cycler && cell.childElt != \"twisty\")\n          this.parentNode.changeOpenState(row);\n      ]]>\n      </handler>\n\n    </handlers>\n  </binding>\n\n  <binding id=\"treecol-base\"\n           extends=\"chrome://global/content/bindings/tree.xml#tree-base\">\n    <implementation>\n      <constructor>\n        this.parentNode.parentNode._columnsDirty = true;\n      </constructor>\n\n      <property name=\"ordinal\">\n        <getter><![CDATA[\n          var val = this.getAttribute(\"ordinal\");\n          if (val == \"\")\n            return \"1\";\n\n          return \"\" + (val == \"0\" ? 0 : parseInt(val));\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"ordinal\", val);\n          return val;\n        ]]></setter>\n      </property>\n\n      <property name=\"_previousVisibleColumn\">\n        <getter><![CDATA[\n          var sib = this.boxObject.previousSibling;\n          while (sib) {\n            if (sib.localName == \"treecol\" && sib.boxObject.width > 0 && sib.parentNode == this.parentNode)\n              return sib;\n            sib = sib.boxObject.previousSibling;\n          }\n          return null;\n        ]]></getter>\n      </property>\n\n      <method name=\"_onDragMouseMove\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          var col = document.treecolDragging;\n          if (!col) return;\n\n          // determine if we have moved the mouse far enough\n          // to initiate a drag\n          if (col.mDragGesturing) {\n            if (Math.abs(aEvent.clientX - col.mStartDragX) < 5 &&\n                Math.abs(aEvent.clientY - col.mStartDragY) < 5) {\n              return;\n            }\n            col.mDragGesturing = false;\n            col.setAttribute(\"dragging\", \"true\");\n            window.addEventListener(\"click\", col._onDragMouseClick, true);\n          }\n\n          var pos = {};\n          var targetCol = col.parentNode.parentNode._getColumnAtX(aEvent.clientX, 0.5, pos);\n\n          // bail if we haven't mousemoved to a different column\n          if (col.mTargetCol == targetCol && col.mTargetDir == pos.value)\n            return;\n\n          var tree = col.parentNode.parentNode;\n          var sib;\n          var column;\n          if (col.mTargetCol) {\n            // remove previous insertbefore/after attributes\n            col.mTargetCol.removeAttribute(\"insertbefore\");\n            col.mTargetCol.removeAttribute(\"insertafter\");\n            column = tree.columns.getColumnFor(col.mTargetCol);\n            tree.treeBoxObject.invalidateColumn(column);\n            sib = col.mTargetCol._previousVisibleColumn;\n            if (sib) {\n              sib.removeAttribute(\"insertafter\");\n              column = tree.columns.getColumnFor(sib);\n              tree.treeBoxObject.invalidateColumn(column);\n            }\n            col.mTargetCol = null;\n            col.mTargetDir = null;\n          }\n\n          if (targetCol) {\n            // set insertbefore/after attributes\n            if (pos.value == \"after\") {\n              targetCol.setAttribute(\"insertafter\", \"true\");\n            } else {\n              targetCol.setAttribute(\"insertbefore\", \"true\");\n              sib = targetCol._previousVisibleColumn;\n              if (sib) {\n                sib.setAttribute(\"insertafter\", \"true\");\n                column = tree.columns.getColumnFor(sib);\n                tree.treeBoxObject.invalidateColumn(column);\n              }\n            }\n            column = tree.columns.getColumnFor(targetCol);\n            tree.treeBoxObject.invalidateColumn(column);\n            col.mTargetCol = targetCol;\n            col.mTargetDir = pos.value;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_onDragMouseUp\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          var col = document.treecolDragging;\n          if (!col) return;\n\n          if (!col.mDragGesturing) {\n            if (col.mTargetCol) {\n              // remove insertbefore/after attributes\n              var before = col.mTargetCol.hasAttribute(\"insertbefore\");\n              col.mTargetCol.removeAttribute(before ? \"insertbefore\" : \"insertafter\");\n\n              var sib = col.mTargetCol._previousVisibleColumn;\n              if (before && sib) {\n                sib.removeAttribute(\"insertafter\");\n              }\n\n              // Move the column only if it will result in a different column\n              // ordering\n              var move = true;\n\n              // If this is a before move and the previous visible column is\n              // the same as the column we're moving, don't move\n              if (before && col == sib) {\n                move = false;\n              } else if (!before && col == col.mTargetCol) {\n                // If this is an after move and the column we're moving is\n                // the same as the target column, don't move.\n                move = false;\n              }\n\n              if (move) {\n                col.parentNode.parentNode._reorderColumn(col, col.mTargetCol, before);\n              }\n\n              // repaint to remove lines\n              col.parentNode.parentNode.treeBoxObject.invalidate();\n\n              col.mTargetCol = null;\n            }\n          } else\n            col.mDragGesturing = false;\n\n          document.treecolDragging = null;\n          col.removeAttribute(\"dragging\");\n\n          window.removeEventListener(\"mousemove\", col._onDragMouseMove, true);\n          window.removeEventListener(\"mouseup\", col._onDragMouseUp, true);\n          // we have to wait for the click event to fire before removing\n          // cancelling handler\n          var clickHandler = function(handler) {\n            window.removeEventListener(\"click\", handler, true);\n          };\n          window.setTimeout(clickHandler, 0, col._onDragMouseClick);\n        ]]></body>\n      </method>\n\n      <method name=\"_onDragMouseClick\">\n        <parameter name=\"aEvent\"/>\n        <body><![CDATA[\n          // prevent click event from firing after column drag and drop\n          aEvent.stopPropagation();\n          aEvent.preventDefault();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"mousedown\" button=\"0\"><![CDATA[\n        if (this.parentNode.parentNode.enableColumnDrag) {\n          var xulns = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          var cols = this.parentNode.getElementsByTagNameNS(xulns, \"treecol\");\n\n          // only start column drag operation if there are at least 2 visible columns\n          var visible = 0;\n          for (var i = 0; i < cols.length; ++i)\n            if (cols[i].boxObject.width > 0) ++visible;\n\n          if (visible > 1) {\n            window.addEventListener(\"mousemove\", this._onDragMouseMove, true);\n            window.addEventListener(\"mouseup\", this._onDragMouseUp, true);\n            document.treecolDragging = this;\n            this.mDragGesturing = true;\n            this.mStartDragX = event.clientX;\n            this.mStartDragY = event.clientY;\n          }\n        }\n      ]]></handler>\n      <handler event=\"click\" button=\"0\" phase=\"target\">\n        <![CDATA[\n          if (event.target != event.originalTarget)\n            return;\n\n          // On Windows multiple clicking on tree columns only cycles one time\n          // every 2 clicks.\n          if (/Win/.test(navigator.platform) && event.detail % 2 == 0)\n            return;\n\n          var tree = this.parentNode.parentNode;\n          if (tree.columns) {\n            tree.view.cycleHeader(tree.columns.getColumnFor(this));\n          }\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"treecol\" extends=\"chrome://global/content/bindings/tree.xml#treecol-base\">\n    <content>\n      <xul:label class=\"treecol-text\" xbl:inherits=\"crop,value=label\" flex=\"1\" crop=\"right\"/>\n      <xul:image class=\"treecol-sortdirection\" xbl:inherits=\"sortDirection,hidden=hideheader\"/>\n    </content>\n  </binding>\n\n  <binding id=\"treecol-image\" extends=\"chrome://global/content/bindings/tree.xml#treecol-base\">\n    <content>\n      <xul:image class=\"treecol-icon\" xbl:inherits=\"src\"/>\n    </content>\n  </binding>\n\n  <binding id=\"columnpicker\" display=\"xul:button\"\n           extends=\"chrome://global/content/bindings/tree.xml#tree-base\">\n    <content>\n      <xul:image class=\"tree-columnpicker-icon\"/>\n      <xul:menupopup anonid=\"popup\">\n        <xul:menuseparator anonid=\"menuseparator\"/>\n        <xul:menuitem anonid=\"menuitem\" label=\"FROM-DTD.restoreColumnOrder.label;\"/>\n      </xul:menupopup>\n    </content>\n\n    <implementation>\n      <method name=\"buildPopup\">\n        <parameter name=\"aPopup\"/>\n        <body>\n          <![CDATA[\n            // We no longer cache the picker content, remove the old content.\n            while (aPopup.childNodes.length > 2)\n              aPopup.firstChild.remove();\n\n            var refChild = aPopup.firstChild;\n\n            var tree = this.parentNode.parentNode;\n            for (var currCol = tree.columns.getFirstColumn(); currCol;\n                 currCol = currCol.getNext()) {\n              // Construct an entry for each column in the row, unless\n              // it is not being shown.\n              var currElement = currCol.element;\n              if (!currElement.hasAttribute(\"ignoreincolumnpicker\")) {\n                var popupChild = document.createElement(\"menuitem\");\n                popupChild.setAttribute(\"type\", \"checkbox\");\n                var columnName = currElement.getAttribute(\"display\") ||\n                                 currElement.getAttribute(\"label\");\n                popupChild.setAttribute(\"label\", columnName);\n                popupChild.setAttribute(\"colindex\", currCol.index);\n                if (currElement.getAttribute(\"hidden\") != \"true\")\n                  popupChild.setAttribute(\"checked\", \"true\");\n                if (currCol.primary)\n                  popupChild.setAttribute(\"disabled\", \"true\");\n                aPopup.insertBefore(popupChild, refChild);\n              }\n            }\n\n            var hidden = !tree.enableColumnDrag;\n            const anonids = [\"menuseparator\", \"menuitem\"];\n            for (var i = 0; i < anonids.length; i++) {\n              var element = document.getAnonymousElementByAttribute(this, \"anonid\", anonids[i]);\n              element.hidden = hidden;\n            }\n          ]]>\n        </body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"command\">\n        <![CDATA[\n          if (event.originalTarget == this) {\n            var popup = document.getAnonymousElementByAttribute(this, \"anonid\", \"popup\");\n            this.buildPopup(popup);\n            popup.openPopup(this, \"after_end\");\n          } else {\n            var tree = this.parentNode.parentNode;\n            tree.stopEditing(true);\n            var menuitem = document.getAnonymousElementByAttribute(this, \"anonid\", \"menuitem\");\n            if (event.originalTarget == menuitem) {\n              tree.columns.restoreNaturalOrder();\n              tree._ensureColumnOrder();\n            } else {\n              var colindex = event.originalTarget.getAttribute(\"colindex\");\n              var column = tree.columns[colindex];\n              if (column) {\n                var element = column.element;\n                if (element.getAttribute(\"hidden\") == \"true\")\n                  element.setAttribute(\"hidden\", \"false\");\n                else\n                  element.setAttribute(\"hidden\", \"true\");\n              }\n            }\n          }\n        ]]>\n      </handler>\n    </handlers>\n  </binding>\n</bindings>\n"},{"file":"wizard.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE bindings [\n  <!ENTITY % wizardDTD SYSTEM \"chrome://global/locale/wizard.dtd\">\n  %wizardDTD;\n]>\n\n<bindings id=\"wizardBindings\"\n   xmlns=\"http://www.mozilla.org/xbl\"\n   xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n   xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"wizard\">\n    <content>\n      <xul:hbox class=\"wizard-header\" anonid=\"Header\"/>\n\n      <xul:deck class=\"wizard-page-box\" flex=\"1\" anonid=\"Deck\">\n        <children includes=\"wizardpage\"/>\n      </xul:deck>\n      <children/>\n\n      <xul:hbox class=\"wizard-buttons\" anonid=\"Buttons\" xbl:inherits=\"pagestep,firstpage,lastpage\"/>\n    </content>\n\n    <implementation>\n      <property name=\"title\" onget=\"return document.title;\"\n                             onset=\"return document.title = val;\"/>\n\n      <property name=\"canAdvance\" onget=\"return this._canAdvance;\"\n                                  onset=\"this._nextButton.disabled = !val; return this._canAdvance = val;\"/>\n      <property name=\"canRewind\" onget=\"return this._canRewind;\"\n                                 onset=\"this._backButton.disabled = !val; return this._canRewind = val;\"/>\n\n      <property name=\"pageStep\" readonly=\"true\" onget=\"return this._pageStack.length\"/>\n\n      <field name=\"pageCount\">0</field>\n\n      <field name=\"_accessMethod\">null</field>\n      <field name=\"_pageStack\">null</field>\n      <field name=\"_currentPage\">null</field>\n\n      <property name=\"wizardPages\">\n        <getter>\n        <![CDATA[\n          var xulns = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          return this.getElementsByTagNameNS(xulns, \"wizardpage\");\n        ]]>\n        </getter>\n      </property>\n\n      <property name=\"currentPage\" onget=\"return this._currentPage\">\n        <setter>\n        <![CDATA[\n          if (!val)\n            return val;\n\n          this._currentPage = val;\n\n          // Setting this attribute allows wizard's clients to dynamically\n          // change the styles of each page based on purpose of the page.\n          this.setAttribute(\"currentpageid\", val.pageid);\n          if (this.onFirstPage) {\n            this.canRewind = false;\n            this.setAttribute(\"firstpage\", \"true\");\n            if (/Linux/.test(navigator.platform)) {\n              this._backButton.setAttribute('hidden', 'true');\n            }\n          } else {\n            this.canRewind = true;\n            this.setAttribute(\"firstpage\", \"false\");\n            if (/Linux/.test(navigator.platform)) {\n              this._backButton.setAttribute('hidden', 'false');\n            }\n          }\n\n          if (this.onLastPage) {\n            this.canAdvance = true;\n            this.setAttribute(\"lastpage\", \"true\");\n          } else {\n            this.setAttribute(\"lastpage\", \"false\");\n          }\n\n          this._deck.setAttribute(\"selectedIndex\", val.pageIndex);\n          this._advanceFocusToPage(val);\n\n          this._adjustWizardHeader();\n          this._wizardButtons.onPageChange();\n\n          this._fireEvent(val, \"pageshow\");\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"pageIndex\"\n                onget=\"return this._currentPage ? this._currentPage.pageIndex : -1;\">\n        <setter>\n        <![CDATA[\n          if (val < 0 || val >= this.pageCount)\n            return val;\n\n          var page = this.wizardPages[val];\n          this._pageStack[this._pageStack.length-1] = page;\n          this.currentPage = page;\n\n          return val;\n        ]]>\n        </setter>\n      </property>\n\n      <property name=\"onFirstPage\" readonly=\"true\"\n                onget=\"return this._pageStack.length == 1;\"/>\n\n      <property name=\"onLastPage\" readonly=\"true\">\n        <getter><![CDATA[\n          var cp = this.currentPage;\n          return cp && ((this._accessMethod == \"sequential\" && cp.pageIndex == this.pageCount-1) ||\n                       (this._accessMethod == \"random\" && cp.next == \"\"));\n         ]]></getter>\n      </property>\n\n      <method name=\"getButton\">\n        <parameter name=\"aDlgType\"/>\n        <body>\n        <![CDATA[\n          var btns = this.getElementsByAttribute(\"dlgtype\", aDlgType);\n          return btns.item(0) ? btns[0] : document.getAnonymousElementByAttribute(this._wizardButtons, \"dlgtype\", aDlgType);\n        ]]>\n        </body>\n      </method>\n\n      <field name=\"_canAdvance\"/>\n      <field name=\"_canRewind\"/>\n      <field name=\"_wizardHeader\"/>\n      <field name=\"_wizardButtons\"/>\n      <field name=\"_deck\"/>\n      <field name=\"_backButton\"/>\n      <field name=\"_nextButton\"/>\n      <field name=\"_cancelButton\"/>\n\n      <!-- functions to be added as oncommand listeners to the wizard buttons -->\n      <field name=\"_backFunc\">(function() { document.documentElement.rewind(); })</field>\n      <field name=\"_nextFunc\">(function() { document.documentElement.advance(); })</field>\n      <field name=\"_finishFunc\">(function() { document.documentElement.advance(); })</field>\n      <field name=\"_cancelFunc\">(function() { document.documentElement.cancel(); })</field>\n      <field name=\"_extra1Func\">(function() { document.documentElement.extra1(); })</field>\n      <field name=\"_extra2Func\">(function() { document.documentElement.extra2(); })</field>\n\n      <field name=\"_closeHandler\">(function(event) {\n        if (document.documentElement.cancel())\n          event.preventDefault();\n      })</field>\n\n      <constructor><![CDATA[\n        this._canAdvance = true;\n        this._canRewind = false;\n        this._hasLoaded = false;\n\n        this._pageStack = [];\n\n        try {\n          // need to create string bundle manually instead of using <xul:stringbundle/>\n          // see bug 63370 for details\n          this._bundle = Cc[\"@mozilla.org/intl/stringbundle;1\"]\n                           .getService(Ci.nsIStringBundleService)\n                           .createBundle(\"chrome://global/locale/wizard.properties\");\n        } catch (e) {\n          // This fails in remote XUL, which has to provide titles for all pages\n          // see bug 142502\n        }\n\n        // get anonymous content references\n        this._wizardHeader = document.getAnonymousElementByAttribute(this, \"anonid\", \"Header\");\n        this._wizardButtons = document.getAnonymousElementByAttribute(this, \"anonid\", \"Buttons\");\n        this._deck = document.getAnonymousElementByAttribute(this, \"anonid\", \"Deck\");\n\n        this._initWizardButton(\"back\");\n        this._initWizardButton(\"next\");\n        this._initWizardButton(\"finish\");\n        this._initWizardButton(\"cancel\");\n        this._initWizardButton(\"extra1\");\n        this._initWizardButton(\"extra2\");\n\n        this._initPages();\n\n        window.addEventListener(\"close\", this._closeHandler);\n\n        // start off on the first page\n        this.pageCount = this.wizardPages.length;\n        this.advance();\n\n        // give focus to the first focusable element in the dialog\n        window.addEventListener(\"load\", this._setInitialFocus);\n      ]]></constructor>\n\n      <method name=\"getPageById\">\n        <parameter name=\"aPageId\"/>\n        <body><![CDATA[\n          var els = this.getElementsByAttribute(\"pageid\", aPageId);\n          return els.item(0);\n        ]]></body>\n      </method>\n\n      <method name=\"extra1\">\n        <body><![CDATA[\n          if (this.currentPage)\n            this._fireEvent(this.currentPage, \"extra1\");\n        ]]></body>\n      </method>\n\n      <method name=\"extra2\">\n        <body><![CDATA[\n          if (this.currentPage)\n            this._fireEvent(this.currentPage, \"extra2\");\n        ]]></body>\n      </method>\n\n      <method name=\"rewind\">\n        <body><![CDATA[\n          if (!this.canRewind)\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pagehide\"))\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pagerewound\"))\n            return;\n\n          if (!this._fireEvent(this, \"wizardback\"))\n            return;\n\n\n          this._pageStack.pop();\n          this.currentPage = this._pageStack[this._pageStack.length-1];\n          this.setAttribute(\"pagestep\", this._pageStack.length);\n        ]]></body>\n      </method>\n\n      <method name=\"advance\">\n        <parameter name=\"aPageId\"/>\n        <body><![CDATA[\n          if (!this.canAdvance)\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pagehide\"))\n            return;\n\n          if (this.currentPage && !this._fireEvent(this.currentPage, \"pageadvanced\"))\n            return;\n\n          if (this.onLastPage && !aPageId) {\n            if (this._fireEvent(this, \"wizardfinish\"))\n              window.setTimeout(function() {window.close();}, 1);\n          } else {\n            if (!this._fireEvent(this, \"wizardnext\"))\n              return;\n\n            var page;\n            if (aPageId)\n              page = this.getPageById(aPageId);\n            else {\n              if (this.currentPage) {\n                if (this._accessMethod == \"random\")\n                  page = this.getPageById(this.currentPage.next);\n                else\n                  page = this.wizardPages[this.currentPage.pageIndex+1];\n              } else\n                page = this.wizardPages[0];\n            }\n\n            if (page) {\n              this._pageStack.push(page);\n              this.setAttribute(\"pagestep\", this._pageStack.length);\n\n              this.currentPage = page;\n            }\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"goTo\">\n        <parameter name=\"aPageId\"/>\n        <body><![CDATA[\n          var page = this.getPageById(aPageId);\n          if (page) {\n            this._pageStack[this._pageStack.length-1] = page;\n            this.currentPage = page;\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"cancel\">\n        <body><![CDATA[\n          if (!this._fireEvent(this, \"wizardcancel\"))\n            return true;\n\n          window.close();\n          window.setTimeout(function() {window.close();}, 1);\n          return false;\n        ]]></body>\n      </method>\n\n      <method name=\"_setInitialFocus\">\n        <parameter name=\"aEvent\"/>\n        <body>\n        <![CDATA[\n          document.documentElement._hasLoaded = true;\n          var focusInit =\n            function() {\n              // give focus to the first focusable element in the dialog\n              if (!document.commandDispatcher.focusedElement)\n                document.commandDispatcher.advanceFocusIntoSubtree(document.documentElement);\n\n              try {\n                var button =\n                      document.documentElement._wizardButtons.defaultButton;\n                if (button)\n                  window.notifyDefaultButtonLoaded(button);\n              } catch (e) { }\n            };\n\n          // Give focus after onload completes, see bug 103197.\n          setTimeout(focusInit, 0);\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_advanceFocusToPage\">\n        <parameter name=\"aPage\"/>\n        <body>\n        <![CDATA[\n          if (!this._hasLoaded)\n            return;\n\n          document.commandDispatcher.advanceFocusIntoSubtree(aPage);\n\n          // if advanceFocusIntoSubtree tries to focus one of our\n          // dialog buttons, then remove it and put it on the root\n          var focused = document.commandDispatcher.focusedElement;\n          if (focused && focused.hasAttribute(\"dlgtype\"))\n            this.focus();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_initPages\">\n        <body><![CDATA[\n          var meth = \"sequential\";\n          var pages = this.wizardPages;\n          for (var i = 0; i < pages.length; ++i) {\n            var page = pages[i];\n            page.pageIndex = i;\n            if (page.next != \"\")\n              meth = \"random\";\n          }\n          this._accessMethod = meth;\n        ]]></body>\n      </method>\n\n      <method name=\"_initWizardButton\">\n        <parameter name=\"aName\"/>\n        <body><![CDATA[\n         var btn = document.getAnonymousElementByAttribute(this._wizardButtons, \"dlgtype\", aName);\n         if (btn) {\n           btn.addEventListener(\"command\", this[\"_\"+aName+\"Func\"]);\n           this[\"_\"+aName+\"Button\"] = btn;\n         }\n         return btn;\n        ]]></body>\n      </method>\n\n      <method name=\"_adjustWizardHeader\">\n        <body><![CDATA[\n          var label = this.currentPage.getAttribute(\"label\");\n          if (!label && this.onFirstPage && this._bundle) {\n            if (/Mac/.test(navigator.platform)) {\n              label = this._bundle.GetStringFromName(\"default-first-title-mac\");\n            } else {\n              label = this._bundle.formatStringFromName(\"default-first-title\", [this.title], 1);\n            }\n          } else if (!label && this.onLastPage && this._bundle) {\n            if (/Mac/.test(navigator.platform)) {\n              label = this._bundle.GetStringFromName(\"default-last-title-mac\");\n            } else {\n              label = this._bundle.formatStringFromName(\"default-last-title\", [this.title], 1);\n            }\n          }\n          this._wizardHeader.setAttribute(\"label\", label);\n          this._wizardHeader.setAttribute(\"description\", this.currentPage.getAttribute(\"description\"));\n        ]]></body>\n      </method>\n\n      <method name=\"_hitEnter\">\n        <parameter name=\"evt\"/>\n        <body>\n        <![CDATA[\n          if (!evt.defaultPrevented)\n            this.advance();\n        ]]>\n        </body>\n      </method>\n\n      <method name=\"_fireEvent\">\n        <parameter name=\"aTarget\"/>\n        <parameter name=\"aType\"/>\n        <body>\n        <![CDATA[\n          var event = document.createEvent(\"Events\");\n          event.initEvent(aType, true, true);\n\n          // handle dom event handlers\n          var noCancel = aTarget.dispatchEvent(event);\n\n          // handle any xml attribute event handlers\n          var handler = aTarget.getAttribute(\"on\"+aType);\n          if (handler != \"\") {\n            var fn = new Function(\"event\", handler);\n            var returned = fn.apply(aTarget, [event]);\n            if (returned == false)\n              noCancel = false;\n          }\n\n          return noCancel;\n        ]]>\n        </body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"keypress\" keycode=\"VK_RETURN\"\n               group=\"system\" action=\"this._hitEnter(event)\"/>\n      <handler event=\"keypress\" keycode=\"VK_ESCAPE\" group=\"system\">\n        if (!event.defaultPrevented)\n          this.cancel();\n      </handler>\n    </handlers>\n  </binding>\n\n  <binding id=\"wizardpage\">\n    <implementation>\n      <field name=\"pageIndex\">-1</field>\n\n      <property name=\"pageid\" onget=\"return this.getAttribute('pageid');\"\n                              onset=\"this.setAttribute('pageid', val);\"/>\n\n      <property name=\"next\"   onget=\"return this.getAttribute('next');\"\n                              onset=\"this.setAttribute('next', val);\n                                     this.parentNode._accessMethod = 'random';\n                                     return val;\"/>\n    </implementation>\n  </binding>\n\n\n\n  <binding id=\"wizard-header\">\n    <content>\n      <xul:hbox class=\"wizard-header-box-1\" flex=\"1\">\n        <xul:vbox class=\"wizard-header-box-text\" flex=\"1\">\n          <xul:label class=\"wizard-header-label\" xbl:inherits=\"xbl:text=label\"/>\n          <xul:label class=\"wizard-header-description\" xbl:inherits=\"xbl:text=description\"/>\n        </xul:vbox>\n        <xul:image class=\"wizard-header-icon\" xbl:inherits=\"src=iconsrc\"/>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"wizard-buttons\">\n    <content>\n      <xul:vbox class=\"wizard-buttons-box-1\" flex=\"1\">\n        <xul:separator class=\"wizard-buttons-separator groove\"/>\n        <xul:hbox class=\"wizard-buttons-box-2\">\n          <xul:button class=\"wizard-button\" dlgtype=\"extra1\" hidden=\"true\"/>\n          <xul:button class=\"wizard-button\" dlgtype=\"extra2\" hidden=\"true\"/>\n          <xul:spacer flex=\"1\" anonid=\"spacer\"/>\n\n          <xul:button label=\"FROM-DTD.button-back-win.label;\" accesskey=\"FROM-DTD.button-back-win.accesskey;\"\n                      class=\"wizard-button\" dlgtype=\"back\"/>\n          <xul:deck class=\"wizard-next-deck\" anonid=\"WizardButtonDeck\">\n            <xul:hbox>\n              <xul:button label=\"FROM-DTD.button-finish-win.label;\" class=\"wizard-button\"\n                          dlgtype=\"finish\" default=\"true\" flex=\"1\"/>\n            </xul:hbox>\n            <xul:hbox>\n              <xul:button label=\"FROM-DTD.button-next-win.label;\" accesskey=\"FROM-DTD.button-next-win.accesskey;\"\n                          class=\"wizard-button\" dlgtype=\"next\" \n                          default=\"true\" flex=\"1\"/>\n            </xul:hbox>\n          </xul:deck>\n          <xul:button label=\"FROM-DTD.button-cancel-win.label;\" class=\"wizard-button\"\n                      dlgtype=\"cancel\"/>\n\n        </xul:hbox>\n      </xul:vbox>\n    </content>\n\n    <implementation>\n      <field name=\"_wizardButtonDeck\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"WizardButtonDeck\");\n      </field>\n\n      <method name=\"onPageChange\">\n        <body><![CDATA[\n          if (this.getAttribute(\"lastpage\") == \"true\") {\n            this._wizardButtonDeck.setAttribute(\"selectedIndex\", 0);\n          } else {\n            this._wizardButtonDeck.setAttribute(\"selectedIndex\", 1);\n          }\n        ]]></body>\n      </method>\n\n      <property name=\"defaultButton\" readonly=\"true\">\n        <getter><![CDATA[\n          const kXULNS =\n            \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n          var buttons = this._wizardButtonDeck.selectedPanel\n                            .getElementsByTagNameNS(kXULNS, \"button\");\n          for (var i = 0; i < buttons.length; i++) {\n            if (buttons[i].getAttribute(\"default\") == \"true\" &&\n                !buttons[i].hidden && !buttons[i].disabled)\n              return buttons[i];\n          }\n          return null;\n        ]]></getter>\n      </property>\n    </implementation>\n  </binding>\n\n\n</bindings>\n"},{"file":"blocklist.xml","body":"<?xml version=\"1.0\"?>\n\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<!DOCTYPE bindings [\n  <!ENTITY % blocklistDTD SYSTEM \"chrome://mozapps/locale/extensions/blocklist.dtd\" >\n  %blocklistDTD;\n]>\n\n<bindings id=\"blocklistBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"hardblockedaddon\">\n    <content align=\"start\">\n      <xul:image xbl:inherits=\"src=icon\"/>\n      <xul:vbox flex=\"1\">\n        <xul:hbox class=\"addon-name-version\">\n          <xul:label class=\"addonName\" crop=\"end\" xbl:inherits=\"value=name\"/>\n          <xul:label class=\"addonVersion\" xbl:inherits=\"value=version\"/>\n        </xul:hbox>\n        <xul:hbox>\n          <xul:spacer flex=\"1\"/>\n          <xul:label class=\"blockedLabel\" value=\"FROM-DTD.blocklist.blocked.label;\"/>\n        </xul:hbox>\n      </xul:vbox>\n    </content>\n  </binding>\n\n  <binding id=\"softblockedaddon\">\n    <content align=\"start\">\n      <xul:image xbl:inherits=\"src=icon\"/>\n      <xul:vbox flex=\"1\">\n        <xul:hbox class=\"addon-name-version\">\n          <xul:label class=\"addonName\" crop=\"end\" xbl:inherits=\"value=name\"/>\n          <xul:label class=\"addonVersion\" xbl:inherits=\"value=version\"/>\n        </xul:hbox>\n        <xul:hbox>\n          <xul:spacer flex=\"1\"/>\n          <xul:checkbox class=\"disableCheckbox\" checked=\"true\" label=\"FROM-DTD.blocklist.checkbox.label;\"/>\n        </xul:hbox>\n      </xul:vbox>\n    </content>\n    <implementation>\n      <field name=\"_checkbox\">\n        document.getAnonymousElementByAttribute(this, \"class\", \"disableCheckbox\")\n      </field>\n      <property name=\"checked\" readonly=\"true\">\n        <getter>\n          return this._checkbox.checked;\n        </getter>\n      </property>\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"extensions.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE page [\n<!ENTITY % extensionsDTD SYSTEM \"chrome://mozapps/locale/extensions/extensions.dtd\">\n%extensionsDTD;\n]>\n\n<!-- import-globals-from extensions.js -->\n\n<bindings id=\"addonBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n\n  <!-- Rating - displays current/average rating, allows setting user rating -->\n  <binding id=\"rating\">\n    <content>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(1);\"\n                 onclick=\"document.getBindingParent(this).userRating = 1;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(2);\"\n                 onclick=\"document.getBindingParent(this).userRating = 2;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(3);\"\n                 onclick=\"document.getBindingParent(this).userRating = 3;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(4);\"\n                 onclick=\"document.getBindingParent(this).userRating = 4;\"/>\n      <xul:image class=\"star\"\n                 onmouseover=\"document.getBindingParent(this)._hover(5);\"\n                 onclick=\"document.getBindingParent(this).userRating = 5;\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._updateStars();\n      ]]></constructor>\n\n      <property name=\"stars\" readonly=\"true\">\n        <getter><![CDATA[\n          return document.getAnonymousNodes(this);\n        ]]></getter>\n      </property>\n\n      <property name=\"averageRating\">\n        <getter><![CDATA[\n          if (this.hasAttribute(\"averagerating\"))\n            return this.getAttribute(\"averagerating\");\n          return -1;\n        ]]></getter>\n        <setter><![CDATA[\n          this.setAttribute(\"averagerating\", val);\n          if (this.showRating == \"average\")\n            this._updateStars();\n        ]]></setter>\n      </property>\n\n      <property name=\"userRating\">\n        <getter><![CDATA[\n          if (this.hasAttribute(\"userrating\"))\n            return this.getAttribute(\"userrating\");\n          return -1;\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.showRating != \"user\")\n            return;\n          this.setAttribute(\"userrating\", val);\n          if (this.showRating == \"user\")\n            this._updateStars();\n        ]]></setter>\n      </property>\n\n      <property name=\"showRating\">\n        <getter><![CDATA[\n          if (this.hasAttribute(\"showrating\"))\n            return this.getAttribute(\"showrating\");\n          return \"average\";\n        ]]></getter>\n        <setter><![CDATA[\n          if (val != \"average\" || val != \"user\")\n            throw Components.Exception(\"Invalid value\", Cr.NS_ERROR_ILLEGAL_VALUE);\n          this.setAttribute(\"showrating\", val);\n          this._updateStars();\n        ]]></setter>\n      </property>\n\n      <method name=\"_updateStars\">\n        <body><![CDATA[\n          var stars = this.stars;\n          var rating = this[this.showRating + \"Rating\"];\n          // average ratings can be non-whole numbers, round them so they\n          // match to their closest star\n          rating = Math.round(rating);\n          for (let i = 0; i < stars.length; i++)\n            stars[i].setAttribute(\"on\", rating > i);\n        ]]></body>\n      </method>\n\n      <method name=\"_hover\">\n        <parameter name=\"aScore\"/>\n        <body><![CDATA[\n          if (this.showRating != \"user\")\n            return;\n          var stars = this.stars;\n          for (let i = 0; i < stars.length; i++)\n            stars[i].setAttribute(\"on\", i <= (aScore - 1));\n        ]]></body>\n      </method>\n\n    </implementation>\n\n    <handlers>\n      <handler event=\"mouseout\">\n        this._updateStars();\n      </handler>\n    </handlers>\n  </binding>\n\n  <!-- Download progress - shows graphical progress of download and any\n       related status message. -->\n  <binding id=\"download-progress\">\n    <content>\n      <xul:stack flex=\"1\">\n        <xul:hbox flex=\"1\">\n          <xul:hbox class=\"start-cap\"/>\n          <xul:progressmeter anonid=\"progress\" class=\"progress\" flex=\"1\"\n                             min=\"0\" max=\"100\"/>\n          <xul:hbox class=\"end-cap\"/>\n        </xul:hbox>\n        <xul:hbox class=\"status-container\">\n          <xul:spacer flex=\"1\"/>\n          <xul:label anonid=\"status\" class=\"status\"/>\n          <xul:spacer flex=\"1\"/>\n          <xul:button anonid=\"cancel-btn\" class=\"cancel\"\n                      tooltiptext=\"FROM-DTD.progress.cancel.tooltip;\"\n                      oncommand=\"document.getBindingParent(this).cancel();\"/>\n        </xul:hbox>\n      </xul:stack>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        var progress = 0;\n        if (this.hasAttribute(\"progress\"))\n          progress = parseInt(this.getAttribute(\"progress\"));\n        this.progress = progress;\n      ]]></constructor>\n\n      <field name=\"_progress\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"progress\");\n      </field>\n      <field name=\"_cancel\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"cancel-btn\");\n      </field>\n      <field name=\"_status\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"status\");\n      </field>\n\n      <property name=\"progress\">\n        <getter><![CDATA[\n          return this._progress.value;\n        ]]></getter>\n        <setter><![CDATA[\n          this._progress.value = val;\n          if (val == this._progress.max)\n            this.setAttribute(\"complete\", true);\n          else\n            this.removeAttribute(\"complete\");\n        ]]></setter>\n      </property>\n\n      <property name=\"maxProgress\">\n        <getter><![CDATA[\n          return this._progress.max;\n        ]]></getter>\n        <setter><![CDATA[\n          if (val == -1) {\n            this._progress.mode = \"undetermined\";\n          } else {\n            this._progress.mode = \"determined\";\n            this._progress.max = val;\n          }\n          this.setAttribute(\"mode\", this._progress.mode);\n        ]]></setter>\n      </property>\n\n      <property name=\"status\">\n        <getter><![CDATA[\n          return this._status.value;\n        ]]></getter>\n        <setter><![CDATA[\n          this._status.value = val;\n        ]]></setter>\n      </property>\n\n      <method name=\"cancel\">\n        <body><![CDATA[\n          this.mInstall.cancel();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n  <!-- Categories list - displays the list of categories on the left pane. -->\n  <binding id=\"categories-list\"\n           extends=\"chrome://global/content/bindings/richlistbox.xml#richlistbox\">\n    <implementation>\n      <!-- This needs to be overridden to allow the fancy animation while not\n           allowing that item to be selected when hiding.  -->\n      <method name=\"_canUserSelect\">\n        <parameter name=\"aItem\"/>\n        <body>\n        <![CDATA[\n          if (aItem.hasAttribute(\"disabled\") &&\n              aItem.getAttribute(\"disabled\") == \"true\")\n            return false;\n          var style = document.defaultView.getComputedStyle(aItem);\n          return style.display != \"none\" && style.visibility == \"visible\";\n        ]]>\n        </body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Category item - an item in the category list. -->\n  <binding id=\"category\"\n           extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <content align=\"center\">\n      <xul:image anonid=\"icon\" class=\"category-icon\"/>\n      <xul:label anonid=\"name\" class=\"category-name\" crop=\"end\" flex=\"1\" xbl:inherits=\"value=name\"/>\n      <xul:label anonid=\"badge\" class=\"category-badge\" xbl:inherits=\"value=count\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (!this.hasAttribute(\"count\"))\n          this.setAttribute(\"count\", 0);\n      ]]></constructor>\n\n      <property name=\"badgeCount\">\n        <getter><![CDATA[\n          return this.getAttribute(\"count\");\n        ]]></getter>\n        <setter><![CDATA[\n          if (this.getAttribute(\"count\") == val)\n            return;\n\n          this.setAttribute(\"count\", val);\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"CategoryBadgeUpdated\", true, true);\n          this.dispatchEvent(event);\n        ]]></setter>\n      </property>\n    </implementation>\n  </binding>\n\n\n  <!-- Creator link - Name of a user/developer, providing a link if relevant. -->\n  <binding id=\"creator-link\">\n    <content>\n      <xul:label anonid=\"label\" value=\"FROM-DTD.addon.createdBy.label;\"/>\n      <xul:label anonid=\"creator-link\" class=\"creator-link text-link\"/>\n      <xul:label anonid=\"creator-name\" class=\"creator-name\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (this.hasAttribute(\"nameonly\") &&\n            this.getAttribute(\"nameonly\") == \"true\") {\n          this._label.hidden = true;\n        }\n      ]]></constructor>\n\n      <field name=\"_label\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"label\");\n      </field>\n      <field name=\"_creatorLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"creator-link\");\n      </field>\n      <field name=\"_creatorName\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"creator-name\");\n      </field>\n\n      <method name=\"setCreator\">\n        <parameter name=\"aCreator\"/>\n        <parameter name=\"aHomepageURL\"/>\n        <body><![CDATA[\n          if (!aCreator) {\n            this.collapsed = true;\n            return;\n          }\n          this.collapsed = false;\n          var url = aCreator.url || aHomepageURL;\n          var showLink = !!url;\n          if (showLink) {\n            this._creatorLink.value = aCreator.name;\n            this._creatorLink.href = url;\n          } else {\n            this._creatorName.value = aCreator.name;\n          }\n          this._creatorLink.hidden = !showLink;\n          this._creatorName.hidden = showLink;\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Install status - Displays the status of an install/upgrade. -->\n  <binding id=\"install-status\">\n    <content>\n      <xul:label anonid=\"message\"/>\n      <xul:box anonid=\"progress\" class=\"download-progress\"/>\n      <xul:button anonid=\"install-remote-btn\" hidden=\"true\"\n                  class=\"addon-control install\" label=\"FROM-DTD.addon.install.label;\"\n                  tooltiptext=\"FROM-DTD.addon.install.tooltip;\"\n                  oncommand=\"document.getBindingParent(this).installRemote();\"/>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        if (this.mInstall)\n          this.initWithInstall(this.mInstall);\n        else if (this.mControl.mAddon.install)\n          this.initWithInstall(this.mControl.mAddon.install);\n        else\n          this.refreshState();\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        if (this.mInstall)\n          this.mInstall.removeListener(this);\n      ]]></destructor>\n\n      <field name=\"_message\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"message\");\n      </field>\n      <field name=\"_progress\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"progress\");\n      </field>\n      <field name=\"_installRemote\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"install-remote-btn\");\n      </field>\n      <field name=\"_undo\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"undo-btn\");\n      </field>\n\n      <method name=\"initWithInstall\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          if (this.mInstall) {\n            this.mInstall.removeListener(this);\n            this.mInstall = null;\n          }\n          this.mInstall = aInstall;\n          this._progress.mInstall = aInstall;\n          this.refreshState();\n          this.mInstall.addListener(this);\n        ]]></body>\n      </method>\n\n      <method name=\"refreshState\">\n        <body><![CDATA[\n          var showInstallRemote = false;\n\n          if (this.mInstall) {\n\n            switch (this.mInstall.state) {\n              case AddonManager.STATE_AVAILABLE:\n                if (this.mControl.getAttribute(\"remote\") != \"true\")\n                  break;\n\n                this._progress.hidden = true;\n                showInstallRemote = true;\n                break;\n              case AddonManager.STATE_DOWNLOADING:\n                this.showMessage(\"installDownloading\");\n                break;\n              case AddonManager.STATE_CHECKING:\n                this.showMessage(\"installVerifying\");\n                break;\n              case AddonManager.STATE_DOWNLOADED:\n                this.showMessage(\"installDownloaded\");\n                break;\n              case AddonManager.STATE_DOWNLOAD_FAILED:\n                // XXXunf expose what error occured (bug 553487)\n                this.showMessage(\"installDownloadFailed\", true);\n                break;\n              case AddonManager.STATE_INSTALLING:\n                this.showMessage(\"installInstalling\");\n                break;\n              case AddonManager.STATE_INSTALL_FAILED:\n                // XXXunf expose what error occured (bug 553487)\n                this.showMessage(\"installFailed\", true);\n                break;\n              case AddonManager.STATE_CANCELLED:\n                this.showMessage(\"installCancelled\", true);\n                break;\n            }\n\n          }\n\n          this._installRemote.hidden = !showInstallRemote;\n\n          if (\"refreshInfo\" in this.mControl)\n            this.mControl.refreshInfo();\n        ]]></body>\n      </method>\n\n      <method name=\"showMessage\">\n        <parameter name=\"aMsgId\"/>\n        <parameter name=\"aHideProgress\"/>\n        <body><![CDATA[\n          this._message.setAttribute(\"hidden\", !aHideProgress);\n          this._progress.setAttribute(\"hidden\", !!aHideProgress);\n\n          var msg = gStrings.ext.GetStringFromName(aMsgId);\n          if (aHideProgress)\n            this._message.value = msg;\n          else\n            this._progress.status = msg;\n        ]]></body>\n      </method>\n\n      <method name=\"installRemote\">\n        <body><![CDATA[\n          if (this.mControl.getAttribute(\"remote\") != \"true\")\n            return;\n\n          if (this.mControl.mAddon.eula) {\n            var data = {\n              addon: this.mControl.mAddon,\n              accepted: false,\n            };\n            window.openDialog(\"chrome://mozapps/content/extensions/eula.xul\", \"_blank\",\n                              \"chrome,dialog,modal,centerscreen,resizable=no\", data);\n            if (!data.accepted)\n              return;\n          }\n\n          delete this.mControl.mAddon;\n          this.mControl.mInstall = this.mInstall;\n          this.mControl.setAttribute(\"status\", \"installing\");\n          let prompt = Services.prefs.getBoolPref(\"extensions.webextPermissionPrompts\", false);\n          if (prompt) {\n            this.mInstall.promptHandler = info => new Promise((resolve, reject) => {\n              // Skip prompts for non-webextensions\n              if (!info.addon.userPermissions) {\n                resolve();\n                return;\n              }\n              let subject = {\n                wrappedJSObject: {\n                  target: window.docShell.chromeEventHandler,\n                  info: {\n                    addon: info.addon,\n                    source: \"AMO\",\n                    icon: info.addon.iconURL,\n                    permissions: info.addon.userPermissions,\n                    resolve,\n                    reject,\n                  },\n                },\n              };\n              Services.obs.notifyObservers(subject, \"webextension-permission-prompt\");\n            });\n          }\n          this.mInstall.install();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadStarted\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadEnded\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadFailed\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadProgress\">\n        <body><![CDATA[\n          this._progress.maxProgress = this.mInstall.maxProgress;\n          this._progress.progress = this.mInstall.progress;\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallStarted\">\n        <body><![CDATA[\n          this._progress.progress = 0;\n          this.refreshState();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallEnded\">\n        <body><![CDATA[\n          this.refreshState();\n          if (\"onInstallCompleted\" in this.mControl)\n            this.mControl.onInstallCompleted();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallFailed\">\n        <body><![CDATA[\n          this.refreshState();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Addon - base - parent binding of any item representing an addon. -->\n  <binding id=\"addon-base\"\n           extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <implementation>\n      <property name=\"isLegacy\" readonly=\"true\">\n        <getter><![CDATA[\n          if (this.mAddon.install) {\n            return false;\n          }\n          return isLegacyExtension(this.mAddon);\n        ]]></getter>\n      </property>\n\n      <method name=\"hasPermission\">\n        <parameter name=\"aPerm\"/>\n        <body><![CDATA[\n          var perm = AddonManager[\"PERM_CAN_\" + aPerm.toUpperCase()];\n          return !!(this.mAddon.permissions & perm);\n        ]]></body>\n      </method>\n\n      <method name=\"isPending\">\n        <parameter name=\"aAction\"/>\n        <body><![CDATA[\n          var action = AddonManager[\"PENDING_\" + aAction.toUpperCase()];\n          return !!(this.mAddon.pendingOperations & action);\n        ]]></body>\n      </method>\n\n      <method name=\"typeHasFlag\">\n        <parameter name=\"aFlag\"/>\n        <body><![CDATA[\n          let flag = AddonManager[\"TYPE_\" + aFlag];\n          let type = AddonManager.addonTypes[this.mAddon.type];\n\n          return !!(type.flags & flag);\n        ]]></body>\n      </method>\n\n      <method name=\"onUninstalled\">\n        <body><![CDATA[\n          this.remove();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Addon - generic - A normal addon item, or an update to one -->\n  <binding id=\"addon-generic\"\n           extends=\"chrome://mozapps/content/extensions/extensions.xml#addon-base\">\n    <content>\n      <xul:hbox anonid=\"warning-container\"\n                class=\"warning\">\n        <xul:image class=\"warning-icon\"/>\n        <xul:label anonid=\"warning\" flex=\"1\"/>\n        <xul:label anonid=\"warning-link\" class=\"text-link\"/>\n        <xul:button anonid=\"warning-btn\" class=\"button-link\" hidden=\"true\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n      <xul:hbox anonid=\"error-container\"\n                class=\"error\">\n        <xul:image class=\"error-icon\"/>\n        <xul:label anonid=\"error\" flex=\"1\"/>\n        <xul:label anonid=\"error-link\" class=\"text-link\" hidden=\"true\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n      <xul:hbox anonid=\"pending-container\"\n                class=\"pending\">\n        <xul:image class=\"pending-icon\"/>\n        <xul:label anonid=\"pending\" flex=\"1\"/>\n        <xul:button anonid=\"undo-btn\" class=\"button-link\"\n                    label=\"FROM-DTD.addon.undoAction.label;\"\n                    tooltipText=\"FROM-DTD.addon.undoAction.tooltip;\"\n                    oncommand=\"document.getBindingParent(this).undo();\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n\n      <xul:image class=\"card-heading-image\" anonid=\"theme-screenshot\" hidden=\"true\"/>\n\n      <xul:hbox class=\"content-container\" align=\"center\">\n        <xul:vbox class=\"icon-container\">\n          <xul:image anonid=\"icon\" class=\"icon\"/>\n        </xul:vbox>\n        <xul:vbox class=\"content-inner-container\" flex=\"1\">\n          <xul:hbox class=\"basicinfo-container\">\n              <xul:hbox class=\"name-container\">\n                <xul:label anonid=\"name\" class=\"name\" crop=\"end\" flex=\"1\"\n                           tooltip=\"addonitem-tooltip\" xbl:inherits=\"xbl:text=name\"/>\n                <xul:label anonid=\"legacy\" class=\"legacy-warning text-link\" value=\"FROM-DTD.addon.legacy.label;\"/>\n                <xul:label class=\"disabled-postfix\" value=\"FROM-DTD.addon.disabled.postfix;\"/>\n                <xul:label class=\"update-postfix\" value=\"FROM-DTD.addon.update.postfix;\"/>\n                <xul:spacer flex=\"5000\"/> <!-- Necessary to make the name crop -->\n              </xul:hbox>\n            <xul:label anonid=\"date-updated\" class=\"date-updated\"\n                       unknown=\"FROM-DTD.addon.unknownDate;\"/>\n          </xul:hbox>\n\n          <xul:hbox class=\"advancedinfo-container\" flex=\"1\">\n            <xul:vbox class=\"description-outer-container\" flex=\"1\">\n              <xul:hbox class=\"relnotes-toggle-container\">\n                <xul:button anonid=\"relnotes-toggle-btn\" class=\"relnotes-toggle\"\n                            hidden=\"true\" label=\"FROM-DTD.cmd.showReleaseNotes.label;\"\n                            tooltiptext=\"FROM-DTD.cmd.showReleaseNotes.tooltip;\"\n                            showlabel=\"FROM-DTD.cmd.showReleaseNotes.label;\"\n                            showtooltip=\"FROM-DTD.cmd.showReleaseNotes.tooltip;\"\n                            hidelabel=\"FROM-DTD.cmd.hideReleaseNotes.label;\"\n                            hidetooltip=\"FROM-DTD.cmd.hideReleaseNotes.tooltip;\"\n                            oncommand=\"document.getBindingParent(this).toggleReleaseNotes();\"/>\n              </xul:hbox>\n              <xul:vbox anonid=\"relnotes-container\" class=\"relnotes-container\">\n                <xul:label class=\"relnotes-header\" value=\"FROM-DTD.addon.releaseNotes.label;\"/>\n                <xul:label anonid=\"relnotes-loading\" value=\"FROM-DTD.addon.loadingReleaseNotes.label;\"/>\n                <xul:label anonid=\"relnotes-error\" hidden=\"true\"\n                           value=\"FROM-DTD.addon.errorLoadingReleaseNotes.label;\"/>\n                <xul:vbox anonid=\"relnotes\" class=\"relnotes\"/>\n              </xul:vbox>\n            </xul:vbox>\n          </xul:hbox>\n        </xul:vbox>\n        <xul:vbox class=\"status-control-wrapper\">\n          <xul:hbox class=\"status-container\">\n            <xul:hbox anonid=\"checking-update\" hidden=\"true\">\n              <xul:image class=\"spinner\"/>\n              <xul:label value=\"FROM-DTD.addon.checkingForUpdates.label;\"/>\n            </xul:hbox>\n            <xul:vbox anonid=\"update-available\" class=\"update-available\"\n                      hidden=\"true\">\n              <xul:checkbox anonid=\"include-update\" class=\"include-update\"\n                            label=\"FROM-DTD.addon.includeUpdate.label;\" checked=\"true\"\n                            oncommand=\"document.getBindingParent(this).onIncludeUpdateChanged();\"/>\n              <xul:hbox class=\"update-info-container\">\n                <xul:label class=\"update-available-notice\"\n                           value=\"FROM-DTD.addon.updateAvailable.label;\"/>\n                <xul:button anonid=\"update-btn\" class=\"addon-control update\"\n                            label=\"FROM-DTD.addon.updateNow.label;\"\n                            tooltiptext=\"FROM-DTD.addon.updateNow.tooltip;\"\n                            oncommand=\"document.getBindingParent(this).upgrade();\"/>\n              </xul:hbox>\n            </xul:vbox>\n            <xul:hbox anonid=\"install-status\" class=\"install-status\"\n                      hidden=\"true\"/>\n          </xul:hbox>\n          <xul:hbox anonid=\"control-container\" class=\"control-container\" flex=\"1\">\n            <xul:button anonid=\"preferences-btn\"\n                        class=\"addon-control preferences\"\n\n                        label=\"FROM-DTD.cmd.showPreferencesWin.label;\"\n                        tooltiptext=\"FROM-DTD.cmd.showPreferencesWin.tooltip;\"\n\n                        oncommand=\"document.getBindingParent(this).showPreferences();\"/>\n            <xul:button anonid=\"enable-btn\"  class=\"addon-control enable\"\n                        label=\"FROM-DTD.cmd.enableAddon.label;\"\n                        oncommand=\"document.getBindingParent(this).userDisabled = false;\"/>\n            <xul:button anonid=\"disable-btn\" class=\"addon-control disable\"\n                        label=\"FROM-DTD.cmd.disableAddon.label;\"\n                        oncommand=\"document.getBindingParent(this).userDisabled = true;\"/>\n            <xul:button anonid=\"replacement-btn\" class=\"addon-control replacement\"\n                        label=\"FROM-DTD.cmd.findReplacement.label;\"\n                        oncommand=\"document.getBindingParent(this).findReplacement();\"/>\n            <xul:button anonid=\"remove-btn\" class=\"addon-control remove\"\n                        label=\"FROM-DTD.cmd.uninstallAddon.label;\"\n                        oncommand=\"document.getBindingParent(this).uninstall();\"/>\n            <xul:menulist anonid=\"state-menulist\"\n                          class=\"addon-control state\"\n                          flex=\"1\"\n                          tooltiptext=\"FROM-DTD.cmd.stateMenu.tooltip;\">\n              <xul:menupopup>\n                <xul:menuitem anonid=\"ask-to-activate-menuitem\"\n                              class=\"addon-control\"\n                              label=\"FROM-DTD.cmd.askToActivate.label;\"\n                              tooltiptext=\"FROM-DTD.cmd.askToActivate.tooltip;\"\n                              oncommand=\"document.getBindingParent(this).userDisabled = AddonManager.STATE_ASK_TO_ACTIVATE;\"/>\n                <xul:menuitem anonid=\"always-activate-menuitem\"\n                              class=\"addon-control\"\n                              label=\"FROM-DTD.cmd.alwaysActivate.label;\"\n                              tooltiptext=\"FROM-DTD.cmd.alwaysActivate.tooltip;\"\n                              oncommand=\"document.getBindingParent(this).userDisabled = false;\"/>\n                <xul:menuitem anonid=\"never-activate-menuitem\"\n                              class=\"addon-control\"\n                              label=\"FROM-DTD.cmd.neverActivate.label;\"\n                              tooltiptext=\"FROM-DTD.cmd.neverActivate.tooltip;\"\n                              oncommand=\"document.getBindingParent(this).userDisabled = true;\"/>\n              </xul:menupopup>\n            </xul:menulist>\n          </xul:hbox>\n        </xul:vbox>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._installStatus = document.getAnonymousElementByAttribute(this, \"anonid\", \"install-status\");\n        this._installStatus.mControl = this;\n\n        this.setAttribute(\"contextmenu\", \"addonitem-popup\");\n\n        this._showStatus(\"none\");\n\n        this._initWithAddon(this.mAddon);\n\n        gEventManager.registerAddonListener(this, this.mAddon.id);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        gEventManager.unregisterAddonListener(this, this.mAddon.id);\n      ]]></destructor>\n\n      <field name=\"_warningContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning-container\");\n      </field>\n      <field name=\"_warning\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning\");\n      </field>\n      <field name=\"_warningLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning-link\");\n      </field>\n      <field name=\"_warningBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"warning-btn\");\n      </field>\n      <field name=\"_errorContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"error-container\");\n      </field>\n      <field name=\"_error\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"error\");\n      </field>\n      <field name=\"_errorLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"error-link\");\n      </field>\n      <field name=\"_pendingContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"pending-container\");\n      </field>\n      <field name=\"_pending\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"pending\");\n      </field>\n      <field name=\"_infoContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"info-container\");\n      </field>\n      <field name=\"_info\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"info\");\n      </field>\n      <field name=\"_icon\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"icon\");\n      </field>\n      <field name=\"_dateUpdated\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"date-updated\");\n      </field>\n      <field name=\"_stateMenulist\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"state-menulist\");\n      </field>\n      <field name=\"_askToActivateMenuitem\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"ask-to-activate-menuitem\");\n      </field>\n      <field name=\"_alwaysActivateMenuitem\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"always-activate-menuitem\");\n      </field>\n      <field name=\"_neverActivateMenuitem\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"never-activate-menuitem\");\n      </field>\n      <field name=\"_preferencesBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"preferences-btn\");\n      </field>\n      <field name=\"_enableBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"enable-btn\");\n      </field>\n      <field name=\"_disableBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"disable-btn\");\n      </field>\n      <field name=\"_removeBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"remove-btn\");\n      </field>\n      <field name=\"_updateBtn\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"update-btn\");\n      </field>\n      <field name=\"_controlContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"control-container\");\n      </field>\n      <field name=\"_installStatus\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"install-status\");\n      </field>\n      <field name=\"_checkingUpdate\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"checking-update\");\n      </field>\n      <field name=\"_updateAvailable\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"update-available\");\n      </field>\n      <field name=\"_includeUpdate\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"include-update\");\n      </field>\n      <field name=\"_relNotesLoaded\">false</field>\n      <field name=\"_relNotesToggle\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-toggle-btn\");\n      </field>\n      <field name=\"_relNotesLoading\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-loading\");\n      </field>\n      <field name=\"_relNotesError\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-error\");\n      </field>\n      <field name=\"_relNotesContainer\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes-container\");\n      </field>\n      <field name=\"_relNotes\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"relnotes\");\n      </field>\n\n      <property name=\"userDisabled\">\n        <getter><![CDATA[\n          return this.mAddon.userDisabled;\n        ]]></getter>\n        <setter><![CDATA[\n          if (val === true) {\n            gViewController.commands.cmd_disableItem.doCommand(this.mAddon);\n          } else if (val === false) {\n            gViewController.commands.cmd_enableItem.doCommand(this.mAddon);\n          } else {\n            this.mAddon.userDisabled = val;\n          }\n        ]]></setter>\n      </property>\n\n      <property name=\"includeUpdate\">\n        <getter><![CDATA[\n          return this._includeUpdate.checked && !!this.mManualUpdate;\n        ]]></getter>\n        <setter><![CDATA[\n          // XXXunf Eventually, we'll want to persist this for individual\n          //        updates - see bug 594619.\n          this._includeUpdate.checked = !!val;\n        ]]></setter>\n      </property>\n\n      <method name=\"_initWithAddon\">\n        <parameter name=\"aAddon\"/>\n        <body><![CDATA[\n          this.mAddon = aAddon;\n\n          this._installStatus.mAddon = this.mAddon;\n          this._updateDates();\n          this._updateState();\n\n          this.setAttribute(\"name\", aAddon.name);\n\n          var iconURL = AddonManager.getPreferredIconURL(aAddon, 32, window);\n          if (iconURL)\n            this._icon.src = iconURL;\n          else\n            this._icon.src = \"\";\n\n          let legacyWarning = legacyExtensionsEnabled && !this.mAddon.install &&\n            isLegacyExtension(this.mAddon);\n          this.setAttribute(\"legacy\", legacyWarning);\n          document.getAnonymousElementByAttribute(this, \"anonid\", \"legacy\").href = SUPPORT_URL + \"webextensions\";\n\n          if (!(\"applyBackgroundUpdates\" in this.mAddon) ||\n              (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DISABLE ||\n               (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DEFAULT &&\n                !AddonManager.autoUpdateDefault))) {\n            AddonManager.getAllInstalls().then(aInstallsList => {\n              // This can return after the binding has been destroyed,\n              // so try to detect that and return early\n              if (!(\"onNewInstall\" in this))\n                return;\n              for (let install of aInstallsList) {\n                if (install.existingAddon &&\n                    install.existingAddon.id == this.mAddon.id &&\n                    install.state == AddonManager.STATE_AVAILABLE) {\n                  this.onNewInstall(install);\n                  this.onIncludeUpdateChanged();\n                }\n              }\n            });\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"_showStatus\">\n        <parameter name=\"aType\"/>\n        <body><![CDATA[\n          this._controlContainer.hidden = aType != \"none\" &&\n                                          !(aType == \"update-available\" && !this.hasAttribute(\"upgrade\"));\n\n          this._installStatus.hidden = aType != \"progress\";\n          if (aType == \"progress\")\n            this._installStatus.refreshState();\n          this._checkingUpdate.hidden = aType != \"checking-update\";\n          this._updateAvailable.hidden = aType != \"update-available\";\n          this._relNotesToggle.hidden = !(this.mManualUpdate ?\n                                          this.mManualUpdate.releaseNotesURI :\n                                          this.mAddon.releaseNotesURI);\n        ]]></body>\n      </method>\n\n      <method name=\"_updateDates\">\n        <body><![CDATA[\n          function formatDate(aDate) {\n            const dtOptions = { year: \"numeric\", month: \"long\", day: \"numeric\" };\n            return aDate.toLocaleDateString(undefined, dtOptions);\n          }\n\n          if (this.mAddon.updateDate)\n            this._dateUpdated.value = formatDate(this.mAddon.updateDate);\n          else\n            this._dateUpdated.value = this._dateUpdated.getAttribute(\"unknown\");\n        ]]></body>\n      </method>\n\n      <method name=\"_updateState\">\n        <body><![CDATA[\n          if (this.parentNode.selectedItem == this)\n            gViewController.updateCommands();\n\n          var pending = this.mAddon.pendingOperations;\n          if (pending & AddonManager.PENDING_UNINSTALL) {\n            this.removeAttribute(\"notification\");\n\n            // We don't care about pending operations other than uninstall.\n            // They're transient, and cannot be undone.\n            this.setAttribute(\"pending\", \"uninstall\");\n            this._pending.textContent = gStrings.ext.formatStringFromName(\n              \"notification.restartless-uninstall\",\n              [this.mAddon.name], 1);\n          } else {\n            this.removeAttribute(\"pending\");\n\n            var isUpgrade = this.hasAttribute(\"upgrade\");\n            var install = this._installStatus.mInstall;\n\n            if (install && install.state == AddonManager.STATE_DOWNLOAD_FAILED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.downloadError\",\n                [this.mAddon.name], 1\n              );\n              this._warningBtn.label = gStrings.ext.GetStringFromName(\"notification.downloadError.retry\");\n              this._warningBtn.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n              this._warningBtn.setAttribute(\"oncommand\", \"document.getBindingParent(this).retryInstall();\");\n              this._warningBtn.hidden = false;\n              this._warningLink.hidden = true;\n            } else if (install && install.state == AddonManager.STATE_INSTALL_FAILED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.installError\",\n                [this.mAddon.name], 1\n              );\n              this._warningBtn.label = gStrings.ext.GetStringFromName(\"notification.installError.retry\");\n              this._warningBtn.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n              this._warningBtn.setAttribute(\"oncommand\", \"document.getBindingParent(this).retryInstall();\");\n              this._warningBtn.hidden = false;\n              this._warningLink.hidden = true;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_BLOCKED) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.blocked\",\n                [this.mAddon.name], 1\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.blocked.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._errorLink.href = url;\n                this._errorLink.hidden = false;\n              });\n            } else if (!isUpgrade && isDisabledUnsigned(this.mAddon)) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.unsignedAndDisabled\", [this.mAddon.name, gStrings.brandShortName], 2\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.unsigned.link\");\n              this._errorLink.href = SUPPORT_URL + \"unsigned-addons\";\n              this._errorLink.hidden = false;\n            } else if ((!isUpgrade && !this.mAddon.isCompatible) && (AddonManager.checkCompatibility\n            || (this.mAddon.blocklistState != Ci.nsIBlocklistService.STATE_SOFTBLOCKED))) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.incompatible\",\n                [this.mAddon.name, gStrings.brandShortName, gStrings.appVersion], 3\n              );\n              this._warningLink.hidden = true;\n              this._warningBtn.hidden = true;\n            } else if (!isUpgrade && !isCorrectlySigned(this.mAddon)) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.unsigned\", [this.mAddon.name, gStrings.brandShortName], 2\n              );\n              this._warningLink.value = gStrings.ext.GetStringFromName(\"notification.unsigned.link\");\n              this._warningLink.href = SUPPORT_URL + \"unsigned-addons\";\n              this._warningLink.hidden = false;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_SOFTBLOCKED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.softblocked\",\n                [this.mAddon.name], 1\n              );\n              this._warningLink.value = gStrings.ext.GetStringFromName(\"notification.softblocked.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._warningLink.href = url;\n                this._warningLink.hidden = false;\n              });\n              this._warningBtn.hidden = true;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_OUTDATED) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent = gStrings.ext.formatStringFromName(\n                \"notification.outdated\",\n                [this.mAddon.name], 1\n              );\n              this._warningLink.value = gStrings.ext.GetStringFromName(\"notification.outdated.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._warningLink.href = url;\n                this._warningLink.hidden = false;\n              });\n              this._warningBtn.hidden = true;\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_VULNERABLE_UPDATE_AVAILABLE) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.vulnerableUpdatable\",\n                [this.mAddon.name], 1\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.vulnerableUpdatable.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._errorLink.href = url;\n                this._errorLink.hidden = false;\n              });\n            } else if (!isUpgrade && this.mAddon.blocklistState == Ci.nsIBlocklistService.STATE_VULNERABLE_NO_UPDATE) {\n              this.setAttribute(\"notification\", \"error\");\n              this._error.textContent = gStrings.ext.formatStringFromName(\n                \"notification.vulnerableNoUpdate\",\n                [this.mAddon.name], 1\n              );\n              this._errorLink.value = gStrings.ext.GetStringFromName(\"notification.vulnerableNoUpdate.link\");\n              this.mAddon.getBlocklistURL().then(url => {\n                this._errorLink.href = url;\n                this._errorLink.hidden = false;\n              });\n            } else if (this.mAddon.isGMPlugin && !this.mAddon.isInstalled &&\n                       this.mAddon.isActive) {\n              this.setAttribute(\"notification\", \"warning\");\n              this._warning.textContent =\n                gStrings.ext.formatStringFromName(\"notification.gmpPending\",\n                                                  [this.mAddon.name], 1);\n            } else {\n              this.removeAttribute(\"notification\");\n            }\n          }\n\n          this._preferencesBtn.hidden = !this.mAddon.optionsType && this.mAddon.type != \"plugin\";\n\n          if (this.typeHasFlag(\"SUPPORTS_ASK_TO_ACTIVATE\")) {\n            this._enableBtn.disabled = true;\n            this._disableBtn.disabled = true;\n            this._askToActivateMenuitem.disabled = !this.hasPermission(\"ask_to_activate\");\n            this._alwaysActivateMenuitem.disabled = !this.hasPermission(\"enable\");\n            this._neverActivateMenuitem.disabled = !this.hasPermission(\"disable\");\n            if (!this.mAddon.isActive) {\n              this._stateMenulist.selectedItem = this._neverActivateMenuitem;\n            } else if (this.mAddon.userDisabled == AddonManager.STATE_ASK_TO_ACTIVATE) {\n              this._stateMenulist.selectedItem = this._askToActivateMenuitem;\n            } else {\n              this._stateMenulist.selectedItem = this._alwaysActivateMenuitem;\n            }\n            let hasActivatePermission =\n              [\"ask_to_activate\", \"enable\", \"disable\"].some(perm => this.hasPermission(perm));\n            this._stateMenulist.disabled = !hasActivatePermission;\n            this._stateMenulist.hidden = false;\n            this._stateMenulist.classList.add(\"no-auto-hide\");\n          } else {\n            this._stateMenulist.hidden = true;\n\n            let enableTooltip = gViewController.commands.cmd_enableItem\n                                               .getTooltip(this.mAddon);\n            this._enableBtn.setAttribute(\"tooltiptext\", enableTooltip);\n            if (this.hasPermission(\"enable\")) {\n              this._enableBtn.hidden = false;\n            } else {\n              this._enableBtn.hidden = true;\n            }\n\n            let disableTooltip = gViewController.commands.cmd_disableItem\n                                                .getTooltip(this.mAddon);\n            this._disableBtn.setAttribute(\"tooltiptext\", disableTooltip);\n            if (this.hasPermission(\"disable\")) {\n              this._disableBtn.hidden = false;\n            } else {\n              this._disableBtn.hidden = true;\n            }\n          }\n\n          let uninstallTooltip = gViewController.commands.cmd_uninstallItem\n                                                .getTooltip(this.mAddon);\n          this._removeBtn.setAttribute(\"tooltiptext\", uninstallTooltip);\n          if (this.hasPermission(\"uninstall\")) {\n            this._removeBtn.hidden = false;\n          } else {\n            this._removeBtn.hidden = true;\n          }\n\n          this.setAttribute(\"active\", this.mAddon.isActive);\n\n          var showProgress = (this.mAddon.install &&\n                              this.mAddon.install.state != AddonManager.STATE_INSTALLED);\n          this._showStatus(showProgress ? \"progress\" : \"none\");\n        ]]></body>\n      </method>\n\n      <method name=\"_fetchReleaseNotes\">\n        <parameter name=\"aURI\"/>\n        <body><![CDATA[\n          if (!aURI || this._relNotesLoaded) {\n            sendToggleEvent();\n            return;\n          }\n\n          var relNotesData = null, transformData = null;\n\n          this._relNotesLoaded = true;\n          this._relNotesLoading.hidden = false;\n          this._relNotesError.hidden = true;\n\n          let sendToggleEvent = () => {\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"RelNotesToggle\", true, true);\n            this.dispatchEvent(event);\n          };\n\n          let showRelNotes = () => {\n            if (!relNotesData || !transformData)\n              return;\n\n            this._relNotesLoading.hidden = true;\n\n            var processor = new XSLTProcessor();\n            processor.flags |= XSLTProcessor.DISABLE_ALL_LOADS;\n\n            processor.importStylesheet(transformData);\n            var fragment = processor.transformToFragment(relNotesData, document);\n            this._relNotes.appendChild(fragment);\n            if (this.hasAttribute(\"show-relnotes\")) {\n              var container = this._relNotesContainer;\n              container.style.height = container.scrollHeight + \"px\";\n            }\n            sendToggleEvent();\n          };\n\n          let handleError = () => {\n            dataReq.abort();\n            styleReq.abort();\n            this._relNotesLoading.hidden = true;\n            this._relNotesError.hidden = false;\n            this._relNotesLoaded = false; // allow loading to be re-tried\n            sendToggleEvent();\n          };\n\n          function handleResponse(aEvent) {\n            var req = aEvent.target;\n            var ct = req.getResponseHeader(\"content-type\");\n            if ((!ct || !ct.includes(\"text/html\")) &&\n                req.responseXML &&\n                req.responseXML.documentElement.namespaceURI != XMLURI_PARSE_ERROR) {\n              if (req == dataReq)\n                relNotesData = req.responseXML;\n              else\n                transformData = req.responseXML;\n              showRelNotes();\n            } else {\n              handleError();\n            }\n          }\n\n          var dataReq = new XMLHttpRequest();\n          dataReq.open(\"GET\", aURI.spec, true);\n          dataReq.responseType = \"document\";\n          dataReq.addEventListener(\"load\", handleResponse);\n          dataReq.addEventListener(\"error\", handleError);\n          dataReq.send(null);\n\n          var styleReq = new XMLHttpRequest();\n          styleReq.open(\"GET\", UPDATES_RELEASENOTES_TRANSFORMFILE, true);\n          styleReq.responseType = \"document\";\n          styleReq.addEventListener(\"load\", handleResponse);\n          styleReq.addEventListener(\"error\", handleError);\n          styleReq.send(null);\n        ]]></body>\n      </method>\n\n      <method name=\"toggleReleaseNotes\">\n        <body><![CDATA[\n          if (this.hasAttribute(\"show-relnotes\")) {\n            this._relNotesContainer.style.height = \"0px\";\n            this.removeAttribute(\"show-relnotes\");\n            this._relNotesToggle.setAttribute(\n              \"label\",\n              this._relNotesToggle.getAttribute(\"showlabel\")\n            );\n            this._relNotesToggle.setAttribute(\n              \"tooltiptext\",\n              this._relNotesToggle.getAttribute(\"showtooltip\")\n            );\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"RelNotesToggle\", true, true);\n            this.dispatchEvent(event);\n          } else {\n            this._relNotesContainer.style.height = this._relNotesContainer.scrollHeight +\n                                                   \"px\";\n            this.setAttribute(\"show-relnotes\", true);\n            this._relNotesToggle.setAttribute(\n              \"label\",\n              this._relNotesToggle.getAttribute(\"hidelabel\")\n            );\n            this._relNotesToggle.setAttribute(\n              \"tooltiptext\",\n              this._relNotesToggle.getAttribute(\"hidetooltip\")\n            );\n            var uri = this.mManualUpdate ?\n                      this.mManualUpdate.releaseNotesURI :\n                      this.mAddon.releaseNotesURI;\n            this._fetchReleaseNotes(uri);\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"undo\">\n        <body><![CDATA[\n          gViewController.commands.cmd_cancelOperation.doCommand(this.mAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"uninstall\">\n        <body><![CDATA[\n          // If the type doesn't support undoing of restartless uninstalls,\n          // then we fake it by just disabling it it, and doing the real\n          // uninstall later.\n          if (this.typeHasFlag(\"SUPPORTS_UNDO_RESTARTLESS_UNINSTALL\")) {\n            this.mAddon.uninstall(true);\n          } else {\n            this.setAttribute(\"wasDisabled\", this.mAddon.userDisabled);\n\n            // We must set userDisabled to true first, this will call\n            // _updateState which will clear any pending attribute set.\n            this.mAddon.disable().then(() => {\n              // This won't update any other add-on manager views (bug 582002)\n              this.setAttribute(\"pending\", \"uninstall\");\n            });\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"showPreferences\">\n        <body><![CDATA[\n          gViewController.doCommand(\"cmd_showItemPreferences\", this.mAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"upgrade\">\n        <body><![CDATA[\n          var install = this.mManualUpdate;\n          delete this.mManualUpdate;\n          install.install();\n        ]]></body>\n      </method>\n\n      <method name=\"retryInstall\">\n        <body><![CDATA[\n          var install = this._installStatus.mInstall;\n          if (!install)\n            return;\n          if (install.state != AddonManager.STATE_DOWNLOAD_FAILED &&\n              install.state != AddonManager.STATE_INSTALL_FAILED)\n            return;\n          install.install();\n        ]]></body>\n      </method>\n\n      <method name=\"showInDetailView\">\n        <body><![CDATA[\n          gViewController.loadView(\"addons://detail/\" +\n                                   encodeURIComponent(this.mAddon.id));\n        ]]></body>\n      </method>\n\n      <method name=\"findReplacement\">\n        <body><![CDATA[\n          let url = (this.mAddon.type == \"theme\") ?\n            SUPPORT_URL + \"complete-themes\" :\n            `https://addons.mozilla.org/find-replacement/?guid=${this.mAddon.id}`;\n            openURL(url);\n        ]]></body>\n      </method>\n\n      <method name=\"onIncludeUpdateChanged\">\n        <body><![CDATA[\n          var event = document.createEvent(\"Events\");\n          event.initEvent(\"IncludeUpdateChanged\", true, true);\n          this.dispatchEvent(event);\n        ]]></body>\n      </method>\n\n      <method name=\"onEnabling\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onEnabled\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDisabling\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onDisabled\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onUninstalling\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onOperationCancelled\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onPropertyChanged\">\n        <parameter name=\"aProperties\"/>\n        <body><![CDATA[\n          if (aProperties.includes(\"appDisabled\") ||\n              aProperties.includes(\"signedState\") ||\n              aProperties.includes(\"userDisabled\"))\n            this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onNoUpdateAvailable\">\n        <body><![CDATA[\n          this._showStatus(\"none\");\n        ]]></body>\n      </method>\n\n      <method name=\"onCheckingUpdate\">\n        <body><![CDATA[\n          this._showStatus(\"checking-update\");\n        ]]></body>\n      </method>\n\n      <method name=\"onCompatibilityUpdateAvailable\">\n        <body><![CDATA[\n          this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onExternalInstall\">\n        <parameter name=\"aAddon\"/>\n        <parameter name=\"aExistingAddon\"/>\n        <body><![CDATA[\n          if (aExistingAddon.id != this.mAddon.id)\n            return;\n\n          this._initWithAddon(aAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"onNewInstall\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          if (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_ENABLE)\n            return;\n          if (this.mAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DEFAULT &&\n              AddonManager.autoUpdateDefault)\n            return;\n\n          this.mManualUpdate = aInstall;\n          this._showStatus(\"update-available\");\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadStarted\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          this._updateState();\n          this._showStatus(\"progress\");\n          this._installStatus.initWithInstall(aInstall);\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallStarted\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          this._updateState();\n          this._showStatus(\"progress\");\n          this._installStatus.initWithInstall(aInstall);\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallEnded\">\n        <parameter name=\"aInstall\"/>\n        <parameter name=\"aAddon\"/>\n        <body><![CDATA[\n          this._initWithAddon(aAddon);\n        ]]></body>\n      </method>\n\n      <method name=\"onDownloadFailed\">\n        <body><![CDATA[\n            this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallFailed\">\n        <body><![CDATA[\n            this._updateState();\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallCancelled\">\n        <body><![CDATA[\n            this._updateState();\n        ]]></body>\n      </method>\n    </implementation>\n\n    <handlers>\n      <handler event=\"click\" button=\"0\"><![CDATA[\n        if (![\"button\", \"checkbox\", \"menulist\", \"menuitem\"].includes(event.originalTarget.localName) &&\n            !event.originalTarget.classList.contains(\"text-link\") &&\n            // Treat the relnotes container as embedded text instead of a click target.\n            !event.originalTarget.closest(\".relnotes-container\")) {\n          this.showInDetailView();\n        }\n      ]]></handler>\n    </handlers>\n  </binding>\n\n\n  <!-- Addon - uninstalled - An uninstalled addon that can be re-installed. -->\n  <binding id=\"addon-uninstalled\"\n           extends=\"chrome://mozapps/content/extensions/extensions.xml#addon-base\">\n    <content>\n      <xul:hbox class=\"pending\">\n        <xul:image class=\"pending-icon\"/>\n        <xul:label anonid=\"notice\" flex=\"1\"/>\n        <xul:button anonid=\"undo-btn\" class=\"button-link\"\n                    label=\"FROM-DTD.addon.undoRemove.label;\"\n                    tooltiptext=\"FROM-DTD.addon.undoRemove.tooltip;\"\n                    oncommand=\"document.getBindingParent(this).cancelUninstall();\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._notice.textContent = gStrings.ext.formatStringFromName(\"uninstallNotice\",\n                                                                     [this.mAddon.name],\n                                                                     1);\n\n        gEventManager.registerAddonListener(this, this.mAddon.id);\n      ]]></constructor>\n\n      <destructor><![CDATA[\n        gEventManager.unregisterAddonListener(this, this.mAddon.id);\n      ]]></destructor>\n\n      <field name=\"_notice\" readonly=\"true\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"notice\");\n      </field>\n\n      <method name=\"cancelUninstall\">\n        <body><![CDATA[\n          // This assumes that disabling does not require a restart when\n          // uninstalling doesn't. Things will still work if not, the add-on\n          // will just still be active until finally getting uninstalled.\n\n          if (this.isPending(\"uninstall\"))\n            this.mAddon.cancelUninstall();\n          else if (this.getAttribute(\"wasDisabled\") != \"true\")\n            this.mAddon.enable();\n\n          this.removeAttribute(\"pending\");\n        ]]></body>\n      </method>\n\n      <method name=\"onExternalInstall\">\n        <parameter name=\"aAddon\"/>\n        <parameter name=\"aExistingAddon\"/>\n        <body><![CDATA[\n          if (aExistingAddon.id != this.mAddon.id)\n            return;\n\n          // Make sure any newly installed add-on has the correct disabled state\n          if (this.hasAttribute(\"wasDisabled\")) {\n            if (this.getAttribute(\"wasDisabled\") == \"true\")\n              aAddon.disable();\n            else\n              aAddon.enable();\n          }\n\n          this.mAddon = aAddon;\n\n          this.removeAttribute(\"pending\");\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallStarted\">\n        <parameter name=\"aInstall\"/>\n        <body><![CDATA[\n          // Make sure any newly installed add-on has the correct disabled state\n          if (this.hasAttribute(\"wasDisabled\")) {\n            if (this.getAttribute(\"wasDisabled\") == \"true\")\n              aInstall.addon.disable();\n            else\n              aInstall.addon.enable();\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"onInstallEnded\">\n        <parameter name=\"aInstall\"/>\n        <parameter name=\"aAddon\"/>\n        <body><![CDATA[\n          this.mAddon = aAddon;\n\n          this.removeAttribute(\"pending\");\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n\n  <!-- Addon - installing - an addon item that is currently being installed -->\n  <binding id=\"addon-installing\"\n           extends=\"chrome://mozapps/content/extensions/extensions.xml#addon-base\">\n    <content>\n      <xul:hbox anonid=\"warning-container\" class=\"warning\">\n        <xul:image class=\"warning-icon\"/>\n        <xul:label anonid=\"warning\" flex=\"1\"/>\n        <xul:button anonid=\"warning-link\" class=\"button-link\"\n                   oncommand=\"document.getBindingParent(this).retryInstall();\"/>\n        <xul:spacer flex=\"5000\"/> <!-- Necessary to allow the message to wrap -->\n      </xul:hbox>\n      <xul:hbox class=\"content-container\">\n        <xul:vbox class=\"icon-outer-container\">\n          <xul:vbox class=\"icon-container\">\n            <xul:image anonid=\"icon\" class=\"icon\"/>\n          </xul:vbox>\n        </xul:vbox>\n        <xul:vbox class=\"fade name-outer-container\" flex=\"1\">\n          <xul:hbox class=\"name-container\">\n            <xul:label anonid=\"name\" class=\"name\" crop=\"end\" tooltip=\"addonitem-tooltip\"/>\n          </xul:hbox>\n        </xul:vbox>\n        <xul:vbox class=\"install-status-container\">\n          <xul:hbox anonid=\"install-status\" class=\"install-status\"/>\n        </xul:vbox>\n      </xul:hbox>\n    </content>\n\n    <implementation>\n      <constructor><![CDATA[\n        this._installStatus.mControl = this;\n        this._installStatus.mInstall = this.mInstall;\n        this.refreshInfo();\n      ]]></constructor>\n\n      <field name=\"_icon\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"icon\");\n      </field>\n      <field name=\"_name\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"name\");\n      </field>\n      <field name=\"_warning\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"warning\");\n      </field>\n      <field name=\"_warningLink\">\n        document.getAnonymousElementByAttribute(this, \"anonid\", \"warning-link\");\n      </field>\n      <field name=\"_installStatus\">\n        document.getAnonymousElementByAttribute(this, \"anonid\",\n                                                \"install-status\");\n      </field>\n\n      <method name=\"onInstallCompleted\">\n        <body><![CDATA[\n          this.mAddon = this.mInstall.addon;\n          this.setAttribute(\"name\", this.mAddon.name);\n          this.setAttribute(\"value\", this.mAddon.id);\n          this.setAttribute(\"status\", \"installed\");\n        ]]></body>\n      </method>\n\n      <method name=\"refreshInfo\">\n        <body><![CDATA[\n          this.mAddon = this.mAddon || this.mInstall.addon;\n          if (this.mAddon) {\n            this._icon.src = this.mAddon.iconURL ||\n                             (this.mInstall ? this.mInstall.iconURL : \"\");\n            this._name.value = this.mAddon.name;\n          } else {\n            this._icon.src = this.mInstall.iconURL;\n            // AddonInstall.name isn't always available - fallback to filename\n            if (this.mInstall.name) {\n              this._name.value = this.mInstall.name;\n            } else if (this.mInstall.sourceURI) {\n              var url = Cc[\"@mozilla.org/network/standard-url-mutator;1\"]\n                          .createInstance(Ci.nsIStandardURLMutator)\n                          .init(Ci.nsIStandardURL.URLTYPE_STANDARD,\n                                80, this.mInstall.sourceURI.spec,\n                                null, null)\n                          .finalize()\n                          .QueryInterface(Ci.nsIURL);\n              this._name.value = url.fileName;\n            }\n          }\n\n          if (this.mInstall.state == AddonManager.STATE_DOWNLOAD_FAILED) {\n            this.setAttribute(\"notification\", \"warning\");\n            this._warning.textContent = gStrings.ext.formatStringFromName(\n              \"notification.downloadError\",\n              [this._name.value], 1\n            );\n            this._warningLink.label = gStrings.ext.GetStringFromName(\"notification.downloadError.retry\");\n            this._warningLink.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n          } else if (this.mInstall.state == AddonManager.STATE_INSTALL_FAILED) {\n            this.setAttribute(\"notification\", \"warning\");\n            this._warning.textContent = gStrings.ext.formatStringFromName(\n              \"notification.installError\",\n              [this._name.value], 1\n            );\n            this._warningLink.label = gStrings.ext.GetStringFromName(\"notification.installError.retry\");\n            this._warningLink.tooltipText = gStrings.ext.GetStringFromName(\"notification.downloadError.retry.tooltip\");\n          } else {\n            this.removeAttribute(\"notification\");\n          }\n        ]]></body>\n      </method>\n\n      <method name=\"retryInstall\">\n        <body><![CDATA[\n          this.mInstall.install();\n        ]]></body>\n      </method>\n    </implementation>\n  </binding>\n\n  <binding id=\"detail-row\">\n    <content>\n      <xul:label class=\"detail-row-label\" xbl:inherits=\"value=label\"/>\n      <xul:label class=\"detail-row-value\" xbl:inherits=\"value\"/>\n    </content>\n\n    <implementation>\n      <property name=\"value\">\n        <getter><![CDATA[\n          return this.getAttribute(\"value\");\n        ]]></getter>\n        <setter><![CDATA[\n          if (!val)\n            this.removeAttribute(\"value\");\n          else\n            this.setAttribute(\"value\", val);\n        ]]></setter>\n      </property>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"handler.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n<bindings id=\"hanlder-bindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"handler\"\n           extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n\n    <content>\n      <xul:vbox pack=\"center\">\n        <xul:image xbl:inherits=\"src=image\" height=\"32\" width=\"32\"/>\n      </xul:vbox>\n      <xul:vbox flex=\"1\">\n        <xul:label class=\"name\" xbl:inherits=\"value=name\"/>\n        <xul:label class=\"description\" xbl:inherits=\"value=description\"/>\n      </xul:vbox>\n    </content>\n    <implementation>\n      <property name=\"label\" onget=\"return this.getAttribute('name') + ' ' + this.getAttribute('description');\"/>\n    </implementation>\n  </binding>\n\n</bindings>\n"},{"file":"updates.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n\n\n<!DOCTYPE bindings SYSTEM \"chrome://mozapps/locale/update/updates.dtd\">\n\n<bindings id=\"updatesBindings\"\n          xmlns=\"http://www.mozilla.org/xbl\"\n          xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n          xmlns:xbl=\"http://www.mozilla.org/xbl\">\n\n  <binding id=\"updateheader\" extends=\"chrome://global/content/bindings/wizard.xml#wizard-header\">\n    <content>\n      <xul:hbox class=\"wizard-header update-header\" flex=\"1\">\n        <xul:vbox class=\"wizard-header-box-1\">\n          <xul:vbox class=\"wizard-header-box-text\">\n            <xul:label class=\"wizard-header-label\" xbl:inherits=\"value=label\"/>\n          </xul:vbox>\n        </xul:vbox>\n      </xul:hbox>\n    </content>\n  </binding>\n\n  <binding id=\"update\" extends=\"chrome://global/content/bindings/richlistbox.xml#richlistitem\">\n    <content>\n      <xul:hbox>\n        <xul:label class=\"update-name\" xbl:inherits=\"value=name\" flex=\"1\" crop=\"right\"/>\n        <xul:label xbl:inherits=\"href=detailsURL,hidden=hideDetailsURL\" class=\"text-link\"\n                   value=\"FROM-DTD.update.details.label;\"/>\n      </xul:hbox>\n      <xul:grid>\n        <xul:columns>\n          <xul:column class=\"update-label-column\"/>\n          <xul:column flex=\"1\"/>\n        </xul:columns>\n        <xul:rows>\n          <xul:row>\n            <xul:label class=\"update-installedOn-label\">FROM-DTD.update.installedOn.label;</xul:label>\n            <xul:label class=\"update-installedOn-value\" xbl:inherits=\"value=installDate\" flex=\"1\" crop=\"right\"/>\n          </xul:row>\n          <xul:row>\n            <xul:label class=\"update-status-label\">FROM-DTD.update.status.label;</xul:label>\n            <xul:description class=\"update-status-value\" flex=\"1\"/>\n          </xul:row>\n        </xul:rows>\n      </xul:grid>\n    </content>\n    <implementation>\n      <property name=\"name\"\n                onget=\"return this.getAttribute('name');\"\n                onset=\"this.setAttribute('name', val); return val;\"/>\n      <property name=\"detailsURL\"\n                onget=\"return this.getAttribute('detailsURL');\"\n                onset=\"this.setAttribute('detailsURL', val); return val;\"/>\n      <property name=\"installDate\"\n                onget=\"return this.getAttribute('installDate');\"\n                onset=\"this.setAttribute('installDate', val); return val;\"/>\n      <property name=\"hideDetailsURL\"\n                onget=\"return this.getAttribute('hideDetailsURL');\"\n                onset=\"this.setAttribute('hideDetailsURL', val); return val;\"/>\n      <property name=\"status\"\n                onget=\"return this.getAttribute('status');\">\n        <setter><![CDATA[\n          this.setAttribute(\"status\", val);\n          var field = document.getAnonymousElementByAttribute(this, \"class\", \"update-status-value\");\n          while (field.hasChildNodes())\n            field.firstChild.remove();\n          field.appendChild(document.createTextNode(val));\n          return val;\n        ]]></setter>\n      </property>\n    </implementation>\n  </binding>\n</bindings>\n"},{"file":"pluginProblem.xml","body":"<?xml version=\"1.0\"?>\n<!-- This Source Code Form is subject to the terms of the Mozilla Public\n   - License, v. 2.0. If a copy of the MPL was not distributed with this\n   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->\n<!DOCTYPE bindings [\n  <!ENTITY % pluginproblemDTD SYSTEM \"chrome://pluginproblem/locale/pluginproblem.dtd\">\n  <!ENTITY % globalDTD SYSTEM \"chrome://global/locale/global.dtd\">\n  <!ENTITY % brandDTD SYSTEM \"chrome://branding/locale/brand.dtd\" >\n  %pluginproblemDTD;\n  %globalDTD;\n  %brandDTD;\n]>\n\n<bindings id=\"pluginBindings\"\n              xmlns=\"http://www.mozilla.org/xbl\"\n              xmlns:xul=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"\n              xmlns:html=\"http://www.w3.org/1999/xhtml\">\n<binding id=\"pluginProblem\" inheritstyle=\"false\" chromeOnlyContent=\"true\" bindToUntrustedContent=\"true\">\n    <resources>\n        <stylesheet src=\"chrome://pluginproblem/content/pluginProblemContent.css\"/>\n        <stylesheet src=\"chrome://mozapps/skin/plugins/pluginProblem.css\"/>\n    </resources>\n\n    <content>\n        <html:div class=\"mainBox\" anonid=\"main\" chromedir=\"FROM-DTD.locale.dir;\">\n            <html:div class=\"hoverBox\">\n                <html:label>\n                    <html:button class=\"icon\" anonid=\"icon\"/>\n                    <html:div class=\"msg msgVulnerabilityStatus\" anonid=\"vulnerabilityStatus\"><!-- set at runtime --></html:div>\n                    <html:div class=\"msg msgTapToPlay\">FROM-DTD.tapToPlayPlugin;</html:div>\n                    <html:div class=\"msg msgClickToPlay\" anonid=\"clickToPlay\">FROM-DTD.clickToActivatePlugin;</html:div>\n                </html:label>\n\n                <html:div class=\"msg msgBlocked\">FROM-DTD.blockedPlugin.label;</html:div>\n                <html:div class=\"msg msgCrashed\">\n                    <html:div class=\"msgCrashedText\" anonid=\"crashedText\"><!-- set at runtime --></html:div>\n                    <!-- link href set at runtime -->\n                    <html:div class=\"msgReload\">FROM-DTD.reloadPlugin.pre;<html:a class=\"reloadLink\" anonid=\"reloadLink\" href=\"\">FROM-DTD.reloadPlugin.middle;</html:a>FROM-DTD.reloadPlugin.post;</html:div>\n                </html:div>\n\n                <html:div class=\"msg msgManagePlugins\"><html:a class=\"action-link\" anonid=\"managePluginsLink\" href=\"\">FROM-DTD.managePlugins;</html:a></html:div>\n                <html:div class=\"submitStatus\" anonid=\"submitStatus\">\n                    <html:div class=\"msg msgPleaseSubmit\" anonid=\"pleaseSubmit\">\n                        <html:textarea class=\"submitComment\"\n                                       anonid=\"submitComment\"\n                                       placeholder=\"FROM-DTD.report.comment;\"/>\n                        <html:div class=\"submitURLOptInBox\">\n                            <html:label><html:input class=\"submitURLOptIn\" anonid=\"submitURLOptIn\" type=\"checkbox\"/> FROM-DTD.report.pageURL;</html:label>\n                        </html:div>\n                        <html:div class=\"submitButtonBox\">\n                            <html:span class=\"helpIcon\" anonid=\"helpIcon\" role=\"link\"/>\n                            <html:input class=\"submitButton\" type=\"button\"\n                                        anonid=\"submitButton\"\n                                        value=\"FROM-DTD.report.please;\"/>\n                        </html:div>\n                    </html:div>\n                    <html:div class=\"msg msgSubmitting\">FROM-DTD.report.submitting;<html:span class=\"throbber\"> </html:span></html:div>\n                    <html:div class=\"msg msgSubmitted\">FROM-DTD.report.submitted;</html:div>\n                    <html:div class=\"msg msgNotSubmitted\">FROM-DTD.report.disabled;</html:div>\n                    <html:div class=\"msg msgSubmitFailed\">FROM-DTD.report.failed;</html:div>\n                    <html:div class=\"msg msgNoCrashReport\">FROM-DTD.report.unavailable;</html:div>\n                </html:div>\n                <html:div class=\"msg msgCheckForUpdates\"><html:a class=\"action-link\" anonid=\"checkForUpdatesLink\" href=\"\">FROM-DTD.checkForUpdates;</html:a></html:div>\n            </html:div>\n            <html:button class=\"closeIcon\" anonid=\"closeIcon\" title=\"FROM-DTD.hidePluginBtn.label;\"/>\n        </html:div>\n        <html:div style=\"display:none;\"><children/></html:div>\n    </content>\n    <implementation>\n      <constructor>\n        // Notify browser-plugins.js that we were attached, on a delay because\n        // this binding doesn't complete layout until the constructor\n        // completes.\n        this.dispatchEvent(new CustomEvent(\"PluginBindingAttached\"));\n      </constructor>\n    </implementation>\n</binding>\n</bindings>\n"}];
    </script>
  </head>
  <body>
  <main>
  <header>
  <div id="links">
    <a href="../">Home</a>
    <a href="https://github.com/bgrins/xbl-analysis">Code</a>
  </div>
  <h1>XBL To Custom Element Converter</h1>
  </header>
  <div id="converter">
    <ul>
    <li><a href='#' data-index=0>tabbrowser.xml</a></li>
<li><a href='#' data-index=1>urlbarBindings.xml</a></li>
<li><a href='#' data-index=2>toolbar.xml</a></li>
<li><a href='#' data-index=3>download.xml</a></li>
<li><a href='#' data-index=4>menu.xml</a></li>
<li><a href='#' data-index=5>tree.xml</a></li>
<li><a href='#' data-index=6>search.xml</a></li>
<li><a href='#' data-index=7>translation-infobar.xml</a></li>
<li><a href='#' data-index=8>formautofill.xml</a></li>
<li><a href='#' data-index=9>organizer.xml</a></li>
<li><a href='#' data-index=10>platformHTMLBindings.xml</a></li>
<li><a href='#' data-index=11>platformHTMLBindings.xml</a></li>
<li><a href='#' data-index=12>platformHTMLBindings.xml</a></li>
<li><a href='#' data-index=13>platformHTMLBindings.xml</a></li>
<li><a href='#' data-index=14>platformHTMLBindings.xml</a></li>
<li><a href='#' data-index=15>xbl-marquee.xml</a></li>
<li><a href='#' data-index=16>tabprompts.xml</a></li>
<li><a href='#' data-index=17>autocomplete.xml</a></li>
<li><a href='#' data-index=18>browser.xml</a></li>
<li><a href='#' data-index=19>button.xml</a></li>
<li><a href='#' data-index=20>checkbox.xml</a></li>
<li><a href='#' data-index=21>datetimebox.xml</a></li>
<li><a href='#' data-index=22>datetimepopup.xml</a></li>
<li><a href='#' data-index=23>dialog.xml</a></li>
<li><a href='#' data-index=24>general.xml</a></li>
<li><a href='#' data-index=25>menu.xml</a></li>
<li><a href='#' data-index=26>menulist.xml</a></li>
<li><a href='#' data-index=27>notification.xml</a></li>
<li><a href='#' data-index=28>numberbox.xml</a></li>
<li><a href='#' data-index=29>popup.xml</a></li>
<li><a href='#' data-index=30>radio.xml</a></li>
<li><a href='#' data-index=31>richlistbox.xml</a></li>
<li><a href='#' data-index=32>scrollbox.xml</a></li>
<li><a href='#' data-index=33>tabbox.xml</a></li>
<li><a href='#' data-index=34>text.xml</a></li>
<li><a href='#' data-index=35>textbox.xml</a></li>
<li><a href='#' data-index=36>toolbar.xml</a></li>
<li><a href='#' data-index=37>toolbarbutton.xml</a></li>
<li><a href='#' data-index=38>tree.xml</a></li>
<li><a href='#' data-index=39>wizard.xml</a></li>
<li><a href='#' data-index=40>blocklist.xml</a></li>
<li><a href='#' data-index=41>extensions.xml</a></li>
<li><a href='#' data-index=42>handler.xml</a></li>
<li><a href='#' data-index=43>updates.xml</a></li>
<li><a href='#' data-index=44>pluginProblem.xml</a></li>
    </ul>
    <textarea>
    <?xml version="1.0"?>
<!-- -*- Mode: HTML; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- -->
<!-- vim: set ts=2 et sw=2 tw=80: -->

<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this file,
   - You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!DOCTYPE bindings SYSTEM "chrome://browser/locale/downloads/downloads.dtd">

<bindings id="downloadBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">
  <binding id="download-subview-toolbarbutton"
           extends="chrome://global/content/bindings/button.xml#button-base">
    <content>
      <xul:image class="toolbarbutton-icon" validate="always" xbl:inherits="src=image"/>
      <xul:vbox class="toolbarbutton-text" flex="1">
        <xul:label crop="end" xbl:inherits="value=label"/>
        <xul:label class="status-text status-full" crop="end" xbl:inherits="value=status"/>
        <xul:label class="status-text status-open" crop="end" xbl:inherits="value=openLabel"/>
        <xul:label class="status-text status-retry" crop="end" xbl:inherits="value=retryLabel"/>
        <xul:label class="status-text status-show" crop="end" xbl:inherits="value=showLabel"/>
      </xul:vbox>
      <xul:toolbarbutton anonid="button" class="action-button"/>
    </content>
  </binding>
</bindings>

    </textarea>
    <pre></pre>
  </div>
  </main>
    <script>
    function getJSForBinding(binding) {
  let js = [];
  let elementName = binding.attrs.id;
  let className = 'Moz' + titleCase(elementName);
  let hasExtends = !!formatExtends(binding.attrs.extends);
  js.push(`class ${className} `);
  if (hasExtends) {
    js.push(`extends Moz${formatExtends(binding.attrs.extends)} `);
  } else {
    js.push(`extends MozXULElement `);
  }

  js.push('{')

  let childMarkup = [];
  let content = binding.find("content");
  if (content.length === 0) {
    content = binding.find("xbl:content");
  }
  if (content.length > 1) {
    throw "Unexpected second content field";
  } else if (content.length === 1) {
    function printChild(child, depth) {
      let attrs = '';
      for (var attr in child.attrs) {
        attrs += ' ' + attr.replace('xbl:', '') + '="' + child.attrs[attr].replace('"', '\"').replace(/xbl\:/g, '') + '"';
      }
      let name = child.name.replace('xul:', '');
      let padding = (new Array(depth + 3)).join("  ");
      childMarkup.push(`\n${padding}<${name}${attrs}>`);
      child.children.forEach(c => printChild(c, depth+1));
      let closePadding = child.children.length ? `\n${padding}` : '';
      childMarkup.push(`${closePadding}</${name}>`);
    }
    content[0].children.forEach(c => printChild(c, 1));
  } else {
    console.log("No content for binding", binding.attrs.id);
  }

  let innerHTML = content.length ?
        "this.appendChild(MozXULElement.parseXULToFragment(`" + childMarkup.join('') + "\n    `));" :
        "";

  let xblconstructor = (binding.find("constructor") || [])[0];
  let xblconstructorComment = xblconstructor ? formatComment(xblconstructor.comment) : null;
  xblconstructor = xblconstructor ? `${xblconstructor.cdata || xblconstructor.value}` : '';
  if (xblconstructorComment) {
    xblconstructor = xblconstructorComment + "\n" + xblconstructor;
  }
  // Or, try / catch since many components will fail when loaded in a tab due to chrome references
  // xblconstructor = xblconstructor ? `try { ${xblconstructor.cdata} } catch(e) { }` : '';

  let xbldestructor = (binding.find("destructor") || [])[0];
  let xbldestructorComment = xbldestructor ? formatComment(xbldestructor.comment) : null;
  xbldestructor = xbldestructor ? `${xbldestructor.cdata || xbldestructor.value}` : '';
  // Or, try / catch since many components will fail when loaded in a tab due to chrome references
  // xbldestructor = xbldestructor ? `try { ${xbldestructor.cdata} } catch(e) { }` : '';
  if (xbldestructor != '') {
    xbldestructor = `disconnectedCallback() { ${xbldestructor} }`
    if (xblconstructorComment) {
      xbldestructor = xblconstructorComment + "\n" + xbldestructor;
    }
  }

  let handlers = [];
  // <handler>
  for (let handler of binding.find('handler')) {
    let comment = formatComment(handler.comment);
    if (comment) {
      handlers.push(comment);
    }

    let secondParam = "";
    let isCapturing = handler.attrs.phase === "capturing";
    if (handler.attrs.group === "system") {
      if (isCapturing) {
        secondParam = `, { capture: true, mozSystemGroup: true }`;
      } else {
        secondParam = `, { mozSystemGroup: true }`;
      }
    } else if (isCapturing) {
      secondParam = ", true";
    }

    let keycode = handler.attrs.keycode ? `if (event.keyCode != KeyEvent.DOM_${handler.attrs.keycode}) { return; }` : "";
    let button = handler.attrs.button ? `if (event.button != ${handler.attrs.button}) { return; }` : "";

    handlers.push(`this.addEventListener("${handler.attrs.event}", (event) => {${keycode}${button} ${handler.cdata || handler.value || handler.attrs.action}}${secondParam});\n`);
  }


  // <field>
  let fields = [];
  for (let field of binding.find('field')) {
    // Work around fields like _weekStart in the datepicker where the value is coming from a dtd.
    // Just print an empty string in that case.
    let data = (field.cdata || field.value || "").trim();
    if (data.startsWith("FROM-DTD")) {
      data = `"${data}"`
    }
    data = (data.length === 0) ? '""' : data;

    // Remove leading comments, which would cause the 'return' to be on a different line
    // than the expression.
    let leadingComments = [];
    let expressions = data.split("\n");
    for (var i = 0; i < expressions.length; i++) {
      if (expressions[i].trim().startsWith("//")) {
        leadingComments.push(expressions[i]);
      } else {
        expressions = expressions.slice(i);
        break;
      }
    }

    let expr = expressions.join("\n");
    if (expr[expr.length - 1] !== ";") {
      expr += ";";
    }
    // Strip away parens that were only needed for XBL
    if (expr[0] === "(" && expr[expr.length - 2] === ")") {
      expr = expr.substring(1, expr.length - 2) + ";";
    }

    let comment = formatComment(field.comment);
    if (comment) {
      fields.push(comment);
    }

    if (leadingComments.length) {
      fields.push(leadingComments.join("\n"));
    }

    fields.push(`this.${field.attrs.name} = ${expr}\n`);

    // let setter = field.attrs.readonly ? '' :
    // `set(val) {
    //     delete this.${field.attrs.name};
    //     return this.${field.attrs.name} = val;
    // },`;

    // fields.push(`Object.defineProperty(this, "${field.attrs.name}", {
    //   configurable: true,
    //   enumerable: true,
    //   get() {
    //     ${comments.join('\n')}
    //     delete this.${field.attrs.name};
    //     return this.${field.attrs.name} = ${expressions.join('\n')}
    //   },
    //   ${setter}
    // })`);
  }

  if (handlers.length) {
    js.push(`
      constructor() {
        super();

        ${handlers.join("\n")}
      }
    `)
  }

  js.push(`
    connectedCallback() {
      ${hasExtends ? "super.connectedCallback()" : ""}
      ${innerHTML}
      ${fields.join("\n")}

      ${xblconstructor}
    }
  `);

  // <property>
  for (let property of binding.find('property')) {
    let comment = formatComment(property.comment);
    if (comment) {
      js.push(comment);
    }
    if (property.attrs.onset) {
      js.push(`
        set ${property.attrs.name}(val) {
          ${property.attrs.onset}
        }
      `);
    } else if(property.find('setter').length) {
      js.push(`
        set ${property.attrs.name}(val) {${property.find('setter')[0].cdata || property.find('setter')[0].value}}
      `);
    }
    if (property.attrs.onget) {
      js.push(`
        get ${property.attrs.name}() {
          ${property.attrs.onget}
        }
      `);
    } else if(property.find('getter').length) {
      js.push(`
        get ${property.attrs.name}() {${property.find('getter')[0].cdata || property.find('getter')[0].value}}
      `);
    }
  }

  // <method>
  for (let method of binding.find('method')) {
    js.push('\n');
    let comment = formatComment(method.comment);
    if (comment) {
      js.push(comment);
    }
    js.push(`${method.attrs.name}(`);
    js.push(`${method.find('parameter').map(p => p.attrs.name).join(',')}`);
    js.push(`) {`);
    js.push(method.find('body')[0].cdata || method.find('body')[0].value);
    js.push(`}\n`);
  }

  js.push(`${xbldestructor}`);

  js.push("}\n\n");

  let implements =
    binding.find("implementation").length &&
    binding.find("implementation")[0].attrs.implements
  if (implements) {
    implements = implements.split(",").map(i=>"Ci." + i.trim()).join(", ");
    js.push(`MozXULElement.implementCustomInterface(${className}, [${implements}]);`)
  }



  js.push(`customElements.define("${elementName}", ${className});
  `)
  return js.join(' ');
}
    function titleCase(str) {
  if (str == "basecontrol") {
    // Special case so we don't end up with Basecontrol:
    return "BaseControl";
  }
  return str[0].toUpperCase() + str.substr(1).replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
}
    function formatExtends(ext) {
  if (!ext || ext.startsWith("xul:")) {
    return null;
  }
  return titleCase(ext.split('#')[1]);
}
    function formatComment(comment, spaces = 2) {
  if (!comment) {
    return '';
  }

  let spacesStr = new Array(spaces).join(" ");
  let commentArr = comment.split("\n").map(s=> s.trim());
  if (!commentArr[0]) { commentArr.shift(); }
  if (!commentArr[commentArr.length - 1]) { commentArr.pop(); }
  let commentFormatted = commentArr
    .map(s => (s ? `${spacesStr}* ${s}` : `${spacesStr}*`))
    .join("\n");

  return `${spacesStr}/**\n${commentFormatted}\n${spacesStr}*/`;
}
    function getFormattedJSForBinding(binding) {
  let js = [];
  js.push(
`/* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

"use strict";

// This is loaded into all XUL windows. Wrap in a block to prevent
// leaking to window scope.
{

`);

  js.push(js_beautify(
    getJSForBinding(binding),
    {
      indent_size: 2,
      // preserve_newlines: false,
      max_preserve_newlines: 2,
      brace_style: "preserve-inline"
      // keep_array_indentation: true
    }
  ));

  js.push(`

}
`);

  return js.join("");
}

    var textarea = document.querySelector("textarea");
    var pre = document.querySelector("pre");
    function createPreview() {
      var body = textarea.value;
      body = body.replace(/&([a-z0-9-]+);/gi, "FROM-DTD-$1"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2-$3"); // Replace DTD entities
      body = body.replace(/&([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+).([a-z0-9-]+);/gi, "FROM-DTD-$1-$2-$3-$4"); // Replace DTD entities
      var parsed = xmlom.parseString(body, {
        xmlns: true,
      });
      parsed.then(doc => {
        console.log(doc, doc.find("binding"));
        let js = doc.find("binding").map(binding => {
          return getFormattedJSForBinding(binding);
        }).join("\n");
        pre.textContent = js;
      }).catch(e => {
        pre.textContent =  "Error parsing XML:\n" + e;
      });
    }
    textarea.addEventListener("input", createPreview);
    createPreview();

    document.querySelector("ul").addEventListener("click", function(e) {
      if (e.originalTarget.localName === "a") {
        e.preventDefault();
        textarea.value = files[e.originalTarget.dataset.index].body;
        createPreview();
      }
    });
    </script>
  </body>
  </html>
